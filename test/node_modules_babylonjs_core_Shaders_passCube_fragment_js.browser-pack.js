"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["node_modules_babylonjs_core_Shaders_passCube_fragment_js"],{

/***/ "./node_modules/@babylonjs/core/Shaders/passCube.fragment.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/passCube.fragment.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   passCubePixelShader: () => (/* binding */ passCubePixelShader)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "passCubePixelShader";
const shader = `varying vec2 vUV;uniform samplerCube textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{vec2 uv=vUV*2.0-1.0;
#ifdef POSITIVEX
gl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));
#endif
#ifdef NEGATIVEX
gl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));
#endif
#ifdef POSITIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));
#endif
#ifdef NEGATIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));
#endif
#ifdef POSITIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,1.001));
#endif
#ifdef NEGATIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));
#endif
}`;
// Sideeffect
if (!_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.ShadersStore[name]) {
    _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.ShadersStore[name] = shader;
}
/** @internal */
const passCubePixelShader = { name, shader };
//# sourceMappingURL=passCube.fragment.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2JhYnlsb25qc19jb3JlX1NoYWRlcnNfcGFzc0N1YmVfZnJhZ21lbnRfanMuYnJvd3Nlci1wYWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0Q7QUFDeEQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxLQUFLLGdFQUFXO0FBQ2hCLElBQUksZ0VBQVc7QUFDZjtBQUNBO0FBQ08sOEJBQThCO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnMvcGFzc0N1YmUuZnJhZ21lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJwYXNzQ3ViZVBpeGVsU2hhZGVyXCI7XG5jb25zdCBzaGFkZXIgPSBgdmFyeWluZyB2ZWMyIHZVVjt1bmlmb3JtIHNhbXBsZXJDdWJlIHRleHR1cmVTYW1wbGVyO1xuI2RlZmluZSBDVVNUT01fRlJBR01FTlRfREVGSU5JVElPTlNcbnZvaWQgbWFpbih2b2lkKSBcbnt2ZWMyIHV2PXZVVioyLjAtMS4wO1xuI2lmZGVmIFBPU0lUSVZFWFxuZ2xfRnJhZ0NvbG9yPXRleHR1cmVDdWJlKHRleHR1cmVTYW1wbGVyLHZlYzMoMS4wMDEsdXYueSx1di54KSk7XG4jZW5kaWZcbiNpZmRlZiBORUdBVElWRVhcbmdsX0ZyYWdDb2xvcj10ZXh0dXJlQ3ViZSh0ZXh0dXJlU2FtcGxlcix2ZWMzKC0xLjAwMSx1di55LHV2LngpKTtcbiNlbmRpZlxuI2lmZGVmIFBPU0lUSVZFWVxuZ2xfRnJhZ0NvbG9yPXRleHR1cmVDdWJlKHRleHR1cmVTYW1wbGVyLHZlYzModXYueSwxLjAwMSx1di54KSk7XG4jZW5kaWZcbiNpZmRlZiBORUdBVElWRVlcbmdsX0ZyYWdDb2xvcj10ZXh0dXJlQ3ViZSh0ZXh0dXJlU2FtcGxlcix2ZWMzKHV2LnksLTEuMDAxLHV2LngpKTtcbiNlbmRpZlxuI2lmZGVmIFBPU0lUSVZFWlxuZ2xfRnJhZ0NvbG9yPXRleHR1cmVDdWJlKHRleHR1cmVTYW1wbGVyLHZlYzModXYsMS4wMDEpKTtcbiNlbmRpZlxuI2lmZGVmIE5FR0FUSVZFWlxuZ2xfRnJhZ0NvbG9yPXRleHR1cmVDdWJlKHRleHR1cmVTYW1wbGVyLHZlYzModXYsLTEuMDAxKSk7XG4jZW5kaWZcbn1gO1xuLy8gU2lkZWVmZmVjdFxuaWYgKCFTaGFkZXJTdG9yZS5TaGFkZXJzU3RvcmVbbmFtZV0pIHtcbiAgICBTaGFkZXJTdG9yZS5TaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgcGFzc0N1YmVQaXhlbFNoYWRlciA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXNzQ3ViZS5mcmFnbWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=