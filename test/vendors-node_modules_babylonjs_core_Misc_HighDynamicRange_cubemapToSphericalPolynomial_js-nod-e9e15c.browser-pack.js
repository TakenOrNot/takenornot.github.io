"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["vendors-node_modules_babylonjs_core_Misc_HighDynamicRange_cubemapToSphericalPolynomial_js-nod-e9e15c"],{

/***/ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.alpha.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.alpha.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");


_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setAlphaEquation = function (equation) {
    if (this._alphaEquation === equation) {
        return;
    }
    switch (equation) {
        case 0:
            this._alphaState.setAlphaEquationParameters(32774, 32774);
            break;
        case 1:
            this._alphaState.setAlphaEquationParameters(32778, 32778);
            break;
        case 2:
            this._alphaState.setAlphaEquationParameters(32779, 32779);
            break;
        case 3:
            this._alphaState.setAlphaEquationParameters(32776, 32776);
            break;
        case 4:
            this._alphaState.setAlphaEquationParameters(32775, 32775);
            break;
        case 5:
            this._alphaState.setAlphaEquationParameters(32775, 32774);
            break;
    }
    this._alphaEquation = equation;
};
//# sourceMappingURL=abstractEngine.alpha.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.dom.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.dom.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");

_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getInputElement = function () {
    return this._renderingCanvas;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getRenderingCanvasClientRect = function () {
    if (!this._renderingCanvas) {
        return null;
    }
    return this._renderingCanvas.getBoundingClientRect();
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getInputElementClientRect = function () {
    if (!this._renderingCanvas) {
        return null;
    }
    return this.getInputElement().getBoundingClientRect();
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getAspectRatio = function (viewportOwner, useScreen = false) {
    const viewport = viewportOwner.viewport;
    return (this.getRenderWidth(useScreen) * viewport.width) / (this.getRenderHeight(useScreen) * viewport.height);
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getScreenAspectRatio = function () {
    return this.getRenderWidth(true) / this.getRenderHeight(true);
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype._verifyPointerLock = function () {
    this._onPointerLockChange?.();
};
//# sourceMappingURL=abstractEngine.dom.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.loadingScreen.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.loadingScreen.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Misc_domManagement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Misc/domManagement.js */ "./node_modules/@babylonjs/core/Misc/domManagement.js");
/* harmony import */ var _abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");


_abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.prototype.displayLoadingUI = function () {
    if (!(0,_Misc_domManagement_js__WEBPACK_IMPORTED_MODULE_0__.IsWindowObjectExist)()) {
        return;
    }
    const loadingScreen = this.loadingScreen;
    if (loadingScreen) {
        loadingScreen.displayLoadingUI();
    }
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.prototype.hideLoadingUI = function () {
    if (!(0,_Misc_domManagement_js__WEBPACK_IMPORTED_MODULE_0__.IsWindowObjectExist)()) {
        return;
    }
    const loadingScreen = this._loadingScreen;
    if (loadingScreen) {
        loadingScreen.hideLoadingUI();
    }
};
Object.defineProperty(_abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.prototype, "loadingScreen", {
    get: function () {
        if (!this._loadingScreen && this._renderingCanvas) {
            this._loadingScreen = _abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.DefaultLoadingScreenFactory(this._renderingCanvas);
        }
        return this._loadingScreen;
    },
    set: function (value) {
        this._loadingScreen = value;
    },
    enumerable: true,
    configurable: true,
});
Object.defineProperty(_abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.prototype, "loadingUIText", {
    set: function (value) {
        this.loadingScreen.loadingUIText = value;
    },
    enumerable: true,
    configurable: true,
});
Object.defineProperty(_abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.prototype, "loadingUIBackgroundColor", {
    set: function (value) {
        this.loadingScreen.loadingUIBackgroundColor = value;
    },
    enumerable: true,
    configurable: true,
});
//# sourceMappingURL=abstractEngine.loadingScreen.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.renderPass.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.renderPass.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");

_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getRenderPassNames = function () {
    return this._renderPassNames;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getCurrentRenderPassName = function () {
    return this._renderPassNames[this.currentRenderPassId];
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.createRenderPassId = function (name) {
    // Note: render pass id == 0 is always for the main render pass
    const id = ++_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine._RenderPassIdCounter;
    this._renderPassNames[id] = name ?? "NONAME";
    return id;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.releaseRenderPassId = function (id) {
    this._renderPassNames[id] = undefined;
    for (let s = 0; s < this.scenes.length; ++s) {
        const scene = this.scenes[s];
        for (let m = 0; m < scene.meshes.length; ++m) {
            const mesh = scene.meshes[m];
            if (mesh.subMeshes) {
                for (let b = 0; b < mesh.subMeshes.length; ++b) {
                    const subMesh = mesh.subMeshes[b];
                    subMesh._removeDrawWrapper(id);
                }
            }
        }
    }
};
//# sourceMappingURL=abstractEngine.renderPass.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.states.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.states.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");
/* harmony import */ var _abstractEngine_alpha_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstractEngine.alpha.js */ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.alpha.js");



_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getInputElement = function () {
    return this._renderingCanvas;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getDepthFunction = function () {
    return this._depthCullingState.depthFunc;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setDepthFunction = function (depthFunc) {
    this._depthCullingState.depthFunc = depthFunc;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setDepthFunctionToGreater = function () {
    this.setDepthFunction(516);
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setDepthFunctionToGreaterOrEqual = function () {
    this.setDepthFunction(518);
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setDepthFunctionToLess = function () {
    this.setDepthFunction(513);
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setDepthFunctionToLessOrEqual = function () {
    this.setDepthFunction(515);
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getDepthWrite = function () {
    return this._depthCullingState.depthMask;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setDepthWrite = function (enable) {
    this._depthCullingState.depthMask = enable;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getStencilBuffer = function () {
    return this._stencilState.stencilTest;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setStencilBuffer = function (enable) {
    this._stencilState.stencilTest = enable;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getStencilMask = function () {
    return this._stencilState.stencilMask;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setStencilMask = function (mask) {
    this._stencilState.stencilMask = mask;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getStencilFunction = function () {
    return this._stencilState.stencilFunc;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getStencilFunctionReference = function () {
    return this._stencilState.stencilFuncRef;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getStencilFunctionMask = function () {
    return this._stencilState.stencilFuncMask;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setStencilFunction = function (stencilFunc) {
    this._stencilState.stencilFunc = stencilFunc;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setStencilFunctionReference = function (reference) {
    this._stencilState.stencilFuncRef = reference;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setStencilFunctionMask = function (mask) {
    this._stencilState.stencilFuncMask = mask;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getStencilOperationFail = function () {
    return this._stencilState.stencilOpStencilFail;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getStencilOperationDepthFail = function () {
    return this._stencilState.stencilOpDepthFail;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getStencilOperationPass = function () {
    return this._stencilState.stencilOpStencilDepthPass;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setStencilOperationFail = function (operation) {
    this._stencilState.stencilOpStencilFail = operation;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setStencilOperationDepthFail = function (operation) {
    this._stencilState.stencilOpDepthFail = operation;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setStencilOperationPass = function (operation) {
    this._stencilState.stencilOpStencilDepthPass = operation;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.cacheStencilState = function () {
    this._cachedStencilBuffer = this.getStencilBuffer();
    this._cachedStencilFunction = this.getStencilFunction();
    this._cachedStencilMask = this.getStencilMask();
    this._cachedStencilOperationPass = this.getStencilOperationPass();
    this._cachedStencilOperationFail = this.getStencilOperationFail();
    this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail();
    this._cachedStencilReference = this.getStencilFunctionReference();
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.restoreStencilState = function () {
    this.setStencilFunction(this._cachedStencilFunction);
    this.setStencilMask(this._cachedStencilMask);
    this.setStencilBuffer(this._cachedStencilBuffer);
    this.setStencilOperationPass(this._cachedStencilOperationPass);
    this.setStencilOperationFail(this._cachedStencilOperationFail);
    this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail);
    this.setStencilFunctionReference(this._cachedStencilReference);
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.setAlphaConstants = function (r, g, b, a) {
    this._alphaState.setAlphaBlendConstants(r, g, b, a);
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getAlphaMode = function () {
    return this._alphaMode;
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.getAlphaEquation = function () {
    return this._alphaEquation;
};
//# sourceMappingURL=abstractEngine.states.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.texture.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.texture.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");

_abstractEngine_js__WEBPACK_IMPORTED_MODULE_0__.AbstractEngine.prototype.createDepthStencilTexture = function (size, options, rtWrapper) {
    if (options.isCube) {
        const width = size.width || size;
        return this._createDepthStencilCubeTexture(width, options);
    }
    else {
        return this._createDepthStencilTexture(size, options, rtWrapper);
    }
};
//# sourceMappingURL=abstractEngine.texture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/Extensions/engine.alpha.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/Extensions/engine.alpha.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js");


_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.setAlphaMode = function (mode, noDepthWriteChange = false) {
    if (this._alphaMode === mode) {
        if (!noDepthWriteChange) {
            // Make sure we still have the correct depth mask according to the alpha mode (a transparent material could have forced writting to the depth buffer, for instance)
            const depthMask = mode === 0;
            if (this.depthCullingState.depthMask !== depthMask) {
                this.depthCullingState.depthMask = depthMask;
            }
        }
        return;
    }
    switch (mode) {
        case 0:
            this._alphaState.alphaBlend = false;
            break;
        case 7:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
            this._alphaState.alphaBlend = true;
            break;
        case 8:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
            this._alphaState.alphaBlend = true;
            break;
        case 2:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
            this._alphaState.alphaBlend = true;
            break;
        case 6:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
            this._alphaState.alphaBlend = true;
            break;
        case 1:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
            this._alphaState.alphaBlend = true;
            break;
        case 3:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
            this._alphaState.alphaBlend = true;
            break;
        case 4:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE);
            this._alphaState.alphaBlend = true;
            break;
        case 5:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
            this._alphaState.alphaBlend = true;
            break;
        case 9:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA);
            this._alphaState.alphaBlend = true;
            break;
        case 10:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
            this._alphaState.alphaBlend = true;
            break;
        case 11:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE);
            this._alphaState.alphaBlend = true;
            break;
        case 12:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO);
            this._alphaState.alphaBlend = true;
            break;
        case 13:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
            this._alphaState.alphaBlend = true;
            break;
        case 14:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
            this._alphaState.alphaBlend = true;
            break;
        case 15:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO);
            this._alphaState.alphaBlend = true;
            break;
        case 16:
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE);
            this._alphaState.alphaBlend = true;
            break;
        case 17:
            // Same as ALPHA_COMBINE but accumulates (1 - alpha) values in the alpha channel for a later readout in order independant transparency
            this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
            this._alphaState.alphaBlend = true;
            break;
    }
    if (!noDepthWriteChange) {
        this.depthCullingState.depthMask = mode === 0;
    }
    this._alphaMode = mode;
};
//# sourceMappingURL=engine.alpha.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/Extensions/engine.cubeTexture.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/Extensions/engine.cubeTexture.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js");
/* harmony import */ var _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Materials/Textures/internalTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/internalTexture.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Misc/tools.functions.js */ "./node_modules/@babylonjs/core/Misc/tools.functions.js");





_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype._createDepthStencilCubeTexture = function (size, options) {
    const internalTexture = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_1__.InternalTexture(this, 12 /* InternalTextureSource.DepthStencil */);
    internalTexture.isCube = true;
    if (this.webGLVersion === 1) {
        _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.Error("Depth cube texture is not supported by WebGL 1.");
        return internalTexture;
    }
    const internalOptions = {
        bilinearFiltering: false,
        comparisonFunction: 0,
        generateStencil: false,
        ...options,
    };
    const gl = this._gl;
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);
    this._setupDepthStencilTexture(internalTexture, size, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);
    // Create the depth/stencil buffer
    for (let face = 0; face < 6; face++) {
        if (internalOptions.generateStencil) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);
        }
        else {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
        }
    }
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
    this._internalTexturesCache.push(internalTexture);
    return internalTexture;
};
_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype._setCubeMapTextureParams = function (texture, loadMipmap, maxLevel) {
    const gl = this._gl;
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    texture.samplingMode = loadMipmap ? 3 : 2;
    if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== undefined && maxLevel > 0) {
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);
        texture._maxLodLevel = maxLevel;
    }
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
};
_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, loaderOptions, useSRGBBuffer = false, buffer = null) {
    const gl = this._gl;
    return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, (texture) => this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true), (texture, imgs) => {
        const width = this.needPOTTextures ? (0,_Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_3__.GetExponentOfTwo)(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;
        const height = width;
        const faces = [
            gl.TEXTURE_CUBE_MAP_POSITIVE_X,
            gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
            gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
        ];
        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
        this._unpackFlipY(false);
        const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : gl.RGBA;
        let texelFormat = format ? this._getInternalFormat(format) : gl.RGBA;
        if (texture._useSRGBBuffer && this.webGLVersion === 1) {
            texelFormat = internalFormat;
        }
        for (let index = 0; index < faces.length; index++) {
            if (imgs[index].width !== width || imgs[index].height !== height) {
                this._prepareWorkingCanvas();
                if (!this._workingCanvas || !this._workingContext) {
                    _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.Warn("Cannot create canvas to resize texture.");
                    return;
                }
                this._workingCanvas.width = width;
                this._workingCanvas.height = height;
                this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);
                gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas);
            }
            else {
                gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);
            }
        }
        if (!noMipmap) {
            gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        }
        this._setCubeMapTextureParams(texture, !noMipmap);
        texture.width = width;
        texture.height = height;
        texture.isReady = true;
        if (format) {
            texture.format = format;
        }
        texture.onLoadedObservable.notifyObservers(texture);
        texture.onLoadedObservable.clear();
        if (onLoad) {
            onLoad();
        }
    }, !!useSRGBBuffer, buffer);
};
_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.generateMipMapsForCubemap = function (texture, unbind = true) {
    if (texture.generateMipMaps) {
        const gl = this._gl;
        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        if (unbind) {
            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
        }
    }
};
//# sourceMappingURL=engine.cubeTexture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicBuffer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicBuffer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js");

// eslint-disable-next-line @typescript-eslint/no-unused-vars
_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer, indices, offset = 0) {
    // Force cache update
    this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null;
    this.bindIndexBuffer(indexBuffer);
    let view;
    if (indexBuffer.is32Bits) {
        // anything else than Uint32Array needs to be converted to Uint32Array
        view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);
    }
    else {
        // anything else than Uint16Array needs to be converted to Uint16Array
        view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);
    }
    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, view, this._gl.DYNAMIC_DRAW);
    this._resetIndexBufferBinding();
};
_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer, data, byteOffset, byteLength) {
    this.bindArrayBuffer(vertexBuffer);
    if (byteOffset === undefined) {
        byteOffset = 0;
    }
    const dataLength = data.byteLength || data.length;
    if (byteLength === undefined || (byteLength >= dataLength && byteOffset === 0)) {
        if (data instanceof Array) {
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data));
        }
        else {
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);
        }
    }
    else {
        if (data instanceof Array) {
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data).subarray(0, byteLength / 4));
        }
        else {
            if (data instanceof ArrayBuffer) {
                data = new Uint8Array(data, 0, byteLength);
            }
            else {
                data = new Uint8Array(data.buffer, data.byteOffset, byteLength);
            }
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);
        }
    }
    this._resetVertexBufferBinding();
};
//# sourceMappingURL=engine.dynamicBuffer.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/Extensions/engine.prefilteredCubeTexture.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/Extensions/engine.prefilteredCubeTexture.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js");
/* harmony import */ var _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Materials/Textures/internalTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/internalTexture.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _Maths_sphericalPolynomial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Maths/sphericalPolynomial.js */ "./node_modules/@babylonjs/core/Maths/sphericalPolynomial.js");
/* harmony import */ var _Materials_Textures_baseTexture_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Materials/Textures/baseTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/baseTexture.js");






_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.createPrefilteredCubeTexture = function (rootUrl, scene, lodScale, lodOffset, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = true) {
    const callbackAsync = async (loadData) => {
        if (!loadData) {
            if (onLoad) {
                onLoad(null);
            }
            return;
        }
        const texture = loadData.texture;
        if (!createPolynomials) {
            texture._sphericalPolynomial = new _Maths_sphericalPolynomial_js__WEBPACK_IMPORTED_MODULE_3__.SphericalPolynomial();
        }
        else if (loadData.info.sphericalPolynomial) {
            texture._sphericalPolynomial = loadData.info.sphericalPolynomial;
        }
        texture._source = 9 /* InternalTextureSource.CubePrefiltered */;
        if (this.getCaps().textureLOD) {
            // Do not add extra process if texture lod is supported.
            if (onLoad) {
                onLoad(texture);
            }
            return;
        }
        const mipSlices = 3;
        const gl = this._gl;
        const width = loadData.width;
        if (!width) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const { DDSTools } = await __webpack_require__.e(/*! import() */ "vendors-node_modules_babylonjs_core_Misc_dds_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../Misc/dds.js */ "./node_modules/@babylonjs/core/Misc/dds.js"));
        const textures = [];
        for (let i = 0; i < mipSlices; i++) {
            //compute LOD from even spacing in smoothness (matching shader calculation)
            const smoothness = i / (mipSlices - 1);
            const roughness = 1 - smoothness;
            const minLODIndex = lodOffset; // roughness = 0
            const maxLODIndex = Math.log2(width) * lodScale + lodOffset; // roughness = 1
            const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
            const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
            const glTextureFromLod = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_1__.InternalTexture(this, 2 /* InternalTextureSource.Temp */);
            glTextureFromLod.type = texture.type;
            glTextureFromLod.format = texture.format;
            glTextureFromLod.width = Math.pow(2, Math.max(Math.log2(width) - mipmapIndex, 0));
            glTextureFromLod.height = glTextureFromLod.width;
            glTextureFromLod.isCube = true;
            glTextureFromLod._cachedWrapU = 0;
            glTextureFromLod._cachedWrapV = 0;
            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);
            glTextureFromLod.samplingMode = 2;
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            if (loadData.isDDS) {
                const info = loadData.info;
                const data = loadData.data;
                this._unpackFlipY(info.isCompressed);
                DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);
            }
            else {
                _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.Warn("DDS is the only prefiltered cube map supported so far.");
            }
            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
            // Wrap in a base texture for easy binding.
            const lodTexture = new _Materials_Textures_baseTexture_js__WEBPACK_IMPORTED_MODULE_4__.BaseTexture(scene);
            lodTexture._isCube = true;
            lodTexture._texture = glTextureFromLod;
            glTextureFromLod.isReady = true;
            textures.push(lodTexture);
        }
        texture._lodTextureHigh = textures[2];
        texture._lodTextureMid = textures[1];
        texture._lodTextureLow = textures[0];
        if (onLoad) {
            onLoad(texture);
        }
    };
    return this.createCubeTexture(rootUrl, scene, null, false, callbackAsync, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);
};
//# sourceMappingURL=engine.prefilteredCubeTexture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/Extensions/engine.rawTexture.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/Extensions/engine.rawTexture.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Materials/Textures/internalTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/internalTexture.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _thinEngine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js");
/* harmony import */ var _Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Misc/tools.functions.js */ "./node_modules/@babylonjs/core/Misc/tools.functions.js");





_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.updateRawTexture = function (texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {
    if (!texture) {
        return;
    }
    // Babylon's internalSizedFomat but gl's texImage2D internalFormat
    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);
    // Babylon's internalFormat but gl's texImage2D format
    const internalFormat = this._getInternalFormat(format);
    const textureType = this._getWebGLTextureType(type);
    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);
    if (!this._doNotHandleContextLost) {
        texture._bufferView = data;
        texture.format = format;
        texture.type = type;
        texture.invertY = invertY;
        texture._compression = compression;
    }
    if (texture.width % 4 !== 0) {
        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
    }
    if (compression && data) {
        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);
    }
    else {
        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);
    }
    if (texture.generateMipMaps) {
        this._gl.generateMipmap(this._gl.TEXTURE_2D);
    }
    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
    //  this.resetTextureCache();
    texture.isReady = true;
};
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
creationFlags = 0, useSRGBBuffer = false) {
    const texture = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__.InternalTexture(this, 3 /* InternalTextureSource.Raw */);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.format = format;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture._compression = compression;
    texture.type = type;
    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);
    if (!this._doNotHandleContextLost) {
        texture._bufferView = data;
    }
    this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);
    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
    // Filters
    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
        this._gl.generateMipmap(this._gl.TEXTURE_2D);
    }
    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
    this._internalTexturesCache.push(texture);
    return texture;
};
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.createRawCubeTexture = function (data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {
    const gl = this._gl;
    const texture = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__.InternalTexture(this, 8 /* InternalTextureSource.CubeRaw */);
    texture.isCube = true;
    texture.format = format;
    texture.type = type;
    if (!this._doNotHandleContextLost) {
        texture._bufferViewArray = data;
    }
    const textureType = this._getWebGLTextureType(type);
    let internalFormat = this._getInternalFormat(format);
    if (internalFormat === gl.RGB) {
        internalFormat = gl.RGBA;
    }
    // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable
    if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {
        generateMipMaps = false;
        samplingMode = 1;
        _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
    }
    else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {
        generateMipMaps = false;
        samplingMode = 1;
        _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
    }
    else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {
        generateMipMaps = false;
        _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn("Render to float textures is not supported. Mipmap generation forced to false.");
    }
    else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {
        generateMipMaps = false;
        _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn("Render to half float textures is not supported. Mipmap generation forced to false.");
    }
    const width = size;
    const height = width;
    texture.width = width;
    texture.height = height;
    texture.invertY = invertY;
    texture._compression = compression;
    // Double check on POT to generate Mips.
    const isPot = !this.needPOTTextures || ((0,_Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_3__.IsExponentOfTwo)(texture.width) && (0,_Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_3__.IsExponentOfTwo)(texture.height));
    if (!isPot) {
        generateMipMaps = false;
    }
    // Upload data if needed. The texture won't be ready until then.
    if (data) {
        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);
    }
    else {
        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
        const level = 0;
        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
            if (compression) {
                gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, undefined);
            }
            else {
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);
            }
        }
        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
    }
    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
    // Filters
    if (data && generateMipMaps) {
        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
    }
    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.isReady = true;
    return texture;
};
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.updateRawCubeTexture = function (texture, data, format, type, invertY, compression = null, level = 0) {
    texture._bufferViewArray = data;
    texture.format = format;
    texture.type = type;
    texture.invertY = invertY;
    texture._compression = compression;
    const gl = this._gl;
    const textureType = this._getWebGLTextureType(type);
    let internalFormat = this._getInternalFormat(format);
    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
    let needConversion = false;
    if (internalFormat === gl.RGB) {
        internalFormat = gl.RGBA;
        needConversion = true;
    }
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);
    if (texture.width % 4 !== 0) {
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    }
    // Data are known to be in +X +Y +Z -X -Y -Z
    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
        let faceData = data[faceIndex];
        if (compression) {
            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);
        }
        else {
            if (needConversion) {
                faceData = ConvertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);
            }
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);
        }
    }
    const isPot = !this.needPOTTextures || ((0,_Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_3__.IsExponentOfTwo)(texture.width) && (0,_Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_3__.IsExponentOfTwo)(texture.height));
    if (isPot && texture.generateMipMaps && level === 0) {
        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
    }
    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
    // this.resetTextureCache();
    texture.isReady = true;
};
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.createRawCubeTextureFromUrl = function (url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad = null, onError = null, samplingMode = 3, invertY = false) {
    const gl = this._gl;
    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);
    scene?.addPendingData(texture);
    texture.url = url;
    texture.isReady = false;
    this._internalTexturesCache.push(texture);
    const onerror = (request, exception) => {
        scene?.removePendingData(texture);
        if (onError && request) {
            onError(request.status + " " + request.statusText, exception);
        }
    };
    const internalCallback = (data) => {
        // If the texture has been disposed
        if (!texture._hardwareTexture) {
            return;
        }
        const width = texture.width;
        const faceDataArrays = callback(data);
        if (!faceDataArrays) {
            return;
        }
        if (mipmapGenerator) {
            const textureType = this._getWebGLTextureType(type);
            let internalFormat = this._getInternalFormat(format);
            const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
            let needConversion = false;
            if (internalFormat === gl.RGB) {
                internalFormat = gl.RGBA;
                needConversion = true;
            }
            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
            this._unpackFlipY(false);
            const mipData = mipmapGenerator(faceDataArrays);
            for (let level = 0; level < mipData.length; level++) {
                const mipSize = width >> level;
                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
                    let mipFaceData = mipData[level][faceIndex];
                    if (needConversion) {
                        mipFaceData = ConvertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);
                    }
                    gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);
                }
            }
            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
        }
        else {
            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);
        }
        texture.isReady = true;
        // this.resetTextureCache();
        scene?.removePendingData(texture);
        texture.onLoadedObservable.notifyObservers(texture);
        texture.onLoadedObservable.clear();
        if (onLoad) {
            onLoad();
        }
    };
    this._loadFile(url, (data) => {
        internalCallback(data);
    }, undefined, scene?.offlineProvider, true, onerror);
    return texture;
};
/**
 * @internal
 */
function ConvertRGBtoRGBATextureData(rgbData, width, height, textureType) {
    // Create new RGBA data container.
    let rgbaData;
    let val1 = 1;
    if (textureType === 1) {
        rgbaData = new Float32Array(width * height * 4);
    }
    else if (textureType === 2) {
        rgbaData = new Uint16Array(width * height * 4);
        val1 = 15360; // 15360 is the encoding of 1 in half float
    }
    else if (textureType === 7) {
        rgbaData = new Uint32Array(width * height * 4);
    }
    else {
        rgbaData = new Uint8Array(width * height * 4);
    }
    // Convert each pixel.
    for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
            const index = (y * width + x) * 3;
            const newIndex = (y * width + x) * 4;
            // Map Old Value to new value.
            rgbaData[newIndex + 0] = rgbData[index + 0];
            rgbaData[newIndex + 1] = rgbData[index + 1];
            rgbaData[newIndex + 2] = rgbData[index + 2];
            // Add fully opaque alpha channel.
            rgbaData[newIndex + 3] = val1;
        }
    }
    return rgbaData;
}
/**
 * Create a function for createRawTexture3D/createRawTexture2DArray
 * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function MakeCreateRawTextureFunction(is3D) {
    return function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
        const source = is3D ? 10 /* InternalTextureSource.Raw3D */ : 11 /* InternalTextureSource.Raw2DArray */;
        const texture = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__.InternalTexture(this, source);
        texture.baseWidth = width;
        texture.baseHeight = height;
        texture.baseDepth = depth;
        texture.width = width;
        texture.height = height;
        texture.depth = depth;
        texture.format = format;
        texture.type = textureType;
        texture.generateMipMaps = generateMipMaps;
        texture.samplingMode = samplingMode;
        if (is3D) {
            texture.is3D = true;
        }
        else {
            texture.is2DArray = true;
        }
        if (!this._doNotHandleContextLost) {
            texture._bufferView = data;
        }
        if (is3D) {
            this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);
        }
        else {
            this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);
        }
        this._bindTextureDirectly(target, texture, true);
        // Filters
        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
        this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);
        this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
        if (generateMipMaps) {
            this._gl.generateMipmap(target);
        }
        this._bindTextureDirectly(target, null);
        this._internalTexturesCache.push(texture);
        return texture;
    };
}
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.createRawTexture2DArray = MakeCreateRawTextureFunction(false);
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.createRawTexture3D = MakeCreateRawTextureFunction(true);
/**
 * Create a function for updateRawTexture3D/updateRawTexture2DArray
 * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY
 * @internal
 */
function MakeUpdateRawTextureFunction(is3D) {
    return function (texture, data, format, invertY, compression = null, textureType = 0) {
        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
        const internalType = this._getWebGLTextureType(textureType);
        const internalFormat = this._getInternalFormat(format);
        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);
        this._bindTextureDirectly(target, texture, true);
        this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);
        if (!this._doNotHandleContextLost) {
            texture._bufferView = data;
            texture.format = format;
            texture.invertY = invertY;
            texture._compression = compression;
        }
        if (texture.width % 4 !== 0) {
            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
        }
        if (compression && data) {
            this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);
        }
        else {
            this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);
        }
        if (texture.generateMipMaps) {
            this._gl.generateMipmap(target);
        }
        this._bindTextureDirectly(target, null);
        // this.resetTextureCache();
        texture.isReady = true;
    };
}
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.updateRawTexture2DArray = MakeUpdateRawTextureFunction(false);
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.updateRawTexture3D = MakeUpdateRawTextureFunction(true);
//# sourceMappingURL=engine.rawTexture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/Extensions/engine.readTexture.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/Extensions/engine.readTexture.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   allocateAndCopyTypedBuffer: () => (/* reexport safe */ _Engines_abstractEngine_functions_js__WEBPACK_IMPORTED_MODULE_1__.allocateAndCopyTypedBuffer)
/* harmony export */ });
/* harmony import */ var _Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js");
/* harmony import */ var _Engines_abstractEngine_functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Engines/abstractEngine.functions.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.functions.js");

// back-compat


_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype._readTexturePixelsSync = function (texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {
    const gl = this._gl;
    if (!gl) {
        throw new Error("Engine does not have gl rendering context.");
    }
    if (!this._dummyFramebuffer) {
        const dummy = gl.createFramebuffer();
        if (!dummy) {
            throw new Error("Unable to create dummy framebuffer");
        }
        this._dummyFramebuffer = dummy;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);
    if (faceIndex > -1) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture._hardwareTexture?.underlyingResource, level);
    }
    else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture?.underlyingResource, level);
    }
    let readType = texture.type !== undefined ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;
    if (!noDataConversion) {
        switch (readType) {
            case gl.UNSIGNED_BYTE:
                if (!buffer) {
                    buffer = new Uint8Array(4 * width * height);
                }
                readType = gl.UNSIGNED_BYTE;
                break;
            default:
                if (!buffer) {
                    buffer = new Float32Array(4 * width * height);
                }
                readType = gl.FLOAT;
                break;
        }
    }
    else if (!buffer) {
        buffer = (0,_Engines_abstractEngine_functions_js__WEBPACK_IMPORTED_MODULE_1__.allocateAndCopyTypedBuffer)(texture.type, 4 * width * height);
    }
    if (flushRenderer) {
        this.flushFramebuffer();
    }
    gl.readPixels(x, y, width, height, gl.RGBA, readType, buffer);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);
    return buffer;
};
_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype._readTexturePixels = function (texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {
    return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y));
};
//# sourceMappingURL=engine.readTexture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/Extensions/engine.renderTarget.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/Extensions/engine.renderTarget.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Materials/Textures/internalTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/internalTexture.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _thinEngine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js");
/* harmony import */ var _WebGL_webGLRenderTargetWrapper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../WebGL/webGLRenderTargetWrapper.js */ "./node_modules/@babylonjs/core/Engines/WebGL/webGLRenderTargetWrapper.js");
/* harmony import */ var _Materials_Textures_textureHelper_functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Materials/Textures/textureHelper.functions.js */ "./node_modules/@babylonjs/core/Materials/Textures/textureHelper.functions.js");
/* harmony import */ var _AbstractEngine_abstractEngine_texture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../AbstractEngine/abstractEngine.texture.js */ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.texture.js");







_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype._createHardwareRenderTargetWrapper = function (isMulti, isCube, size) {
    const rtWrapper = new _WebGL_webGLRenderTargetWrapper_js__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTargetWrapper(isMulti, isCube, size, this, this._gl);
    this._renderTargetWrapperCache.push(rtWrapper);
    return rtWrapper;
};
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.createRenderTargetTexture = function (size, options) {
    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);
    let generateDepthBuffer = true;
    let generateStencilBuffer = false;
    let noColorAttachment = false;
    let colorAttachment = undefined;
    let samples = 1;
    let label = undefined;
    if (options !== undefined && typeof options === "object") {
        generateDepthBuffer = options.generateDepthBuffer ?? true;
        generateStencilBuffer = !!options.generateStencilBuffer;
        noColorAttachment = !!options.noColorAttachment;
        colorAttachment = options.colorAttachment;
        samples = options.samples ?? 1;
        label = options.label;
    }
    const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, 5 /* InternalTextureSource.RenderTarget */));
    const width = size.width || size;
    const height = size.height || size;
    const currentFrameBuffer = this._currentFramebuffer;
    const gl = this._gl;
    // Create the framebuffer
    const framebuffer = gl.createFramebuffer();
    this._bindUnboundFramebuffer(framebuffer);
    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height);
    // No need to rebind on every frame
    if (texture && !texture.is2DArray && !texture.is3D) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, 0);
    }
    this._bindUnboundFramebuffer(currentFrameBuffer);
    rtWrapper.label = label ?? "RenderTargetWrapper";
    rtWrapper._framebuffer = framebuffer;
    rtWrapper._generateDepthBuffer = generateDepthBuffer;
    rtWrapper._generateStencilBuffer = generateStencilBuffer;
    rtWrapper.setTextures(texture);
    if (!colorAttachment) {
        this.updateRenderTargetTextureSampleCount(rtWrapper, samples);
    }
    else {
        rtWrapper._samples = colorAttachment.samples;
        if (colorAttachment.samples > 1) {
            const msaaRenderBuffer = colorAttachment._hardwareTexture.getMSAARenderBuffer(0);
            rtWrapper._MSAAFramebuffer = gl.createFramebuffer();
            this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, msaaRenderBuffer);
            this._bindUnboundFramebuffer(null);
        }
    }
    return rtWrapper;
};
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype._createDepthStencilTexture = function (size, options, rtWrapper) {
    const gl = this._gl;
    const layers = size.layers || 0;
    const depth = size.depth || 0;
    let target = gl.TEXTURE_2D;
    if (layers !== 0) {
        target = gl.TEXTURE_2D_ARRAY;
    }
    else if (depth !== 0) {
        target = gl.TEXTURE_3D;
    }
    const internalTexture = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__.InternalTexture(this, 12 /* InternalTextureSource.DepthStencil */);
    internalTexture.label = options.label;
    if (!this._caps.depthTextureExtension) {
        _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Error("Depth texture is not supported by your browser or hardware.");
        return internalTexture;
    }
    const internalOptions = {
        bilinearFiltering: false,
        comparisonFunction: 0,
        generateStencil: false,
        ...options,
    };
    this._bindTextureDirectly(target, internalTexture, true);
    this._setupDepthStencilTexture(internalTexture, size, internalOptions.comparisonFunction === 0 ? false : internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);
    if (internalOptions.depthTextureFormat !== undefined) {
        if (internalOptions.depthTextureFormat !== 15 &&
            internalOptions.depthTextureFormat !== 16 &&
            internalOptions.depthTextureFormat !== 17 &&
            internalOptions.depthTextureFormat !== 13 &&
            internalOptions.depthTextureFormat !== 14 &&
            internalOptions.depthTextureFormat !== 18) {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(`Depth texture ${internalOptions.depthTextureFormat} format is not supported.`);
            return internalTexture;
        }
        internalTexture.format = internalOptions.depthTextureFormat;
    }
    else {
        internalTexture.format = internalOptions.generateStencil ? 13 : 16;
    }
    const hasStencil = (0,_Materials_Textures_textureHelper_functions_js__WEBPACK_IMPORTED_MODULE_4__.HasStencilAspect)(internalTexture.format);
    const type = this._getWebGLTextureTypeFromDepthTextureFormat(internalTexture.format);
    const format = hasStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;
    const internalFormat = this._getInternalFormatFromDepthTextureFormat(internalTexture.format, true, hasStencil);
    if (internalTexture.is2DArray) {
        gl.texImage3D(target, 0, internalFormat, internalTexture.width, internalTexture.height, layers, 0, format, type, null);
    }
    else if (internalTexture.is3D) {
        gl.texImage3D(target, 0, internalFormat, internalTexture.width, internalTexture.height, depth, 0, format, type, null);
    }
    else {
        gl.texImage2D(target, 0, internalFormat, internalTexture.width, internalTexture.height, 0, format, type, null);
    }
    this._bindTextureDirectly(target, null);
    this._internalTexturesCache.push(internalTexture);
    if (rtWrapper._depthStencilBuffer) {
        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);
        rtWrapper._depthStencilBuffer = null;
    }
    this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer ?? rtWrapper._framebuffer);
    rtWrapper._generateStencilBuffer = hasStencil;
    rtWrapper._depthStencilTextureWithStencil = hasStencil;
    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.width, rtWrapper.height, rtWrapper.samples, internalTexture.format);
    this._bindUnboundFramebuffer(null);
    return internalTexture;
};
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.updateRenderTargetTextureSampleCount = function (rtWrapper, samples) {
    if (this.webGLVersion < 2 || !rtWrapper) {
        return 1;
    }
    if (rtWrapper.samples === samples) {
        return samples;
    }
    const gl = this._gl;
    samples = Math.min(samples, this.getCaps().maxMSAASamples);
    // Dispose previous render buffers
    if (rtWrapper._depthStencilBuffer) {
        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);
        rtWrapper._depthStencilBuffer = null;
    }
    if (rtWrapper._MSAAFramebuffer) {
        gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);
        rtWrapper._MSAAFramebuffer = null;
    }
    const hardwareTexture = rtWrapper.texture?._hardwareTexture;
    hardwareTexture?.releaseMSAARenderBuffers();
    if (rtWrapper.texture && samples > 1 && typeof gl.renderbufferStorageMultisample === "function") {
        const framebuffer = gl.createFramebuffer();
        if (!framebuffer) {
            throw new Error("Unable to create multi sampled framebuffer");
        }
        rtWrapper._MSAAFramebuffer = framebuffer;
        this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer);
        const colorRenderbuffer = this._createRenderBuffer(rtWrapper.texture.width, rtWrapper.texture.height, samples, -1 /* not used */, this._getRGBABufferInternalSizedFormat(rtWrapper.texture.type, rtWrapper.texture.format, rtWrapper.texture._useSRGBBuffer), gl.COLOR_ATTACHMENT0, false);
        if (!colorRenderbuffer) {
            throw new Error("Unable to create multi sampled framebuffer");
        }
        hardwareTexture?.addMSAARenderBuffer(colorRenderbuffer);
    }
    this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer ?? rtWrapper._framebuffer);
    if (rtWrapper.texture) {
        rtWrapper.texture.samples = samples;
    }
    rtWrapper._samples = samples;
    const depthFormat = rtWrapper._depthStencilTexture ? rtWrapper._depthStencilTexture.format : undefined;
    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.width, rtWrapper.height, samples, depthFormat);
    this._bindUnboundFramebuffer(null);
    return samples;
};
_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype._setupDepthStencilTexture = function (internalTexture, size, bilinearFiltering, comparisonFunction, samples = 1) {
    const width = size.width ?? size;
    const height = size.height ?? size;
    const layers = size.layers || 0;
    const depth = size.depth || 0;
    internalTexture.baseWidth = width;
    internalTexture.baseHeight = height;
    internalTexture.width = width;
    internalTexture.height = height;
    internalTexture.is2DArray = layers > 0;
    internalTexture.depth = layers || depth;
    internalTexture.isReady = true;
    internalTexture.samples = samples;
    internalTexture.generateMipMaps = false;
    internalTexture.samplingMode = bilinearFiltering ? 2 : 1;
    internalTexture.type = 0;
    internalTexture._comparisonFunction = comparisonFunction;
    const gl = this._gl;
    const target = this._getTextureTarget(internalTexture);
    const samplingParameters = this._getSamplingParameters(internalTexture.samplingMode, false);
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, samplingParameters.mag);
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, samplingParameters.min);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    // TEXTURE_COMPARE_FUNC/MODE are only availble in WebGL2.
    if (this.webGLVersion > 1) {
        if (comparisonFunction === 0) {
            gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, 515);
            gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.NONE);
        }
        else {
            gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
            gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
        }
    }
};
//# sourceMappingURL=engine.renderTarget.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetCube.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetCube.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Materials/Textures/internalTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/internalTexture.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _thinEngine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js");




_thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine.prototype.createRenderTargetCubeTexture = function (size, options) {
    const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);
    const fullOptions = {
        generateMipMaps: true,
        generateDepthBuffer: true,
        generateStencilBuffer: false,
        type: 0,
        samplingMode: 3,
        format: 5,
        ...options,
    };
    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;
    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
        // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE
        fullOptions.samplingMode = 1;
    }
    else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
        // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE
        fullOptions.samplingMode = 1;
    }
    const gl = this._gl;
    const texture = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__.InternalTexture(this, 5 /* InternalTextureSource.RenderTarget */);
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
    const filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps);
    if (fullOptions.type === 1 && !this._caps.textureFloat) {
        fullOptions.type = 0;
        _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type");
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    for (let face = 0; face < 6; face++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format), size, size, 0, this._getInternalFormat(fullOptions.format), this._getWebGLTextureType(fullOptions.type), null);
    }
    // Create the framebuffer
    const framebuffer = gl.createFramebuffer();
    this._bindUnboundFramebuffer(framebuffer);
    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer, fullOptions.generateDepthBuffer, size, size);
    // MipMaps
    if (fullOptions.generateMipMaps) {
        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
    }
    // Unbind
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
    this._bindUnboundFramebuffer(null);
    rtWrapper._framebuffer = framebuffer;
    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;
    texture.width = size;
    texture.height = size;
    texture.isReady = true;
    texture.isCube = true;
    texture.samples = 1;
    texture.generateMipMaps = fullOptions.generateMipMaps;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    texture.format = fullOptions.format;
    this._internalTexturesCache.push(texture);
    rtWrapper.setTextures(texture);
    return rtWrapper;
};
//# sourceMappingURL=engine.renderTargetCube.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetTexture.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetTexture.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js");

_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.setDepthStencilTexture = function (channel, uniform, texture, name) {
    if (channel === undefined) {
        return;
    }
    if (uniform) {
        this._boundUniforms[channel] = uniform;
    }
    if (!texture || !texture.depthStencilTexture) {
        this._setTexture(channel, null, undefined, undefined, name);
    }
    else {
        this._setTexture(channel, texture, false, true, name);
    }
};
//# sourceMappingURL=engine.renderTargetTexture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/Extensions/engine.uniformBuffer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/Extensions/engine.uniformBuffer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js");
/* harmony import */ var _Meshes_WebGL_webGLDataBuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Meshes/WebGL/webGLDataBuffer.js */ "./node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js");


_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.createUniformBuffer = function (elements, _label) {
    const ubo = this._gl.createBuffer();
    if (!ubo) {
        throw new Error("Unable to create uniform buffer");
    }
    const result = new _Meshes_WebGL_webGLDataBuffer_js__WEBPACK_IMPORTED_MODULE_1__.WebGLDataBuffer(ubo);
    this.bindUniformBuffer(result);
    if (elements instanceof Float32Array) {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.STATIC_DRAW);
    }
    else {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.STATIC_DRAW);
    }
    this.bindUniformBuffer(null);
    result.references = 1;
    return result;
};
_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.createDynamicUniformBuffer = function (elements, _label) {
    const ubo = this._gl.createBuffer();
    if (!ubo) {
        throw new Error("Unable to create dynamic uniform buffer");
    }
    const result = new _Meshes_WebGL_webGLDataBuffer_js__WEBPACK_IMPORTED_MODULE_1__.WebGLDataBuffer(ubo);
    this.bindUniformBuffer(result);
    if (elements instanceof Float32Array) {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.DYNAMIC_DRAW);
    }
    else {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.DYNAMIC_DRAW);
    }
    this.bindUniformBuffer(null);
    result.references = 1;
    return result;
};
_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.updateUniformBuffer = function (uniformBuffer, elements, offset, count) {
    this.bindUniformBuffer(uniformBuffer);
    if (offset === undefined) {
        offset = 0;
    }
    if (count === undefined) {
        if (elements instanceof Float32Array) {
            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, elements);
        }
        else {
            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(elements));
        }
    }
    else {
        if (elements instanceof Float32Array) {
            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, elements.subarray(offset, offset + count));
        }
        else {
            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(elements).subarray(offset, offset + count));
        }
    }
    this.bindUniformBuffer(null);
};
_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.bindUniformBuffer = function (buffer) {
    this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);
};
// eslint-disable-next-line @typescript-eslint/no-unused-vars
_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.bindUniformBufferBase = function (buffer, location, name) {
    this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location, buffer ? buffer.underlyingResource : null);
};
_Engines_thinEngine_js__WEBPACK_IMPORTED_MODULE_0__.ThinEngine.prototype.bindUniformBlock = function (pipelineContext, blockName, index) {
    const program = pipelineContext.program;
    const uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
    if (uniformLocation !== 0xffffffff) {
        this._gl.uniformBlockBinding(program, uniformLocation, index);
    }
};
//# sourceMappingURL=engine.uniformBuffer.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/WebGL/webGL2ShaderProcessors.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/WebGL/webGL2ShaderProcessors.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGL2ShaderProcessor: () => (/* binding */ WebGL2ShaderProcessor)
/* harmony export */ });
const VaryingRegex = /(flat\s)?\s*varying\s*.*/;
/** @internal */
class WebGL2ShaderProcessor {
    constructor() {
        this.shaderLanguage = 0 /* ShaderLanguage.GLSL */;
    }
    attributeProcessor(attribute) {
        return attribute.replace("attribute", "in");
    }
    varyingCheck(varying, _isFragment) {
        return VaryingRegex.test(varying);
    }
    varyingProcessor(varying, isFragment) {
        return varying.replace("varying", isFragment ? "in" : "out");
    }
    postProcessor(code, defines, isFragment) {
        const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;
        // Remove extensions
        const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
        code = code.replace(regex, "");
        // Replace instructions
        code = code.replace(/texture2D\s*\(/g, "texture(");
        if (isFragment) {
            const hasOutput = code.search(/layout *\(location *= *0\) *out/g) !== -1;
            code = code.replace(/texture2DLodEXT\s*\(/g, "textureLod(");
            code = code.replace(/textureCubeLodEXT\s*\(/g, "textureLod(");
            code = code.replace(/textureCube\s*\(/g, "texture(");
            code = code.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
            code = code.replace(/gl_FragColor/g, "glFragColor");
            code = code.replace(/gl_FragData/g, "glFragData");
            code = code.replace(/void\s+?main\s*\(/g, (hasDrawBuffersExtension || hasOutput ? "" : "layout(location = 0) out vec4 glFragColor;\n") + "void main(");
        }
        else {
            const hasMultiviewExtension = defines.indexOf("#define MULTIVIEW") !== -1;
            if (hasMultiviewExtension) {
                return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + code;
            }
        }
        return code;
    }
}
//# sourceMappingURL=webGL2ShaderProcessors.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/WebGL/webGLHardwareTexture.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/WebGL/webGLHardwareTexture.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLHardwareTexture: () => (/* binding */ WebGLHardwareTexture)
/* harmony export */ });
/** @internal */
class WebGLHardwareTexture {
    get underlyingResource() {
        return this._webGLTexture;
    }
    constructor(existingTexture = null, context) {
        // There can be multiple buffers for a single WebGL texture because different layers of a 2DArrayTexture / 3DTexture
        // or different faces of a cube texture can be bound to different render targets at the same time.
        // eslint-disable-next-line @typescript-eslint/naming-convention
        this._MSAARenderBuffers = null;
        this._context = context;
        if (!existingTexture) {
            existingTexture = context.createTexture();
            if (!existingTexture) {
                throw new Error("Unable to create webGL texture");
            }
        }
        this.set(existingTexture);
    }
    setUsage() { }
    set(hardwareTexture) {
        this._webGLTexture = hardwareTexture;
    }
    reset() {
        this._webGLTexture = null;
        this._MSAARenderBuffers = null;
    }
    addMSAARenderBuffer(buffer) {
        if (!this._MSAARenderBuffers) {
            this._MSAARenderBuffers = [];
        }
        this._MSAARenderBuffers.push(buffer);
    }
    releaseMSAARenderBuffers() {
        if (this._MSAARenderBuffers) {
            for (const buffer of this._MSAARenderBuffers) {
                this._context.deleteRenderbuffer(buffer);
            }
            this._MSAARenderBuffers = null;
        }
    }
    getMSAARenderBuffer(index = 0) {
        return this._MSAARenderBuffers?.[index] ?? null;
    }
    release() {
        this.releaseMSAARenderBuffers();
        if (this._webGLTexture) {
            this._context.deleteTexture(this._webGLTexture);
        }
        this.reset();
    }
}
//# sourceMappingURL=webGLHardwareTexture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/WebGL/webGLRenderTargetWrapper.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/WebGL/webGLRenderTargetWrapper.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLRenderTargetWrapper: () => (/* binding */ WebGLRenderTargetWrapper)
/* harmony export */ });
/* harmony import */ var _renderTargetWrapper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderTargetWrapper.js */ "./node_modules/@babylonjs/core/Engines/renderTargetWrapper.js");
/* harmony import */ var _Materials_Textures_textureHelper_functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Materials/Textures/textureHelper.functions.js */ "./node_modules/@babylonjs/core/Materials/Textures/textureHelper.functions.js");



/** @internal */
class WebGLRenderTargetWrapper extends _renderTargetWrapper_js__WEBPACK_IMPORTED_MODULE_0__.RenderTargetWrapper {
    setDepthStencilTexture(texture, disposeExisting = true) {
        super.setDepthStencilTexture(texture, disposeExisting);
        if (!texture) {
            return;
        }
        const engine = this._engine;
        const gl = this._context;
        const hardwareTexture = texture._hardwareTexture;
        if (hardwareTexture && texture._autoMSAAManagement && this._MSAAFramebuffer) {
            const currentFb = engine._currentFramebuffer;
            engine._bindUnboundFramebuffer(this._MSAAFramebuffer);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, (0,_Materials_Textures_textureHelper_functions_js__WEBPACK_IMPORTED_MODULE_1__.HasStencilAspect)(texture.format) ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, hardwareTexture.getMSAARenderBuffer());
            engine._bindUnboundFramebuffer(currentFb);
        }
    }
    constructor(isMulti, isCube, size, engine, context) {
        super(isMulti, isCube, size, engine);
        /**
         * @internal
         */
        this._framebuffer = null;
        /**
         * @internal
         */
        this._depthStencilBuffer = null;
        // eslint-disable-next-line @typescript-eslint/naming-convention
        /**
         * @internal
         */
        // eslint-disable-next-line @typescript-eslint/naming-convention
        this._MSAAFramebuffer = null;
        // Multiview
        /**
         * @internal
         */
        this._colorTextureArray = null;
        /**
         * @internal
         */
        this._depthStencilTextureArray = null;
        /**
         * @internal
         */
        this._disposeOnlyFramebuffers = false;
        /**
         * @internal
         */
        this._currentLOD = 0;
        this._context = context;
    }
    _cloneRenderTargetWrapper() {
        let rtw = null;
        if (this._colorTextureArray && this._depthStencilTextureArray) {
            rtw = this._engine.createMultiviewRenderTargetTexture(this.width, this.height);
            rtw.texture.isReady = true;
        }
        else {
            rtw = super._cloneRenderTargetWrapper();
        }
        return rtw;
    }
    _swapRenderTargetWrapper(target) {
        super._swapRenderTargetWrapper(target);
        target._framebuffer = this._framebuffer;
        target._depthStencilBuffer = this._depthStencilBuffer;
        target._MSAAFramebuffer = this._MSAAFramebuffer;
        target._colorTextureArray = this._colorTextureArray;
        target._depthStencilTextureArray = this._depthStencilTextureArray;
        this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;
    }
    /**
     * Creates the depth/stencil texture
     * @param comparisonFunction Comparison function to use for the texture
     * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture
     * @param generateStencil true if the stencil aspect should also be created
     * @param samples sample count to use when creating the texture
     * @param format format of the depth texture
     * @param label defines the label to use for the texture (for debugging purpose only)
     * @returns the depth/stencil created texture
     */
    createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14, label) {
        if (this._depthStencilBuffer) {
            const engine = this._engine;
            // Dispose previous depth/stencil render buffers and clear the corresponding attachment.
            // Next time this framebuffer is bound, the new depth/stencil texture will be attached.
            const currentFrameBuffer = engine._currentFramebuffer;
            const gl = this._context;
            engine._bindUnboundFramebuffer(this._framebuffer);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, null);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);
            engine._bindUnboundFramebuffer(currentFrameBuffer);
            gl.deleteRenderbuffer(this._depthStencilBuffer);
            this._depthStencilBuffer = null;
        }
        return super.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format, label);
    }
    /**
     * Shares the depth buffer of this render target with another render target.
     * @param renderTarget Destination renderTarget
     */
    shareDepth(renderTarget) {
        super.shareDepth(renderTarget);
        const gl = this._context;
        const depthbuffer = this._depthStencilBuffer;
        const framebuffer = renderTarget._MSAAFramebuffer || renderTarget._framebuffer;
        const engine = this._engine;
        if (renderTarget._depthStencilBuffer && renderTarget._depthStencilBuffer !== depthbuffer) {
            gl.deleteRenderbuffer(renderTarget._depthStencilBuffer);
        }
        renderTarget._depthStencilBuffer = depthbuffer;
        const attachment = renderTarget._generateStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
        engine._bindUnboundFramebuffer(framebuffer);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, depthbuffer);
        engine._bindUnboundFramebuffer(null);
    }
    /**
     * Binds a texture to this render target on a specific attachment
     * @param texture The texture to bind to the framebuffer
     * @param attachmentIndex Index of the attachment
     * @param faceIndexOrLayer The face or layer of the texture to render to in case of cube texture or array texture
     * @param lodLevel defines the lod level to bind to the frame buffer
     */
    _bindTextureRenderTarget(texture, attachmentIndex = 0, faceIndexOrLayer, lodLevel = 0) {
        const hardwareTexture = texture._hardwareTexture;
        if (!hardwareTexture) {
            return;
        }
        const framebuffer = this._framebuffer;
        const engine = this._engine;
        const currentFb = engine._currentFramebuffer;
        engine._bindUnboundFramebuffer(framebuffer);
        let attachment;
        if (engine.webGLVersion > 1) {
            const gl = this._context;
            attachment = gl["COLOR_ATTACHMENT" + attachmentIndex];
            if (texture.is2DArray || texture.is3D) {
                faceIndexOrLayer = faceIndexOrLayer ?? this.layerIndices?.[attachmentIndex] ?? 0;
                gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, hardwareTexture.underlyingResource, lodLevel, faceIndexOrLayer);
            }
            else if (texture.isCube) {
                // if face index is not specified, try to query it from faceIndices
                // default is face 0
                faceIndexOrLayer = faceIndexOrLayer ?? this.faceIndices?.[attachmentIndex] ?? 0;
                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer, hardwareTexture.underlyingResource, lodLevel);
            }
            else {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, hardwareTexture.underlyingResource, lodLevel);
            }
        }
        else {
            // Default behavior (WebGL)
            const gl = this._context;
            attachment = gl["COLOR_ATTACHMENT" + attachmentIndex + "_WEBGL"];
            const target = faceIndexOrLayer !== undefined ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer : gl.TEXTURE_2D;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, target, hardwareTexture.underlyingResource, lodLevel);
        }
        if (texture._autoMSAAManagement && this._MSAAFramebuffer) {
            const gl = this._context;
            engine._bindUnboundFramebuffer(this._MSAAFramebuffer);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, hardwareTexture.getMSAARenderBuffer());
        }
        engine._bindUnboundFramebuffer(currentFb);
    }
    /**
     * Set a texture in the textures array
     * @param texture the texture to set
     * @param index the index in the textures array to set
     * @param disposePrevious If this function should dispose the previous texture
     */
    setTexture(texture, index = 0, disposePrevious = true) {
        super.setTexture(texture, index, disposePrevious);
        this._bindTextureRenderTarget(texture, index);
    }
    /**
     * Sets the layer and face indices of every render target texture
     * @param layers The layer of the texture to be set (make negative to not modify)
     * @param faces The face of the texture to be set (make negative to not modify)
     */
    setLayerAndFaceIndices(layers, faces) {
        super.setLayerAndFaceIndices(layers, faces);
        if (!this.textures || !this.layerIndices || !this.faceIndices) {
            return;
        }
        // the length of this._attachments is the right one as it does not count the depth texture, in case we generated it
        const textureCount = this._attachments?.length ?? this.textures.length;
        for (let index = 0; index < textureCount; index++) {
            const texture = this.textures[index];
            if (!texture) {
                // The target type was probably -1 at creation time and setTexture has not been called yet for this index
                continue;
            }
            if (texture.is2DArray || texture.is3D) {
                this._bindTextureRenderTarget(texture, index, this.layerIndices[index]);
            }
            else if (texture.isCube) {
                this._bindTextureRenderTarget(texture, index, this.faceIndices[index]);
            }
            else {
                this._bindTextureRenderTarget(texture, index);
            }
        }
    }
    /**
     * Set the face and layer indices of a texture in the textures array
     * @param index The index of the texture in the textures array to modify
     * @param layer The layer of the texture to be set
     * @param face The face of the texture to be set
     */
    setLayerAndFaceIndex(index = 0, layer, face) {
        super.setLayerAndFaceIndex(index, layer, face);
        if (!this.textures || !this.layerIndices || !this.faceIndices) {
            return;
        }
        const texture = this.textures[index];
        if (texture.is2DArray || texture.is3D) {
            this._bindTextureRenderTarget(this.textures[index], index, this.layerIndices[index]);
        }
        else if (texture.isCube) {
            this._bindTextureRenderTarget(this.textures[index], index, this.faceIndices[index]);
        }
    }
    resolveMSAATextures() {
        const engine = this._engine;
        const currentFramebuffer = engine._currentFramebuffer;
        engine._bindUnboundFramebuffer(this._MSAAFramebuffer);
        super.resolveMSAATextures();
        engine._bindUnboundFramebuffer(currentFramebuffer);
    }
    dispose(disposeOnlyFramebuffers = this._disposeOnlyFramebuffers) {
        const gl = this._context;
        if (!disposeOnlyFramebuffers) {
            if (this._colorTextureArray) {
                this._context.deleteTexture(this._colorTextureArray);
                this._colorTextureArray = null;
            }
            if (this._depthStencilTextureArray) {
                this._context.deleteTexture(this._depthStencilTextureArray);
                this._depthStencilTextureArray = null;
            }
        }
        if (this._framebuffer) {
            gl.deleteFramebuffer(this._framebuffer);
            this._framebuffer = null;
        }
        if (this._depthStencilBuffer) {
            gl.deleteRenderbuffer(this._depthStencilBuffer);
            this._depthStencilBuffer = null;
        }
        if (this._MSAAFramebuffer) {
            gl.deleteFramebuffer(this._MSAAFramebuffer);
            this._MSAAFramebuffer = null;
        }
        super.dispose(disposeOnlyFramebuffers);
    }
}
//# sourceMappingURL=webGLRenderTargetWrapper.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/WebGL/webGLShaderProcessors.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/WebGL/webGLShaderProcessors.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLShaderProcessor: () => (/* binding */ WebGLShaderProcessor)
/* harmony export */ });
/** @internal */
class WebGLShaderProcessor {
    constructor() {
        this.shaderLanguage = 0 /* ShaderLanguage.GLSL */;
    }
    postProcessor(code, defines, isFragment, processingContext, parameters) {
        // Remove extensions
        if (parameters.drawBuffersExtensionDisabled) {
            // even if enclosed in #if/#endif, IE11 does parse the #extension declaration, so we need to remove it altogether
            const regex = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
            code = code.replace(regex, "");
        }
        return code;
    }
}
//# sourceMappingURL=webGLShaderProcessors.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/engine.common.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/engine.common.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateImageBitmapFromSource: () => (/* binding */ CreateImageBitmapFromSource),
/* harmony export */   ExitFullscreen: () => (/* binding */ ExitFullscreen),
/* harmony export */   ExitPointerlock: () => (/* binding */ ExitPointerlock),
/* harmony export */   GetFontOffset: () => (/* binding */ GetFontOffset),
/* harmony export */   RequestFullscreen: () => (/* binding */ RequestFullscreen),
/* harmony export */   RequestPointerlock: () => (/* binding */ RequestPointerlock),
/* harmony export */   ResizeImageBitmap: () => (/* binding */ ResizeImageBitmap),
/* harmony export */   _CommonDispose: () => (/* binding */ _CommonDispose),
/* harmony export */   _CommonInit: () => (/* binding */ _CommonInit)
/* harmony export */ });
/* harmony import */ var _Misc_domManagement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Misc/domManagement.js */ "./node_modules/@babylonjs/core/Misc/domManagement.js");
/* harmony import */ var _abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");
/* harmony import */ var _engineStore_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./engineStore.js */ "./node_modules/@babylonjs/core/Engines/engineStore.js");



/** @internal */
function DisableTouchAction(canvas) {
    if (!canvas || !canvas.setAttribute) {
        return;
    }
    canvas.setAttribute("touch-action", "none");
    canvas.style.touchAction = "none";
    canvas.style.webkitTapHighlightColor = "transparent";
}
/** @internal */
function _CommonInit(commonEngine, canvas, creationOptions) {
    commonEngine._onCanvasFocus = () => {
        commonEngine.onCanvasFocusObservable.notifyObservers(commonEngine);
    };
    commonEngine._onCanvasBlur = () => {
        commonEngine.onCanvasBlurObservable.notifyObservers(commonEngine);
    };
    commonEngine._onCanvasContextMenu = (evt) => {
        if (commonEngine.disableContextMenu) {
            evt.preventDefault();
        }
    };
    canvas.addEventListener("focus", commonEngine._onCanvasFocus);
    canvas.addEventListener("blur", commonEngine._onCanvasBlur);
    canvas.addEventListener("contextmenu", commonEngine._onCanvasContextMenu);
    commonEngine._onBlur = () => {
        if (commonEngine.disablePerformanceMonitorInBackground) {
            commonEngine.performanceMonitor.disable();
        }
        commonEngine._windowIsBackground = true;
    };
    commonEngine._onFocus = () => {
        if (commonEngine.disablePerformanceMonitorInBackground) {
            commonEngine.performanceMonitor.enable();
        }
        commonEngine._windowIsBackground = false;
    };
    commonEngine._onCanvasPointerOut = (ev) => {
        // Check that the element at the point of the pointer out isn't the canvas and if it isn't, notify observers
        // Note: This is a workaround for a bug with Safari
        if (document.elementFromPoint(ev.clientX, ev.clientY) !== canvas) {
            commonEngine.onCanvasPointerOutObservable.notifyObservers(ev);
        }
    };
    const hostWindow = commonEngine.getHostWindow(); // it calls IsWindowObjectExist()
    if (hostWindow && typeof hostWindow.addEventListener === "function") {
        hostWindow.addEventListener("blur", commonEngine._onBlur);
        hostWindow.addEventListener("focus", commonEngine._onFocus);
    }
    canvas.addEventListener("pointerout", commonEngine._onCanvasPointerOut);
    if (!creationOptions.doNotHandleTouchAction) {
        DisableTouchAction(canvas);
    }
    // Create Audio Engine if needed.
    if (!_abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.audioEngine && creationOptions.audioEngine && _abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.AudioEngineFactory) {
        _abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.audioEngine = _abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.AudioEngineFactory(commonEngine.getRenderingCanvas(), commonEngine.getAudioContext(), commonEngine.getAudioDestination());
    }
    if ((0,_Misc_domManagement_js__WEBPACK_IMPORTED_MODULE_0__.IsDocumentAvailable)()) {
        // Fullscreen
        commonEngine._onFullscreenChange = () => {
            commonEngine.isFullscreen = !!document.fullscreenElement;
            // Pointer lock
            if (commonEngine.isFullscreen && commonEngine._pointerLockRequested && canvas) {
                RequestPointerlock(canvas);
            }
        };
        document.addEventListener("fullscreenchange", commonEngine._onFullscreenChange, false);
        document.addEventListener("webkitfullscreenchange", commonEngine._onFullscreenChange, false);
        // Pointer lock
        commonEngine._onPointerLockChange = () => {
            commonEngine.isPointerLock = document.pointerLockElement === canvas;
        };
        document.addEventListener("pointerlockchange", commonEngine._onPointerLockChange, false);
        document.addEventListener("webkitpointerlockchange", commonEngine._onPointerLockChange, false);
    }
    commonEngine.enableOfflineSupport = _abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.OfflineProviderFactory !== undefined;
    commonEngine._deterministicLockstep = !!creationOptions.deterministicLockstep;
    commonEngine._lockstepMaxSteps = creationOptions.lockstepMaxSteps || 0;
    commonEngine._timeStep = creationOptions.timeStep || 1 / 60;
}
/** @internal */
function _CommonDispose(commonEngine, canvas) {
    // Release audio engine
    if (_engineStore_js__WEBPACK_IMPORTED_MODULE_2__.EngineStore.Instances.length === 1 && _abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.audioEngine) {
        _abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.audioEngine.dispose();
        _abstractEngine_js__WEBPACK_IMPORTED_MODULE_1__.AbstractEngine.audioEngine = null;
    }
    // Events
    const hostWindow = commonEngine.getHostWindow(); // it calls IsWindowObjectExist()
    if (hostWindow && typeof hostWindow.removeEventListener === "function") {
        hostWindow.removeEventListener("blur", commonEngine._onBlur);
        hostWindow.removeEventListener("focus", commonEngine._onFocus);
    }
    if (canvas) {
        canvas.removeEventListener("focus", commonEngine._onCanvasFocus);
        canvas.removeEventListener("blur", commonEngine._onCanvasBlur);
        canvas.removeEventListener("pointerout", commonEngine._onCanvasPointerOut);
        canvas.removeEventListener("contextmenu", commonEngine._onCanvasContextMenu);
    }
    if ((0,_Misc_domManagement_js__WEBPACK_IMPORTED_MODULE_0__.IsDocumentAvailable)()) {
        document.removeEventListener("fullscreenchange", commonEngine._onFullscreenChange);
        document.removeEventListener("mozfullscreenchange", commonEngine._onFullscreenChange);
        document.removeEventListener("webkitfullscreenchange", commonEngine._onFullscreenChange);
        document.removeEventListener("msfullscreenchange", commonEngine._onFullscreenChange);
        document.removeEventListener("pointerlockchange", commonEngine._onPointerLockChange);
        document.removeEventListener("mspointerlockchange", commonEngine._onPointerLockChange);
        document.removeEventListener("mozpointerlockchange", commonEngine._onPointerLockChange);
        document.removeEventListener("webkitpointerlockchange", commonEngine._onPointerLockChange);
    }
}
/**
 * Get Font size information
 * @param font font name
 * @returns an object containing ascent, height and descent
 */
function GetFontOffset(font) {
    const text = document.createElement("span");
    text.textContent = "Hg";
    text.style.font = font;
    const block = document.createElement("div");
    block.style.display = "inline-block";
    block.style.width = "1px";
    block.style.height = "0px";
    block.style.verticalAlign = "bottom";
    const div = document.createElement("div");
    div.style.whiteSpace = "nowrap";
    div.appendChild(text);
    div.appendChild(block);
    document.body.appendChild(div);
    let fontAscent = 0;
    let fontHeight = 0;
    try {
        fontHeight = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
        block.style.verticalAlign = "baseline";
        fontAscent = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
    }
    finally {
        document.body.removeChild(div);
    }
    return { ascent: fontAscent, height: fontHeight, descent: fontHeight - fontAscent };
}
/** @internal */
async function CreateImageBitmapFromSource(engine, imageSource, options) {
    return new Promise((resolve, reject) => {
        const image = new Image();
        image.onload = () => {
            image.decode().then(() => {
                engine.createImageBitmap(image, options).then((imageBitmap) => {
                    resolve(imageBitmap);
                });
            });
        };
        image.onerror = () => {
            reject(`Error loading image ${image.src}`);
        };
        image.src = imageSource;
    });
}
/** @internal */
function ResizeImageBitmap(engine, image, bufferWidth, bufferHeight) {
    const canvas = engine.createCanvas(bufferWidth, bufferHeight);
    const context = canvas.getContext("2d");
    if (!context) {
        throw new Error("Unable to get 2d context for resizeImageBitmap");
    }
    context.drawImage(image, 0, 0);
    // Create VertexData from map data
    // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949
    const buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;
    return buffer;
}
/**
 * Ask the browser to promote the current element to fullscreen rendering mode
 * @param element defines the DOM element to promote
 */
function RequestFullscreen(element) {
    const requestFunction = element.requestFullscreen || element.webkitRequestFullscreen;
    if (!requestFunction) {
        return;
    }
    requestFunction.call(element);
}
/**
 * Asks the browser to exit fullscreen mode
 */
function ExitFullscreen() {
    const anyDoc = document;
    if (document.exitFullscreen) {
        document.exitFullscreen();
    }
    else if (anyDoc.webkitCancelFullScreen) {
        anyDoc.webkitCancelFullScreen();
    }
}
/**
 * Ask the browser to promote the current element to pointerlock mode
 * @param element defines the DOM element to promote
 */
function RequestPointerlock(element) {
    if (element.requestPointerLock) {
        // In some browsers, requestPointerLock returns a promise.
        // Handle possible rejections to avoid an unhandled top-level exception.
        const promise = element.requestPointerLock();
        if (promise instanceof Promise) {
            promise
                .then(() => {
                element.focus();
            })
                .catch(() => { });
        }
        else {
            element.focus();
        }
    }
}
/**
 * Asks the browser to exit pointerlock mode
 */
function ExitPointerlock() {
    if (document.exitPointerLock) {
        document.exitPointerLock();
    }
}
//# sourceMappingURL=engine.common.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/engine.js":
/*!********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/engine.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Engine: () => (/* binding */ Engine)
/* harmony export */ });
/* harmony import */ var _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Materials/Textures/internalTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/internalTexture.js");
/* harmony import */ var _engineStore_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engineStore.js */ "./node_modules/@babylonjs/core/Engines/engineStore.js");
/* harmony import */ var _thinEngine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js");
/* harmony import */ var _Misc_performanceMonitor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Misc/performanceMonitor.js */ "./node_modules/@babylonjs/core/Misc/performanceMonitor.js");
/* harmony import */ var _Meshes_WebGL_webGLDataBuffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Meshes/WebGL/webGLDataBuffer.js */ "./node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _WebGL_webGLHardwareTexture_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WebGL/webGLHardwareTexture.js */ "./node_modules/@babylonjs/core/Engines/WebGL/webGLHardwareTexture.js");
/* harmony import */ var _Extensions_engine_alpha_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Extensions/engine.alpha.js */ "./node_modules/@babylonjs/core/Engines/Extensions/engine.alpha.js");
/* harmony import */ var _Extensions_engine_rawTexture_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Extensions/engine.rawTexture.js */ "./node_modules/@babylonjs/core/Engines/Extensions/engine.rawTexture.js");
/* harmony import */ var _Extensions_engine_readTexture_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Extensions/engine.readTexture.js */ "./node_modules/@babylonjs/core/Engines/Extensions/engine.readTexture.js");
/* harmony import */ var _Extensions_engine_dynamicBuffer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Extensions/engine.dynamicBuffer.js */ "./node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicBuffer.js");
/* harmony import */ var _Extensions_engine_cubeTexture_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Extensions/engine.cubeTexture.js */ "./node_modules/@babylonjs/core/Engines/Extensions/engine.cubeTexture.js");
/* harmony import */ var _Extensions_engine_renderTarget_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Extensions/engine.renderTarget.js */ "./node_modules/@babylonjs/core/Engines/Extensions/engine.renderTarget.js");
/* harmony import */ var _Extensions_engine_renderTargetTexture_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Extensions/engine.renderTargetTexture.js */ "./node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetTexture.js");
/* harmony import */ var _Extensions_engine_renderTargetCube_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Extensions/engine.renderTargetCube.js */ "./node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetCube.js");
/* harmony import */ var _Extensions_engine_prefilteredCubeTexture_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Extensions/engine.prefilteredCubeTexture.js */ "./node_modules/@babylonjs/core/Engines/Extensions/engine.prefilteredCubeTexture.js");
/* harmony import */ var _Extensions_engine_uniformBuffer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Extensions/engine.uniformBuffer.js */ "./node_modules/@babylonjs/core/Engines/Extensions/engine.uniformBuffer.js");
/* harmony import */ var _AbstractEngine_abstractEngine_loadingScreen_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./AbstractEngine/abstractEngine.loadingScreen.js */ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.loadingScreen.js");
/* harmony import */ var _AbstractEngine_abstractEngine_dom_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./AbstractEngine/abstractEngine.dom.js */ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.dom.js");
/* harmony import */ var _AbstractEngine_abstractEngine_states_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./AbstractEngine/abstractEngine.states.js */ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.states.js");
/* harmony import */ var _AbstractEngine_abstractEngine_renderPass_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./AbstractEngine/abstractEngine.renderPass.js */ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.renderPass.js");
/* harmony import */ var _AbstractEngine_abstractEngine_texture_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./AbstractEngine/abstractEngine.texture.js */ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.texture.js");
/* harmony import */ var _abstractEngine_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");
/* harmony import */ var _engine_common_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./engine.common.js */ "./node_modules/@babylonjs/core/Engines/engine.common.js");
/* harmony import */ var _Misc_perfCounter_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../Misc/perfCounter.js */ "./node_modules/@babylonjs/core/Misc/perfCounter.js");
/* harmony import */ var _Misc_timingTools_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../Misc/timingTools.js */ "./node_modules/@babylonjs/core/Misc/timingTools.js");



























/**
 * The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio
 */
class Engine extends _thinEngine_js__WEBPACK_IMPORTED_MODULE_2__.ThinEngine {
    /**
     * Returns the current npm package of the sdk
     */
    // Not mixed with Version for tooling purpose.
    static get NpmPackage() {
        return _abstractEngine_js__WEBPACK_IMPORTED_MODULE_22__.AbstractEngine.NpmPackage;
    }
    /**
     * Returns the current version of the framework
     */
    static get Version() {
        return _abstractEngine_js__WEBPACK_IMPORTED_MODULE_22__.AbstractEngine.Version;
    }
    /** Gets the list of created engines */
    static get Instances() {
        return _engineStore_js__WEBPACK_IMPORTED_MODULE_1__.EngineStore.Instances;
    }
    /**
     * Gets the latest created engine
     */
    static get LastCreatedEngine() {
        return _engineStore_js__WEBPACK_IMPORTED_MODULE_1__.EngineStore.LastCreatedEngine;
    }
    /**
     * Gets the latest created scene
     */
    static get LastCreatedScene() {
        return _engineStore_js__WEBPACK_IMPORTED_MODULE_1__.EngineStore.LastCreatedScene;
    }
    /** @internal */
    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * Method called to create the default loading screen.
     * This can be overridden in your own app.
     * @param canvas The rendering canvas element
     * @returns The loading screen
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static DefaultLoadingScreenFactory(canvas) {
        return _abstractEngine_js__WEBPACK_IMPORTED_MODULE_22__.AbstractEngine.DefaultLoadingScreenFactory(canvas);
    }
    get _supportsHardwareTextureRescaling() {
        return !!Engine._RescalePostProcessFactory;
    }
    _measureFps() {
        this._performanceMonitor.sampleFrame();
        this._fps = this._performanceMonitor.averageFPS;
        this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
    }
    /**
     * Gets the performance monitor attached to this engine
     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation
     */
    get performanceMonitor() {
        return this._performanceMonitor;
    }
    // Events
    /**
     * Creates a new engine
     * @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which already used the WebGL context
     * @param antialias defines enable antialiasing (default: false)
     * @param options defines further options to be sent to the getContext() function
     * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)
     */
    constructor(canvasOrContext, antialias, options, adaptToDeviceRatio = false) {
        super(canvasOrContext, antialias, options, adaptToDeviceRatio);
        // Members
        /**
         * If set, will be used to request the next animation frame for the render loop
         */
        this.customAnimationFrameRequester = null;
        this._performanceMonitor = new _Misc_performanceMonitor_js__WEBPACK_IMPORTED_MODULE_3__.PerformanceMonitor();
        this._drawCalls = new _Misc_perfCounter_js__WEBPACK_IMPORTED_MODULE_24__.PerfCounter();
        if (!canvasOrContext) {
            return;
        }
        this._features.supportRenderPasses = true;
        options = this._creationOptions;
    }
    _initGLContext() {
        super._initGLContext();
        this._rescalePostProcess = null;
    }
    /**
     * Shared initialization across engines types.
     * @param canvas The canvas associated with this instance of the engine.
     */
    _sharedInit(canvas) {
        super._sharedInit(canvas);
        (0,_engine_common_js__WEBPACK_IMPORTED_MODULE_23__._CommonInit)(this, canvas, this._creationOptions);
    }
    /**
     * Resize an image and returns the image data as an uint8array
     * @param image image to resize
     * @param bufferWidth destination buffer width
     * @param bufferHeight destination buffer height
     * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size
     */
    resizeImageBitmap(image, bufferWidth, bufferHeight) {
        return (0,_engine_common_js__WEBPACK_IMPORTED_MODULE_23__.ResizeImageBitmap)(this, image, bufferWidth, bufferHeight);
    }
    /**
     * Engine abstraction for loading and creating an image bitmap from a given source string.
     * @param imageSource source to load the image from.
     * @param options An object that sets options for the image's extraction.
     * @returns ImageBitmap
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    async _createImageBitmapFromSource(imageSource, options) {
        return (0,_engine_common_js__WEBPACK_IMPORTED_MODULE_23__.CreateImageBitmapFromSource)(this, imageSource, options);
    }
    /**
     * Toggle full screen mode
     * @param requestPointerLock defines if a pointer lock should be requested from the user
     */
    switchFullscreen(requestPointerLock) {
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        else {
            this.enterFullscreen(requestPointerLock);
        }
    }
    /**
     * Enters full screen mode
     * @param requestPointerLock defines if a pointer lock should be requested from the user
     */
    enterFullscreen(requestPointerLock) {
        if (!this.isFullscreen) {
            this._pointerLockRequested = requestPointerLock;
            if (this._renderingCanvas) {
                (0,_engine_common_js__WEBPACK_IMPORTED_MODULE_23__.RequestFullscreen)(this._renderingCanvas);
            }
        }
    }
    /**
     * Exits full screen mode
     */
    exitFullscreen() {
        if (this.isFullscreen) {
            (0,_engine_common_js__WEBPACK_IMPORTED_MODULE_23__.ExitFullscreen)();
        }
    }
    /** States */
    /**
     * Sets a boolean indicating if the dithering state is enabled or disabled
     * @param value defines the dithering state
     */
    setDitheringState(value) {
        if (value) {
            this._gl.enable(this._gl.DITHER);
        }
        else {
            this._gl.disable(this._gl.DITHER);
        }
    }
    /**
     * Sets a boolean indicating if the rasterizer state is enabled or disabled
     * @param value defines the rasterizer state
     */
    setRasterizerState(value) {
        if (value) {
            this._gl.disable(this._gl.RASTERIZER_DISCARD);
        }
        else {
            this._gl.enable(this._gl.RASTERIZER_DISCARD);
        }
    }
    /**
     * Directly set the WebGL Viewport
     * @param x defines the x coordinate of the viewport (in screen space)
     * @param y defines the y coordinate of the viewport (in screen space)
     * @param width defines the width of the viewport (in screen space)
     * @param height defines the height of the viewport (in screen space)
     * @returns the current viewport Object (if any) that is being replaced by this call. You can restore this viewport later on to go back to the original state
     */
    setDirectViewport(x, y, width, height) {
        const currentViewport = this._cachedViewport;
        this._cachedViewport = null;
        this._viewport(x, y, width, height);
        return currentViewport;
    }
    /**
     * Executes a scissor clear (ie. a clear on a specific portion of the screen)
     * @param x defines the x-coordinate of the bottom left corner of the clear rectangle
     * @param y defines the y-coordinate of the corner of the clear rectangle
     * @param width defines the width of the clear rectangle
     * @param height defines the height of the clear rectangle
     * @param clearColor defines the clear color
     */
    scissorClear(x, y, width, height, clearColor) {
        this.enableScissor(x, y, width, height);
        this.clear(clearColor, true, true, true);
        this.disableScissor();
    }
    /**
     * Enable scissor test on a specific rectangle (ie. render will only be executed on a specific portion of the screen)
     * @param x defines the x-coordinate of the bottom left corner of the clear rectangle
     * @param y defines the y-coordinate of the corner of the clear rectangle
     * @param width defines the width of the clear rectangle
     * @param height defines the height of the clear rectangle
     */
    enableScissor(x, y, width, height) {
        const gl = this._gl;
        // Change state
        gl.enable(gl.SCISSOR_TEST);
        gl.scissor(x, y, width, height);
    }
    /**
     * Disable previously set scissor test rectangle
     */
    disableScissor() {
        const gl = this._gl;
        gl.disable(gl.SCISSOR_TEST);
    }
    /**
     * @internal
     */
    async _loadFileAsync(url, offlineProvider, useArrayBuffer) {
        return new Promise((resolve, reject) => {
            this._loadFile(url, (data) => {
                resolve(data);
            }, undefined, offlineProvider, useArrayBuffer, (request, exception) => {
                reject(exception);
            });
        });
    }
    /**
     * Gets the source code of the vertex shader associated with a specific webGL program
     * @param program defines the program to use
     * @returns a string containing the source code of the vertex shader associated with the program
     */
    getVertexShaderSource(program) {
        const shaders = this._gl.getAttachedShaders(program);
        if (!shaders) {
            return null;
        }
        return this._gl.getShaderSource(shaders[0]);
    }
    /**
     * Gets the source code of the fragment shader associated with a specific webGL program
     * @param program defines the program to use
     * @returns a string containing the source code of the fragment shader associated with the program
     */
    getFragmentShaderSource(program) {
        const shaders = this._gl.getAttachedShaders(program);
        if (!shaders) {
            return null;
        }
        return this._gl.getShaderSource(shaders[1]);
    }
    /**
     * sets the object from which width and height will be taken from when getting render width and height
     * Will fallback to the gl object
     * @param dimensions the framebuffer width and height that will be used.
     */
    set framebufferDimensionsObject(dimensions) {
        this._framebufferDimensionsObject = dimensions;
        if (this._framebufferDimensionsObject) {
            this.onResizeObservable.notifyObservers(this);
        }
    }
    _rebuildBuffers() {
        // Index / Vertex
        for (const scene of this.scenes) {
            scene.resetCachedMaterial();
            scene._rebuildGeometries();
        }
        for (const scene of this._virtualScenes) {
            scene.resetCachedMaterial();
            scene._rebuildGeometries();
        }
        super._rebuildBuffers();
    }
    /**
     * Get Font size information
     * @param font font name
     * @returns an object containing ascent, height and descent
     */
    getFontOffset(font) {
        return (0,_engine_common_js__WEBPACK_IMPORTED_MODULE_23__.GetFontOffset)(font);
    }
    _cancelFrame() {
        if (this.customAnimationFrameRequester) {
            if (this._frameHandler !== 0) {
                this._frameHandler = 0;
                const { cancelAnimationFrame } = this.customAnimationFrameRequester;
                if (cancelAnimationFrame) {
                    cancelAnimationFrame(this.customAnimationFrameRequester.requestID);
                }
            }
        }
        else {
            super._cancelFrame();
        }
    }
    _renderLoop(timestamp) {
        this._processFrame(timestamp);
        // The first condition prevents queuing another frame if we no longer have active render loops (e.g., if
        // `stopRenderLoop` is called mid frame). The second condition prevents queuing another frame if one has
        // already been queued (e.g., if `stopRenderLoop` and `runRenderLoop` is called mid frame).
        if (this._activeRenderLoops.length > 0 && this._frameHandler === 0) {
            if (this.customAnimationFrameRequester) {
                this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester);
                this._frameHandler = this.customAnimationFrameRequester.requestID;
            }
            else {
                this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
            }
        }
    }
    /**
     * Enters Pointerlock mode
     */
    enterPointerlock() {
        if (this._renderingCanvas) {
            (0,_engine_common_js__WEBPACK_IMPORTED_MODULE_23__.RequestPointerlock)(this._renderingCanvas);
        }
    }
    /**
     * Exits Pointerlock mode
     */
    exitPointerlock() {
        (0,_engine_common_js__WEBPACK_IMPORTED_MODULE_23__.ExitPointerlock)();
    }
    /**
     * Begin a new frame
     */
    beginFrame() {
        this._measureFps();
        super.beginFrame();
    }
    _deletePipelineContext(pipelineContext) {
        const webGLPipelineContext = pipelineContext;
        if (webGLPipelineContext && webGLPipelineContext.program) {
            if (webGLPipelineContext.transformFeedback) {
                this.deleteTransformFeedback(webGLPipelineContext.transformFeedback);
                webGLPipelineContext.transformFeedback = null;
            }
        }
        super._deletePipelineContext(pipelineContext);
    }
    createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings = null) {
        context = context || this._gl;
        this.onBeforeShaderCompilationObservable.notifyObservers(this);
        const program = super.createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings);
        this.onAfterShaderCompilationObservable.notifyObservers(this);
        return program;
    }
    _createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings = null) {
        const shaderProgram = context.createProgram();
        pipelineContext.program = shaderProgram;
        if (!shaderProgram) {
            throw new Error("Unable to create program");
        }
        context.attachShader(shaderProgram, vertexShader);
        context.attachShader(shaderProgram, fragmentShader);
        if (this.webGLVersion > 1 && transformFeedbackVaryings) {
            const transformFeedback = this.createTransformFeedback();
            this.bindTransformFeedback(transformFeedback);
            this.setTranformFeedbackVaryings(shaderProgram, transformFeedbackVaryings);
            pipelineContext.transformFeedback = transformFeedback;
        }
        context.linkProgram(shaderProgram);
        if (this.webGLVersion > 1 && transformFeedbackVaryings) {
            this.bindTransformFeedback(null);
        }
        pipelineContext.context = context;
        pipelineContext.vertexShader = vertexShader;
        pipelineContext.fragmentShader = fragmentShader;
        if (!pipelineContext.isParallelCompiled) {
            this._finalizePipelineContext(pipelineContext);
        }
        return shaderProgram;
    }
    /**
     * @internal
     */
    _releaseTexture(texture) {
        super._releaseTexture(texture);
    }
    /**
     * @internal
     */
    _releaseRenderTargetWrapper(rtWrapper) {
        super._releaseRenderTargetWrapper(rtWrapper);
        // Set output texture of post process to null if the framebuffer has been released/disposed
        for (const scene of this.scenes) {
            for (const postProcess of scene.postProcesses) {
                if (postProcess._outputTexture === rtWrapper) {
                    postProcess._outputTexture = null;
                }
            }
            for (const camera of scene.cameras) {
                for (const postProcess of camera._postProcesses) {
                    if (postProcess) {
                        if (postProcess._outputTexture === rtWrapper) {
                            postProcess._outputTexture = null;
                        }
                    }
                }
            }
        }
    }
    /**
     * @internal
     * Rescales a texture
     * @param source input texture
     * @param destination destination texture
     * @param scene scene to use to render the resize
     * @param internalFormat format to use when resizing
     * @param onComplete callback to be called when resize has completed
     */
    _rescaleTexture(source, destination, scene, internalFormat, onComplete) {
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
        const rtt = this.createRenderTargetTexture({
            width: destination.width,
            height: destination.height,
        }, {
            generateMipMaps: false,
            type: 0,
            samplingMode: 2,
            generateDepthBuffer: false,
            generateStencilBuffer: false,
        });
        if (!this._rescalePostProcess && Engine._RescalePostProcessFactory) {
            this._rescalePostProcess = Engine._RescalePostProcessFactory(this);
        }
        if (this._rescalePostProcess) {
            this._rescalePostProcess.externalTextureSamplerBinding = true;
            const onCompiled = () => {
                this._rescalePostProcess.onApply = function (effect) {
                    effect._bindTexture("textureSampler", source);
                };
                let hostingScene = scene;
                if (!hostingScene) {
                    hostingScene = this.scenes[this.scenes.length - 1];
                }
                hostingScene.postProcessManager.directRender([this._rescalePostProcess], rtt, true);
                this._bindTextureDirectly(this._gl.TEXTURE_2D, destination, true);
                this._gl.copyTexImage2D(this._gl.TEXTURE_2D, 0, internalFormat, 0, 0, destination.width, destination.height, 0);
                this.unBindFramebuffer(rtt);
                rtt.dispose();
                if (onComplete) {
                    onComplete();
                }
            };
            const effect = this._rescalePostProcess.getEffect();
            if (effect) {
                effect.executeWhenCompiled(onCompiled);
            }
            else {
                this._rescalePostProcess.onEffectCreatedObservable.addOnce((effect) => {
                    effect.executeWhenCompiled(onCompiled);
                });
            }
        }
    }
    /**
     * Wraps an external web gl texture in a Babylon texture.
     * @param texture defines the external texture
     * @param hasMipMaps defines whether the external texture has mip maps (default: false)
     * @param samplingMode defines the sampling mode for the external texture (default: 3)
     * @param width defines the width for the external texture (default: 0)
     * @param height defines the height for the external texture (default: 0)
     * @returns the babylon internal texture
     */
    wrapWebGLTexture(texture, hasMipMaps = false, samplingMode = 3, width = 0, height = 0) {
        const hardwareTexture = new _WebGL_webGLHardwareTexture_js__WEBPACK_IMPORTED_MODULE_6__.WebGLHardwareTexture(texture, this._gl);
        const internalTexture = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__.InternalTexture(this, 0 /* InternalTextureSource.Unknown */, true);
        internalTexture._hardwareTexture = hardwareTexture;
        internalTexture.baseWidth = width;
        internalTexture.baseHeight = height;
        internalTexture.width = width;
        internalTexture.height = height;
        internalTexture.isReady = true;
        internalTexture.useMipMaps = hasMipMaps;
        this.updateTextureSamplingMode(samplingMode, internalTexture);
        return internalTexture;
    }
    /**
     * @internal
     */
    _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {
        const gl = this._gl;
        const textureType = this._getWebGLTextureType(texture.type);
        const format = this._getInternalFormat(texture.format);
        const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, format);
        const bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
        this._bindTextureDirectly(bindTarget, texture, true);
        this._unpackFlipY(texture.invertY);
        let target = gl.TEXTURE_2D;
        if (texture.isCube) {
            target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
        }
        gl.texImage2D(target, lod, internalFormat, format, textureType, image);
        this._bindTextureDirectly(bindTarget, null, true);
    }
    /**
     * Updates a depth texture Comparison Mode and Function.
     * If the comparison Function is equal to 0, the mode will be set to none.
     * Otherwise, this only works in webgl 2 and requires a shadow sampler in the shader.
     * @param texture The texture to set the comparison function for
     * @param comparisonFunction The comparison function to set, 0 if no comparison required
     */
    updateTextureComparisonFunction(texture, comparisonFunction) {
        if (this.webGLVersion === 1) {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_5__.Logger.Error("WebGL 1 does not support texture comparison.");
            return;
        }
        const gl = this._gl;
        if (texture.isCube) {
            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
            if (comparisonFunction === 0) {
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, 515);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);
            }
            else {
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
            }
            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
        }
        else {
            this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
            if (comparisonFunction === 0) {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, 515);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.NONE);
            }
            else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
            }
            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
        }
        texture._comparisonFunction = comparisonFunction;
    }
    /**
     * Creates a webGL buffer to use with instantiation
     * @param capacity defines the size of the buffer
     * @returns the webGL buffer
     */
    createInstancesBuffer(capacity) {
        const buffer = this._gl.createBuffer();
        if (!buffer) {
            throw new Error("Unable to create instance buffer");
        }
        const result = new _Meshes_WebGL_webGLDataBuffer_js__WEBPACK_IMPORTED_MODULE_4__.WebGLDataBuffer(buffer);
        result.capacity = capacity;
        this.bindArrayBuffer(result);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, capacity, this._gl.DYNAMIC_DRAW);
        result.references = 1;
        return result;
    }
    /**
     * Delete a webGL buffer used with instantiation
     * @param buffer defines the webGL buffer to delete
     */
    deleteInstancesBuffer(buffer) {
        this._gl.deleteBuffer(buffer);
    }
    async _clientWaitAsync(sync, flags = 0, intervalms = 10) {
        const gl = this._gl;
        return new Promise((resolve, reject) => {
            (0,_Misc_timingTools_js__WEBPACK_IMPORTED_MODULE_25__._RetryWithInterval)(() => {
                const res = gl.clientWaitSync(sync, flags, 0);
                if (res == gl.WAIT_FAILED) {
                    throw new Error("clientWaitSync failed");
                }
                if (res == gl.TIMEOUT_EXPIRED) {
                    return false;
                }
                return true;
            }, resolve, reject, intervalms);
        });
    }
    /**
     * This function might return null synchronously, so it is technically not async.
     * @internal
     */
    // eslint-disable-next-line no-restricted-syntax
    _readPixelsAsync(x, y, w, h, format, type, outputBuffer) {
        if (this._webGLVersion < 2) {
            throw new Error("_readPixelsAsync only work on WebGL2+");
        }
        const gl = this._gl;
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
        gl.bufferData(gl.PIXEL_PACK_BUFFER, outputBuffer.byteLength, gl.STREAM_READ);
        gl.readPixels(x, y, w, h, format, type, 0);
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
        const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
        if (!sync) {
            return null;
        }
        gl.flush();
        return this._clientWaitAsync(sync, 0, 10).then(() => {
            gl.deleteSync(sync);
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
            gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);
            gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
            gl.deleteBuffer(buf);
            return outputBuffer;
        });
    }
    dispose() {
        this.hideLoadingUI();
        // Rescale PP
        if (this._rescalePostProcess) {
            this._rescalePostProcess.dispose();
        }
        (0,_engine_common_js__WEBPACK_IMPORTED_MODULE_23__._CommonDispose)(this, this._renderingCanvas);
        super.dispose();
    }
}
// Const statics
/** Defines that alpha blending is disabled */
Engine.ALPHA_DISABLE = 0;
/** Defines that alpha blending to SRC ALPHA * SRC + DEST */
Engine.ALPHA_ADD = 1;
/** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */
Engine.ALPHA_COMBINE = 2;
/** Defines that alpha blending to DEST - SRC * DEST */
Engine.ALPHA_SUBTRACT = 3;
/** Defines that alpha blending to SRC * DEST */
Engine.ALPHA_MULTIPLY = 4;
/** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC) * DEST */
Engine.ALPHA_MAXIMIZED = 5;
/** Defines that alpha blending to SRC + DEST */
Engine.ALPHA_ONEONE = 6;
/** Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST */
Engine.ALPHA_PREMULTIPLIED = 7;
/**
 * Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST
 * Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA
 */
Engine.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
/** Defines that alpha blending to CST * SRC + (1 - CST) * DEST */
Engine.ALPHA_INTERPOLATE = 9;
/**
 * Defines that alpha blending to SRC + (1 - SRC) * DEST
 * Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA
 */
Engine.ALPHA_SCREENMODE = 10;
/** Defines that the resource is not delayed*/
Engine.DELAYLOADSTATE_NONE = 0;
/** Defines that the resource was successfully delay loaded */
Engine.DELAYLOADSTATE_LOADED = 1;
/** Defines that the resource is currently delay loading */
Engine.DELAYLOADSTATE_LOADING = 2;
/** Defines that the resource is delayed and has not started loading */
Engine.DELAYLOADSTATE_NOTLOADED = 4;
// Depht or Stencil test Constants.
/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn */
Engine.NEVER = 512;
/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */
Engine.ALWAYS = 519;
/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value */
Engine.LESS = 513;
/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value */
Engine.EQUAL = 514;
/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value */
Engine.LEQUAL = 515;
/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value */
Engine.GREATER = 516;
/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value */
Engine.GEQUAL = 518;
/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value */
Engine.NOTEQUAL = 517;
// Stencil Actions Constants.
/** Passed to stencilOperation to specify that stencil value must be kept */
Engine.KEEP = 7680;
/** Passed to stencilOperation to specify that stencil value must be replaced */
Engine.REPLACE = 7681;
/** Passed to stencilOperation to specify that stencil value must be incremented */
Engine.INCR = 7682;
/** Passed to stencilOperation to specify that stencil value must be decremented */
Engine.DECR = 7683;
/** Passed to stencilOperation to specify that stencil value must be inverted */
Engine.INVERT = 5386;
/** Passed to stencilOperation to specify that stencil value must be incremented with wrapping */
Engine.INCR_WRAP = 34055;
/** Passed to stencilOperation to specify that stencil value must be decremented with wrapping */
Engine.DECR_WRAP = 34056;
/** Texture is not repeating outside of 0..1 UVs */
Engine.TEXTURE_CLAMP_ADDRESSMODE = 0;
/** Texture is repeating outside of 0..1 UVs */
Engine.TEXTURE_WRAP_ADDRESSMODE = 1;
/** Texture is repeating and mirrored */
Engine.TEXTURE_MIRROR_ADDRESSMODE = 2;
/** ALPHA */
Engine.TEXTUREFORMAT_ALPHA = 0;
/** LUMINANCE */
Engine.TEXTUREFORMAT_LUMINANCE = 1;
/** LUMINANCE_ALPHA */
Engine.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
/** RGB */
// eslint-disable-next-line @typescript-eslint/naming-convention
Engine.TEXTUREFORMAT_RGB = 4;
/** RGBA */
// eslint-disable-next-line @typescript-eslint/naming-convention
Engine.TEXTUREFORMAT_RGBA = 5;
/** RED */
Engine.TEXTUREFORMAT_RED = 6;
/** RED (2nd reference) */
Engine.TEXTUREFORMAT_R = 6;
/** RED unsigned short normed to [0, 1] **/
Engine.TEXTUREFORMAT_R16_UNORM = 33322;
/** RG unsigned short normed to [0, 1] **/
Engine.TEXTUREFORMAT_RG16_UNORM = 33324;
/** RGB unsigned short normed to [0, 1] **/
// eslint-disable-next-line @typescript-eslint/naming-convention
Engine.TEXTUREFORMAT_RGB16_UNORM = 32852;
/** RGBA unsigned short normed to [0, 1] **/
// eslint-disable-next-line @typescript-eslint/naming-convention
Engine.TEXTUREFORMAT_RGBA16_UNORM = 32859;
/** RED signed short normed to [-1, 1] **/
Engine.TEXTUREFORMAT_R16_SNORM = 36760;
/** RG signed short normed to [-1, 1] **/
Engine.TEXTUREFORMAT_RG16_SNORM = 36761;
/** RGB signed short normed to [-1, 1] **/
// eslint-disable-next-line @typescript-eslint/naming-convention
Engine.TEXTUREFORMAT_RGB16_SNORM = 36762;
/** RGBA signed short normed to [-1, 1] **/
// eslint-disable-next-line @typescript-eslint/naming-convention
Engine.TEXTUREFORMAT_RGBA16_SNORM = 36763;
/** RG */
Engine.TEXTUREFORMAT_RG = 7;
/** RED_INTEGER */
Engine.TEXTUREFORMAT_RED_INTEGER = 8;
/** RED_INTEGER (2nd reference) */
Engine.TEXTUREFORMAT_R_INTEGER = 8;
/** RG_INTEGER */
Engine.TEXTUREFORMAT_RG_INTEGER = 9;
/** RGB_INTEGER */
// eslint-disable-next-line @typescript-eslint/naming-convention
Engine.TEXTUREFORMAT_RGB_INTEGER = 10;
/** RGBA_INTEGER */
// eslint-disable-next-line @typescript-eslint/naming-convention
Engine.TEXTUREFORMAT_RGBA_INTEGER = 11;
/** UNSIGNED_BYTE */
Engine.TEXTURETYPE_UNSIGNED_BYTE = 0;
/** @deprecated use more explicit TEXTURETYPE_UNSIGNED_BYTE instead. Use TEXTURETYPE_UNSIGNED_INTEGER for 32bits values.*/
Engine.TEXTURETYPE_UNSIGNED_INT = 0;
/** FLOAT */
Engine.TEXTURETYPE_FLOAT = 1;
/** HALF_FLOAT */
Engine.TEXTURETYPE_HALF_FLOAT = 2;
/** BYTE */
Engine.TEXTURETYPE_BYTE = 3;
/** SHORT */
Engine.TEXTURETYPE_SHORT = 4;
/** UNSIGNED_SHORT */
Engine.TEXTURETYPE_UNSIGNED_SHORT = 5;
/** INT */
Engine.TEXTURETYPE_INT = 6;
/** UNSIGNED_INT */
Engine.TEXTURETYPE_UNSIGNED_INTEGER = 7;
/** UNSIGNED_SHORT_4_4_4_4 */
Engine.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
/** UNSIGNED_SHORT_5_5_5_1 */
Engine.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
/** UNSIGNED_SHORT_5_6_5 */
Engine.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
/** UNSIGNED_INT_2_10_10_10_REV */
Engine.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
/** UNSIGNED_INT_24_8 */
Engine.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
/** UNSIGNED_INT_10F_11F_11F_REV */
Engine.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
/** UNSIGNED_INT_5_9_9_9_REV */
Engine.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
/** FLOAT_32_UNSIGNED_INT_24_8_REV */
Engine.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
/** nearest is mag = nearest and min = nearest and mip = none */
Engine.TEXTURE_NEAREST_SAMPLINGMODE = 1;
/** Bilinear is mag = linear and min = linear and mip = nearest */
Engine.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
/** Trilinear is mag = linear and min = linear and mip = linear */
Engine.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
/** nearest is mag = nearest and min = nearest and mip = linear */
Engine.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
/** Bilinear is mag = linear and min = linear and mip = nearest */
Engine.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
/** Trilinear is mag = linear and min = linear and mip = linear */
Engine.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
/** mag = nearest and min = nearest and mip = nearest */
Engine.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
/** mag = nearest and min = linear and mip = nearest */
Engine.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
/** mag = nearest and min = linear and mip = linear */
Engine.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
/** mag = nearest and min = linear and mip = none */
Engine.TEXTURE_NEAREST_LINEAR = 7;
/** mag = nearest and min = nearest and mip = none */
Engine.TEXTURE_NEAREST_NEAREST = 1;
/** mag = linear and min = nearest and mip = nearest */
Engine.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
/** mag = linear and min = nearest and mip = linear */
Engine.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
/** mag = linear and min = linear and mip = none */
Engine.TEXTURE_LINEAR_LINEAR = 2;
/** mag = linear and min = nearest and mip = none */
Engine.TEXTURE_LINEAR_NEAREST = 12;
/** Explicit coordinates mode */
Engine.TEXTURE_EXPLICIT_MODE = 0;
/** Spherical coordinates mode */
Engine.TEXTURE_SPHERICAL_MODE = 1;
/** Planar coordinates mode */
Engine.TEXTURE_PLANAR_MODE = 2;
/** Cubic coordinates mode */
Engine.TEXTURE_CUBIC_MODE = 3;
/** Projection coordinates mode */
Engine.TEXTURE_PROJECTION_MODE = 4;
/** Skybox coordinates mode */
Engine.TEXTURE_SKYBOX_MODE = 5;
/** Inverse Cubic coordinates mode */
Engine.TEXTURE_INVCUBIC_MODE = 6;
/** Equirectangular coordinates mode */
// eslint-disable-next-line @typescript-eslint/naming-convention
Engine.TEXTURE_EQUIRECTANGULAR_MODE = 7;
/** Equirectangular Fixed coordinates mode */
// eslint-disable-next-line @typescript-eslint/naming-convention
Engine.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
/** Equirectangular Fixed Mirrored coordinates mode */
// eslint-disable-next-line @typescript-eslint/naming-convention
Engine.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
// Texture rescaling mode
/** Defines that texture rescaling will use a floor to find the closer power of 2 size */
Engine.SCALEMODE_FLOOR = 1;
/** Defines that texture rescaling will look for the nearest power of 2 size */
Engine.SCALEMODE_NEAREST = 2;
/** Defines that texture rescaling will use a ceil to find the closer power of 2 size */
Engine.SCALEMODE_CEILING = 3;
//# sourceMappingURL=engine.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/renderTargetWrapper.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/renderTargetWrapper.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderTargetWrapper: () => (/* binding */ RenderTargetWrapper)
/* harmony export */ });
/* harmony import */ var _Materials_Textures_textureHelper_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Materials/Textures/textureHelper.functions.js */ "./node_modules/@babylonjs/core/Materials/Textures/textureHelper.functions.js");


/**
 * Wrapper around a render target (either single or multi textures)
 */
class RenderTargetWrapper {
    /**
     * Gets the depth/stencil texture
     */
    get depthStencilTexture() {
        return this._depthStencilTexture;
    }
    /**
     * Sets the depth/stencil texture
     * @param texture The depth/stencil texture to set
     * @param disposeExisting True to dispose the existing depth/stencil texture (if any) before replacing it (default: true)
     */
    setDepthStencilTexture(texture, disposeExisting = true) {
        if (disposeExisting && this._depthStencilTexture) {
            this._depthStencilTexture.dispose();
        }
        this._depthStencilTexture = texture;
        this._generateDepthBuffer = this._generateStencilBuffer = this._depthStencilTextureWithStencil = false;
        if (texture) {
            this._generateDepthBuffer = true;
            this._generateStencilBuffer = this._depthStencilTextureWithStencil = (0,_Materials_Textures_textureHelper_functions_js__WEBPACK_IMPORTED_MODULE_0__.HasStencilAspect)(texture.format);
        }
    }
    /**
     * Indicates if the depth/stencil texture has a stencil aspect
     */
    get depthStencilTextureWithStencil() {
        return this._depthStencilTextureWithStencil;
    }
    /**
     * Defines if the render target wrapper is for a cube texture or if false a 2d texture
     */
    get isCube() {
        return this._isCube;
    }
    /**
     * Defines if the render target wrapper is for a single or multi target render wrapper
     */
    get isMulti() {
        return this._isMulti;
    }
    /**
     * Defines if the render target wrapper is for a single or an array of textures
     */
    get is2DArray() {
        return this.layers > 0;
    }
    /**
     * Defines if the render target wrapper is for a 3D texture
     */
    get is3D() {
        return this.depth > 0;
    }
    /**
     * Gets the size of the render target wrapper (used for cubes, as width=height in this case)
     */
    get size() {
        return this.width;
    }
    /**
     * Gets the width of the render target wrapper
     */
    get width() {
        return this._size.width ?? this._size;
    }
    /**
     * Gets the height of the render target wrapper
     */
    get height() {
        return this._size.height ?? this._size;
    }
    /**
     * Gets the number of layers of the render target wrapper (only used if is2DArray is true and wrapper is not a multi render target)
     */
    get layers() {
        return this._size.layers || 0;
    }
    /**
     * Gets the depth of the render target wrapper (only used if is3D is true and wrapper is not a multi render target)
     */
    get depth() {
        return this._size.depth || 0;
    }
    /**
     * Gets the render texture. If this is a multi render target, gets the first texture
     */
    get texture() {
        return this._textures?.[0] ?? null;
    }
    /**
     * Gets the list of render textures. If we are not in a multi render target, the list will be null (use the texture getter instead)
     */
    get textures() {
        return this._textures;
    }
    /**
     * Gets the face indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null
     */
    get faceIndices() {
        return this._faceIndices;
    }
    /**
     * Gets the layer indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null
     */
    get layerIndices() {
        return this._layerIndices;
    }
    /**
     * Gets the base array layer of a texture in the textures array
     * This is an number that is calculated based on the layer and face indices set for this texture at that index
     * @param index The index of the texture in the textures array to get the base array layer for
     * @returns the base array layer of the texture at the given index
     */
    getBaseArrayLayer(index) {
        if (!this._textures) {
            return -1;
        }
        const texture = this._textures[index];
        const layerIndex = this._layerIndices?.[index] ?? 0;
        const faceIndex = this._faceIndices?.[index] ?? 0;
        return texture.isCube ? layerIndex * 6 + faceIndex : texture.is3D ? 0 : layerIndex;
    }
    /**
     * Gets the sample count of the render target
     */
    get samples() {
        return this._samples;
    }
    /**
     * Sets the sample count of the render target
     * @param value sample count
     * @param initializeBuffers If set to true, the engine will make an initializing call to drawBuffers (only used when isMulti=true).
     * @param force true to force calling the update sample count engine function even if the current sample count is equal to value
     * @returns the sample count that has been set
     */
    setSamples(value, initializeBuffers = true, force = false) {
        if (this.samples === value && !force) {
            return value;
        }
        const result = this._isMulti
            ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers)
            : this._engine.updateRenderTargetTextureSampleCount(this, value);
        this._samples = value;
        return result;
    }
    /**
     * Resolves the MSAA textures into their non-MSAA version.
     * Note that if samples equals 1 (no MSAA), no resolve is performed.
     */
    resolveMSAATextures() {
        if (this.isMulti) {
            this._engine.resolveMultiFramebuffer(this);
        }
        else {
            this._engine.resolveFramebuffer(this);
        }
    }
    /**
     * Generates mipmaps for each texture of the render target
     */
    generateMipMaps() {
        if (this._engine._currentRenderTarget === this) {
            this._engine.unBindFramebuffer(this, true);
        }
        if (this.isMulti) {
            this._engine.generateMipMapsMultiFramebuffer(this);
        }
        else {
            this._engine.generateMipMapsFramebuffer(this);
        }
    }
    /**
     * Initializes the render target wrapper
     * @param isMulti true if the wrapper is a multi render target
     * @param isCube true if the wrapper should render to a cube texture
     * @param size size of the render target (width/height/layers)
     * @param engine engine used to create the render target
     * @param label defines the label to use for the wrapper (for debugging purpose only)
     */
    constructor(isMulti, isCube, size, engine, label) {
        this._textures = null;
        this._faceIndices = null;
        this._layerIndices = null;
        /** @internal */
        this._samples = 1;
        /** @internal */
        this._attachments = null;
        /** @internal */
        this._generateStencilBuffer = false;
        /** @internal */
        this._generateDepthBuffer = false;
        /** @internal */
        this._depthStencilTextureWithStencil = false;
        /**
         * Sets this property to true to disable the automatic MSAA resolve that happens when the render target wrapper is unbound (default is false)
         */
        this.disableAutomaticMSAAResolve = false;
        /**
         * Indicates if MSAA color texture(s) should be resolved when a resolve occur (either automatically by the engine or manually by the user) (default is true)
         * Note that you can trigger a MSAA resolve at any time by calling resolveMSAATextures()
         */
        this.resolveMSAAColors = true;
        /**
         * Indicates if MSAA depth texture should be resolved when a resolve occur (either automatically by the engine or manually by the user) (default is false)
         */
        this.resolveMSAADepth = false;
        /**
         * Indicates if MSAA stencil texture should be resolved when a resolve occur (either automatically by the engine or manually by the user) (default is false)
         */
        this.resolveMSAAStencil = false;
        this._isMulti = isMulti;
        this._isCube = isCube;
        this._size = size;
        this._engine = engine;
        this._depthStencilTexture = null;
        this.label = label;
    }
    /**
     * Sets the render target texture(s)
     * @param textures texture(s) to set
     */
    setTextures(textures) {
        if (Array.isArray(textures)) {
            this._textures = textures;
        }
        else if (textures) {
            this._textures = [textures];
        }
        else {
            this._textures = null;
        }
    }
    /**
     * Set a texture in the textures array
     * @param texture The texture to set
     * @param index The index in the textures array to set
     * @param disposePrevious If this function should dispose the previous texture
     */
    setTexture(texture, index = 0, disposePrevious = true) {
        if (!this._textures) {
            this._textures = [];
        }
        if (this._textures[index] === texture) {
            return;
        }
        if (this._textures[index] && disposePrevious) {
            this._textures[index].dispose();
        }
        this._textures[index] = texture;
    }
    /**
     * Sets the layer and face indices of every render target texture bound to each color attachment
     * @param layers The layers of each texture to be set
     * @param faces The faces of each texture to be set
     */
    setLayerAndFaceIndices(layers, faces) {
        this._layerIndices = layers;
        this._faceIndices = faces;
    }
    /**
     * Sets the layer and face indices of a texture in the textures array that should be bound to each color attachment
     * @param index The index of the texture in the textures array to modify
     * @param layer The layer of the texture to be set
     * @param face The face of the texture to be set
     */
    setLayerAndFaceIndex(index = 0, layer, face) {
        if (!this._layerIndices) {
            this._layerIndices = [];
        }
        if (!this._faceIndices) {
            this._faceIndices = [];
        }
        if (layer !== undefined && layer >= 0) {
            this._layerIndices[index] = layer;
        }
        if (face !== undefined && face >= 0) {
            this._faceIndices[index] = face;
        }
    }
    /**
     * Creates the depth/stencil texture
     * @param comparisonFunction Comparison function to use for the texture
     * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture
     * @param generateStencil Not used anymore. "format" will be used to determine if stencil should be created
     * @param samples sample count to use when creating the texture (default: 1)
     * @param format format of the depth texture (default: 14)
     * @param label defines the label to use for the texture (for debugging purpose only)
     * @returns the depth/stencil created texture
     */
    createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14, label) {
        this._depthStencilTexture?.dispose();
        this._depthStencilTextureWithStencil = generateStencil;
        this._depthStencilTextureLabel = label;
        this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {
            bilinearFiltering,
            comparisonFunction,
            generateStencil,
            isCube: this._isCube,
            samples,
            depthTextureFormat: format,
            label,
        }, this);
        return this._depthStencilTexture;
    }
    /**
     * @deprecated Use shareDepth instead
     * @param renderTarget Destination renderTarget
     */
    _shareDepth(renderTarget) {
        this.shareDepth(renderTarget);
    }
    /**
     * Shares the depth buffer of this render target with another render target.
     * @param renderTarget Destination renderTarget
     */
    shareDepth(renderTarget) {
        if (this._depthStencilTexture) {
            if (renderTarget._depthStencilTexture) {
                renderTarget._depthStencilTexture.dispose();
            }
            renderTarget._depthStencilTexture = this._depthStencilTexture;
            renderTarget._depthStencilTextureWithStencil = this._depthStencilTextureWithStencil;
            this._depthStencilTexture.incrementReferences();
        }
    }
    /**
     * @internal
     */
    _swapAndDie(target) {
        if (this.texture) {
            this.texture._swapAndDie(target);
        }
        this._textures = null;
        this.dispose(true);
    }
    _cloneRenderTargetWrapper() {
        let rtw = null;
        if (this._isMulti) {
            const textureArray = this.textures;
            if (textureArray && textureArray.length > 0) {
                let generateDepthTexture = false;
                let textureCount = textureArray.length;
                let depthTextureFormat = -1;
                const lastTextureSource = textureArray[textureArray.length - 1]._source;
                if (lastTextureSource === 14 /* InternalTextureSource.Depth */ || lastTextureSource === 12 /* InternalTextureSource.DepthStencil */) {
                    generateDepthTexture = true;
                    depthTextureFormat = textureArray[textureArray.length - 1].format;
                    textureCount--;
                }
                const samplingModes = [];
                const types = [];
                const formats = [];
                const targetTypes = [];
                const faceIndex = [];
                const layerIndex = [];
                const layerCounts = [];
                const internalTexture2Index = {};
                for (let i = 0; i < textureCount; ++i) {
                    const texture = textureArray[i];
                    samplingModes.push(texture.samplingMode);
                    types.push(texture.type);
                    formats.push(texture.format);
                    const index = internalTexture2Index[texture.uniqueId];
                    if (index !== undefined) {
                        targetTypes.push(-1);
                        layerCounts.push(0);
                    }
                    else {
                        internalTexture2Index[texture.uniqueId] = i;
                        if (texture.is2DArray) {
                            targetTypes.push(35866);
                            layerCounts.push(texture.depth);
                        }
                        else if (texture.isCube) {
                            targetTypes.push(34067);
                            layerCounts.push(0);
                        } /*else if (texture.isCubeArray) {
                            targetTypes.push(3735928559);
                            layerCounts.push(texture.depth);
                        }*/
                        else if (texture.is3D) {
                            targetTypes.push(32879);
                            layerCounts.push(texture.depth);
                        }
                        else {
                            targetTypes.push(3553);
                            layerCounts.push(0);
                        }
                    }
                    if (this._faceIndices) {
                        faceIndex.push(this._faceIndices[i] ?? 0);
                    }
                    if (this._layerIndices) {
                        layerIndex.push(this._layerIndices[i] ?? 0);
                    }
                }
                const optionsMRT = {
                    samplingModes,
                    generateMipMaps: textureArray[0].generateMipMaps,
                    generateDepthBuffer: this._generateDepthBuffer,
                    generateStencilBuffer: this._generateStencilBuffer,
                    generateDepthTexture,
                    depthTextureFormat,
                    types,
                    formats,
                    textureCount,
                    targetTypes,
                    faceIndex,
                    layerIndex,
                    layerCounts,
                    label: this.label,
                };
                const size = {
                    width: this.width,
                    height: this.height,
                    depth: this.depth,
                };
                rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);
                for (let i = 0; i < textureCount; ++i) {
                    if (targetTypes[i] !== -1) {
                        continue;
                    }
                    const index = internalTexture2Index[textureArray[i].uniqueId];
                    rtw.setTexture(rtw.textures[index], i);
                }
            }
        }
        else {
            const options = {};
            options.generateDepthBuffer = this._generateDepthBuffer;
            options.generateMipMaps = this.texture?.generateMipMaps ?? false;
            options.generateStencilBuffer = this._generateStencilBuffer;
            options.samplingMode = this.texture?.samplingMode;
            options.type = this.texture?.type;
            options.format = this.texture?.format;
            options.noColorAttachment = !this._textures;
            options.label = this.label;
            if (this.isCube) {
                rtw = this._engine.createRenderTargetCubeTexture(this.width, options);
            }
            else {
                const size = {
                    width: this.width,
                    height: this.height,
                    layers: this.is2DArray || this.is3D ? this.texture?.depth : undefined,
                };
                rtw = this._engine.createRenderTargetTexture(size, options);
            }
            if (rtw.texture) {
                rtw.texture.isReady = true;
            }
        }
        return rtw;
    }
    _swapRenderTargetWrapper(target) {
        if (this._textures && target._textures) {
            for (let i = 0; i < this._textures.length; ++i) {
                this._textures[i]._swapAndDie(target._textures[i], false);
                target._textures[i].isReady = true;
            }
        }
        if (this._depthStencilTexture && target._depthStencilTexture) {
            this._depthStencilTexture._swapAndDie(target._depthStencilTexture);
            target._depthStencilTexture.isReady = true;
        }
        this._textures = null;
        this._depthStencilTexture = null;
    }
    /** @internal */
    _rebuild() {
        const rtw = this._cloneRenderTargetWrapper();
        if (!rtw) {
            return;
        }
        if (this._depthStencilTexture) {
            const samplingMode = this._depthStencilTexture.samplingMode;
            const format = this._depthStencilTexture.format;
            const bilinear = samplingMode === 2 ||
                samplingMode === 3 ||
                samplingMode === 11;
            rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples, format, this._depthStencilTextureLabel);
        }
        if (this.samples > 1) {
            rtw.setSamples(this.samples);
        }
        rtw._swapRenderTargetWrapper(this);
        rtw.dispose();
    }
    /**
     * Releases the internal render textures
     */
    releaseTextures() {
        if (this._textures) {
            for (let i = 0; i < this._textures.length; ++i) {
                this._textures[i].dispose();
            }
        }
        this._textures = null;
    }
    /**
     * Disposes the whole render target wrapper
     * @param disposeOnlyFramebuffers true if only the frame buffers should be released (used for the WebGL engine). If false, all the textures will also be released
     */
    dispose(disposeOnlyFramebuffers = false) {
        if (!disposeOnlyFramebuffers) {
            this._depthStencilTexture?.dispose();
            this._depthStencilTexture = null;
            this.releaseTextures();
        }
        this._engine._releaseRenderTargetWrapper(this);
    }
}
//# sourceMappingURL=renderTargetWrapper.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Engines/thinEngine.js":
/*!************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/thinEngine.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ThinEngine: () => (/* binding */ ThinEngine)
/* harmony export */ });
/* harmony import */ var _thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thinEngine.functions.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.functions.js");
/* harmony import */ var _Materials_drawWrapper_functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Materials/drawWrapper.functions.js */ "./node_modules/@babylonjs/core/Materials/drawWrapper.functions.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _Misc_domManagement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Misc/domManagement.js */ "./node_modules/@babylonjs/core/Misc/domManagement.js");
/* harmony import */ var _WebGL_webGLShaderProcessors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WebGL/webGLShaderProcessors.js */ "./node_modules/@babylonjs/core/Engines/WebGL/webGLShaderProcessors.js");
/* harmony import */ var _WebGL_webGL2ShaderProcessors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WebGL/webGL2ShaderProcessors.js */ "./node_modules/@babylonjs/core/Engines/WebGL/webGL2ShaderProcessors.js");
/* harmony import */ var _Meshes_WebGL_webGLDataBuffer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Meshes/WebGL/webGLDataBuffer.js */ "./node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js");
/* harmony import */ var _Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Misc/tools.functions.js */ "./node_modules/@babylonjs/core/Misc/tools.functions.js");
/* harmony import */ var _abstractEngine_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");
/* harmony import */ var _WebGL_webGLHardwareTexture_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./WebGL/webGLHardwareTexture.js */ "./node_modules/@babylonjs/core/Engines/WebGL/webGLHardwareTexture.js");
/* harmony import */ var _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Materials/Textures/internalTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/internalTexture.js");
/* harmony import */ var _Materials_effect_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Materials/effect.js */ "./node_modules/@babylonjs/core/Materials/effect.js");
/* harmony import */ var _abstractEngine_functions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./abstractEngine.functions.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.functions.js");
/* harmony import */ var _Materials_effect_functions_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../Materials/effect.functions.js */ "./node_modules/@babylonjs/core/Materials/effect.functions.js");
/* harmony import */ var _Materials_Textures_textureHelper_functions_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../Materials/Textures/textureHelper.functions.js */ "./node_modules/@babylonjs/core/Materials/Textures/textureHelper.functions.js");
















/**
 * Keeps track of all the buffer info used in engine.
 */
class BufferPointer {
}
/**
 * The base engine class (root of all engines)
 */
class ThinEngine extends _abstractEngine_js__WEBPACK_IMPORTED_MODULE_8__.AbstractEngine {
    /**
     * Gets or sets the name of the engine
     */
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    /**
     * Returns the version of the engine
     */
    get version() {
        return this._webGLVersion;
    }
    /**
     * Gets or sets the relative url used to load shaders if using the engine in non-minified mode
     */
    static get ShadersRepository() {
        return _Materials_effect_js__WEBPACK_IMPORTED_MODULE_11__.Effect.ShadersRepository;
    }
    static set ShadersRepository(value) {
        _Materials_effect_js__WEBPACK_IMPORTED_MODULE_11__.Effect.ShadersRepository = value;
    }
    /**
     * Gets a boolean indicating that the engine supports uniform buffers
     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets
     */
    get supportsUniformBuffers() {
        return this.webGLVersion > 1 && !this.disableUniformBuffers;
    }
    /**
     * Gets a boolean indicating that only power of 2 textures are supported
     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them
     */
    get needPOTTextures() {
        return this._webGLVersion < 2 || this.forcePOTTextures;
    }
    get _supportsHardwareTextureRescaling() {
        return false;
    }
    /**
     * sets the object from which width and height will be taken from when getting render width and height
     * Will fallback to the gl object
     * @param dimensions the framebuffer width and height that will be used.
     */
    set framebufferDimensionsObject(dimensions) {
        this._framebufferDimensionsObject = dimensions;
    }
    /**
     * Creates a new snapshot at the next frame using the current snapshotRenderingMode
     */
    snapshotRenderingReset() {
        this.snapshotRendering = false;
    }
    /**
     * Creates a new engine
     * @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which already used the WebGL context
     * @param antialias defines whether anti-aliasing should be enabled (default value is "undefined", meaning that the browser may or may not enable it)
     * @param options defines further options to be sent to the getContext() function
     * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)
     */
    constructor(canvasOrContext, antialias, options, adaptToDeviceRatio) {
        options = options || {};
        super(antialias ?? options.antialias, options, adaptToDeviceRatio);
        /** @internal */
        this._name = "WebGL";
        /**
         * Gets or sets a boolean that indicates if textures must be forced to power of 2 size even if not required
         */
        this.forcePOTTextures = false;
        /** Gets or sets a boolean indicating if the engine should validate programs after compilation */
        this.validateShaderPrograms = false;
        /**
         * Gets or sets a boolean indicating that uniform buffers must be disabled even if they are supported
         */
        this.disableUniformBuffers = false;
        /** @internal */
        this._webGLVersion = 1.0;
        this._vertexAttribArraysEnabled = [];
        this._uintIndicesCurrentlySet = false;
        this._currentBoundBuffer = new Array();
        /** @internal */
        this._currentFramebuffer = null;
        /** @internal */
        this._dummyFramebuffer = null;
        this._currentBufferPointers = new Array();
        this._currentInstanceLocations = new Array();
        this._currentInstanceBuffers = new Array();
        this._vaoRecordInProgress = false;
        this._mustWipeVertexAttributes = false;
        this._nextFreeTextureSlots = new Array();
        this._maxSimultaneousTextures = 0;
        this._maxMSAASamplesOverride = null;
        // eslint-disable-next-line @typescript-eslint/naming-convention
        this._unpackFlipYCached = null;
        /**
         * In case you are sharing the context with other applications, it might
         * be interested to not cache the unpack flip y state to ensure a consistent
         * value would be set.
         */
        // eslint-disable-next-line @typescript-eslint/naming-convention
        this.enableUnpackFlipYCached = true;
        /**
         * @internal
         */
        this._boundUniforms = {};
        if (!canvasOrContext) {
            return;
        }
        let canvas = null;
        if (canvasOrContext.getContext) {
            canvas = canvasOrContext;
            if (options.preserveDrawingBuffer === undefined) {
                options.preserveDrawingBuffer = false;
            }
            if (options.xrCompatible === undefined) {
                options.xrCompatible = false;
            }
            // Exceptions
            if (navigator && navigator.userAgent) {
                this._setupMobileChecks();
                const ua = navigator.userAgent;
                for (const exception of ThinEngine.ExceptionList) {
                    const key = exception.key;
                    const targets = exception.targets;
                    const check = new RegExp(key);
                    if (check.test(ua)) {
                        if (exception.capture && exception.captureConstraint) {
                            const capture = exception.capture;
                            const constraint = exception.captureConstraint;
                            const regex = new RegExp(capture);
                            const matches = regex.exec(ua);
                            if (matches && matches.length > 0) {
                                const capturedValue = parseInt(matches[matches.length - 1]);
                                if (capturedValue >= constraint) {
                                    continue;
                                }
                            }
                        }
                        for (const target of targets) {
                            switch (target) {
                                case "uniformBuffer":
                                    this.disableUniformBuffers = true;
                                    break;
                                case "vao":
                                    this.disableVertexArrayObjects = true;
                                    break;
                                case "antialias":
                                    options.antialias = false;
                                    break;
                                case "maxMSAASamples":
                                    this._maxMSAASamplesOverride = 1;
                                    break;
                            }
                        }
                    }
                }
            }
            // Context lost
            if (!this._doNotHandleContextLost) {
                this._onContextLost = (evt) => {
                    evt.preventDefault();
                    this._contextWasLost = true;
                    (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.deleteStateObject)(this._gl);
                    _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.Warn("WebGL context lost.");
                    this.onContextLostObservable.notifyObservers(this);
                };
                this._onContextRestored = () => {
                    this._restoreEngineAfterContextLost(() => this._initGLContext());
                };
                canvas.addEventListener("webglcontextrestored", this._onContextRestored, false);
                options.powerPreference = options.powerPreference || "high-performance";
            }
            else {
                this._onContextLost = () => {
                    (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.deleteStateObject)(this._gl);
                };
            }
            canvas.addEventListener("webglcontextlost", this._onContextLost, false);
            if (this._badDesktopOS) {
                options.xrCompatible = false;
            }
            // GL
            if (!options.disableWebGL2Support) {
                try {
                    this._gl = (canvas.getContext("webgl2", options) || canvas.getContext("experimental-webgl2", options));
                    if (this._gl) {
                        this._webGLVersion = 2.0;
                        this._shaderPlatformName = "WEBGL2";
                        // Prevent weird browsers to lie (yeah that happens!)
                        if (!this._gl.deleteQuery) {
                            this._webGLVersion = 1.0;
                            this._shaderPlatformName = "WEBGL1";
                        }
                    }
                }
                catch (e) {
                    // Do nothing
                }
            }
            if (!this._gl) {
                if (!canvas) {
                    throw new Error("The provided canvas is null or undefined.");
                }
                try {
                    this._gl = (canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options));
                }
                catch (e) {
                    throw new Error("WebGL not supported");
                }
            }
            if (!this._gl) {
                throw new Error("WebGL not supported");
            }
        }
        else {
            this._gl = canvasOrContext;
            canvas = this._gl.canvas;
            if (this._gl.renderbufferStorageMultisample) {
                this._webGLVersion = 2.0;
                this._shaderPlatformName = "WEBGL2";
            }
            else {
                this._shaderPlatformName = "WEBGL1";
            }
            const attributes = this._gl.getContextAttributes();
            if (attributes) {
                options.stencil = attributes.stencil;
            }
        }
        this._sharedInit(canvas);
        // Ensures a consistent color space unpacking of textures cross browser.
        this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
        if (options.useHighPrecisionFloats !== undefined) {
            this._highPrecisionShadersAllowed = options.useHighPrecisionFloats;
        }
        this.resize();
        this._initGLContext();
        this._initFeatures();
        // Prepare buffer pointers
        for (let i = 0; i < this._caps.maxVertexAttribs; i++) {
            this._currentBufferPointers[i] = new BufferPointer();
        }
        // Shader processor
        this._shaderProcessor = this.webGLVersion > 1 ? new _WebGL_webGL2ShaderProcessors_js__WEBPACK_IMPORTED_MODULE_5__.WebGL2ShaderProcessor() : new _WebGL_webGLShaderProcessors_js__WEBPACK_IMPORTED_MODULE_4__.WebGLShaderProcessor();
        // Starting with iOS 14, we can trust the browser
        // let matches = navigator.userAgent.match(/Version\/(\d+)/);
        // if (matches && matches.length === 2) {
        //     if (parseInt(matches[1]) >= 14) {
        //         this._badOS = false;
        //     }
        // }
        const versionToLog = `Babylon.js v${ThinEngine.Version}`;
        _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.Log(versionToLog + ` - ${this.description}`);
        // Check setAttribute in case of workers
        if (this._renderingCanvas && this._renderingCanvas.setAttribute) {
            this._renderingCanvas.setAttribute("data-engine", versionToLog);
        }
        const stateObject = (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.getStateObject)(this._gl);
        // update state object with the current engine state
        stateObject.validateShaderPrograms = this.validateShaderPrograms;
        stateObject.parallelShaderCompile = this._caps.parallelShaderCompile;
    }
    _clearEmptyResources() {
        this._dummyFramebuffer = null;
        super._clearEmptyResources();
    }
    /**
     * @internal
     */
    _getShaderProcessingContext(shaderLanguage) {
        return null;
    }
    /**
     * Gets a boolean indicating if all created effects are ready
     * @returns true if all effects are ready
     */
    areAllEffectsReady() {
        for (const key in this._compiledEffects) {
            const effect = this._compiledEffects[key];
            if (!effect.isReady()) {
                return false;
            }
        }
        return true;
    }
    _initGLContext() {
        // Caps
        this._caps = {
            maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
            maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
            maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
            maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
            maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
            maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
            maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
            maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
            maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
            maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
            parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || undefined,
            standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null,
            maxAnisotropy: 1,
            astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
            bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
            s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
            // eslint-disable-next-line @typescript-eslint/naming-convention
            s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
            pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
            etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") ||
                this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") ||
                this._gl.getExtension("WEBGL_compressed_texture_es3_0"), // also a requirement of OpenGL ES 3
            textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") ||
                this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") ||
                this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
            uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null,
            fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null,
            highPrecisionShaderSupported: false,
            timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
            supportOcclusionQuery: this._webGLVersion > 1,
            canUseTimestampForTimerQuery: false,
            drawBuffersExtension: false,
            maxMSAASamples: 1,
            colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
            supportFloatTexturesResolve: false,
            rg11b10ufColorRenderable: false,
            colorBufferHalfFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_half_float")),
            textureFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float") ? true : false,
            textureHalfFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float") ? true : false,
            textureHalfFloatRender: false,
            textureFloatLinearFiltering: false,
            textureFloatRender: false,
            textureHalfFloatLinearFiltering: false,
            vertexArrayObject: false,
            instancedArrays: false,
            textureLOD: this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod") ? true : false,
            texelFetch: this._webGLVersion !== 1,
            blendMinMax: false,
            multiview: this._gl.getExtension("OVR_multiview2"),
            oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
            depthTextureExtension: false,
            canUseGLInstanceID: this._webGLVersion > 1,
            canUseGLVertexID: this._webGLVersion > 1,
            supportComputeShaders: false,
            supportSRGBBuffers: false,
            supportTransformFeedbacks: this._webGLVersion > 1,
            textureMaxLevel: this._webGLVersion > 1,
            texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_ARRAY_TEXTURE_LAYERS) : 128,
            disableMorphTargetTexture: false,
            textureNorm16: this._gl.getExtension("EXT_texture_norm16") ? true : false,
        };
        this._caps.supportFloatTexturesResolve = this._caps.colorBufferFloat;
        this._caps.rg11b10ufColorRenderable = this._caps.colorBufferFloat;
        // Infos
        this._glVersion = this._gl.getParameter(this._gl.VERSION);
        const rendererInfo = this._gl.getExtension("WEBGL_debug_renderer_info");
        if (rendererInfo != null) {
            this._glRenderer = this._gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);
            this._glVendor = this._gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);
        }
        if (!this._glVendor) {
            this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor";
        }
        if (!this._glRenderer) {
            this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer";
        }
        // Constants
        if (this._gl.HALF_FLOAT_OES !== 0x8d61) {
            this._gl.HALF_FLOAT_OES = 0x8d61; // Half floating-point type (16-bit).
        }
        if (this._gl.RGBA16F !== 0x881a) {
            this._gl.RGBA16F = 0x881a; // RGBA 16-bit floating-point color-renderable internal sized format.
        }
        if (this._gl.RGBA32F !== 0x8814) {
            this._gl.RGBA32F = 0x8814; // RGBA 32-bit floating-point color-renderable internal sized format.
        }
        if (this._gl.DEPTH24_STENCIL8 !== 35056) {
            this._gl.DEPTH24_STENCIL8 = 35056;
        }
        // Extensions
        if (this._caps.timerQuery) {
            if (this._webGLVersion === 1) {
                this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery);
            }
            // WebGLQuery casted to number to avoid TS error
            this._caps.canUseTimestampForTimerQuery = (this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT) ?? 0) > 0;
        }
        this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension
            ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            : 0;
        this._caps.textureFloatLinearFiltering = this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear") ? true : false;
        this._caps.textureFloatRender = this._caps.textureFloat && this._canRenderToFloatFramebuffer() ? true : false;
        this._caps.textureHalfFloatLinearFiltering =
            this._webGLVersion > 1 || (this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear")) ? true : false;
        if (this._caps.textureNorm16) {
            this._gl.R16_EXT = 0x822a;
            this._gl.RG16_EXT = 0x822c;
            this._gl.RGB16_EXT = 0x8054;
            this._gl.RGBA16_EXT = 0x805b;
            this._gl.R16_SNORM_EXT = 0x8f98;
            this._gl.RG16_SNORM_EXT = 0x8f99;
            this._gl.RGB16_SNORM_EXT = 0x8f9a;
            this._gl.RGBA16_SNORM_EXT = 0x8f9b;
        }
        // Compressed formats
        if (this._caps.astc) {
            this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
        }
        if (this._caps.bptc) {
            this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
        }
        if (this._caps.s3tc_srgb) {
            this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        }
        if (this._caps.etc2) {
            this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2;
            this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
        }
        // Checks if some of the format renders first to allow the use of webgl inspector.
        if (this._webGLVersion > 1) {
            if (this._gl.HALF_FLOAT_OES !== 0x140b) {
                this._gl.HALF_FLOAT_OES = 0x140b;
            }
        }
        this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer();
        // Draw buffers
        if (this._webGLVersion > 1) {
            this._caps.drawBuffersExtension = true;
            this._caps.maxMSAASamples = this._maxMSAASamplesOverride !== null ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES);
            this._caps.maxDrawBuffers = this._gl.getParameter(this._gl.MAX_DRAW_BUFFERS);
        }
        else {
            const drawBuffersExtension = this._gl.getExtension("WEBGL_draw_buffers");
            if (drawBuffersExtension !== null) {
                this._caps.drawBuffersExtension = true;
                this._gl.drawBuffers = drawBuffersExtension.drawBuffersWEBGL.bind(drawBuffersExtension);
                this._caps.maxDrawBuffers = this._gl.getParameter(drawBuffersExtension.MAX_DRAW_BUFFERS_WEBGL);
                this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
                for (let i = 0; i < 16; i++) {
                    this._gl["COLOR_ATTACHMENT" + i + "_WEBGL"] = drawBuffersExtension["COLOR_ATTACHMENT" + i + "_WEBGL"];
                }
            }
        }
        // Depth Texture
        if (this._webGLVersion > 1) {
            this._caps.depthTextureExtension = true;
        }
        else {
            const depthTextureExtension = this._gl.getExtension("WEBGL_depth_texture");
            if (depthTextureExtension != null) {
                this._caps.depthTextureExtension = true;
                this._gl.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
            }
        }
        // Vertex array object
        if (this.disableVertexArrayObjects) {
            this._caps.vertexArrayObject = false;
        }
        else if (this._webGLVersion > 1) {
            this._caps.vertexArrayObject = true;
        }
        else {
            const vertexArrayObjectExtension = this._gl.getExtension("OES_vertex_array_object");
            if (vertexArrayObjectExtension != null) {
                this._caps.vertexArrayObject = true;
                this._gl.createVertexArray = vertexArrayObjectExtension.createVertexArrayOES.bind(vertexArrayObjectExtension);
                this._gl.bindVertexArray = vertexArrayObjectExtension.bindVertexArrayOES.bind(vertexArrayObjectExtension);
                this._gl.deleteVertexArray = vertexArrayObjectExtension.deleteVertexArrayOES.bind(vertexArrayObjectExtension);
            }
        }
        // Instances count
        if (this._webGLVersion > 1) {
            this._caps.instancedArrays = true;
        }
        else {
            const instanceExtension = this._gl.getExtension("ANGLE_instanced_arrays");
            if (instanceExtension != null) {
                this._caps.instancedArrays = true;
                this._gl.drawArraysInstanced = instanceExtension.drawArraysInstancedANGLE.bind(instanceExtension);
                this._gl.drawElementsInstanced = instanceExtension.drawElementsInstancedANGLE.bind(instanceExtension);
                this._gl.vertexAttribDivisor = instanceExtension.vertexAttribDivisorANGLE.bind(instanceExtension);
            }
            else {
                this._caps.instancedArrays = false;
            }
        }
        if (this._gl.getShaderPrecisionFormat) {
            const vertexhighp = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT);
            const fragmenthighp = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
            if (vertexhighp && fragmenthighp) {
                this._caps.highPrecisionShaderSupported = vertexhighp.precision !== 0 && fragmenthighp.precision !== 0;
            }
        }
        if (this._webGLVersion > 1) {
            this._caps.blendMinMax = true;
        }
        else {
            const blendMinMaxExtension = this._gl.getExtension("EXT_blend_minmax");
            if (blendMinMaxExtension != null) {
                this._caps.blendMinMax = true;
                this._gl.MAX = blendMinMaxExtension.MAX_EXT;
                this._gl.MIN = blendMinMaxExtension.MIN_EXT;
            }
        }
        // sRGB buffers
        // only run this if not already set to true (in the constructor, for example)
        if (!this._caps.supportSRGBBuffers) {
            if (this._webGLVersion > 1) {
                this._caps.supportSRGBBuffers = true;
                this._glSRGBExtensionValues = {
                    SRGB: WebGL2RenderingContext.SRGB,
                    SRGB8: WebGL2RenderingContext.SRGB8,
                    SRGB8_ALPHA8: WebGL2RenderingContext.SRGB8_ALPHA8,
                };
            }
            else {
                const sRGBExtension = this._gl.getExtension("EXT_sRGB");
                if (sRGBExtension != null) {
                    this._caps.supportSRGBBuffers = true;
                    this._glSRGBExtensionValues = {
                        SRGB: sRGBExtension.SRGB_EXT,
                        SRGB8: sRGBExtension.SRGB_ALPHA_EXT,
                        SRGB8_ALPHA8: sRGBExtension.SRGB_ALPHA_EXT,
                    };
                }
            }
            // take into account the forced state that was provided in options
            if (this._creationOptions) {
                const forceSRGBBufferSupportState = this._creationOptions.forceSRGBBufferSupportState;
                if (forceSRGBBufferSupportState !== undefined) {
                    this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && forceSRGBBufferSupportState;
                }
            }
        }
        // Depth buffer
        this._depthCullingState.depthTest = true;
        this._depthCullingState.depthFunc = this._gl.LEQUAL;
        this._depthCullingState.depthMask = true;
        // Texture maps
        this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
        for (let slot = 0; slot < this._maxSimultaneousTextures; slot++) {
            this._nextFreeTextureSlots.push(slot);
        }
        if (this._glRenderer === "Mali-G72") {
            // Overcome a bug when using a texture to store morph targets on Mali-G72
            this._caps.disableMorphTargetTexture = true;
        }
    }
    _initFeatures() {
        this._features = {
            forceBitmapOverHTMLImageElement: typeof HTMLImageElement === "undefined",
            supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1,
            supportDepthStencilTexture: this._webGLVersion !== 1,
            supportShadowSamplers: this._webGLVersion !== 1,
            uniformBufferHardCheckMatrix: false,
            allowTexturePrefiltering: this._webGLVersion !== 1,
            trackUbosInFrame: false,
            checkUbosContentBeforeUpload: false,
            supportCSM: this._webGLVersion !== 1,
            basisNeedsPOT: this._webGLVersion === 1,
            support3DTextures: this._webGLVersion !== 1,
            needTypeSuffixInShaderConstants: this._webGLVersion !== 1,
            supportMSAA: this._webGLVersion !== 1,
            supportSSAO2: this._webGLVersion !== 1,
            supportIBLShadows: this._webGLVersion !== 1,
            supportExtendedTextureFormats: this._webGLVersion !== 1,
            supportSwitchCaseInShader: this._webGLVersion !== 1,
            supportSyncTextureRead: true,
            needsInvertingBitmap: true,
            useUBOBindingCache: true,
            needShaderCodeInlining: false,
            needToAlwaysBindUniformBuffers: false,
            supportRenderPasses: false,
            supportSpriteInstancing: true,
            forceVertexBufferStrideAndOffsetMultiple4Bytes: false,
            _checkNonFloatVertexBuffersDontRecreatePipelineContext: false,
            _collectUbosUpdatedInFrame: false,
        };
    }
    /**
     * Gets version of the current webGL context
     * Keep it for back compat - use version instead
     */
    get webGLVersion() {
        return this._webGLVersion;
    }
    /**
     * Gets a string identifying the name of the class
     * @returns "Engine" string
     */
    getClassName() {
        return "ThinEngine";
    }
    /** @internal */
    _prepareWorkingCanvas() {
        if (this._workingCanvas) {
            return;
        }
        this._workingCanvas = this.createCanvas(1, 1);
        const context = this._workingCanvas.getContext("2d");
        if (context) {
            this._workingContext = context;
        }
    }
    /**
     * Gets an object containing information about the current engine context
     * @returns an object containing the vendor, the renderer and the version of the current engine context
     */
    getInfo() {
        return this.getGlInfo();
    }
    /**
     * Gets an object containing information about the current webGL context
     * @returns an object containing the vendor, the renderer and the version of the current webGL context
     */
    getGlInfo() {
        return {
            vendor: this._glVendor,
            renderer: this._glRenderer,
            version: this._glVersion,
        };
    }
    /**Gets driver info if available */
    extractDriverInfo() {
        const glInfo = this.getGlInfo();
        if (glInfo && glInfo.renderer) {
            return glInfo.renderer;
        }
        return "";
    }
    /**
     * Gets the current render width
     * @param useScreen defines if screen size must be used (or the current render target if any)
     * @returns a number defining the current render width
     */
    getRenderWidth(useScreen = false) {
        if (!useScreen && this._currentRenderTarget) {
            return this._currentRenderTarget.width;
        }
        return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;
    }
    /**
     * Gets the current render height
     * @param useScreen defines if screen size must be used (or the current render target if any)
     * @returns a number defining the current render height
     */
    getRenderHeight(useScreen = false) {
        if (!useScreen && this._currentRenderTarget) {
            return this._currentRenderTarget.height;
        }
        return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;
    }
    /**
     * Clear the current render buffer or the current render target (if any is set up)
     * @param color defines the color to use
     * @param backBuffer defines if the back buffer must be cleared
     * @param depth defines if the depth buffer must be cleared
     * @param stencil defines if the stencil buffer must be cleared
     */
    clear(color, backBuffer, depth, stencil = false) {
        const useStencilGlobalOnly = this.stencilStateComposer.useStencilGlobalOnly;
        this.stencilStateComposer.useStencilGlobalOnly = true; // make sure the stencil mask is coming from the global stencil and not from a material (effect) which would currently be in effect
        this.applyStates();
        this.stencilStateComposer.useStencilGlobalOnly = useStencilGlobalOnly;
        let mode = 0;
        if (backBuffer && color) {
            let setBackBufferColor = true;
            if (this._currentRenderTarget) {
                const textureFormat = this._currentRenderTarget.texture?.format;
                if (textureFormat === 8 ||
                    textureFormat === 9 ||
                    textureFormat === 10 ||
                    textureFormat === 11) {
                    const textureType = this._currentRenderTarget.texture?.type;
                    if (textureType === 7 || textureType === 5) {
                        ThinEngine._TempClearColorUint32[0] = color.r * 255;
                        ThinEngine._TempClearColorUint32[1] = color.g * 255;
                        ThinEngine._TempClearColorUint32[2] = color.b * 255;
                        ThinEngine._TempClearColorUint32[3] = color.a * 255;
                        this._gl.clearBufferuiv(this._gl.COLOR, 0, ThinEngine._TempClearColorUint32);
                        setBackBufferColor = false;
                    }
                    else {
                        ThinEngine._TempClearColorInt32[0] = color.r * 255;
                        ThinEngine._TempClearColorInt32[1] = color.g * 255;
                        ThinEngine._TempClearColorInt32[2] = color.b * 255;
                        ThinEngine._TempClearColorInt32[3] = color.a * 255;
                        this._gl.clearBufferiv(this._gl.COLOR, 0, ThinEngine._TempClearColorInt32);
                        setBackBufferColor = false;
                    }
                }
            }
            if (setBackBufferColor) {
                this._gl.clearColor(color.r, color.g, color.b, color.a !== undefined ? color.a : 1.0);
                mode |= this._gl.COLOR_BUFFER_BIT;
            }
        }
        if (depth) {
            if (this.useReverseDepthBuffer) {
                this._depthCullingState.depthFunc = this._gl.GEQUAL;
                this._gl.clearDepth(0.0);
            }
            else {
                this._gl.clearDepth(1.0);
            }
            mode |= this._gl.DEPTH_BUFFER_BIT;
        }
        if (stencil) {
            this._gl.clearStencil(0);
            mode |= this._gl.STENCIL_BUFFER_BIT;
        }
        this._gl.clear(mode);
    }
    /**
     * @internal
     */
    _viewport(x, y, width, height) {
        if (x !== this._viewportCached.x || y !== this._viewportCached.y || width !== this._viewportCached.z || height !== this._viewportCached.w) {
            this._viewportCached.x = x;
            this._viewportCached.y = y;
            this._viewportCached.z = width;
            this._viewportCached.w = height;
            this._gl.viewport(x, y, width, height);
        }
    }
    /**
     * End the current frame
     */
    endFrame() {
        super.endFrame();
        // Force a flush in case we are using a bad OS.
        if (this._badOS) {
            this.flushFramebuffer();
        }
    }
    /**
     * Gets the performance monitor attached to this engine
     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation
     */
    get performanceMonitor() {
        throw new Error("Not Supported by ThinEngine");
    }
    /**
     * Binds the frame buffer to the specified texture.
     * @param rtWrapper The render target wrapper to render to
     * @param faceIndex The face of the texture to render to in case of cube texture and if the render target wrapper is not a multi render target
     * @param requiredWidth The width of the target to render to
     * @param requiredHeight The height of the target to render to
     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true
     * @param lodLevel Defines the lod level to bind to the frame buffer
     * @param layer Defines the 2d array index to bind to the frame buffer if the render target wrapper is not a multi render target
     */
    bindFramebuffer(rtWrapper, faceIndex = 0, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel = 0, layer = 0) {
        const webglRtWrapper = rtWrapper;
        if (this._currentRenderTarget) {
            this.unBindFramebuffer(this._currentRenderTarget);
        }
        this._currentRenderTarget = rtWrapper;
        this._bindUnboundFramebuffer(webglRtWrapper._framebuffer);
        const gl = this._gl;
        if (!rtWrapper.isMulti) {
            if (rtWrapper.is2DArray || rtWrapper.is3D) {
                gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, rtWrapper.texture._hardwareTexture?.underlyingResource, lodLevel, layer);
                webglRtWrapper._currentLOD = lodLevel;
            }
            else if (rtWrapper.isCube) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, rtWrapper.texture._hardwareTexture?.underlyingResource, lodLevel);
            }
            else if (webglRtWrapper._currentLOD !== lodLevel) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rtWrapper.texture._hardwareTexture?.underlyingResource, lodLevel);
                webglRtWrapper._currentLOD = lodLevel;
            }
        }
        const depthStencilTexture = rtWrapper._depthStencilTexture;
        if (depthStencilTexture) {
            if (rtWrapper.is3D) {
                if (rtWrapper.texture.width !== depthStencilTexture.width ||
                    rtWrapper.texture.height !== depthStencilTexture.height ||
                    rtWrapper.texture.depth !== depthStencilTexture.depth) {
                    _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.Warn("Depth/Stencil attachment for 3D target must have same dimensions as color attachment");
                }
            }
            const attachment = rtWrapper._depthStencilTextureWithStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
            if (rtWrapper.is2DArray || rtWrapper.is3D) {
                gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, depthStencilTexture._hardwareTexture?.underlyingResource, lodLevel, layer);
            }
            else if (rtWrapper.isCube) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, depthStencilTexture._hardwareTexture?.underlyingResource, lodLevel);
            }
            else {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, depthStencilTexture._hardwareTexture?.underlyingResource, lodLevel);
            }
        }
        if (webglRtWrapper._MSAAFramebuffer) {
            this._bindUnboundFramebuffer(webglRtWrapper._MSAAFramebuffer);
        }
        if (this._cachedViewport && !forceFullscreenViewport) {
            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
        }
        else {
            if (!requiredWidth) {
                requiredWidth = rtWrapper.width;
                if (lodLevel) {
                    requiredWidth = requiredWidth / Math.pow(2, lodLevel);
                }
            }
            if (!requiredHeight) {
                requiredHeight = rtWrapper.height;
                if (lodLevel) {
                    requiredHeight = requiredHeight / Math.pow(2, lodLevel);
                }
            }
            this._viewport(0, 0, requiredWidth, requiredHeight);
        }
        this.wipeCaches();
    }
    setStateCullFaceType(cullBackFaces, force) {
        const cullFace = (this.cullBackFaces ?? cullBackFaces ?? true) ? this._gl.BACK : this._gl.FRONT;
        if (this._depthCullingState.cullFace !== cullFace || force) {
            this._depthCullingState.cullFace = cullFace;
        }
    }
    /**
     * Set various states to the webGL context
     * @param culling defines culling state: true to enable culling, false to disable it
     * @param zOffset defines the value to apply to zOffset (0 by default)
     * @param force defines if states must be applied even if cache is up to date
     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)
     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)
     * @param stencil stencil states to set
     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)
     */
    setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {
        // Culling
        if (this._depthCullingState.cull !== culling || force) {
            this._depthCullingState.cull = culling;
        }
        // Cull face
        this.setStateCullFaceType(cullBackFaces, force);
        // Z offset
        this.setZOffset(zOffset);
        this.setZOffsetUnits(zOffsetUnits);
        // Front face
        const frontFace = reverseSide ? this._gl.CW : this._gl.CCW;
        if (this._depthCullingState.frontFace !== frontFace || force) {
            this._depthCullingState.frontFace = frontFace;
        }
        this._stencilStateComposer.stencilMaterial = stencil;
    }
    /**
     * @internal
     */
    _bindUnboundFramebuffer(framebuffer) {
        if (this._currentFramebuffer !== framebuffer) {
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
            this._currentFramebuffer = framebuffer;
        }
    }
    /** @internal */
    _currentFrameBufferIsDefaultFrameBuffer() {
        return this._currentFramebuffer === null;
    }
    /**
     * Generates the mipmaps for a texture
     * @param texture texture to generate the mipmaps for
     */
    generateMipmaps(texture) {
        const target = this._getTextureTarget(texture);
        this._bindTextureDirectly(target, texture, true);
        this._gl.generateMipmap(target);
        this._bindTextureDirectly(target, null);
    }
    /**
     * Unbind the current render target texture from the webGL context
     * @param texture defines the render target wrapper to unbind
     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
     * @param onBeforeUnbind defines a function which will be called before the effective unbind
     */
    unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {
        const webglRtWrapper = texture;
        this._currentRenderTarget = null;
        if (!webglRtWrapper.disableAutomaticMSAAResolve) {
            if (texture.isMulti) {
                this.resolveMultiFramebuffer(texture);
            }
            else {
                this.resolveFramebuffer(texture);
            }
        }
        if (!disableGenerateMipMaps) {
            if (texture.isMulti) {
                this.generateMipMapsMultiFramebuffer(texture);
            }
            else {
                this.generateMipMapsFramebuffer(texture);
            }
        }
        if (onBeforeUnbind) {
            if (webglRtWrapper._MSAAFramebuffer) {
                // Bind the correct framebuffer
                this._bindUnboundFramebuffer(webglRtWrapper._framebuffer);
            }
            onBeforeUnbind();
        }
        this._bindUnboundFramebuffer(null);
    }
    /**
     * Generates mipmaps for the texture of the (single) render target
     * @param texture The render target containing the texture to generate the mipmaps for
     */
    generateMipMapsFramebuffer(texture) {
        if (!texture.isMulti && texture.texture?.generateMipMaps && !texture.isCube) {
            this.generateMipmaps(texture.texture);
        }
    }
    /**
     * Resolves the MSAA texture of the (single) render target into its non-MSAA version.
     * Note that if "texture" is not a MSAA render target, no resolve is performed.
     * @param texture  The render target texture containing the MSAA textures to resolve
     */
    resolveFramebuffer(texture) {
        const rtWrapper = texture;
        const gl = this._gl;
        if (!rtWrapper._MSAAFramebuffer || rtWrapper.isMulti) {
            return;
        }
        let bufferBits = rtWrapper.resolveMSAAColors ? gl.COLOR_BUFFER_BIT : 0;
        bufferBits |= rtWrapper._generateDepthBuffer && rtWrapper.resolveMSAADepth ? gl.DEPTH_BUFFER_BIT : 0;
        bufferBits |= rtWrapper._generateStencilBuffer && rtWrapper.resolveMSAAStencil ? gl.STENCIL_BUFFER_BIT : 0;
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, rtWrapper._MSAAFramebuffer);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, rtWrapper._framebuffer);
        gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, bufferBits, gl.NEAREST);
    }
    /**
     * Force a webGL flush (ie. a flush of all waiting webGL commands)
     */
    flushFramebuffer() {
        this._gl.flush();
    }
    /**
     * Unbind the current render target and bind the default framebuffer
     */
    restoreDefaultFramebuffer() {
        if (this._currentRenderTarget) {
            this.unBindFramebuffer(this._currentRenderTarget);
        }
        else {
            this._bindUnboundFramebuffer(null);
        }
        if (this._cachedViewport) {
            this.setViewport(this._cachedViewport);
        }
        this.wipeCaches();
    }
    // VBOs
    /** @internal */
    _resetVertexBufferBinding() {
        this.bindArrayBuffer(null);
        this._cachedVertexBuffers = null;
    }
    /**
     * Creates a vertex buffer
     * @param data the data or size for the vertex buffer
     * @param _updatable whether the buffer should be created as updatable
     * @param _label defines the label of the buffer (for debug purpose)
     * @returns the new WebGL static buffer
     */
    createVertexBuffer(data, _updatable, _label) {
        return this._createVertexBuffer(data, this._gl.STATIC_DRAW);
    }
    _createVertexBuffer(data, usage) {
        const vbo = this._gl.createBuffer();
        if (!vbo) {
            throw new Error("Unable to create vertex buffer");
        }
        const dataBuffer = new _Meshes_WebGL_webGLDataBuffer_js__WEBPACK_IMPORTED_MODULE_6__.WebGLDataBuffer(vbo);
        this.bindArrayBuffer(dataBuffer);
        if (typeof data !== "number") {
            if (data instanceof Array) {
                this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(data), usage);
                dataBuffer.capacity = data.length * 4;
            }
            else {
                this._gl.bufferData(this._gl.ARRAY_BUFFER, data, usage);
                dataBuffer.capacity = data.byteLength;
            }
        }
        else {
            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Uint8Array(data), usage);
            dataBuffer.capacity = data;
        }
        this._resetVertexBufferBinding();
        dataBuffer.references = 1;
        return dataBuffer;
    }
    /**
     * Creates a dynamic vertex buffer
     * @param data the data for the dynamic vertex buffer
     * @param _label defines the label of the buffer (for debug purpose)
     * @returns the new WebGL dynamic buffer
     */
    createDynamicVertexBuffer(data, _label) {
        return this._createVertexBuffer(data, this._gl.DYNAMIC_DRAW);
    }
    _resetIndexBufferBinding() {
        this.bindIndexBuffer(null);
        this._cachedIndexBuffer = null;
    }
    /**
     * Creates a new index buffer
     * @param indices defines the content of the index buffer
     * @param updatable defines if the index buffer must be updatable
     * @param _label defines the label of the buffer (for debug purpose)
     * @returns a new webGL buffer
     */
    createIndexBuffer(indices, updatable, _label) {
        const vbo = this._gl.createBuffer();
        const dataBuffer = new _Meshes_WebGL_webGLDataBuffer_js__WEBPACK_IMPORTED_MODULE_6__.WebGLDataBuffer(vbo);
        if (!vbo) {
            throw new Error("Unable to create index buffer");
        }
        this.bindIndexBuffer(dataBuffer);
        const data = this._normalizeIndexData(indices);
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, updatable ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW);
        this._resetIndexBufferBinding();
        dataBuffer.references = 1;
        dataBuffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
        return dataBuffer;
    }
    _normalizeIndexData(indices) {
        const bytesPerElement = indices.BYTES_PER_ELEMENT;
        if (bytesPerElement === 2) {
            return indices;
        }
        // Check 32 bit support
        if (this._caps.uintIndices) {
            if (indices instanceof Uint32Array) {
                return indices;
            }
            else {
                // number[] or Int32Array, check if 32 bit is necessary
                for (let index = 0; index < indices.length; index++) {
                    if (indices[index] >= 65535) {
                        return new Uint32Array(indices);
                    }
                }
                return new Uint16Array(indices);
            }
        }
        // No 32 bit support, force conversion to 16 bit (values greater 16 bit are lost)
        return new Uint16Array(indices);
    }
    /**
     * Bind a webGL buffer to the webGL context
     * @param buffer defines the buffer to bind
     */
    bindArrayBuffer(buffer) {
        if (!this._vaoRecordInProgress) {
            this._unbindVertexArrayObject();
        }
        this._bindBuffer(buffer, this._gl.ARRAY_BUFFER);
    }
    /**
     * Bind a specific block at a given index in a specific shader program
     * @param pipelineContext defines the pipeline context to use
     * @param blockName defines the block name
     * @param index defines the index where to bind the block
     */
    bindUniformBlock(pipelineContext, blockName, index) {
        const program = pipelineContext.program;
        const uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
        this._gl.uniformBlockBinding(program, uniformLocation, index);
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    bindIndexBuffer(buffer) {
        if (!this._vaoRecordInProgress) {
            this._unbindVertexArrayObject();
        }
        this._bindBuffer(buffer, this._gl.ELEMENT_ARRAY_BUFFER);
    }
    _bindBuffer(buffer, target) {
        if (this._vaoRecordInProgress || this._currentBoundBuffer[target] !== buffer) {
            this._gl.bindBuffer(target, buffer ? buffer.underlyingResource : null);
            this._currentBoundBuffer[target] = buffer;
        }
    }
    /**
     * update the bound buffer with the given data
     * @param data defines the data to update
     */
    updateArrayBuffer(data) {
        this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
    }
    _vertexAttribPointer(buffer, indx, size, type, normalized, stride, offset) {
        const pointer = this._currentBufferPointers[indx];
        if (!pointer) {
            return;
        }
        let changed = false;
        if (!pointer.active) {
            changed = true;
            pointer.active = true;
            pointer.index = indx;
            pointer.size = size;
            pointer.type = type;
            pointer.normalized = normalized;
            pointer.stride = stride;
            pointer.offset = offset;
            pointer.buffer = buffer;
        }
        else {
            if (pointer.buffer !== buffer) {
                pointer.buffer = buffer;
                changed = true;
            }
            if (pointer.size !== size) {
                pointer.size = size;
                changed = true;
            }
            if (pointer.type !== type) {
                pointer.type = type;
                changed = true;
            }
            if (pointer.normalized !== normalized) {
                pointer.normalized = normalized;
                changed = true;
            }
            if (pointer.stride !== stride) {
                pointer.stride = stride;
                changed = true;
            }
            if (pointer.offset !== offset) {
                pointer.offset = offset;
                changed = true;
            }
        }
        if (changed || this._vaoRecordInProgress) {
            this.bindArrayBuffer(buffer);
            if (type === this._gl.UNSIGNED_INT || type === this._gl.INT) {
                this._gl.vertexAttribIPointer(indx, size, type, stride, offset);
            }
            else {
                this._gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);
            }
        }
    }
    /**
     * @internal
     */
    _bindIndexBufferWithCache(indexBuffer) {
        if (indexBuffer == null) {
            return;
        }
        if (this._cachedIndexBuffer !== indexBuffer) {
            this._cachedIndexBuffer = indexBuffer;
            this.bindIndexBuffer(indexBuffer);
            this._uintIndicesCurrentlySet = indexBuffer.is32Bits;
        }
    }
    _bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers) {
        const attributes = effect.getAttributesNames();
        if (!this._vaoRecordInProgress) {
            this._unbindVertexArrayObject();
        }
        this.unbindAllAttributes();
        for (let index = 0; index < attributes.length; index++) {
            const order = effect.getAttributeLocation(index);
            if (order >= 0) {
                const ai = attributes[index];
                let vertexBuffer = null;
                if (overrideVertexBuffers) {
                    vertexBuffer = overrideVertexBuffers[ai];
                }
                if (!vertexBuffer) {
                    vertexBuffer = vertexBuffers[ai];
                }
                if (!vertexBuffer) {
                    continue;
                }
                this._gl.enableVertexAttribArray(order);
                if (!this._vaoRecordInProgress) {
                    this._vertexAttribArraysEnabled[order] = true;
                }
                const buffer = vertexBuffer.getBuffer();
                if (buffer) {
                    this._vertexAttribPointer(buffer, order, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.normalized, vertexBuffer.byteStride, vertexBuffer.byteOffset);
                    if (vertexBuffer.getIsInstanced()) {
                        this._gl.vertexAttribDivisor(order, vertexBuffer.getInstanceDivisor());
                        if (!this._vaoRecordInProgress) {
                            this._currentInstanceLocations.push(order);
                            this._currentInstanceBuffers.push(buffer);
                        }
                    }
                }
            }
        }
    }
    /**
     * Records a vertex array object
     * @see https://doc.babylonjs.com/setup/support/webGL2#vertex-array-objects
     * @param vertexBuffers defines the list of vertex buffers to store
     * @param indexBuffer defines the index buffer to store
     * @param effect defines the effect to store
     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers
     * @returns the new vertex array object
     */
    recordVertexArrayObject(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
        const vao = this._gl.createVertexArray();
        if (!vao) {
            throw new Error("Unable to create VAO");
        }
        this._vaoRecordInProgress = true;
        this._gl.bindVertexArray(vao);
        this._mustWipeVertexAttributes = true;
        this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
        this.bindIndexBuffer(indexBuffer);
        this._vaoRecordInProgress = false;
        this._gl.bindVertexArray(null);
        return vao;
    }
    /**
     * Bind a specific vertex array object
     * @see https://doc.babylonjs.com/setup/support/webGL2#vertex-array-objects
     * @param vertexArrayObject defines the vertex array object to bind
     * @param indexBuffer defines the index buffer to bind
     */
    bindVertexArrayObject(vertexArrayObject, indexBuffer) {
        if (this._cachedVertexArrayObject !== vertexArrayObject) {
            this._cachedVertexArrayObject = vertexArrayObject;
            this._gl.bindVertexArray(vertexArrayObject);
            this._cachedVertexBuffers = null;
            this._cachedIndexBuffer = null;
            this._uintIndicesCurrentlySet = indexBuffer != null && indexBuffer.is32Bits;
            this._mustWipeVertexAttributes = true;
        }
    }
    /**
     * Bind webGl buffers directly to the webGL context
     * @param vertexBuffer defines the vertex buffer to bind
     * @param indexBuffer defines the index buffer to bind
     * @param vertexDeclaration defines the vertex declaration to use with the vertex buffer
     * @param vertexStrideSize defines the vertex stride of the vertex buffer
     * @param effect defines the effect associated with the vertex buffer
     */
    bindBuffersDirectly(vertexBuffer, indexBuffer, vertexDeclaration, vertexStrideSize, effect) {
        if (this._cachedVertexBuffers !== vertexBuffer || this._cachedEffectForVertexBuffers !== effect) {
            this._cachedVertexBuffers = vertexBuffer;
            this._cachedEffectForVertexBuffers = effect;
            const attributesCount = effect.getAttributesCount();
            this._unbindVertexArrayObject();
            this.unbindAllAttributes();
            let offset = 0;
            for (let index = 0; index < attributesCount; index++) {
                if (index < vertexDeclaration.length) {
                    const order = effect.getAttributeLocation(index);
                    if (order >= 0) {
                        this._gl.enableVertexAttribArray(order);
                        this._vertexAttribArraysEnabled[order] = true;
                        this._vertexAttribPointer(vertexBuffer, order, vertexDeclaration[index], this._gl.FLOAT, false, vertexStrideSize, offset);
                    }
                    offset += vertexDeclaration[index] * 4;
                }
            }
        }
        this._bindIndexBufferWithCache(indexBuffer);
    }
    _unbindVertexArrayObject() {
        if (!this._cachedVertexArrayObject) {
            return;
        }
        this._cachedVertexArrayObject = null;
        this._gl.bindVertexArray(null);
    }
    /**
     * Bind a list of vertex buffers to the webGL context
     * @param vertexBuffers defines the list of vertex buffers to bind
     * @param indexBuffer defines the index buffer to bind
     * @param effect defines the effect associated with the vertex buffers
     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers
     */
    bindBuffers(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
        if (this._cachedVertexBuffers !== vertexBuffers || this._cachedEffectForVertexBuffers !== effect) {
            this._cachedVertexBuffers = vertexBuffers;
            this._cachedEffectForVertexBuffers = effect;
            this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
        }
        this._bindIndexBufferWithCache(indexBuffer);
    }
    /**
     * Unbind all instance attributes
     */
    unbindInstanceAttributes() {
        let boundBuffer;
        for (let i = 0, ul = this._currentInstanceLocations.length; i < ul; i++) {
            const instancesBuffer = this._currentInstanceBuffers[i];
            if (boundBuffer != instancesBuffer && instancesBuffer.references) {
                boundBuffer = instancesBuffer;
                this.bindArrayBuffer(instancesBuffer);
            }
            const offsetLocation = this._currentInstanceLocations[i];
            this._gl.vertexAttribDivisor(offsetLocation, 0);
        }
        this._currentInstanceBuffers.length = 0;
        this._currentInstanceLocations.length = 0;
    }
    /**
     * Release and free the memory of a vertex array object
     * @param vao defines the vertex array object to delete
     */
    releaseVertexArrayObject(vao) {
        this._gl.deleteVertexArray(vao);
    }
    /**
     * @internal
     */
    _releaseBuffer(buffer) {
        buffer.references--;
        if (buffer.references === 0) {
            this._deleteBuffer(buffer);
            return true;
        }
        return false;
    }
    _deleteBuffer(buffer) {
        this._gl.deleteBuffer(buffer.underlyingResource);
    }
    /**
     * Update the content of a webGL buffer used with instantiation and bind it to the webGL context
     * @param instancesBuffer defines the webGL buffer to update and bind
     * @param data defines the data to store in the buffer
     * @param offsetLocations defines the offsets or attributes information used to determine where data must be stored in the buffer
     */
    updateAndBindInstancesBuffer(instancesBuffer, data, offsetLocations) {
        this.bindArrayBuffer(instancesBuffer);
        if (data) {
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
        }
        if (offsetLocations[0].index !== undefined) {
            this.bindInstancesBuffer(instancesBuffer, offsetLocations, true);
        }
        else {
            for (let index = 0; index < 4; index++) {
                const offsetLocation = offsetLocations[index];
                if (!this._vertexAttribArraysEnabled[offsetLocation]) {
                    this._gl.enableVertexAttribArray(offsetLocation);
                    this._vertexAttribArraysEnabled[offsetLocation] = true;
                }
                this._vertexAttribPointer(instancesBuffer, offsetLocation, 4, this._gl.FLOAT, false, 64, index * 16);
                this._gl.vertexAttribDivisor(offsetLocation, 1);
                this._currentInstanceLocations.push(offsetLocation);
                this._currentInstanceBuffers.push(instancesBuffer);
            }
        }
    }
    /**
     * Bind the content of a webGL buffer used with instantiation
     * @param instancesBuffer defines the webGL buffer to bind
     * @param attributesInfo defines the offsets or attributes information used to determine where data must be stored in the buffer
     * @param computeStride defines Whether to compute the strides from the info or use the default 0
     */
    bindInstancesBuffer(instancesBuffer, attributesInfo, computeStride = true) {
        this.bindArrayBuffer(instancesBuffer);
        let stride = 0;
        if (computeStride) {
            for (let i = 0; i < attributesInfo.length; i++) {
                const ai = attributesInfo[i];
                stride += ai.attributeSize * 4;
            }
        }
        for (let i = 0; i < attributesInfo.length; i++) {
            const ai = attributesInfo[i];
            if (ai.index === undefined) {
                ai.index = this._currentEffect.getAttributeLocationByName(ai.attributeName);
            }
            if (ai.index < 0) {
                continue;
            }
            if (!this._vertexAttribArraysEnabled[ai.index]) {
                this._gl.enableVertexAttribArray(ai.index);
                this._vertexAttribArraysEnabled[ai.index] = true;
            }
            this._vertexAttribPointer(instancesBuffer, ai.index, ai.attributeSize, ai.attributeType || this._gl.FLOAT, ai.normalized || false, stride, ai.offset);
            this._gl.vertexAttribDivisor(ai.index, ai.divisor === undefined ? 1 : ai.divisor);
            this._currentInstanceLocations.push(ai.index);
            this._currentInstanceBuffers.push(instancesBuffer);
        }
    }
    /**
     * Disable the instance attribute corresponding to the name in parameter
     * @param name defines the name of the attribute to disable
     */
    disableInstanceAttributeByName(name) {
        if (!this._currentEffect) {
            return;
        }
        const attributeLocation = this._currentEffect.getAttributeLocationByName(name);
        this.disableInstanceAttribute(attributeLocation);
    }
    /**
     * Disable the instance attribute corresponding to the location in parameter
     * @param attributeLocation defines the attribute location of the attribute to disable
     */
    disableInstanceAttribute(attributeLocation) {
        let shouldClean = false;
        let index;
        while ((index = this._currentInstanceLocations.indexOf(attributeLocation)) !== -1) {
            this._currentInstanceLocations.splice(index, 1);
            this._currentInstanceBuffers.splice(index, 1);
            shouldClean = true;
            index = this._currentInstanceLocations.indexOf(attributeLocation);
        }
        if (shouldClean) {
            this._gl.vertexAttribDivisor(attributeLocation, 0);
            this.disableAttributeByIndex(attributeLocation);
        }
    }
    /**
     * Disable the attribute corresponding to the location in parameter
     * @param attributeLocation defines the attribute location of the attribute to disable
     */
    disableAttributeByIndex(attributeLocation) {
        this._gl.disableVertexAttribArray(attributeLocation);
        this._vertexAttribArraysEnabled[attributeLocation] = false;
        this._currentBufferPointers[attributeLocation].active = false;
    }
    /**
     * Send a draw order
     * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
     * @param indexStart defines the starting index
     * @param indexCount defines the number of index to draw
     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
     */
    draw(useTriangles, indexStart, indexCount, instancesCount) {
        this.drawElementsType(useTriangles ? 0 : 1, indexStart, indexCount, instancesCount);
    }
    /**
     * Draw a list of points
     * @param verticesStart defines the index of first vertex to draw
     * @param verticesCount defines the count of vertices to draw
     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
     */
    drawPointClouds(verticesStart, verticesCount, instancesCount) {
        this.drawArraysType(2, verticesStart, verticesCount, instancesCount);
    }
    /**
     * Draw a list of unindexed primitives
     * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
     * @param verticesStart defines the index of first vertex to draw
     * @param verticesCount defines the count of vertices to draw
     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
     */
    drawUnIndexed(useTriangles, verticesStart, verticesCount, instancesCount) {
        this.drawArraysType(useTriangles ? 0 : 1, verticesStart, verticesCount, instancesCount);
    }
    /**
     * Draw a list of indexed primitives
     * @param fillMode defines the primitive to use
     * @param indexStart defines the starting index
     * @param indexCount defines the number of index to draw
     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
     */
    drawElementsType(fillMode, indexStart, indexCount, instancesCount) {
        // Apply states
        this.applyStates();
        this._reportDrawCall();
        // Render
        const drawMode = this._drawMode(fillMode);
        const indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;
        const mult = this._uintIndicesCurrentlySet ? 4 : 2;
        if (instancesCount) {
            this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);
        }
        else {
            this._gl.drawElements(drawMode, indexCount, indexFormat, indexStart * mult);
        }
    }
    /**
     * Draw a list of unindexed primitives
     * @param fillMode defines the primitive to use
     * @param verticesStart defines the index of first vertex to draw
     * @param verticesCount defines the count of vertices to draw
     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
     */
    drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {
        // Apply states
        this.applyStates();
        this._reportDrawCall();
        const drawMode = this._drawMode(fillMode);
        if (instancesCount) {
            this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);
        }
        else {
            this._gl.drawArrays(drawMode, verticesStart, verticesCount);
        }
    }
    _drawMode(fillMode) {
        switch (fillMode) {
            // Triangle views
            case 0:
                return this._gl.TRIANGLES;
            case 2:
                return this._gl.POINTS;
            case 1:
                return this._gl.LINES;
            // Draw modes
            case 3:
                return this._gl.POINTS;
            case 4:
                return this._gl.LINES;
            case 5:
                return this._gl.LINE_LOOP;
            case 6:
                return this._gl.LINE_STRIP;
            case 7:
                return this._gl.TRIANGLE_STRIP;
            case 8:
                return this._gl.TRIANGLE_FAN;
            default:
                return this._gl.TRIANGLES;
        }
    }
    // Shaders
    /**
     * @internal
     */
    _releaseEffect(effect) {
        if (this._compiledEffects[effect._key]) {
            delete this._compiledEffects[effect._key];
        }
        const pipelineContext = effect.getPipelineContext();
        if (pipelineContext) {
            this._deletePipelineContext(pipelineContext);
        }
    }
    /**
     * @internal
     */
    _deletePipelineContext(pipelineContext) {
        const webGLPipelineContext = pipelineContext;
        if (webGLPipelineContext && webGLPipelineContext.program) {
            webGLPipelineContext.program.__SPECTOR_rebuildProgram = null;
            (0,_Materials_effect_functions_js__WEBPACK_IMPORTED_MODULE_13__.resetCachedPipeline)(webGLPipelineContext);
            if (this._gl) {
                if (this._currentProgram === webGLPipelineContext.program) {
                    this._setProgram(null);
                }
                this._gl.deleteProgram(webGLPipelineContext.program);
            }
        }
    }
    /**
     * @internal
     */
    _getGlobalDefines(defines) {
        return (0,_abstractEngine_functions_js__WEBPACK_IMPORTED_MODULE_12__._GetGlobalDefines)(defines, this.isNDCHalfZRange, this.useReverseDepthBuffer, this.useExactSrgbConversions);
    }
    /**
     * Create a new effect (used to store vertex/fragment shaders)
     * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)
     * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object
     * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use
     * @param samplers defines an array of string used to represent textures
     * @param defines defines the string containing the defines to use to compile the shaders
     * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails
     * @param onCompiled defines a function to call when the effect creation is successful
     * @param onError defines a function to call when the effect creation has failed
     * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)
     * @param shaderLanguage the language the shader is written in (default: GLSL)
     * @param extraInitializationsAsync additional async code to run before preparing the effect
     * @returns the new Effect
     */
    createEffect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage = 0 /* ShaderLanguage.GLSL */, extraInitializationsAsync) {
        const vertex = typeof baseName === "string" ? baseName : baseName.vertexToken || baseName.vertexSource || baseName.vertexElement || baseName.vertex;
        const fragment = typeof baseName === "string" ? baseName : baseName.fragmentToken || baseName.fragmentSource || baseName.fragmentElement || baseName.fragment;
        const globalDefines = this._getGlobalDefines();
        const isOptions = attributesNamesOrOptions.attributes !== undefined;
        let fullDefines = defines ?? attributesNamesOrOptions.defines ?? "";
        if (globalDefines) {
            fullDefines += globalDefines;
        }
        const name = vertex + "+" + fragment + "@" + fullDefines;
        if (this._compiledEffects[name]) {
            const compiledEffect = this._compiledEffects[name];
            if (onCompiled && compiledEffect.isReady()) {
                onCompiled(compiledEffect);
            }
            compiledEffect._refCount++;
            return compiledEffect;
        }
        if (this._gl) {
            (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.getStateObject)(this._gl);
        }
        const effect = new _Materials_effect_js__WEBPACK_IMPORTED_MODULE_11__.Effect(baseName, attributesNamesOrOptions, isOptions ? this : uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name, attributesNamesOrOptions.shaderLanguage ?? shaderLanguage, attributesNamesOrOptions.extraInitializationsAsync ?? extraInitializationsAsync);
        this._compiledEffects[name] = effect;
        return effect;
    }
    /**
     * @internal
     */
    _getShaderSource(shader) {
        return this._gl.getShaderSource(shader);
    }
    /**
     * Directly creates a webGL program
     * @param pipelineContext  defines the pipeline context to attach to
     * @param vertexCode defines the vertex shader code to use
     * @param fragmentCode defines the fragment shader code to use
     * @param context defines the webGL context to use (if not set, the current one will be used)
     * @param transformFeedbackVaryings defines the list of transform feedback varyings to use
     * @returns the new webGL program
     */
    createRawShaderProgram(pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings = null) {
        const stateObject = (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.getStateObject)(this._gl);
        stateObject._contextWasLost = this._contextWasLost;
        stateObject.validateShaderPrograms = this.validateShaderPrograms;
        return (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.createRawShaderProgram)(pipelineContext, vertexCode, fragmentCode, context || this._gl, transformFeedbackVaryings);
    }
    /**
     * Creates a webGL program
     * @param pipelineContext  defines the pipeline context to attach to
     * @param vertexCode  defines the vertex shader code to use
     * @param fragmentCode defines the fragment shader code to use
     * @param defines defines the string containing the defines to use to compile the shaders
     * @param context defines the webGL context to use (if not set, the current one will be used)
     * @param transformFeedbackVaryings defines the list of transform feedback varyings to use
     * @returns the new webGL program
     */
    createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings = null) {
        const stateObject = (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.getStateObject)(this._gl);
        // assure the state object is correct
        stateObject._contextWasLost = this._contextWasLost;
        stateObject.validateShaderPrograms = this.validateShaderPrograms;
        return (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.createShaderProgram)(pipelineContext, vertexCode, fragmentCode, defines, context || this._gl, transformFeedbackVaryings);
    }
    /**
     * Inline functions in shader code that are marked to be inlined
     * @param code code to inline
     * @returns inlined code
     */
    inlineShaderCode(code) {
        // no inlining needed in the WebGL engine
        return code;
    }
    /**
     * Creates a new pipeline context
     * @param shaderProcessingContext defines the shader processing context used during the processing if available
     * @returns the new pipeline
     */
    createPipelineContext(shaderProcessingContext) {
        if (this._gl) {
            const stateObject = (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.getStateObject)(this._gl);
            stateObject.parallelShaderCompile = this._caps.parallelShaderCompile;
        }
        const context = (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.createPipelineContext)(this._gl, shaderProcessingContext);
        context.engine = this;
        return context;
    }
    /**
     * Creates a new material context
     * @returns the new context
     */
    createMaterialContext() {
        return undefined;
    }
    /**
     * Creates a new draw context
     * @returns the new context
     */
    createDrawContext() {
        return undefined;
    }
    _finalizePipelineContext(pipelineContext) {
        return (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__._finalizePipelineContext)(pipelineContext, this._gl, this.validateShaderPrograms);
    }
    /**
     * @internal
     */
    // named async but not actually an async function
    // eslint-disable-next-line no-restricted-syntax
    _preparePipelineContextAsync(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines, transformFeedbackVaryings, key, onReady) {
        const stateObject = (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.getStateObject)(this._gl);
        stateObject._contextWasLost = this._contextWasLost;
        stateObject.validateShaderPrograms = this.validateShaderPrograms;
        stateObject._createShaderProgramInjection = this._createShaderProgram.bind(this);
        stateObject.createRawShaderProgramInjection = this.createRawShaderProgram.bind(this);
        stateObject.createShaderProgramInjection = this.createShaderProgram.bind(this);
        stateObject.loadFileInjection = this._loadFile.bind(this);
        return (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__._preparePipelineContext)(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines, transformFeedbackVaryings, key, onReady);
    }
    _createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings = null) {
        return (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__._createShaderProgram)(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
    }
    /**
     * @internal
     */
    _isRenderingStateCompiled(pipelineContext) {
        if (this._isDisposed) {
            return false;
        }
        return (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__._isRenderingStateCompiled)(pipelineContext, this._gl, this.validateShaderPrograms);
    }
    /**
     * @internal
     */
    _executeWhenRenderingStateIsCompiled(pipelineContext, action) {
        (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__._executeWhenRenderingStateIsCompiled)(pipelineContext, action);
    }
    /**
     * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names
     * @param pipelineContext defines the pipeline context to use
     * @param uniformsNames defines the list of uniform names
     * @returns an array of webGL uniform locations
     */
    getUniforms(pipelineContext, uniformsNames) {
        const results = new Array();
        const webGLPipelineContext = pipelineContext;
        for (let index = 0; index < uniformsNames.length; index++) {
            results.push(this._gl.getUniformLocation(webGLPipelineContext.program, uniformsNames[index]));
        }
        return results;
    }
    /**
     * Gets the list of active attributes for a given webGL program
     * @param pipelineContext defines the pipeline context to use
     * @param attributesNames defines the list of attribute names to get
     * @returns an array of indices indicating the offset of each attribute
     */
    getAttributes(pipelineContext, attributesNames) {
        const results = [];
        const webGLPipelineContext = pipelineContext;
        for (let index = 0; index < attributesNames.length; index++) {
            try {
                results.push(this._gl.getAttribLocation(webGLPipelineContext.program, attributesNames[index]));
            }
            catch (e) {
                results.push(-1);
            }
        }
        return results;
    }
    /**
     * Activates an effect, making it the current one (ie. the one used for rendering)
     * @param effect defines the effect to activate
     */
    enableEffect(effect) {
        effect = effect !== null && (0,_Materials_drawWrapper_functions_js__WEBPACK_IMPORTED_MODULE_1__.IsWrapper)(effect) ? effect.effect : effect; // get only the effect, we don't need a Wrapper in the WebGL engine
        if (!effect || effect === this._currentEffect) {
            return;
        }
        this._stencilStateComposer.stencilMaterial = undefined;
        // Use program
        this.bindSamplers(effect);
        this._currentEffect = effect;
        if (effect.onBind) {
            effect.onBind(effect);
        }
        if (effect._onBindObservable) {
            effect._onBindObservable.notifyObservers(effect);
        }
    }
    /**
     * Set the value of an uniform to a number (int)
     * @param uniform defines the webGL uniform location where to store the value
     * @param value defines the int number to store
     * @returns true if the value was set
     */
    setInt(uniform, value) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform1i(uniform, value);
        return true;
    }
    /**
     * Set the value of an uniform to a int2
     * @param uniform defines the webGL uniform location where to store the value
     * @param x defines the 1st component of the value
     * @param y defines the 2nd component of the value
     * @returns true if the value was set
     */
    setInt2(uniform, x, y) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform2i(uniform, x, y);
        return true;
    }
    /**
     * Set the value of an uniform to a int3
     * @param uniform defines the webGL uniform location where to store the value
     * @param x defines the 1st component of the value
     * @param y defines the 2nd component of the value
     * @param z defines the 3rd component of the value
     * @returns true if the value was set
     */
    setInt3(uniform, x, y, z) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform3i(uniform, x, y, z);
        return true;
    }
    /**
     * Set the value of an uniform to a int4
     * @param uniform defines the webGL uniform location where to store the value
     * @param x defines the 1st component of the value
     * @param y defines the 2nd component of the value
     * @param z defines the 3rd component of the value
     * @param w defines the 4th component of the value
     * @returns true if the value was set
     */
    setInt4(uniform, x, y, z, w) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform4i(uniform, x, y, z, w);
        return true;
    }
    /**
     * Set the value of an uniform to an array of int32
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of int32 to store
     * @returns true if the value was set
     */
    setIntArray(uniform, array) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform1iv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to an array of int32 (stored as vec2)
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of int32 to store
     * @returns true if the value was set
     */
    setIntArray2(uniform, array) {
        if (!uniform || array.length % 2 !== 0) {
            return false;
        }
        this._gl.uniform2iv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to an array of int32 (stored as vec3)
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of int32 to store
     * @returns true if the value was set
     */
    setIntArray3(uniform, array) {
        if (!uniform || array.length % 3 !== 0) {
            return false;
        }
        this._gl.uniform3iv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to an array of int32 (stored as vec4)
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of int32 to store
     * @returns true if the value was set
     */
    setIntArray4(uniform, array) {
        if (!uniform || array.length % 4 !== 0) {
            return false;
        }
        this._gl.uniform4iv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to a number (unsigned int)
     * @param uniform defines the webGL uniform location where to store the value
     * @param value defines the unsigned int number to store
     * @returns true if the value was set
     */
    setUInt(uniform, value) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform1ui(uniform, value);
        return true;
    }
    /**
     * Set the value of an uniform to a unsigned int2
     * @param uniform defines the webGL uniform location where to store the value
     * @param x defines the 1st component of the value
     * @param y defines the 2nd component of the value
     * @returns true if the value was set
     */
    setUInt2(uniform, x, y) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform2ui(uniform, x, y);
        return true;
    }
    /**
     * Set the value of an uniform to a unsigned int3
     * @param uniform defines the webGL uniform location where to store the value
     * @param x defines the 1st component of the value
     * @param y defines the 2nd component of the value
     * @param z defines the 3rd component of the value
     * @returns true if the value was set
     */
    setUInt3(uniform, x, y, z) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform3ui(uniform, x, y, z);
        return true;
    }
    /**
     * Set the value of an uniform to a unsigned int4
     * @param uniform defines the webGL uniform location where to store the value
     * @param x defines the 1st component of the value
     * @param y defines the 2nd component of the value
     * @param z defines the 3rd component of the value
     * @param w defines the 4th component of the value
     * @returns true if the value was set
     */
    setUInt4(uniform, x, y, z, w) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform4ui(uniform, x, y, z, w);
        return true;
    }
    /**
     * Set the value of an uniform to an array of unsigned int32
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of unsigned int32 to store
     * @returns true if the value was set
     */
    setUIntArray(uniform, array) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform1uiv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to an array of unsigned int32 (stored as vec2)
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of unsigned int32 to store
     * @returns true if the value was set
     */
    setUIntArray2(uniform, array) {
        if (!uniform || array.length % 2 !== 0) {
            return false;
        }
        this._gl.uniform2uiv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to an array of unsigned int32 (stored as vec3)
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of unsigned int32 to store
     * @returns true if the value was set
     */
    setUIntArray3(uniform, array) {
        if (!uniform || array.length % 3 !== 0) {
            return false;
        }
        this._gl.uniform3uiv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to an array of unsigned int32 (stored as vec4)
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of unsigned int32 to store
     * @returns true if the value was set
     */
    setUIntArray4(uniform, array) {
        if (!uniform || array.length % 4 !== 0) {
            return false;
        }
        this._gl.uniform4uiv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to an array of number
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of number to store
     * @returns true if the value was set
     */
    setArray(uniform, array) {
        if (!uniform) {
            return false;
        }
        if (array.length < 1) {
            return false;
        }
        this._gl.uniform1fv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to an array of number (stored as vec2)
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of number to store
     * @returns true if the value was set
     */
    setArray2(uniform, array) {
        if (!uniform || array.length % 2 !== 0) {
            return false;
        }
        this._gl.uniform2fv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to an array of number (stored as vec3)
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of number to store
     * @returns true if the value was set
     */
    setArray3(uniform, array) {
        if (!uniform || array.length % 3 !== 0) {
            return false;
        }
        this._gl.uniform3fv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to an array of number (stored as vec4)
     * @param uniform defines the webGL uniform location where to store the value
     * @param array defines the array of number to store
     * @returns true if the value was set
     */
    setArray4(uniform, array) {
        if (!uniform || array.length % 4 !== 0) {
            return false;
        }
        this._gl.uniform4fv(uniform, array);
        return true;
    }
    /**
     * Set the value of an uniform to an array of float32 (stored as matrices)
     * @param uniform defines the webGL uniform location where to store the value
     * @param matrices defines the array of float32 to store
     * @returns true if the value was set
     */
    setMatrices(uniform, matrices) {
        if (!uniform) {
            return false;
        }
        this._gl.uniformMatrix4fv(uniform, false, matrices);
        return true;
    }
    /**
     * Set the value of an uniform to a matrix (3x3)
     * @param uniform defines the webGL uniform location where to store the value
     * @param matrix defines the Float32Array representing the 3x3 matrix to store
     * @returns true if the value was set
     */
    setMatrix3x3(uniform, matrix) {
        if (!uniform) {
            return false;
        }
        this._gl.uniformMatrix3fv(uniform, false, matrix);
        return true;
    }
    /**
     * Set the value of an uniform to a matrix (2x2)
     * @param uniform defines the webGL uniform location where to store the value
     * @param matrix defines the Float32Array representing the 2x2 matrix to store
     * @returns true if the value was set
     */
    setMatrix2x2(uniform, matrix) {
        if (!uniform) {
            return false;
        }
        this._gl.uniformMatrix2fv(uniform, false, matrix);
        return true;
    }
    /**
     * Set the value of an uniform to a number (float)
     * @param uniform defines the webGL uniform location where to store the value
     * @param value defines the float number to store
     * @returns true if the value was transferred
     */
    setFloat(uniform, value) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform1f(uniform, value);
        return true;
    }
    /**
     * Set the value of an uniform to a vec2
     * @param uniform defines the webGL uniform location where to store the value
     * @param x defines the 1st component of the value
     * @param y defines the 2nd component of the value
     * @returns true if the value was set
     */
    setFloat2(uniform, x, y) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform2f(uniform, x, y);
        return true;
    }
    /**
     * Set the value of an uniform to a vec3
     * @param uniform defines the webGL uniform location where to store the value
     * @param x defines the 1st component of the value
     * @param y defines the 2nd component of the value
     * @param z defines the 3rd component of the value
     * @returns true if the value was set
     */
    setFloat3(uniform, x, y, z) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform3f(uniform, x, y, z);
        return true;
    }
    /**
     * Set the value of an uniform to a vec4
     * @param uniform defines the webGL uniform location where to store the value
     * @param x defines the 1st component of the value
     * @param y defines the 2nd component of the value
     * @param z defines the 3rd component of the value
     * @param w defines the 4th component of the value
     * @returns true if the value was set
     */
    setFloat4(uniform, x, y, z, w) {
        if (!uniform) {
            return false;
        }
        this._gl.uniform4f(uniform, x, y, z, w);
        return true;
    }
    // States
    /**
     * Apply all cached states (depth, culling, stencil and alpha)
     */
    applyStates() {
        this._depthCullingState.apply(this._gl);
        this._stencilStateComposer.apply(this._gl);
        this._alphaState.apply(this._gl);
        if (this._colorWriteChanged) {
            this._colorWriteChanged = false;
            const enable = this._colorWrite;
            this._gl.colorMask(enable, enable, enable, enable);
        }
    }
    // Textures
    /**
     * Force the entire cache to be cleared
     * You should not have to use this function unless your engine needs to share the webGL context with another engine
     * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)
     */
    wipeCaches(bruteForce) {
        if (this.preventCacheWipeBetweenFrames && !bruteForce) {
            return;
        }
        this._currentEffect = null;
        this._viewportCached.x = 0;
        this._viewportCached.y = 0;
        this._viewportCached.z = 0;
        this._viewportCached.w = 0;
        // Done before in case we clean the attributes
        this._unbindVertexArrayObject();
        if (bruteForce) {
            this._currentProgram = null;
            this.resetTextureCache();
            this._stencilStateComposer.reset();
            this._depthCullingState.reset();
            this._depthCullingState.depthFunc = this._gl.LEQUAL;
            this._alphaState.reset();
            this._alphaMode = 1;
            this._alphaEquation = 0;
            this._colorWrite = true;
            this._colorWriteChanged = true;
            this._unpackFlipYCached = null;
            this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
            this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
            this._mustWipeVertexAttributes = true;
            this.unbindAllAttributes();
        }
        this._resetVertexBufferBinding();
        this._cachedIndexBuffer = null;
        this._cachedEffectForVertexBuffers = null;
        this.bindIndexBuffer(null);
    }
    /**
     * @internal
     */
    _getSamplingParameters(samplingMode, generateMipMaps) {
        const gl = this._gl;
        let magFilter = gl.NEAREST;
        let minFilter = gl.NEAREST;
        let hasMipMaps = false;
        switch (samplingMode) {
            case 11:
                magFilter = gl.LINEAR;
                if (generateMipMaps) {
                    minFilter = gl.LINEAR_MIPMAP_NEAREST;
                }
                else {
                    minFilter = gl.LINEAR;
                }
                break;
            case 3:
                magFilter = gl.LINEAR;
                hasMipMaps = true;
                if (generateMipMaps) {
                    minFilter = gl.LINEAR_MIPMAP_LINEAR;
                }
                else {
                    minFilter = gl.LINEAR;
                }
                break;
            case 8:
                hasMipMaps = true;
                magFilter = gl.NEAREST;
                if (generateMipMaps) {
                    minFilter = gl.NEAREST_MIPMAP_LINEAR;
                }
                else {
                    minFilter = gl.NEAREST;
                }
                break;
            case 4:
                magFilter = gl.NEAREST;
                if (generateMipMaps) {
                    minFilter = gl.NEAREST_MIPMAP_NEAREST;
                }
                else {
                    minFilter = gl.NEAREST;
                }
                break;
            case 5:
                magFilter = gl.NEAREST;
                if (generateMipMaps) {
                    minFilter = gl.LINEAR_MIPMAP_NEAREST;
                }
                else {
                    minFilter = gl.LINEAR;
                }
                break;
            case 6:
                hasMipMaps = true;
                magFilter = gl.NEAREST;
                if (generateMipMaps) {
                    minFilter = gl.LINEAR_MIPMAP_LINEAR;
                }
                else {
                    minFilter = gl.LINEAR;
                }
                break;
            case 7:
                magFilter = gl.NEAREST;
                minFilter = gl.LINEAR;
                break;
            case 1:
                magFilter = gl.NEAREST;
                minFilter = gl.NEAREST;
                break;
            case 9:
                magFilter = gl.LINEAR;
                if (generateMipMaps) {
                    minFilter = gl.NEAREST_MIPMAP_NEAREST;
                }
                else {
                    minFilter = gl.NEAREST;
                }
                break;
            case 10:
                hasMipMaps = true;
                magFilter = gl.LINEAR;
                if (generateMipMaps) {
                    minFilter = gl.NEAREST_MIPMAP_LINEAR;
                }
                else {
                    minFilter = gl.NEAREST;
                }
                break;
            case 2:
                magFilter = gl.LINEAR;
                minFilter = gl.LINEAR;
                break;
            case 12:
                magFilter = gl.LINEAR;
                minFilter = gl.NEAREST;
                break;
        }
        return {
            min: minFilter,
            mag: magFilter,
            hasMipMaps: hasMipMaps,
        };
    }
    /** @internal */
    _createTexture() {
        const texture = this._gl.createTexture();
        if (!texture) {
            throw new Error("Unable to create texture");
        }
        return texture;
    }
    /** @internal */
    _createHardwareTexture() {
        return new _WebGL_webGLHardwareTexture_js__WEBPACK_IMPORTED_MODULE_9__.WebGLHardwareTexture(this._createTexture(), this._gl);
    }
    /**
     * Creates an internal texture without binding it to a framebuffer
     * @internal
     * @param size defines the size of the texture
     * @param options defines the options used to create the texture
     * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away
     * @param source source type of the texture
     * @returns a new internal texture
     */
    _createInternalTexture(size, options, delayGPUTextureCreation = true, source = 0 /* InternalTextureSource.Unknown */) {
        let generateMipMaps = false;
        let createMipMaps = false;
        let type = 0;
        let samplingMode = 3;
        let format = 5;
        let useSRGBBuffer = false;
        let samples = 1;
        let label;
        let createMSAATexture = false;
        let comparisonFunction = 0;
        if (options !== undefined && typeof options === "object") {
            generateMipMaps = !!options.generateMipMaps;
            createMipMaps = !!options.createMipMaps;
            type = options.type === undefined ? 0 : options.type;
            samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;
            format = options.format === undefined ? 5 : options.format;
            useSRGBBuffer = options.useSRGBBuffer === undefined ? false : options.useSRGBBuffer;
            samples = options.samples ?? 1;
            label = options.label;
            createMSAATexture = !!options.createMSAATexture;
            comparisonFunction = options.comparisonFunction || 0;
        }
        else {
            generateMipMaps = !!options;
        }
        useSRGBBuffer && (useSRGBBuffer = this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU));
        if (type === 1 && !this._caps.textureFloatLinearFiltering) {
            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE
            samplingMode = 1;
        }
        else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE
            samplingMode = 1;
        }
        if (type === 1 && !this._caps.textureFloat) {
            type = 0;
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE");
        }
        const isDepthTexture = (0,_Materials_Textures_textureHelper_functions_js__WEBPACK_IMPORTED_MODULE_14__.IsDepthTexture)(format);
        const hasStencil = (0,_Materials_Textures_textureHelper_functions_js__WEBPACK_IMPORTED_MODULE_14__.HasStencilAspect)(format);
        const gl = this._gl;
        const texture = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_10__.InternalTexture(this, source);
        const width = size.width || size;
        const height = size.height || size;
        const depth = size.depth || 0;
        const layers = size.layers || 0;
        const filters = this._getSamplingParameters(samplingMode, (generateMipMaps || createMipMaps) && !isDepthTexture);
        const target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : depth !== 0 ? gl.TEXTURE_3D : gl.TEXTURE_2D;
        const sizedFormat = isDepthTexture
            ? this._getInternalFormatFromDepthTextureFormat(format, true, hasStencil)
            : this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);
        const internalFormat = isDepthTexture ? (hasStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT) : this._getInternalFormat(format);
        const textureType = isDepthTexture ? this._getWebGLTextureTypeFromDepthTextureFormat(format) : this._getWebGLTextureType(type);
        // Bind
        this._bindTextureDirectly(target, texture);
        if (layers !== 0) {
            texture.is2DArray = true;
            gl.texImage3D(target, 0, sizedFormat, width, height, layers, 0, internalFormat, textureType, null);
        }
        else if (depth !== 0) {
            texture.is3D = true;
            gl.texImage3D(target, 0, sizedFormat, width, height, depth, 0, internalFormat, textureType, null);
        }
        else {
            gl.texImage2D(target, 0, sizedFormat, width, height, 0, internalFormat, textureType, null);
        }
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (isDepthTexture && this.webGLVersion > 1) {
            if (comparisonFunction === 0) {
                gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, 515);
                gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.NONE);
            }
            else {
                gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
                gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
            }
        }
        // MipMaps
        if (generateMipMaps || createMipMaps) {
            this._gl.generateMipmap(target);
        }
        this._bindTextureDirectly(target, null);
        texture._useSRGBBuffer = useSRGBBuffer;
        texture.baseWidth = width;
        texture.baseHeight = height;
        texture.width = width;
        texture.height = height;
        texture.depth = layers || depth;
        texture.isReady = true;
        texture.samples = samples;
        texture.generateMipMaps = generateMipMaps;
        texture.samplingMode = samplingMode;
        texture.type = type;
        texture.format = format;
        texture.label = label;
        texture.comparisonFunction = comparisonFunction;
        this._internalTexturesCache.push(texture);
        if (createMSAATexture) {
            let renderBuffer = null;
            if ((0,_Materials_Textures_textureHelper_functions_js__WEBPACK_IMPORTED_MODULE_14__.IsDepthTexture)(texture.format)) {
                renderBuffer = this._setupFramebufferDepthAttachments((0,_Materials_Textures_textureHelper_functions_js__WEBPACK_IMPORTED_MODULE_14__.HasStencilAspect)(texture.format), texture.format !== 19, texture.width, texture.height, samples, texture.format, true);
            }
            else {
                renderBuffer = this._createRenderBuffer(texture.width, texture.height, samples, -1 /* not used */, this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer), -1 /* attachment */);
            }
            if (!renderBuffer) {
                throw new Error("Unable to create render buffer");
            }
            texture._autoMSAAManagement = true;
            let hardwareTexture = texture._hardwareTexture;
            if (!hardwareTexture) {
                hardwareTexture = texture._hardwareTexture = this._createHardwareTexture();
            }
            hardwareTexture.addMSAARenderBuffer(renderBuffer);
        }
        return texture;
    }
    /**
     * @internal
     */
    _getUseSRGBBuffer(useSRGBBuffer, noMipmap) {
        // Generating mipmaps for sRGB textures is not supported in WebGL1 so we must disable the support if mipmaps is enabled
        return useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || noMipmap);
    }
    /**
     * Usually called from Texture.ts.
     * Passed information to create a WebGLTexture
     * @param url defines a value which contains one of the following:
     * * A conventional http URL, e.g. 'http://...' or 'file://...'
     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
     * @param scene needed for loading to the correct scene
     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
     * @param onLoad optional callback to be called upon successful completion
     * @param onError optional callback to be called upon failure
     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
     * @param forcedExtension defines the extension to use to pick the right loader
     * @param mimeType defines an optional mime type
     * @param loaderOptions options to be passed to the loader
     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
     * @returns a InternalTexture for assignment back into BABYLON.Texture
     */
    createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {
        return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, (...args) => this._prepareWebGLTexture(...args, format), (potWidth, potHeight, img, extension, texture, continuationCallback) => {
            const gl = this._gl;
            const isPot = img.width === potWidth && img.height === potHeight;
            texture._creationFlags = creationFlags ?? 0;
            const tip = this._getTexImageParametersForCreateTexture(texture.format, texture._useSRGBBuffer);
            if (isPot) {
                gl.texImage2D(gl.TEXTURE_2D, 0, tip.internalFormat, tip.format, tip.type, img);
                return false;
            }
            const maxTextureSize = this._caps.maxTextureSize;
            if (img.width > maxTextureSize || img.height > maxTextureSize || !this._supportsHardwareTextureRescaling) {
                this._prepareWorkingCanvas();
                if (!this._workingCanvas || !this._workingContext) {
                    return false;
                }
                this._workingCanvas.width = potWidth;
                this._workingCanvas.height = potHeight;
                this._workingContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, potWidth, potHeight);
                gl.texImage2D(gl.TEXTURE_2D, 0, tip.internalFormat, tip.format, tip.type, this._workingCanvas);
                texture.width = potWidth;
                texture.height = potHeight;
                return false;
            }
            else {
                // Using shaders when possible to rescale because canvas.drawImage is lossy
                const source = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_10__.InternalTexture(this, 2 /* InternalTextureSource.Temp */);
                this._bindTextureDirectly(gl.TEXTURE_2D, source, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, tip.internalFormat, tip.format, tip.type, img);
                this._rescaleTexture(source, texture, scene, tip.format, () => {
                    this._releaseTexture(source);
                    this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
                    continuationCallback();
                });
            }
            return true;
        }, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
    }
    /**
     * Calls to the GL texImage2D and texImage3D functions require three arguments describing the pixel format of the texture.
     * createTexture derives these from the babylonFormat and useSRGBBuffer arguments and also the file extension of the URL it's working with.
     * This function encapsulates that derivation for easy unit testing.
     * @param babylonFormat Babylon's format enum, as specified in ITextureCreationOptions.
     * @param fileExtension The file extension including the dot, e.g. .jpg.
     * @param useSRGBBuffer Use SRGB not linear.
     * @returns The options to pass to texImage2D or texImage3D calls.
     * @internal
     */
    _getTexImageParametersForCreateTexture(babylonFormat, useSRGBBuffer) {
        let format, internalFormat;
        if (this.webGLVersion === 1) {
            // In WebGL 1, format and internalFormat must be the same and taken from a limited set of values, see https://docs.gl/es2/glTexImage2D.
            // The SRGB extension (https://developer.mozilla.org/en-US/docs/Web/API/EXT_sRGB) adds some extra values, hence passing useSRGBBuffer
            // to getInternalFormat.
            format = this._getInternalFormat(babylonFormat, useSRGBBuffer);
            internalFormat = format;
        }
        else {
            // In WebGL 2, format has a wider range of values and internal format can be one of the sized formats, see
            // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml.
            // SRGB is included in the sized format and should not be passed in "format", hence always passing useSRGBBuffer as false.
            format = this._getInternalFormat(babylonFormat, false);
            internalFormat = this._getRGBABufferInternalSizedFormat(0, babylonFormat, useSRGBBuffer);
        }
        return {
            internalFormat,
            format,
            type: this._gl.UNSIGNED_BYTE,
        };
    }
    /**
     * @internal
     */
    _rescaleTexture(source, destination, scene, internalFormat, onComplete) { }
    /**
     * @internal
     */
    _unpackFlipY(value) {
        if (this._unpackFlipYCached !== value) {
            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, value ? 1 : 0);
            if (this.enableUnpackFlipYCached) {
                this._unpackFlipYCached = value;
            }
        }
    }
    /** @internal */
    _getUnpackAlignement() {
        return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);
    }
    /** @internal */
    _getTextureTarget(texture) {
        if (texture.isCube) {
            return this._gl.TEXTURE_CUBE_MAP;
        }
        else if (texture.is3D) {
            return this._gl.TEXTURE_3D;
        }
        else if (texture.is2DArray || texture.isMultiview) {
            return this._gl.TEXTURE_2D_ARRAY;
        }
        return this._gl.TEXTURE_2D;
    }
    /**
     * Update the sampling mode of a given texture
     * @param samplingMode defines the required sampling mode
     * @param texture defines the texture to update
     * @param generateMipMaps defines whether to generate mipmaps for the texture
     */
    updateTextureSamplingMode(samplingMode, texture, generateMipMaps = false) {
        const target = this._getTextureTarget(texture);
        const filters = this._getSamplingParameters(samplingMode, texture.useMipMaps || generateMipMaps);
        this._setTextureParameterInteger(target, this._gl.TEXTURE_MAG_FILTER, filters.mag, texture);
        this._setTextureParameterInteger(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
        if (generateMipMaps && filters.hasMipMaps) {
            texture.generateMipMaps = true;
            this._gl.generateMipmap(target);
        }
        this._bindTextureDirectly(target, null);
        texture.samplingMode = samplingMode;
    }
    /**
     * Update the dimensions of a texture
     * @param texture texture to update
     * @param width new width of the texture
     * @param height new height of the texture
     * @param depth new depth of the texture
     */
    updateTextureDimensions(texture, width, height, depth = 1) { }
    /**
     * Update the sampling mode of a given texture
     * @param texture defines the texture to update
     * @param wrapU defines the texture wrap mode of the u coordinates
     * @param wrapV defines the texture wrap mode of the v coordinates
     * @param wrapR defines the texture wrap mode of the r coordinates
     */
    updateTextureWrappingMode(texture, wrapU, wrapV = null, wrapR = null) {
        const target = this._getTextureTarget(texture);
        if (wrapU !== null) {
            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(wrapU), texture);
            texture._cachedWrapU = wrapU;
        }
        if (wrapV !== null) {
            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(wrapV), texture);
            texture._cachedWrapV = wrapV;
        }
        if ((texture.is2DArray || texture.is3D) && wrapR !== null) {
            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(wrapR), texture);
            texture._cachedWrapR = wrapR;
        }
        this._bindTextureDirectly(target, null);
    }
    /**
     * @internal
     */
    _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {
        const gl = this._gl;
        let target = gl.TEXTURE_2D;
        if (texture.isCube) {
            target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
        }
        if (texture._useSRGBBuffer) {
            switch (internalFormat) {
                case 37492:
                case 36196:
                    // Note, if using ETC1 and sRGB is requested, this will use ETC2 if available.
                    if (this._caps.etc2) {
                        internalFormat = gl.COMPRESSED_SRGB8_ETC2;
                    }
                    else {
                        texture._useSRGBBuffer = false;
                    }
                    break;
                case 37496:
                    if (this._caps.etc2) {
                        internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
                    }
                    else {
                        texture._useSRGBBuffer = false;
                    }
                    break;
                case 36492:
                    internalFormat = gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
                    break;
                case 37808:
                    internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
                    break;
                case 33776:
                    if (this._caps.s3tc_srgb) {
                        internalFormat = gl.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    }
                    else {
                        // S3TC sRGB extension not supported
                        texture._useSRGBBuffer = false;
                    }
                    break;
                case 33777:
                    if (this._caps.s3tc_srgb) {
                        internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    }
                    else {
                        // S3TC sRGB extension not supported
                        texture._useSRGBBuffer = false;
                    }
                    break;
                case 33779:
                    if (this._caps.s3tc_srgb) {
                        internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                    }
                    else {
                        // S3TC sRGB extension not supported
                        texture._useSRGBBuffer = false;
                    }
                    break;
                default:
                    // We don't support a sRGB format corresponding to internalFormat, so revert to non sRGB format
                    texture._useSRGBBuffer = false;
                    break;
            }
        }
        this._gl.compressedTexImage2D(target, lod, internalFormat, width, height, 0, data);
    }
    /**
     * @internal
     */
    _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0, babylonInternalFormat, useTextureWidthAndHeight = false) {
        const gl = this._gl;
        const textureType = this._getWebGLTextureType(texture.type);
        const format = this._getInternalFormat(texture.format);
        const internalFormat = babylonInternalFormat === undefined
            ? this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer)
            : this._getInternalFormat(babylonInternalFormat, texture._useSRGBBuffer);
        this._unpackFlipY(texture.invertY);
        let target = gl.TEXTURE_2D;
        if (texture.isCube) {
            target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
        }
        const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);
        const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);
        const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));
        const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));
        gl.texImage2D(target, lod, internalFormat, width, height, 0, format, textureType, imageData);
    }
    /**
     * Update a portion of an internal texture
     * @param texture defines the texture to update
     * @param imageData defines the data to store into the texture
     * @param xOffset defines the x coordinates of the update rectangle
     * @param yOffset defines the y coordinates of the update rectangle
     * @param width defines the width of the update rectangle
     * @param height defines the height of the update rectangle
     * @param faceIndex defines the face index if texture is a cube (0 by default)
     * @param lod defines the lod level to update (0 by default)
     * @param generateMipMaps defines whether to generate mipmaps or not
     */
    updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {
        const gl = this._gl;
        const textureType = this._getWebGLTextureType(texture.type);
        const format = this._getInternalFormat(texture.format);
        this._unpackFlipY(texture.invertY);
        let targetForBinding = gl.TEXTURE_2D;
        let target = gl.TEXTURE_2D;
        if (texture.isCube) {
            target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
            targetForBinding = gl.TEXTURE_CUBE_MAP;
        }
        this._bindTextureDirectly(targetForBinding, texture, true);
        gl.texSubImage2D(target, lod, xOffset, yOffset, width, height, format, textureType, imageData);
        if (generateMipMaps) {
            this._gl.generateMipmap(target);
        }
        this._bindTextureDirectly(targetForBinding, null);
    }
    /**
     * @internal
     */
    _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {
        const gl = this._gl;
        const bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
        this._bindTextureDirectly(bindTarget, texture, true);
        this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);
        this._bindTextureDirectly(bindTarget, null, true);
    }
    _prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode) {
        const gl = this._gl;
        if (!gl) {
            return;
        }
        const filters = this._getSamplingParameters(samplingMode, !noMipmap);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);
        if (!noMipmap && !isCompressed) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
        this._bindTextureDirectly(gl.TEXTURE_2D, null);
        // this.resetTextureCache();
        if (scene) {
            scene.removePendingData(texture);
        }
        texture.onLoadedObservable.notifyObservers(texture);
        texture.onLoadedObservable.clear();
    }
    _prepareWebGLTexture(texture, extension, scene, img, invertY, noMipmap, isCompressed, processFunction, samplingMode, format) {
        const maxTextureSize = this.getCaps().maxTextureSize;
        const potWidth = Math.min(maxTextureSize, this.needPOTTextures ? (0,_Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_7__.GetExponentOfTwo)(img.width, maxTextureSize) : img.width);
        const potHeight = Math.min(maxTextureSize, this.needPOTTextures ? (0,_Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_7__.GetExponentOfTwo)(img.height, maxTextureSize) : img.height);
        const gl = this._gl;
        if (!gl) {
            return;
        }
        if (!texture._hardwareTexture) {
            //  this.resetTextureCache();
            if (scene) {
                scene.removePendingData(texture);
            }
            return;
        }
        this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
        this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);
        texture.baseWidth = img.width;
        texture.baseHeight = img.height;
        texture.width = potWidth;
        texture.height = potHeight;
        texture.isReady = true;
        texture.type = texture.type !== -1 ? texture.type : 0;
        texture.format =
            texture.format !== -1 ? texture.format : (format ?? (extension === ".jpg" && !texture._useSRGBBuffer ? 4 : 5));
        if (processFunction(potWidth, potHeight, img, extension, texture, () => {
            this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
        })) {
            // Returning as texture needs extra async steps
            return;
        }
        this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
    }
    _getInternalFormatFromDepthTextureFormat(textureFormat, hasDepth, hasStencil) {
        const gl = this._gl;
        if (!hasDepth) {
            return gl.STENCIL_INDEX8;
        }
        const format = hasStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;
        let internalFormat = format;
        if (this.webGLVersion > 1) {
            if (textureFormat === 15) {
                internalFormat = gl.DEPTH_COMPONENT16;
            }
            else if (textureFormat === 16) {
                internalFormat = gl.DEPTH_COMPONENT24;
            }
            else if (textureFormat === 17 || textureFormat === 13) {
                internalFormat = hasStencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
            }
            else if (textureFormat === 14) {
                internalFormat = gl.DEPTH_COMPONENT32F;
            }
            else if (textureFormat === 18) {
                internalFormat = hasStencil ? gl.DEPTH32F_STENCIL8 : gl.DEPTH_COMPONENT32F;
            }
        }
        else {
            internalFormat = gl.DEPTH_COMPONENT16;
        }
        return internalFormat;
    }
    _getWebGLTextureTypeFromDepthTextureFormat(textureFormat) {
        const gl = this._gl;
        let type = gl.UNSIGNED_INT;
        if (textureFormat === 15) {
            type = gl.UNSIGNED_SHORT;
        }
        else if (textureFormat === 17 || textureFormat === 13) {
            type = gl.UNSIGNED_INT_24_8;
        }
        else if (textureFormat === 14) {
            type = gl.FLOAT;
        }
        else if (textureFormat === 18) {
            type = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
        }
        else if (textureFormat === 19) {
            type = gl.UNSIGNED_BYTE;
        }
        return type;
    }
    /**
     * @internal
     */
    _setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height, samples = 1, depthTextureFormat, dontBindRenderBufferToFrameBuffer = false) {
        const gl = this._gl;
        depthTextureFormat = depthTextureFormat ?? (generateStencilBuffer ? 13 : 14);
        const internalFormat = this._getInternalFormatFromDepthTextureFormat(depthTextureFormat, generateDepthBuffer, generateStencilBuffer);
        // Create the depth/stencil buffer
        if (generateStencilBuffer && generateDepthBuffer) {
            return this._createRenderBuffer(width, height, samples, gl.DEPTH_STENCIL, internalFormat, dontBindRenderBufferToFrameBuffer ? -1 : gl.DEPTH_STENCIL_ATTACHMENT);
        }
        if (generateDepthBuffer) {
            return this._createRenderBuffer(width, height, samples, internalFormat, internalFormat, dontBindRenderBufferToFrameBuffer ? -1 : gl.DEPTH_ATTACHMENT);
        }
        if (generateStencilBuffer) {
            return this._createRenderBuffer(width, height, samples, internalFormat, internalFormat, dontBindRenderBufferToFrameBuffer ? -1 : gl.STENCIL_ATTACHMENT);
        }
        return null;
    }
    /**
     * @internal
     */
    _createRenderBuffer(width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer = true) {
        const gl = this._gl;
        const renderBuffer = gl.createRenderbuffer();
        return this._updateRenderBuffer(renderBuffer, width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer);
    }
    _updateRenderBuffer(renderBuffer, width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer = true) {
        const gl = this._gl;
        gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
        if (samples > 1 && gl.renderbufferStorageMultisample) {
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, msInternalFormat, width, height);
        }
        else {
            gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
        }
        if (attachment !== -1) {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderBuffer);
        }
        if (unbindBuffer) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
        return renderBuffer;
    }
    /**
     * @internal
     */
    _releaseTexture(texture) {
        this._deleteTexture(texture._hardwareTexture);
        // Unbind channels
        this.unbindAllTextures();
        const index = this._internalTexturesCache.indexOf(texture);
        if (index !== -1) {
            this._internalTexturesCache.splice(index, 1);
        }
        // Integrated fixed lod samplers.
        if (texture._lodTextureHigh) {
            texture._lodTextureHigh.dispose();
        }
        if (texture._lodTextureMid) {
            texture._lodTextureMid.dispose();
        }
        if (texture._lodTextureLow) {
            texture._lodTextureLow.dispose();
        }
        // Integrated irradiance map.
        if (texture._irradianceTexture) {
            texture._irradianceTexture.dispose();
        }
    }
    _deleteTexture(texture) {
        texture?.release();
    }
    _setProgram(program) {
        if (this._currentProgram !== program) {
            (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__._setProgram)(program, this._gl);
            this._currentProgram = program;
        }
    }
    /**
     * Binds an effect to the webGL context
     * @param effect defines the effect to bind
     */
    bindSamplers(effect) {
        const webGLPipelineContext = effect.getPipelineContext();
        this._setProgram(webGLPipelineContext.program);
        const samplers = effect.getSamplers();
        for (let index = 0; index < samplers.length; index++) {
            const uniform = effect.getUniform(samplers[index]);
            if (uniform) {
                this._boundUniforms[index] = uniform;
            }
        }
        this._currentEffect = null;
    }
    _activateCurrentTexture() {
        if (this._currentTextureChannel !== this._activeChannel) {
            this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel);
            this._currentTextureChannel = this._activeChannel;
        }
    }
    /**
     * @internal
     */
    _bindTextureDirectly(target, texture, forTextureDataUpdate = false, force = false) {
        let wasPreviouslyBound = false;
        const isTextureForRendering = texture && texture._associatedChannel > -1;
        if (forTextureDataUpdate && isTextureForRendering) {
            this._activeChannel = texture._associatedChannel;
        }
        const currentTextureBound = this._boundTexturesCache[this._activeChannel];
        if (currentTextureBound !== texture || force) {
            this._activateCurrentTexture();
            if (texture && texture.isMultiview) {
                //this._gl.bindTexture(target, texture ? texture._colorTextureArray : null);
                _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.Error(["_bindTextureDirectly called with a multiview texture!", target, texture]);
                // eslint-disable-next-line no-throw-literal
                throw "_bindTextureDirectly called with a multiview texture!";
            }
            else {
                this._gl.bindTexture(target, texture?._hardwareTexture?.underlyingResource ?? null);
            }
            this._boundTexturesCache[this._activeChannel] = texture;
            if (texture) {
                texture._associatedChannel = this._activeChannel;
            }
        }
        else if (forTextureDataUpdate) {
            wasPreviouslyBound = true;
            this._activateCurrentTexture();
        }
        if (isTextureForRendering && !forTextureDataUpdate) {
            this._bindSamplerUniformToChannel(texture._associatedChannel, this._activeChannel);
        }
        return wasPreviouslyBound;
    }
    /**
     * @internal
     */
    _bindTexture(channel, texture, name) {
        if (channel === undefined) {
            return;
        }
        if (texture) {
            texture._associatedChannel = channel;
        }
        this._activeChannel = channel;
        const target = texture ? this._getTextureTarget(texture) : this._gl.TEXTURE_2D;
        this._bindTextureDirectly(target, texture);
    }
    /**
     * Unbind all textures from the webGL context
     */
    unbindAllTextures() {
        for (let channel = 0; channel < this._maxSimultaneousTextures; channel++) {
            this._activeChannel = channel;
            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
            if (this.webGLVersion > 1) {
                this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
                this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
            }
        }
    }
    /**
     * Sets a texture to the according uniform.
     * @param channel The texture channel
     * @param uniform The uniform to set
     * @param texture The texture to apply
     * @param name The name of the uniform in the effect
     */
    setTexture(channel, uniform, texture, name) {
        if (channel === undefined) {
            return;
        }
        if (uniform) {
            this._boundUniforms[channel] = uniform;
        }
        this._setTexture(channel, texture);
    }
    _bindSamplerUniformToChannel(sourceSlot, destination) {
        const uniform = this._boundUniforms[sourceSlot];
        if (!uniform || uniform._currentState === destination) {
            return;
        }
        this._gl.uniform1i(uniform, destination);
        uniform._currentState = destination;
    }
    _getTextureWrapMode(mode) {
        switch (mode) {
            case 1:
                return this._gl.REPEAT;
            case 0:
                return this._gl.CLAMP_TO_EDGE;
            case 2:
                return this._gl.MIRRORED_REPEAT;
        }
        return this._gl.REPEAT;
    }
    _setTexture(channel, texture, isPartOfTextureArray = false, depthStencilTexture = false, name = "") {
        // Not ready?
        if (!texture) {
            if (this._boundTexturesCache[channel] != null) {
                this._activeChannel = channel;
                this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
                this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
                if (this.webGLVersion > 1) {
                    this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
                    this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
                }
            }
            return false;
        }
        // Video
        if (texture.video) {
            this._activeChannel = channel;
            const videoInternalTexture = texture.getInternalTexture();
            if (videoInternalTexture) {
                videoInternalTexture._associatedChannel = channel;
            }
            texture.update();
        }
        else if (texture.delayLoadState === 4) {
            // Delay loading
            texture.delayLoad();
            return false;
        }
        let internalTexture;
        if (depthStencilTexture) {
            internalTexture = texture.depthStencilTexture;
        }
        else if (texture.isReady()) {
            internalTexture = texture.getInternalTexture();
        }
        else if (texture.isCube) {
            internalTexture = this.emptyCubeTexture;
        }
        else if (texture.is3D) {
            internalTexture = this.emptyTexture3D;
        }
        else if (texture.is2DArray) {
            internalTexture = this.emptyTexture2DArray;
        }
        else {
            internalTexture = this.emptyTexture;
        }
        if (!isPartOfTextureArray && internalTexture) {
            internalTexture._associatedChannel = channel;
        }
        let needToBind = true;
        if (this._boundTexturesCache[channel] === internalTexture) {
            if (!isPartOfTextureArray) {
                this._bindSamplerUniformToChannel(internalTexture._associatedChannel, channel);
            }
            needToBind = false;
        }
        this._activeChannel = channel;
        const target = this._getTextureTarget(internalTexture);
        if (needToBind) {
            this._bindTextureDirectly(target, internalTexture, isPartOfTextureArray);
        }
        if (internalTexture && !internalTexture.isMultiview) {
            // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.
            if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {
                internalTexture._cachedCoordinatesMode = texture.coordinatesMode;
                const textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5
                    ? 1
                    : 0;
                texture.wrapU = textureWrapMode;
                texture.wrapV = textureWrapMode;
            }
            if (internalTexture._cachedWrapU !== texture.wrapU) {
                internalTexture._cachedWrapU = texture.wrapU;
                this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(texture.wrapU), internalTexture);
            }
            if (internalTexture._cachedWrapV !== texture.wrapV) {
                internalTexture._cachedWrapV = texture.wrapV;
                this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(texture.wrapV), internalTexture);
            }
            if (internalTexture.is3D && internalTexture._cachedWrapR !== texture.wrapR) {
                internalTexture._cachedWrapR = texture.wrapR;
                this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(texture.wrapR), internalTexture);
            }
            this._setAnisotropicLevel(target, internalTexture, texture.anisotropicFilteringLevel);
        }
        return true;
    }
    /**
     * Sets an array of texture to the webGL context
     * @param channel defines the channel where the texture array must be set
     * @param uniform defines the associated uniform location
     * @param textures defines the array of textures to bind
     * @param name name of the channel
     */
    setTextureArray(channel, uniform, textures, name) {
        if (channel === undefined || !uniform) {
            return;
        }
        if (!this._textureUnits || this._textureUnits.length !== textures.length) {
            this._textureUnits = new Int32Array(textures.length);
        }
        for (let i = 0; i < textures.length; i++) {
            const texture = textures[i].getInternalTexture();
            if (texture) {
                this._textureUnits[i] = channel + i;
                texture._associatedChannel = channel + i;
            }
            else {
                this._textureUnits[i] = -1;
            }
        }
        this._gl.uniform1iv(uniform, this._textureUnits);
        for (let index = 0; index < textures.length; index++) {
            this._setTexture(this._textureUnits[index], textures[index], true);
        }
    }
    /**
     * @internal
     */
    _setAnisotropicLevel(target, internalTexture, anisotropicFilteringLevel) {
        const anisotropicFilterExtension = this._caps.textureAnisotropicFilterExtension;
        if (internalTexture.samplingMode !== 11 &&
            internalTexture.samplingMode !== 3 &&
            internalTexture.samplingMode !== 2) {
            anisotropicFilteringLevel = 1; // Forcing the anisotropic to 1 because else webgl will force filters to linear
        }
        if (anisotropicFilterExtension && internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {
            this._setTextureParameterFloat(target, anisotropicFilterExtension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy), internalTexture);
            internalTexture._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
        }
    }
    _setTextureParameterFloat(target, parameter, value, texture) {
        this._bindTextureDirectly(target, texture, true, true);
        this._gl.texParameterf(target, parameter, value);
    }
    _setTextureParameterInteger(target, parameter, value, texture) {
        if (texture) {
            this._bindTextureDirectly(target, texture, true, true);
        }
        this._gl.texParameteri(target, parameter, value);
    }
    /**
     * Unbind all vertex attributes from the webGL context
     */
    unbindAllAttributes() {
        if (this._mustWipeVertexAttributes) {
            this._mustWipeVertexAttributes = false;
            for (let i = 0; i < this._caps.maxVertexAttribs; i++) {
                this.disableAttributeByIndex(i);
            }
            return;
        }
        for (let i = 0, ul = this._vertexAttribArraysEnabled.length; i < ul; i++) {
            if (i >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[i]) {
                continue;
            }
            this.disableAttributeByIndex(i);
        }
    }
    /**
     * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
     */
    releaseEffects() {
        this._compiledEffects = {};
        this.onReleaseEffectsObservable.notifyObservers(this);
    }
    /**
     * Dispose and release all associated resources
     */
    dispose() {
        // Events
        if ((0,_Misc_domManagement_js__WEBPACK_IMPORTED_MODULE_3__.IsWindowObjectExist)()) {
            if (this._renderingCanvas) {
                this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost);
                if (this._onContextRestored) {
                    this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored);
                }
            }
        }
        // Should not be moved up of renderingCanvas will be null.
        super.dispose();
        if (this._dummyFramebuffer) {
            this._gl.deleteFramebuffer(this._dummyFramebuffer);
        }
        // Unbind
        this.unbindAllAttributes();
        this._boundUniforms = {};
        this._workingCanvas = null;
        this._workingContext = null;
        this._currentBufferPointers.length = 0;
        this._currentProgram = null;
        if (this._creationOptions.loseContextOnDispose) {
            this._gl.getExtension("WEBGL_lose_context")?.loseContext();
        }
        // clear the state object
        (0,_thinEngine_functions_js__WEBPACK_IMPORTED_MODULE_0__.deleteStateObject)(this._gl);
    }
    /**
     * Attach a new callback raised when context lost event is fired
     * @param callback defines the callback to call
     */
    attachContextLostEvent(callback) {
        if (this._renderingCanvas) {
            this._renderingCanvas.addEventListener("webglcontextlost", callback, false);
        }
    }
    /**
     * Attach a new callback raised when context restored event is fired
     * @param callback defines the callback to call
     */
    attachContextRestoredEvent(callback) {
        if (this._renderingCanvas) {
            this._renderingCanvas.addEventListener("webglcontextrestored", callback, false);
        }
    }
    /**
     * Get the current error code of the webGL context
     * @returns the error code
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
     */
    getError() {
        return this._gl.getError();
    }
    _canRenderToFloatFramebuffer() {
        if (this._webGLVersion > 1) {
            return this._caps.colorBufferFloat;
        }
        return this._canRenderToFramebuffer(1);
    }
    _canRenderToHalfFloatFramebuffer() {
        if (this._webGLVersion > 1) {
            return this._caps.colorBufferFloat;
        }
        return this._canRenderToFramebuffer(2);
    }
    // Thank you : http://stackoverflow.com/questions/28827511/webgl-ios-render-to-floating-point-texture
    _canRenderToFramebuffer(type) {
        const gl = this._gl;
        //clear existing errors
        // eslint-disable-next-line no-empty
        while (gl.getError() !== gl.NO_ERROR) { }
        let successful = true;
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), 1, 1, 0, gl.RGBA, this._getWebGLTextureType(type), null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        const fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        successful = successful && status === gl.FRAMEBUFFER_COMPLETE;
        successful = successful && gl.getError() === gl.NO_ERROR;
        //try render by clearing frame buffer's color buffer
        if (successful) {
            gl.clear(gl.COLOR_BUFFER_BIT);
            successful = successful && gl.getError() === gl.NO_ERROR;
        }
        //try reading from frame to ensure render occurs (just creating the FBO is not sufficient to determine if rendering is supported)
        if (successful) {
            //in practice it's sufficient to just read from the backbuffer rather than handle potentially issues reading from the texture
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            const readFormat = gl.RGBA;
            const readType = gl.UNSIGNED_BYTE;
            const buffer = new Uint8Array(4);
            gl.readPixels(0, 0, 1, 1, readFormat, readType, buffer);
            successful = successful && gl.getError() === gl.NO_ERROR;
        }
        //clean up
        gl.deleteTexture(texture);
        gl.deleteFramebuffer(fb);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        //clear accumulated errors
        // eslint-disable-next-line no-empty
        while (!successful && gl.getError() !== gl.NO_ERROR) { }
        return successful;
    }
    /**
     * @internal
     */
    _getWebGLTextureType(type) {
        if (this._webGLVersion === 1) {
            switch (type) {
                case 1:
                    return this._gl.FLOAT;
                case 2:
                    return this._gl.HALF_FLOAT_OES;
                case 0:
                    return this._gl.UNSIGNED_BYTE;
                case 8:
                    return this._gl.UNSIGNED_SHORT_4_4_4_4;
                case 9:
                    return this._gl.UNSIGNED_SHORT_5_5_5_1;
                case 10:
                    return this._gl.UNSIGNED_SHORT_5_6_5;
            }
            return this._gl.UNSIGNED_BYTE;
        }
        switch (type) {
            case 3:
                return this._gl.BYTE;
            case 0:
                return this._gl.UNSIGNED_BYTE;
            case 4:
                return this._gl.SHORT;
            case 5:
                return this._gl.UNSIGNED_SHORT;
            case 6:
                return this._gl.INT;
            case 7: // Refers to UNSIGNED_INT
                return this._gl.UNSIGNED_INT;
            case 1:
                return this._gl.FLOAT;
            case 2:
                return this._gl.HALF_FLOAT;
            case 8:
                return this._gl.UNSIGNED_SHORT_4_4_4_4;
            case 9:
                return this._gl.UNSIGNED_SHORT_5_5_5_1;
            case 10:
                return this._gl.UNSIGNED_SHORT_5_6_5;
            case 11:
                return this._gl.UNSIGNED_INT_2_10_10_10_REV;
            case 12:
                return this._gl.UNSIGNED_INT_24_8;
            case 13:
                return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
            case 14:
                return this._gl.UNSIGNED_INT_5_9_9_9_REV;
            case 15:
                return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
        }
        return this._gl.UNSIGNED_BYTE;
    }
    /**
     * @internal
     */
    _getInternalFormat(format, useSRGBBuffer = false) {
        let internalFormat = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA;
        switch (format) {
            case 0:
                internalFormat = this._gl.ALPHA;
                break;
            case 1:
                internalFormat = this._gl.LUMINANCE;
                break;
            case 2:
                internalFormat = this._gl.LUMINANCE_ALPHA;
                break;
            case 6:
            case 33322:
            case 36760:
                internalFormat = this._gl.RED;
                break;
            case 7:
            case 33324:
            case 36761:
                internalFormat = this._gl.RG;
                break;
            case 4:
            case 32852:
            case 36762:
                internalFormat = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB : this._gl.RGB;
                break;
            case 5:
            case 32859:
            case 36763:
                internalFormat = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA;
                break;
        }
        if (this._webGLVersion > 1) {
            switch (format) {
                case 8:
                    internalFormat = this._gl.RED_INTEGER;
                    break;
                case 9:
                    internalFormat = this._gl.RG_INTEGER;
                    break;
                case 10:
                    internalFormat = this._gl.RGB_INTEGER;
                    break;
                case 11:
                    internalFormat = this._gl.RGBA_INTEGER;
                    break;
            }
        }
        return internalFormat;
    }
    /**
     * @internal
     */
    _getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer = false) {
        if (this._webGLVersion === 1) {
            if (format !== undefined) {
                switch (format) {
                    case 0:
                        return this._gl.ALPHA;
                    case 1:
                        return this._gl.LUMINANCE;
                    case 2:
                        return this._gl.LUMINANCE_ALPHA;
                    case 4:
                        return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB : this._gl.RGB;
                }
            }
            return this._gl.RGBA;
        }
        switch (type) {
            case 3:
                switch (format) {
                    case 6:
                        return this._gl.R8_SNORM;
                    case 7:
                        return this._gl.RG8_SNORM;
                    case 4:
                        return this._gl.RGB8_SNORM;
                    case 8:
                        return this._gl.R8I;
                    case 9:
                        return this._gl.RG8I;
                    case 10:
                        return this._gl.RGB8I;
                    case 11:
                        return this._gl.RGBA8I;
                    default:
                        return this._gl.RGBA8_SNORM;
                }
            case 0:
                switch (format) {
                    case 6:
                        return this._gl.R8;
                    case 7:
                        return this._gl.RG8;
                    case 4:
                        return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8 : this._gl.RGB8; // By default. Other possibilities are RGB565, SRGB8.
                    case 5:
                        return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8; // By default. Other possibilities are RGB5_A1, RGBA4, SRGB8_ALPHA8.
                    case 8:
                        return this._gl.R8UI;
                    case 9:
                        return this._gl.RG8UI;
                    case 10:
                        return this._gl.RGB8UI;
                    case 11:
                        return this._gl.RGBA8UI;
                    case 0:
                        return this._gl.ALPHA;
                    case 1:
                        return this._gl.LUMINANCE;
                    case 2:
                        return this._gl.LUMINANCE_ALPHA;
                    default:
                        return this._gl.RGBA8;
                }
            case 4:
                switch (format) {
                    case 8:
                        return this._gl.R16I;
                    case 36760:
                        return this._gl.R16_SNORM_EXT;
                    case 36761:
                        return this._gl.RG16_SNORM_EXT;
                    case 36762:
                        return this._gl.RGB16_SNORM_EXT;
                    case 36763:
                        return this._gl.RGBA16_SNORM_EXT;
                    case 9:
                        return this._gl.RG16I;
                    case 10:
                        return this._gl.RGB16I;
                    case 11:
                        return this._gl.RGBA16I;
                    default:
                        return this._gl.RGBA16I;
                }
            case 5:
                switch (format) {
                    case 8:
                        return this._gl.R16UI;
                    case 33322:
                        return this._gl.R16_EXT;
                    case 33324:
                        return this._gl.RG16_EXT;
                    case 32852:
                        return this._gl.RGB16_EXT;
                    case 32859:
                        return this._gl.RGBA16_EXT;
                    case 9:
                        return this._gl.RG16UI;
                    case 10:
                        return this._gl.RGB16UI;
                    case 11:
                        return this._gl.RGBA16UI;
                    default:
                        return this._gl.RGBA16UI;
                }
            case 6:
                switch (format) {
                    case 8:
                        return this._gl.R32I;
                    case 9:
                        return this._gl.RG32I;
                    case 10:
                        return this._gl.RGB32I;
                    case 11:
                        return this._gl.RGBA32I;
                    default:
                        return this._gl.RGBA32I;
                }
            case 7: // Refers to UNSIGNED_INT
                switch (format) {
                    case 8:
                        return this._gl.R32UI;
                    case 9:
                        return this._gl.RG32UI;
                    case 10:
                        return this._gl.RGB32UI;
                    case 11:
                        return this._gl.RGBA32UI;
                    default:
                        return this._gl.RGBA32UI;
                }
            case 1:
                switch (format) {
                    case 6:
                        return this._gl.R32F; // By default. Other possibility is R16F.
                    case 7:
                        return this._gl.RG32F; // By default. Other possibility is RG16F.
                    case 4:
                        return this._gl.RGB32F; // By default. Other possibilities are RGB16F, R11F_G11F_B10F, RGB9_E5.
                    case 5:
                        return this._gl.RGBA32F; // By default. Other possibility is RGBA16F.
                    default:
                        return this._gl.RGBA32F;
                }
            case 2:
                switch (format) {
                    case 6:
                        return this._gl.R16F;
                    case 7:
                        return this._gl.RG16F;
                    case 4:
                        return this._gl.RGB16F; // By default. Other possibilities are R11F_G11F_B10F, RGB9_E5.
                    case 5:
                        return this._gl.RGBA16F;
                    default:
                        return this._gl.RGBA16F;
                }
            case 10:
                return this._gl.RGB565;
            case 13:
                return this._gl.R11F_G11F_B10F;
            case 14:
                return this._gl.RGB9_E5;
            case 8:
                return this._gl.RGBA4;
            case 9:
                return this._gl.RGB5_A1;
            case 11:
                switch (format) {
                    case 5:
                        return this._gl.RGB10_A2; // By default. Other possibility is RGB5_A1.
                    case 11:
                        return this._gl.RGB10_A2UI;
                    default:
                        return this._gl.RGB10_A2;
                }
        }
        return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8;
    }
    /**
     * Reads pixels from the current frame buffer. Please note that this function can be slow
     * @param x defines the x coordinate of the rectangle where pixels must be read
     * @param y defines the y coordinate of the rectangle where pixels must be read
     * @param width defines the width of the rectangle where pixels must be read
     * @param height defines the height of the rectangle where pixels must be read
     * @param hasAlpha defines whether the output should have alpha or not (defaults to true)
     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels
     * @param data defines the data to fill with the read pixels (if not provided, a new one will be created)
     * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors
     */
    // Async function, not named Async and not marked as async to avoid breaking changes
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    readPixels(x, y, width, height, hasAlpha = true, flushRenderer = true, data = null) {
        const numChannels = hasAlpha ? 4 : 3;
        const format = hasAlpha ? this._gl.RGBA : this._gl.RGB;
        const dataLength = width * height * numChannels;
        if (!data) {
            data = new Uint8Array(dataLength);
        }
        else if (data.length < dataLength) {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.Error(`Data buffer is too small to store the read pixels (${data.length} should be more than ${dataLength})`);
            return Promise.resolve(data);
        }
        if (flushRenderer) {
            this.flushFramebuffer();
        }
        this._gl.readPixels(x, y, width, height, format, this._gl.UNSIGNED_BYTE, data);
        return Promise.resolve(data);
    }
    /**
     * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a webGL context can be found)
     */
    // eslint-disable-next-line no-restricted-syntax
    static get IsSupportedAsync() {
        return Promise.resolve(this.isSupported());
    }
    /**
     * Gets a boolean indicating if the engine can be instantiated (ie. if a webGL context can be found)
     */
    static get IsSupported() {
        return this.isSupported(); // Backward compat
    }
    /**
     * Gets a boolean indicating if the engine can be instantiated (ie. if a webGL context can be found)
     * @returns true if the engine can be created
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    static isSupported() {
        if (this._HasMajorPerformanceCaveat !== null) {
            return !this._HasMajorPerformanceCaveat; // We know it is performant so WebGL is supported
        }
        if (this._IsSupported === null) {
            try {
                const tempcanvas = _abstractEngine_js__WEBPACK_IMPORTED_MODULE_8__.AbstractEngine._CreateCanvas(1, 1);
                const gl = tempcanvas.getContext("webgl") || tempcanvas.getContext("experimental-webgl");
                this._IsSupported = gl != null && !!window.WebGLRenderingContext;
            }
            catch (e) {
                this._IsSupported = false;
            }
        }
        return this._IsSupported;
    }
    /**
     * Gets a boolean indicating if the engine can be instantiated on a performant device (ie. if a webGL context can be found and it does not use a slow implementation)
     */
    static get HasMajorPerformanceCaveat() {
        if (this._HasMajorPerformanceCaveat === null) {
            try {
                const tempcanvas = _abstractEngine_js__WEBPACK_IMPORTED_MODULE_8__.AbstractEngine._CreateCanvas(1, 1);
                const gl = tempcanvas.getContext("webgl", { failIfMajorPerformanceCaveat: true }) ||
                    tempcanvas.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: true });
                this._HasMajorPerformanceCaveat = !gl;
            }
            catch (e) {
                this._HasMajorPerformanceCaveat = false;
            }
        }
        return this._HasMajorPerformanceCaveat;
    }
}
ThinEngine._TempClearColorUint32 = new Uint32Array(4);
ThinEngine._TempClearColorInt32 = new Int32Array(4);
/** Use this array to turn off some WebGL2 features on known buggy browsers version */
ThinEngine.ExceptionList = [
    { key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] },
    { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: "Chrome/12\\d\\..+?Mobile", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    // desktop osx safari 15.4
    { key: ".*AppleWebKit.*(15.4).*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] },
    // mobile browsers using safari 15.4 on ios
    { key: ".*(15.4).*AppleWebKit.*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] },
];
// eslint-disable-next-line @typescript-eslint/naming-convention
ThinEngine._ConcatenateShader = _abstractEngine_functions_js__WEBPACK_IMPORTED_MODULE_12__._ConcatenateShader;
// Statics
ThinEngine._IsSupported = null;
ThinEngine._HasMajorPerformanceCaveat = null;
//# sourceMappingURL=thinEngine.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RenderTargetTexture: () => (/* binding */ RenderTargetTexture)
/* harmony export */ });
/* harmony import */ var _Misc_observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Misc/observable.js */ "./node_modules/@babylonjs/core/Misc/observable.js");
/* harmony import */ var _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Maths/math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");
/* harmony import */ var _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Materials/Textures/texture.js */ "./node_modules/@babylonjs/core/Materials/Textures/texture.js");
/* harmony import */ var _PostProcesses_postProcessManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../PostProcesses/postProcessManager.js */ "./node_modules/@babylonjs/core/PostProcesses/postProcessManager.js");
/* harmony import */ var _Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Misc/tools.functions.js */ "./node_modules/@babylonjs/core/Misc/tools.functions.js");
/* harmony import */ var _effect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../effect.js */ "./node_modules/@babylonjs/core/Materials/effect.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _Rendering_objectRenderer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../Rendering/objectRenderer.js */ "./node_modules/@babylonjs/core/Rendering/objectRenderer.js");









/**
 * Sets a depth stencil texture from a render target on the engine to be used in the shader.
 * @param channel Name of the sampler variable.
 * @param texture Texture to set.
 */
_effect_js__WEBPACK_IMPORTED_MODULE_5__.Effect.prototype.setDepthStencilTexture = function (channel, texture) {
    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
};
/**
 * This Helps creating a texture that will be created from a camera in your scene.
 * It is basically a dynamic texture that could be used to create special effects for instance.
 * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...
 */
class RenderTargetTexture extends _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture {
    /**
     * Use this predicate to dynamically define the list of mesh you want to render.
     * If set, the renderList property will be overwritten.
     */
    get renderListPredicate() {
        return this._objectRenderer.renderListPredicate;
    }
    set renderListPredicate(value) {
        this._objectRenderer.renderListPredicate = value;
    }
    /**
     * Use this list to define the list of mesh you want to render.
     */
    get renderList() {
        return this._objectRenderer.renderList;
    }
    set renderList(value) {
        this._objectRenderer.renderList = value;
    }
    /**
     * Define the list of particle systems to render in the texture. If not provided, will render all the particle systems of the scene.
     * Note that the particle systems are rendered only if renderParticles is set to true.
     */
    get particleSystemList() {
        return this._objectRenderer.particleSystemList;
    }
    set particleSystemList(value) {
        this._objectRenderer.particleSystemList = value;
    }
    /**
     * Use this function to overload the renderList array at rendering time.
     * Return null to render with the current renderList, else return the list of meshes to use for rendering.
     * For 2DArray RTT, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of
     * the cube (if the RTT is a cube, else layerOrFace=0).
     * The renderList passed to the function is the current render list (the one that will be used if the function returns null).
     * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can
     * hold dummy elements!
     */
    get getCustomRenderList() {
        return this._objectRenderer.getCustomRenderList;
    }
    set getCustomRenderList(value) {
        this._objectRenderer.getCustomRenderList = value;
    }
    /**
     * Define if particles should be rendered in your texture (default: true).
     */
    get renderParticles() {
        return this._objectRenderer.renderParticles;
    }
    set renderParticles(value) {
        this._objectRenderer.renderParticles = value;
    }
    /**
     * Define if sprites should be rendered in your texture (default: false).
     */
    get renderSprites() {
        return this._objectRenderer.renderSprites;
    }
    set renderSprites(value) {
        this._objectRenderer.renderSprites = value;
    }
    /**
     * Force checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined) (default: false).
     */
    get forceLayerMaskCheck() {
        return this._objectRenderer.forceLayerMaskCheck;
    }
    set forceLayerMaskCheck(value) {
        this._objectRenderer.forceLayerMaskCheck = value;
    }
    /**
     * Define the camera used to render the texture.
     */
    get activeCamera() {
        return this._objectRenderer.activeCamera;
    }
    set activeCamera(value) {
        this._objectRenderer.activeCamera = value;
    }
    /**
     * Define the camera used to calculate the LOD of the objects.
     * If not defined, activeCamera will be used. If not defined nor activeCamera, scene's active camera will be used.
     */
    get cameraForLOD() {
        return this._objectRenderer.cameraForLOD;
    }
    set cameraForLOD(value) {
        this._objectRenderer.cameraForLOD = value;
    }
    /**
     * If true, the renderer will render all objects without any image processing applied.
     * If false (default value), the renderer will use the current setting of the scene's image processing configuration.
     */
    get disableImageProcessing() {
        return this._objectRenderer.disableImageProcessing;
    }
    set disableImageProcessing(value) {
        this._objectRenderer.disableImageProcessing = value;
    }
    /**
     * Override the mesh isReady function with your own one.
     */
    get customIsReadyFunction() {
        return this._objectRenderer.customIsReadyFunction;
    }
    set customIsReadyFunction(value) {
        this._objectRenderer.customIsReadyFunction = value;
    }
    /**
     * Override the render function of the texture with your own one.
     */
    get customRenderFunction() {
        return this._objectRenderer.customRenderFunction;
    }
    set customRenderFunction(value) {
        this._objectRenderer.customRenderFunction = value;
    }
    /**
     * Post-processes for this render target
     */
    get postProcesses() {
        return this._postProcesses;
    }
    get _prePassEnabled() {
        return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;
    }
    /**
     * Set a after unbind callback in the texture.
     * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.
     */
    set onAfterUnbind(callback) {
        if (this._onAfterUnbindObserver) {
            this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
        }
        this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);
    }
    /**
     * An event triggered before rendering the texture
     */
    get onBeforeRenderObservable() {
        return this._objectRenderer.onBeforeRenderObservable;
    }
    /**
     * Set a before render callback in the texture.
     * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.
     */
    set onBeforeRender(callback) {
        if (this._onBeforeRenderObserver) {
            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
        }
        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
    }
    /**
     * An event triggered after rendering the texture
     */
    get onAfterRenderObservable() {
        return this._objectRenderer.onAfterRenderObservable;
    }
    /**
     * Set a after render callback in the texture.
     * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.
     */
    set onAfterRender(callback) {
        if (this._onAfterRenderObserver) {
            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
        }
        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
    }
    /**
     * Set a clear callback in the texture.
     * This has been kept for backward compatibility and use of onClearObservable is recommended.
     */
    set onClear(callback) {
        if (this._onClearObserver) {
            this.onClearObservable.remove(this._onClearObserver);
        }
        this._onClearObserver = this.onClearObservable.add(callback);
    }
    /** @internal */
    get _waitingRenderList() {
        return this._objectRenderer._waitingRenderList;
    }
    /** @internal */
    set _waitingRenderList(value) {
        this._objectRenderer._waitingRenderList = value;
    }
    /**
     * Current render pass id of the render target texture. Note it can change over the rendering as there's a separate id for each face of a cube / each layer of an array layer!
     */
    get renderPassId() {
        return this._objectRenderer.renderPassId;
    }
    /**
     * Gets the render pass ids used by the render target texture. For a single render target the array length will be 1, for a cube texture it will be 6 and for
     * a 2D texture array it will return an array of ids the size of the 2D texture array
     */
    get renderPassIds() {
        return this._objectRenderer.renderPassIds;
    }
    /**
     * Gets the current value of the refreshId counter
     */
    get currentRefreshId() {
        return this._objectRenderer.currentRefreshId;
    }
    /**
     * Sets a specific material to be used to render a mesh/a list of meshes in this render target texture
     * @param mesh mesh or array of meshes
     * @param material material or array of materials to use for this render pass. If undefined is passed, no specific material will be used but the regular material instead (mesh.material). It's possible to provide an array of materials to use a different material for each rendering in the case of a cube texture (6 rendering) and a 2D texture array (as many rendering as the length of the array)
     */
    setMaterialForRendering(mesh, material) {
        this._objectRenderer.setMaterialForRendering(mesh, material);
    }
    /**
     * Define if the texture has multiple draw buffers or if false a single draw buffer.
     */
    get isMulti() {
        return this._renderTarget?.isMulti ?? false;
    }
    /**
     * Gets render target creation options that were used.
     */
    get renderTargetOptions() {
        return this._renderTargetOptions;
    }
    /**
     * Gets the render target wrapper associated with this render target
     */
    get renderTarget() {
        return this._renderTarget;
    }
    _onRatioRescale() {
        if (this._sizeRatio) {
            this.resize(this._initialSizeParameter);
        }
    }
    /**
     * Gets or sets the size of the bounding box associated with the texture (when in cube mode)
     * When defined, the cubemap will switch to local mode
     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
     * @example https://www.babylonjs-playground.com/#RNASML
     */
    set boundingBoxSize(value) {
        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
            return;
        }
        this._boundingBoxSize = value;
        const scene = this.getScene();
        if (scene) {
            scene.markAllMaterialsAsDirty(1);
        }
    }
    get boundingBoxSize() {
        return this._boundingBoxSize;
    }
    /**
     * In case the RTT has been created with a depth texture, get the associated
     * depth texture.
     * Otherwise, return null.
     */
    get depthStencilTexture() {
        return this._renderTarget?._depthStencilTexture ?? null;
    }
    /** @internal */
    constructor(name, size, scene, generateMipMaps = false, doNotChangeAspectRatio = true, type = 0, isCube = false, samplingMode = _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture.TRILINEAR_SAMPLINGMODE, generateDepthBuffer = true, generateStencilBuffer = false, isMulti = false, format = 5, delayAllocation = false, samples, creationFlags, noColorAttachment = false, useSRGBBuffer = false) {
        let colorAttachment = undefined;
        let gammaSpace = true;
        let existingObjectRenderer = undefined;
        if (typeof generateMipMaps === "object") {
            const options = generateMipMaps;
            generateMipMaps = !!options.generateMipMaps;
            doNotChangeAspectRatio = options.doNotChangeAspectRatio ?? true;
            type = options.type ?? 0;
            isCube = !!options.isCube;
            samplingMode = options.samplingMode ?? _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture.TRILINEAR_SAMPLINGMODE;
            generateDepthBuffer = options.generateDepthBuffer ?? true;
            generateStencilBuffer = !!options.generateStencilBuffer;
            isMulti = !!options.isMulti;
            format = options.format ?? 5;
            delayAllocation = !!options.delayAllocation;
            samples = options.samples;
            creationFlags = options.creationFlags;
            noColorAttachment = !!options.noColorAttachment;
            useSRGBBuffer = !!options.useSRGBBuffer;
            colorAttachment = options.colorAttachment;
            gammaSpace = options.gammaSpace ?? gammaSpace;
            existingObjectRenderer = options.existingObjectRenderer;
        }
        super(null, scene, !generateMipMaps, undefined, samplingMode, undefined, undefined, undefined, undefined, format);
        /**
         * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.
         */
        this.ignoreCameraViewport = false;
        /**
         * An event triggered when the texture is unbind.
         */
        this.onBeforeBindObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * An event triggered when the texture is unbind.
         */
        this.onAfterUnbindObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * An event triggered after the texture clear
         */
        this.onClearObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * An event triggered when the texture is resized.
         */
        this.onResizeObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /** @internal */
        this._cleared = false;
        /**
         * Skip the initial clear of the rtt at the beginning of the frame render loop
         */
        this.skipInitialClear = false;
        this._samples = 1;
        this._canRescale = true;
        this._renderTarget = null;
        this._dontDisposeObjectRenderer = false;
        /**
         * Gets or sets the center of the bounding box associated with the texture (when in cube mode)
         * It must define where the camera used to render the texture is set
         */
        this.boundingBoxPosition = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero();
        /** @internal */
        this._disableEngineStages = false; // TODO: remove this when the shadow generator task (frame graph) is reworked (see https://github.com/BabylonJS/Babylon.js/pull/15962#discussion_r1874417607)
        this._dumpToolsLoading = false;
        scene = this.getScene();
        if (!scene) {
            return;
        }
        const engine = this.getScene().getEngine();
        this._gammaSpace = gammaSpace;
        this._coordinatesMode = _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture.PROJECTION_MODE;
        this.name = name;
        this.isRenderTarget = true;
        this._initialSizeParameter = size;
        this._dontDisposeObjectRenderer = !!existingObjectRenderer;
        this._processSizeParameter(size);
        this._objectRenderer =
            existingObjectRenderer ??
                new _Rendering_objectRenderer_js__WEBPACK_IMPORTED_MODULE_7__.ObjectRenderer(name, scene, {
                    numPasses: isCube ? 6 : this.getRenderLayers() || 1,
                    doNotChangeAspectRatio,
                });
        this._onBeforeRenderingManagerRenderObserver = this._objectRenderer.onBeforeRenderingManagerRenderObservable.add(() => {
            // Before clear
            if (!this._disableEngineStages) {
                for (const step of this._scene._beforeRenderTargetClearStage) {
                    step.action(this, this._currentFaceIndex, this._currentLayer);
                }
            }
            // Clear
            if (this.onClearObservable.hasObservers()) {
                this.onClearObservable.notifyObservers(engine);
            }
            else if (!this.skipInitialClear) {
                engine.clear(this.clearColor || this._scene.clearColor, true, true, true);
            }
            if (!this._doNotChangeAspectRatio) {
                this._scene.updateTransformMatrix(true);
            }
            // Before Camera Draw
            if (!this._disableEngineStages) {
                for (const step of this._scene._beforeRenderTargetDrawStage) {
                    step.action(this, this._currentFaceIndex, this._currentLayer);
                }
            }
        });
        this._onAfterRenderingManagerRenderObserver = this._objectRenderer.onAfterRenderingManagerRenderObservable.add(() => {
            // After Camera Draw
            if (!this._disableEngineStages) {
                for (const step of this._scene._afterRenderTargetDrawStage) {
                    step.action(this, this._currentFaceIndex, this._currentLayer);
                }
            }
            const saveGenerateMipMaps = this._texture?.generateMipMaps ?? false;
            if (this._texture) {
                this._texture.generateMipMaps = false; // if left true, the mipmaps will be generated (if this._texture.generateMipMaps = true) when the first post process binds its own RTT: by doing so it will unbind the current RTT,
                // which will trigger a mipmap generation. We don't want this because it's a wasted work, we will do an unbind of the current RTT at the end of the process (see unbindFrameBuffer) which will
                // trigger the generation of the final mipmaps
            }
            if (this._postProcessManager) {
                this._postProcessManager._finalizeFrame(false, this._renderTarget ?? undefined, this._currentFaceIndex, this._postProcesses, this.ignoreCameraViewport);
            }
            else if (this._currentUseCameraPostProcess) {
                this._scene.postProcessManager._finalizeFrame(false, this._renderTarget ?? undefined, this._currentFaceIndex);
            }
            if (!this._disableEngineStages) {
                for (const step of this._scene._afterRenderTargetPostProcessStage) {
                    step.action(this, this._currentFaceIndex, this._currentLayer);
                }
            }
            if (this._texture) {
                this._texture.generateMipMaps = saveGenerateMipMaps;
            }
            if (!this._doNotChangeAspectRatio) {
                this._scene.updateTransformMatrix(true);
            }
            // Dump ?
            if (this._currentDumpForDebug) {
                if (!this._dumpTools) {
                    _Misc_logger_js__WEBPACK_IMPORTED_MODULE_6__.Logger.Error("dumpTools module is still being loaded. To speed up the process import dump tools directly in your project");
                }
                else {
                    this._dumpTools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);
                }
            }
        });
        this._onFastPathRenderObserver = this._objectRenderer.onFastPathRenderObservable.add(() => {
            if (this.onClearObservable.hasObservers()) {
                this.onClearObservable.notifyObservers(engine);
            }
            else {
                if (!this.skipInitialClear) {
                    engine.clear(this.clearColor || this._scene.clearColor, true, true, true);
                }
            }
        });
        this._resizeObserver = engine.onResizeObservable.add(() => { });
        this._generateMipMaps = generateMipMaps ? true : false;
        this._doNotChangeAspectRatio = doNotChangeAspectRatio;
        if (isMulti) {
            return;
        }
        this._renderTargetOptions = {
            generateMipMaps: generateMipMaps,
            type: type,
            format: this._format ?? undefined,
            samplingMode: this.samplingMode,
            generateDepthBuffer: generateDepthBuffer,
            generateStencilBuffer: generateStencilBuffer,
            samples,
            creationFlags,
            noColorAttachment: noColorAttachment,
            useSRGBBuffer,
            colorAttachment: colorAttachment,
            label: this.name,
        };
        if (this.samplingMode === _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture.NEAREST_SAMPLINGMODE) {
            this.wrapU = _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture.CLAMP_ADDRESSMODE;
            this.wrapV = _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture.CLAMP_ADDRESSMODE;
        }
        if (!delayAllocation) {
            if (isCube) {
                this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);
                this.coordinatesMode = _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture.INVCUBIC_MODE;
                this._textureMatrix = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Matrix.Identity();
            }
            else {
                this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);
            }
            this._texture = this._renderTarget.texture;
            if (samples !== undefined) {
                this.samples = samples;
            }
        }
    }
    /**
     * Creates a depth stencil texture.
     * This is only available in WebGL 2 or with the depth texture extension available.
     * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode (default: 0)
     * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture (default: true)
     * @param generateStencil Specifies whether or not a stencil should be allocated in the texture (default: false)
     * @param samples sample count of the depth/stencil texture (default: 1)
     * @param format format of the depth texture (default: 14)
     * @param label defines the label of the texture (for debugging purpose)
     */
    createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14, label) {
        this._renderTarget?.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format, label);
    }
    _processSizeParameter(size) {
        if (size.ratio) {
            this._sizeRatio = size.ratio;
            const engine = this._getEngine();
            this._size = {
                width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),
                height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio),
            };
        }
        else {
            this._size = size;
        }
    }
    /**
     * Define the number of samples to use in case of MSAA.
     * It defaults to one meaning no MSAA has been enabled.
     */
    get samples() {
        return this._renderTarget?.samples ?? this._samples;
    }
    set samples(value) {
        if (this._renderTarget) {
            this._samples = this._renderTarget.setSamples(value);
        }
    }
    /**
     * Adds a post process to the render target rendering passes.
     * @param postProcess define the post process to add
     */
    addPostProcess(postProcess) {
        if (!this._postProcessManager) {
            const scene = this.getScene();
            if (!scene) {
                return;
            }
            this._postProcessManager = new _PostProcesses_postProcessManager_js__WEBPACK_IMPORTED_MODULE_3__.PostProcessManager(scene);
            this._postProcesses = new Array();
        }
        this._postProcesses.push(postProcess);
        this._postProcesses[0].autoClear = false;
    }
    /**
     * Clear all the post processes attached to the render target
     * @param dispose define if the cleared post processes should also be disposed (false by default)
     */
    clearPostProcesses(dispose = false) {
        if (!this._postProcesses) {
            return;
        }
        if (dispose) {
            for (const postProcess of this._postProcesses) {
                postProcess.dispose();
            }
        }
        this._postProcesses = [];
    }
    /**
     * Remove one of the post process from the list of attached post processes to the texture
     * @param postProcess define the post process to remove from the list
     */
    removePostProcess(postProcess) {
        if (!this._postProcesses) {
            return;
        }
        const index = this._postProcesses.indexOf(postProcess);
        if (index === -1) {
            return;
        }
        this._postProcesses.splice(index, 1);
        if (this._postProcesses.length > 0) {
            this._postProcesses[0].autoClear = false;
        }
    }
    /**
     * Resets the refresh counter of the texture and start bak from scratch.
     * Could be useful to regenerate the texture if it is setup to render only once.
     */
    resetRefreshCounter() {
        this._objectRenderer.resetRefreshCounter();
    }
    /**
     * Define the refresh rate of the texture or the rendering frequency.
     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
     */
    get refreshRate() {
        return this._objectRenderer.refreshRate;
    }
    set refreshRate(value) {
        this._objectRenderer.refreshRate = value;
    }
    /** @internal */
    _shouldRender() {
        return this._objectRenderer.shouldRender();
    }
    /**
     * Gets the actual render size of the texture.
     * @returns the width of the render size
     */
    getRenderSize() {
        return this.getRenderWidth();
    }
    /**
     * Gets the actual render width of the texture.
     * @returns the width of the render size
     */
    getRenderWidth() {
        if (this._size.width) {
            return this._size.width;
        }
        return this._size;
    }
    /**
     * Gets the actual render height of the texture.
     * @returns the height of the render size
     */
    getRenderHeight() {
        if (this._size.width) {
            return this._size.height;
        }
        return this._size;
    }
    /**
     * Gets the actual number of layers of the texture or, in the case of a 3D texture, return the depth.
     * @returns the number of layers
     */
    getRenderLayers() {
        const layers = this._size.layers;
        if (layers) {
            return layers;
        }
        const depth = this._size.depth;
        if (depth) {
            return depth;
        }
        return 0;
    }
    /**
     * Don't allow this render target texture to rescale. Mainly used to prevent rescaling by the scene optimizer.
     */
    disableRescaling() {
        this._canRescale = false;
    }
    /**
     * Get if the texture can be rescaled or not.
     */
    get canRescale() {
        return this._canRescale;
    }
    /**
     * Resize the texture using a ratio.
     * @param ratio the ratio to apply to the texture size in order to compute the new target size
     */
    scale(ratio) {
        const newSize = Math.max(1, this.getRenderSize() * ratio);
        this.resize(newSize);
    }
    /**
     * Get the texture reflection matrix used to rotate/transform the reflection.
     * @returns the reflection matrix
     */
    getReflectionTextureMatrix() {
        if (this.isCube) {
            return this._textureMatrix;
        }
        return super.getReflectionTextureMatrix();
    }
    /**
     * Resize the texture to a new desired size.
     * Be careful as it will recreate all the data in the new texture.
     * @param size Define the new size. It can be:
     *   - a number for squared texture,
     *   - an object containing { width: number, height: number }
     *   - or an object containing a ratio { ratio: number }
     */
    resize(size) {
        const wasCube = this.isCube;
        this._renderTarget?.dispose();
        this._renderTarget = null;
        const scene = this.getScene();
        if (!scene) {
            return;
        }
        this._processSizeParameter(size);
        if (wasCube) {
            this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);
        }
        else {
            this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);
        }
        this._texture = this._renderTarget.texture;
        if (this._renderTargetOptions.samples !== undefined) {
            this.samples = this._renderTargetOptions.samples;
        }
        if (this.onResizeObservable.hasObservers()) {
            this.onResizeObservable.notifyObservers(this);
        }
    }
    /**
     * Renders all the objects from the render list into the texture.
     * @param useCameraPostProcess Define if camera post processes should be used during the rendering
     * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose
     */
    render(useCameraPostProcess = false, dumpForDebug = false) {
        this._render(useCameraPostProcess, dumpForDebug);
    }
    /**
     * This function will check if the render target texture can be rendered (textures are loaded, shaders are compiled)
     * @returns true if all required resources are ready
     */
    isReadyForRendering() {
        if (!this._dumpToolsLoading) {
            this._dumpToolsLoading = true;
            // avoid a static import to allow ignoring the import in some cases
            __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_Misc_dumpTools_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../Misc/dumpTools.js */ "./node_modules/@babylonjs/core/Misc/dumpTools.js")).then((module) => (this._dumpTools = module));
        }
        this._objectRenderer.prepareRenderList();
        this.onBeforeBindObservable.notifyObservers(this);
        this._objectRenderer.initRender(this.getRenderWidth(), this.getRenderHeight());
        const isReady = this._objectRenderer._checkReadiness();
        this.onAfterUnbindObservable.notifyObservers(this);
        this._objectRenderer.finishRender();
        return isReady;
    }
    _render(useCameraPostProcess = false, dumpForDebug = false) {
        const scene = this.getScene();
        if (!scene) {
            return;
        }
        if (this.useCameraPostProcesses !== undefined) {
            useCameraPostProcess = this.useCameraPostProcesses;
        }
        this._objectRenderer.prepareRenderList();
        this.onBeforeBindObservable.notifyObservers(this);
        this._objectRenderer.initRender(this.getRenderWidth(), this.getRenderHeight());
        if ((this.is2DArray || this.is3D) && !this.isMulti) {
            for (let layer = 0; layer < this.getRenderLayers(); layer++) {
                this._renderToTarget(0, useCameraPostProcess, dumpForDebug, layer);
                scene.incrementRenderId();
                scene.resetCachedMaterial();
            }
        }
        else if (this.isCube && !this.isMulti) {
            for (let face = 0; face < 6; face++) {
                this._renderToTarget(face, useCameraPostProcess, dumpForDebug);
                scene.incrementRenderId();
                scene.resetCachedMaterial();
            }
        }
        else {
            this._renderToTarget(0, useCameraPostProcess, dumpForDebug);
        }
        this.onAfterUnbindObservable.notifyObservers(this);
        this._objectRenderer.finishRender();
    }
    _bestReflectionRenderTargetDimension(renderDimension, scale) {
        const minimum = 128;
        const x = renderDimension * scale;
        const curved = (0,_Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_4__.NearestPOT)(x + (minimum * minimum) / (minimum + x));
        // Ensure we don't exceed the render dimension (while staying POT)
        return Math.min((0,_Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_4__.FloorPOT)(renderDimension), curved);
    }
    /**
     * @internal
     * @param faceIndex face index to bind to if this is a cubetexture
     * @param layer defines the index of the texture to bind in the array
     */
    _bindFrameBuffer(faceIndex = 0, layer = 0) {
        const scene = this.getScene();
        if (!scene) {
            return;
        }
        const engine = scene.getEngine();
        if (this._renderTarget) {
            engine.bindFramebuffer(this._renderTarget, this.isCube ? faceIndex : undefined, undefined, undefined, this.ignoreCameraViewport, 0, layer);
        }
    }
    _unbindFrameBuffer(engine, faceIndex) {
        if (!this._renderTarget) {
            return;
        }
        engine.unBindFramebuffer(this._renderTarget, this.isCube, () => {
            this.onAfterRenderObservable.notifyObservers(faceIndex);
        });
    }
    /**
     * @internal
     */
    _prepareFrame(scene, faceIndex, layer, useCameraPostProcess) {
        if (this._postProcessManager) {
            if (!this._prePassEnabled) {
                this._postProcessManager._prepareFrame(this._texture, this._postProcesses);
            }
        }
        else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {
            this._bindFrameBuffer(faceIndex, layer);
        }
    }
    _renderToTarget(faceIndex, useCameraPostProcess, dumpForDebug, layer = 0) {
        const scene = this.getScene();
        if (!scene) {
            return;
        }
        const engine = scene.getEngine();
        this._currentFaceIndex = faceIndex;
        this._currentLayer = layer;
        this._currentUseCameraPostProcess = useCameraPostProcess;
        this._currentDumpForDebug = dumpForDebug;
        this._prepareFrame(scene, faceIndex, layer, useCameraPostProcess);
        engine._debugPushGroup?.(`render to face #${faceIndex} layer #${layer}`, 2);
        this._objectRenderer.render(faceIndex + layer, true); // only faceIndex or layer (if any) will be different from 0 (we don't support array of cubes), so it's safe to add them to get the pass index
        engine._debugPopGroup?.(2);
        this._unbindFrameBuffer(engine, faceIndex);
        if (this._texture && this.isCube && faceIndex === 5) {
            engine.generateMipMapsForCubemap(this._texture, true);
        }
    }
    /**
     * Overrides the default sort function applied in the rendering group to prepare the meshes.
     * This allowed control for front to back rendering or reversely depending of the special needs.
     *
     * @param renderingGroupId The rendering group id corresponding to its index
     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
     * @param transparentSortCompareFn The transparent queue comparison function use to sort.
     */
    setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
        this._objectRenderer.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
    }
    /**
     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
     *
     * @param renderingGroupId The rendering group id corresponding to its index
     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
     */
    setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {
        this._objectRenderer.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);
    }
    /**
     * Clones the texture.
     * @returns the cloned texture
     */
    clone() {
        const textureSize = this.getSize();
        const newTexture = new RenderTargetTexture(this.name, textureSize, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, undefined, this._renderTargetOptions.format, undefined, this._renderTargetOptions.samples);
        // Base texture
        newTexture.hasAlpha = this.hasAlpha;
        newTexture.level = this.level;
        // RenderTarget Texture
        newTexture.coordinatesMode = this.coordinatesMode;
        if (this.renderList) {
            newTexture.renderList = this.renderList.slice(0);
        }
        return newTexture;
    }
    /**
     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.
     * @returns The JSON representation of the texture
     */
    serialize() {
        if (!this.name) {
            return null;
        }
        const serializationObject = super.serialize();
        serializationObject.renderTargetSize = this.getRenderSize();
        serializationObject.renderList = [];
        if (this.renderList) {
            for (let index = 0; index < this.renderList.length; index++) {
                serializationObject.renderList.push(this.renderList[index].id);
            }
        }
        return serializationObject;
    }
    /**
     *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore
     */
    disposeFramebufferObjects() {
        this._renderTarget?.dispose(true);
    }
    /**
     * Release and destroy the underlying lower level texture aka internalTexture.
     */
    releaseInternalTexture() {
        this._renderTarget?.releaseTextures();
        this._texture = null;
    }
    /**
     * Dispose the texture and release its associated resources.
     */
    dispose() {
        this.onResizeObservable.clear();
        this.onClearObservable.clear();
        this.onAfterUnbindObservable.clear();
        this.onBeforeBindObservable.clear();
        if (this._postProcessManager) {
            this._postProcessManager.dispose();
            this._postProcessManager = null;
        }
        if (this._prePassRenderTarget) {
            this._prePassRenderTarget.dispose();
        }
        this._objectRenderer.onBeforeRenderingManagerRenderObservable.remove(this._onBeforeRenderingManagerRenderObserver);
        this._objectRenderer.onAfterRenderingManagerRenderObservable.remove(this._onAfterRenderingManagerRenderObserver);
        this._objectRenderer.onFastPathRenderObservable.remove(this._onFastPathRenderObserver);
        if (!this._dontDisposeObjectRenderer) {
            this._objectRenderer.dispose();
        }
        this.clearPostProcesses(true);
        if (this._resizeObserver) {
            this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver);
            this._resizeObserver = null;
        }
        // Remove from custom render targets
        const scene = this.getScene();
        if (!scene) {
            return;
        }
        let index = scene.customRenderTargets.indexOf(this);
        if (index >= 0) {
            scene.customRenderTargets.splice(index, 1);
        }
        for (const camera of scene.cameras) {
            index = camera.customRenderTargets.indexOf(this);
            if (index >= 0) {
                camera.customRenderTargets.splice(index, 1);
            }
        }
        this._renderTarget?.dispose();
        this._renderTarget = null;
        this._texture = null;
        super.dispose();
    }
    /** @internal */
    _rebuild() {
        this._objectRenderer._rebuild();
        if (this._postProcessManager) {
            this._postProcessManager._rebuild();
        }
    }
    /**
     * Clear the info related to rendering groups preventing retention point in material dispose.
     */
    freeRenderingGroups() {
        this._objectRenderer.freeRenderingGroups();
    }
    /**
     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)
     * @returns the view count
     */
    getViewCount() {
        return 1;
    }
}
/**
 * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.
 */
RenderTargetTexture.REFRESHRATE_RENDER_ONCE = _Rendering_objectRenderer_js__WEBPACK_IMPORTED_MODULE_7__.ObjectRenderer.REFRESHRATE_RENDER_ONCE;
/**
 * The texture will be rendered every frame and is recommended for dynamic contents.
 */
RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME = _Rendering_objectRenderer_js__WEBPACK_IMPORTED_MODULE_7__.ObjectRenderer.REFRESHRATE_RENDER_ONEVERYFRAME;
/**
 * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not
 * the central point of your effect and can save a lot of performances.
 */
RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = _Rendering_objectRenderer_js__WEBPACK_IMPORTED_MODULE_7__.ObjectRenderer.REFRESHRATE_RENDER_ONEVERYTWOFRAMES;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture._CreateRenderTargetTexture = (name, renderTargetSize, scene, generateMipMaps, creationFlags) => {
    return new RenderTargetTexture(name, renderTargetSize, scene, generateMipMaps);
};
//# sourceMappingURL=renderTargetTexture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/textureHelper.functions.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/textureHelper.functions.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GetTypeForDepthTexture: () => (/* binding */ GetTypeForDepthTexture),
/* harmony export */   HasStencilAspect: () => (/* binding */ HasStencilAspect),
/* harmony export */   IsDepthTexture: () => (/* binding */ IsDepthTexture)
/* harmony export */ });

/**
 * Checks if a given format is a depth texture format
 * @param format Format to check
 * @returns True if the format is a depth texture format
 */
function IsDepthTexture(format) {
    return (format === 13 ||
        format === 14 ||
        format === 15 ||
        format === 16 ||
        format === 17 ||
        format === 18 ||
        format === 19);
}
/**
 * Gets the type of a depth texture for a given format
 * @param format Format of the texture
 * @returns The type of the depth texture
 */
function GetTypeForDepthTexture(format) {
    switch (format) {
        case 13:
        case 17:
        case 18:
        case 14:
        case 16:
            return 1;
        case 15:
            return 5;
        case 19:
            return 0;
    }
    return 0;
}
/**
 * Checks if a given format has a stencil aspect
 * @param format Format to check
 * @returns True if the format has a stencil aspect
 */
function HasStencilAspect(format) {
    return (format === 13 ||
        format === 17 ||
        format === 18 ||
        format === 19);
}
//# sourceMappingURL=textureHelper.functions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/drawWrapper.functions.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/drawWrapper.functions.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IsWrapper: () => (/* binding */ IsWrapper)
/* harmony export */ });
/**
 * Detect if the effect is a DrawWrapper
 * @param effect defines the entity to test
 * @returns if the entity is a DrawWrapper
 */
function IsWrapper(effect) {
    return effect.getPipelineContext === undefined;
}
//# sourceMappingURL=drawWrapper.functions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/drawWrapper.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/drawWrapper.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DrawWrapper: () => (/* binding */ DrawWrapper)
/* harmony export */ });
/* harmony import */ var _Misc_timingTools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Misc/timingTools.js */ "./node_modules/@babylonjs/core/Misc/timingTools.js");

/** @internal */
class DrawWrapper {
    static GetEffect(effect) {
        return effect.getPipelineContext === undefined ? effect.effect : effect;
    }
    constructor(engine, createMaterialContext = true) {
        /**
         * @internal
         * Specifies if the effect was previously ready
         */
        this._wasPreviouslyReady = false;
        /**
         * @internal
         * Forces the code from bindForSubMesh to be fully run the next time it is called
         */
        this._forceRebindOnNextCall = true;
        /**
         * @internal
         * Specifies if the effect was previously using instances
         */
        this._wasPreviouslyUsingInstances = null;
        this.effect = null;
        this.defines = null;
        this.drawContext = engine.createDrawContext();
        if (createMaterialContext) {
            this.materialContext = engine.createMaterialContext();
        }
    }
    setEffect(effect, defines, resetContext = true) {
        this.effect = effect;
        if (defines !== undefined) {
            this.defines = defines;
        }
        if (resetContext) {
            this.drawContext?.reset();
        }
    }
    /**
     * Dispose the effect wrapper and its resources
     * @param immediate if the effect should be disposed immediately or on the next frame.
     * If dispose() is not called during a scene or engine dispose, we want to delay the dispose of the underlying effect. Mostly to give a chance to user code to reuse the effect in some way.
     */
    dispose(immediate = false) {
        if (this.effect) {
            const effect = this.effect;
            if (immediate) {
                effect.dispose();
            }
            else {
                _Misc_timingTools_js__WEBPACK_IMPORTED_MODULE_0__.TimingTools.SetImmediate(() => {
                    effect.getEngine().onEndFrameObservable.addOnce(() => {
                        effect.dispose();
                    });
                });
            }
            this.effect = null;
        }
        this.drawContext?.dispose();
    }
}
//# sourceMappingURL=drawWrapper.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/effectRenderer.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/effectRenderer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EffectRenderer: () => (/* binding */ EffectRenderer),
/* harmony export */   EffectWrapper: () => (/* binding */ EffectWrapper)
/* harmony export */ });
/* harmony import */ var _Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Buffers/buffer.js */ "./node_modules/@babylonjs/core/Buffers/buffer.js");
/* harmony import */ var _Maths_math_viewport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Maths/math.viewport.js */ "./node_modules/@babylonjs/core/Maths/math.viewport.js");
/* harmony import */ var _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Misc/observable.js */ "./node_modules/@babylonjs/core/Misc/observable.js");
/* harmony import */ var _effect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./effect.js */ "./node_modules/@babylonjs/core/Materials/effect.js");
/* harmony import */ var _drawWrapper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawWrapper.js */ "./node_modules/@babylonjs/core/Materials/drawWrapper.js");
/* harmony import */ var _Shaders_postprocess_vertex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Shaders/postprocess.vertex.js */ "./node_modules/@babylonjs/core/Shaders/postprocess.vertex.js");






// Prevents ES6 issue if not imported.

// Fullscreen quad buffers by default.
const DefaultOptions = {
    positions: [1, 1, -1, 1, -1, -1, 1, -1],
    indices: [0, 1, 2, 0, 2, 3],
};
/**
 * Helper class to render one or more effects.
 * You can access the previous rendering in your shader by declaring a sampler named textureSampler
 */
class EffectRenderer {
    /**
     * Creates an effect renderer
     * @param engine the engine to use for rendering
     * @param options defines the options of the effect renderer
     */
    constructor(engine, options = DefaultOptions) {
        this._fullscreenViewport = new _Maths_math_viewport_js__WEBPACK_IMPORTED_MODULE_1__.Viewport(0, 0, 1, 1);
        const positions = options.positions ?? DefaultOptions.positions;
        const indices = options.indices ?? DefaultOptions.indices;
        this.engine = engine;
        this._vertexBuffers = {
            [_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind]: new _Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer(engine, positions, _Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind, false, false, 2),
        };
        this._indexBuffer = engine.createIndexBuffer(indices);
        this._onContextRestoredObserver = engine.onContextRestoredObservable.add(() => {
            this._indexBuffer = engine.createIndexBuffer(indices);
            for (const key in this._vertexBuffers) {
                const vertexBuffer = this._vertexBuffers[key];
                vertexBuffer._rebuild();
            }
        });
    }
    /**
     * Sets the current viewport in normalized coordinates 0-1
     * @param viewport Defines the viewport to set (defaults to 0 0 1 1)
     */
    setViewport(viewport = this._fullscreenViewport) {
        this.engine.setViewport(viewport);
    }
    /**
     * Binds the embedded attributes buffer to the effect.
     * @param effect Defines the effect to bind the attributes for
     */
    bindBuffers(effect) {
        this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
    }
    /**
     * Sets the current effect wrapper to use during draw.
     * The effect needs to be ready before calling this api.
     * This also sets the default full screen position attribute.
     * @param effectWrapper Defines the effect to draw with
     */
    applyEffectWrapper(effectWrapper) {
        this.engine.setState(true);
        this.engine.depthCullingState.depthTest = false;
        this.engine.stencilState.stencilTest = false;
        this.engine.enableEffect(effectWrapper.drawWrapper);
        this.bindBuffers(effectWrapper.effect);
        effectWrapper.onApplyObservable.notifyObservers({});
    }
    /**
     * Saves engine states
     */
    saveStates() {
        this._savedStateDepthTest = this.engine.depthCullingState.depthTest;
        this._savedStateStencilTest = this.engine.stencilState.stencilTest;
    }
    /**
     * Restores engine states
     */
    restoreStates() {
        this.engine.depthCullingState.depthTest = this._savedStateDepthTest;
        this.engine.stencilState.stencilTest = this._savedStateStencilTest;
    }
    /**
     * Draws a full screen quad.
     */
    draw() {
        this.engine.drawElementsType(0, 0, 6);
    }
    _isRenderTargetTexture(texture) {
        return texture.renderTarget !== undefined;
    }
    /**
     * renders one or more effects to a specified texture
     * @param effectWrapper the effect to renderer
     * @param outputTexture texture to draw to, if null it will render to the currently bound frame buffer
     */
    render(effectWrapper, outputTexture = null) {
        // Ensure effect is ready
        if (!effectWrapper.effect.isReady()) {
            return;
        }
        this.saveStates();
        // Reset state
        this.setViewport();
        const out = outputTexture === null ? null : this._isRenderTargetTexture(outputTexture) ? outputTexture.renderTarget : outputTexture;
        if (out) {
            this.engine.bindFramebuffer(out);
        }
        this.applyEffectWrapper(effectWrapper);
        this.draw();
        if (out) {
            this.engine.unBindFramebuffer(out);
        }
        this.restoreStates();
    }
    /**
     * Disposes of the effect renderer
     */
    dispose() {
        const vertexBuffer = this._vertexBuffers[_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind];
        if (vertexBuffer) {
            vertexBuffer.dispose();
            delete this._vertexBuffers[_Buffers_buffer_js__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind];
        }
        if (this._indexBuffer) {
            this.engine._releaseBuffer(this._indexBuffer);
        }
        if (this._onContextRestoredObserver) {
            this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver);
            this._onContextRestoredObserver = null;
        }
    }
}
/**
 * Wraps an effect to be used for rendering
 */
class EffectWrapper {
    /**
     * Registers a shader code processing with an effect wrapper name.
     * @param effectWrapperName name of the effect wrapper. Use null for the fallback shader code processing. This is the shader code processing that will be used in case no specific shader code processing has been associated to an effect wrapper name
     * @param customShaderCodeProcessing shader code processing to associate to the effect wrapper name
     */
    static RegisterShaderCodeProcessing(effectWrapperName, customShaderCodeProcessing) {
        if (!customShaderCodeProcessing) {
            delete EffectWrapper._CustomShaderCodeProcessing[effectWrapperName ?? ""];
            return;
        }
        EffectWrapper._CustomShaderCodeProcessing[effectWrapperName ?? ""] = customShaderCodeProcessing;
    }
    static _GetShaderCodeProcessing(effectWrapperName) {
        return EffectWrapper._CustomShaderCodeProcessing[effectWrapperName] ?? EffectWrapper._CustomShaderCodeProcessing[""];
    }
    /**
     * Gets or sets the name of the effect wrapper
     */
    get name() {
        return this.options.name;
    }
    set name(value) {
        this.options.name = value;
    }
    /**
     * Get a value indicating if the effect is ready to be used
     * @returns true if the post-process is ready (shader is compiled)
     */
    isReady() {
        return this._drawWrapper.effect?.isReady() ?? false;
    }
    /**
     * Get the draw wrapper associated with the effect wrapper
     * @returns the draw wrapper associated with the effect wrapper
     */
    get drawWrapper() {
        return this._drawWrapper;
    }
    /**
     * The underlying effect
     */
    get effect() {
        return this._drawWrapper.effect;
    }
    set effect(effect) {
        this._drawWrapper.effect = effect;
    }
    /**
     * Creates an effect to be rendered
     * @param creationOptions options to create the effect
     */
    constructor(creationOptions) {
        /**
         * Type of alpha mode to use when applying the effect (default: Engine.ALPHA_DISABLE). Used only if useAsPostProcess is true.
         */
        this.alphaMode = 0;
        /**
         * Executed when the effect is created
         * @returns effect that was created for this effect wrapper
         */
        this.onEffectCreatedObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable(undefined, true);
        /**
         * Event that is fired (only when the EffectWrapper is used with an EffectRenderer) right before the effect is drawn (should be used to update uniforms)
         */
        this.onApplyObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable();
        this._shadersLoaded = false;
        /** @internal */
        this._webGPUReady = false;
        this._importPromises = [];
        this.options = {
            ...creationOptions,
            name: creationOptions.name || "effectWrapper",
            engine: creationOptions.engine,
            uniforms: creationOptions.uniforms || creationOptions.uniformNames || [],
            uniformNames: undefined,
            samplers: creationOptions.samplers || creationOptions.samplerNames || [],
            samplerNames: undefined,
            attributeNames: creationOptions.attributeNames || ["position"],
            uniformBuffers: creationOptions.uniformBuffers || [],
            defines: creationOptions.defines || "",
            useShaderStore: creationOptions.useShaderStore || false,
            vertexUrl: creationOptions.vertexUrl || creationOptions.vertexShader || "postprocess",
            vertexShader: undefined,
            fragmentShader: creationOptions.fragmentShader || "pass",
            indexParameters: creationOptions.indexParameters,
            blockCompilation: creationOptions.blockCompilation || false,
            shaderLanguage: creationOptions.shaderLanguage || 0 /* ShaderLanguage.GLSL */,
            onCompiled: creationOptions.onCompiled || undefined,
            extraInitializations: creationOptions.extraInitializations || undefined,
            extraInitializationsAsync: creationOptions.extraInitializationsAsync || undefined,
            useAsPostProcess: creationOptions.useAsPostProcess ?? false,
        };
        this.options.uniformNames = this.options.uniforms;
        this.options.samplerNames = this.options.samplers;
        this.options.vertexShader = this.options.vertexUrl;
        if (this.options.useAsPostProcess) {
            if (this.options.samplers.indexOf("textureSampler") === -1) {
                this.options.samplers.push("textureSampler");
            }
            if (this.options.uniforms.indexOf("scale") === -1) {
                this.options.uniforms.push("scale");
            }
        }
        if (creationOptions.vertexUrl || creationOptions.vertexShader) {
            this._shaderPath = {
                vertexSource: this.options.vertexShader,
            };
        }
        else {
            if (!this.options.useAsPostProcess) {
                this.options.uniforms.push("scale");
                this.onApplyObservable.add(() => {
                    this.effect.setFloat2("scale", 1, 1);
                });
            }
            this._shaderPath = {
                vertex: this.options.vertexShader,
            };
        }
        this._shaderPath.fragmentSource = this.options.fragmentShader;
        this._shaderPath.spectorName = this.options.name;
        if (this.options.useShaderStore) {
            this._shaderPath.fragment = this._shaderPath.fragmentSource;
            if (!this._shaderPath.vertex) {
                this._shaderPath.vertex = this._shaderPath.vertexSource;
            }
            delete this._shaderPath.fragmentSource;
            delete this._shaderPath.vertexSource;
        }
        this.onApplyObservable.add(() => {
            this.bind();
        });
        if (!this.options.useShaderStore) {
            this._onContextRestoredObserver = this.options.engine.onContextRestoredObservable.add(() => {
                this.effect._pipelineContext = null; // because _prepareEffect will try to dispose this pipeline before recreating it and that would lead to webgl errors
                this.effect._prepareEffect();
            });
        }
        this._drawWrapper = new _drawWrapper_js__WEBPACK_IMPORTED_MODULE_4__.DrawWrapper(this.options.engine);
        this._webGPUReady = this.options.shaderLanguage === 1 /* ShaderLanguage.WGSL */;
        const defines = Array.isArray(this.options.defines) ? this.options.defines.join("\n") : this.options.defines;
        this._postConstructor(this.options.blockCompilation, defines, this.options.extraInitializations);
    }
    _gatherImports(useWebGPU = false, list) {
        if (!this.options.useAsPostProcess) {
            return;
        }
        // this._webGPUReady is used to detect when an effect wrapper is intended to be used with WebGPU
        if (useWebGPU && this._webGPUReady) {
            list.push(Promise.all([__webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_ShadersWGSL_postprocess_vertex_js").then(__webpack_require__.bind(__webpack_require__, /*! ../ShadersWGSL/postprocess.vertex.js */ "./node_modules/@babylonjs/core/ShadersWGSL/postprocess.vertex.js"))]));
        }
        else {
            list.push(Promise.all([Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../Shaders/postprocess.vertex.js */ "./node_modules/@babylonjs/core/Shaders/postprocess.vertex.js"))]));
        }
    }
    /** @internal */
    _postConstructor(blockCompilation, defines = null, extraInitializations, importPromises) {
        this._importPromises.length = 0;
        if (importPromises) {
            this._importPromises.push(...importPromises);
        }
        const useWebGPU = this.options.engine.isWebGPU && !EffectWrapper.ForceGLSL;
        this._gatherImports(useWebGPU, this._importPromises);
        if (extraInitializations !== undefined) {
            extraInitializations(useWebGPU, this._importPromises);
        }
        if (useWebGPU && this._webGPUReady) {
            this.options.shaderLanguage = 1 /* ShaderLanguage.WGSL */;
        }
        if (!blockCompilation) {
            this.updateEffect(defines);
        }
    }
    /**
     * Updates the effect with the current effect wrapper compile time values and recompiles the shader.
     * @param defines Define statements that should be added at the beginning of the shader. (default: null)
     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
     * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
     * @param onCompiled Called when the shader has been compiled.
     * @param onError Called if there is an error when compiling a shader.
     * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)
     * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)
     */
    updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {
        const customShaderCodeProcessing = EffectWrapper._GetShaderCodeProcessing(this.name);
        if (customShaderCodeProcessing?.defineCustomBindings) {
            const newUniforms = uniforms?.slice() ?? [];
            newUniforms.push(...this.options.uniforms);
            const newSamplers = samplers?.slice() ?? [];
            newSamplers.push(...this.options.samplers);
            defines = customShaderCodeProcessing.defineCustomBindings(this.name, defines, newUniforms, newSamplers);
            uniforms = newUniforms;
            samplers = newSamplers;
        }
        this.options.defines = defines || "";
        const waitImportsLoaded = this._shadersLoaded || this._importPromises.length === 0
            ? undefined
            : async () => {
                await Promise.all(this._importPromises);
                this._shadersLoaded = true;
            };
        let extraInitializationsAsync;
        if (this.options.extraInitializationsAsync) {
            extraInitializationsAsync = async () => {
                waitImportsLoaded?.();
                await this.options.extraInitializationsAsync();
            };
        }
        else {
            extraInitializationsAsync = waitImportsLoaded;
        }
        if (this.options.useShaderStore) {
            this._drawWrapper.effect = this.options.engine.createEffect({ vertex: vertexUrl ?? this._shaderPath.vertex, fragment: fragmentUrl ?? this._shaderPath.fragment }, {
                attributes: this.options.attributeNames,
                uniformsNames: uniforms || this.options.uniforms,
                uniformBuffersNames: this.options.uniformBuffers,
                samplers: samplers || this.options.samplers,
                defines: defines !== null ? defines : "",
                fallbacks: null,
                onCompiled: onCompiled ?? this.options.onCompiled,
                onError: onError ?? null,
                indexParameters: indexParameters || this.options.indexParameters,
                processCodeAfterIncludes: customShaderCodeProcessing?.processCodeAfterIncludes
                    ? (shaderType, code) => customShaderCodeProcessing.processCodeAfterIncludes(this.name, shaderType, code)
                    : null,
                processFinalCode: customShaderCodeProcessing?.processFinalCode
                    ? (shaderType, code) => customShaderCodeProcessing.processFinalCode(this.name, shaderType, code)
                    : null,
                shaderLanguage: this.options.shaderLanguage,
                extraInitializationsAsync,
            }, this.options.engine);
        }
        else {
            this._drawWrapper.effect = new _effect_js__WEBPACK_IMPORTED_MODULE_3__.Effect(this._shaderPath, this.options.attributeNames, uniforms || this.options.uniforms, samplers || this.options.samplerNames, this.options.engine, defines, undefined, onCompiled || this.options.onCompiled, undefined, undefined, undefined, this.options.shaderLanguage, extraInitializationsAsync);
        }
        this.onEffectCreatedObservable.notifyObservers(this._drawWrapper.effect);
    }
    /**
     * Binds the data to the effect.
     * @param noDefaultBindings if true, the default bindings (scale and alpha mode) will not be set.
     */
    bind(noDefaultBindings = false) {
        if (this.options.useAsPostProcess && !noDefaultBindings) {
            this.options.engine.setAlphaMode(this.alphaMode);
            this.drawWrapper.effect.setFloat2("scale", 1, 1);
        }
        EffectWrapper._GetShaderCodeProcessing(this.name)?.bindCustomBindings?.(this.name, this._drawWrapper.effect);
    }
    /**
     * Disposes of the effect wrapper
     * @param _ignored kept for backward compatibility
     */
    dispose(_ignored = false) {
        if (this._onContextRestoredObserver) {
            this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
            this._onContextRestoredObserver = null;
        }
        this.onEffectCreatedObservable.clear();
        this._drawWrapper.dispose(true);
    }
}
/**
 * Force code to compile to glsl even on WebGPU engines.
 * False by default. This is mostly meant for backward compatibility.
 */
EffectWrapper.ForceGLSL = false;
EffectWrapper._CustomShaderCodeProcessing = {};
//# sourceMappingURL=effectRenderer.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Maths/math.axis.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Maths/math.axis.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Axis: () => (/* binding */ Axis),
/* harmony export */   Coordinate: () => (/* binding */ Coordinate),
/* harmony export */   Space: () => (/* binding */ Space)
/* harmony export */ });
/* harmony import */ var _math_vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");

/** Defines supported spaces */
var Space;
(function (Space) {
    /** Local (object) space */
    Space[Space["LOCAL"] = 0] = "LOCAL";
    /** World space */
    Space[Space["WORLD"] = 1] = "WORLD";
    /** Bone space */
    Space[Space["BONE"] = 2] = "BONE";
})(Space || (Space = {}));
/** Defines the 3 main axes */
class Axis {
}
/** X axis */
Axis.X = new _math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, 0.0, 0.0);
/** Y axis */
Axis.Y = new _math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.0, 1.0, 0.0);
/** Z axis */
Axis.Z = new _math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.0, 0.0, 1.0);
/**
 * Defines cartesian components.
 */
var Coordinate;
(function (Coordinate) {
    /** X axis */
    Coordinate[Coordinate["X"] = 0] = "X";
    /** Y axis */
    Coordinate[Coordinate["Y"] = 1] = "Y";
    /** Z axis */
    Coordinate[Coordinate["Z"] = 2] = "Z";
})(Coordinate || (Coordinate = {}));
//# sourceMappingURL=math.axis.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Maths/math.js":
/*!****************************************************!*\
  !*** ./node_modules/@babylonjs/core/Maths/math.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Angle: () => (/* reexport safe */ _math_path_js__WEBPACK_IMPORTED_MODULE_4__.Angle),
/* harmony export */   Arc2: () => (/* reexport safe */ _math_path_js__WEBPACK_IMPORTED_MODULE_4__.Arc2),
/* harmony export */   Axis: () => (/* reexport safe */ _math_axis_js__WEBPACK_IMPORTED_MODULE_0__.Axis),
/* harmony export */   BezierCurve: () => (/* reexport safe */ _math_path_js__WEBPACK_IMPORTED_MODULE_4__.BezierCurve),
/* harmony export */   Color3: () => (/* reexport safe */ _math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color3),
/* harmony export */   Color4: () => (/* reexport safe */ _math_color_js__WEBPACK_IMPORTED_MODULE_1__.Color4),
/* harmony export */   Coordinate: () => (/* reexport safe */ _math_axis_js__WEBPACK_IMPORTED_MODULE_0__.Coordinate),
/* harmony export */   Curve3: () => (/* reexport safe */ _math_path_js__WEBPACK_IMPORTED_MODULE_4__.Curve3),
/* harmony export */   Epsilon: () => (/* reexport safe */ _math_constants_js__WEBPACK_IMPORTED_MODULE_2__.Epsilon),
/* harmony export */   Frustum: () => (/* reexport safe */ _math_frustum_js__WEBPACK_IMPORTED_MODULE_3__.Frustum),
/* harmony export */   Matrix: () => (/* reexport safe */ _math_vector_js__WEBPACK_IMPORTED_MODULE_7__.Matrix),
/* harmony export */   Orientation: () => (/* reexport safe */ _math_path_js__WEBPACK_IMPORTED_MODULE_4__.Orientation),
/* harmony export */   PHI: () => (/* reexport safe */ _math_constants_js__WEBPACK_IMPORTED_MODULE_2__.PHI),
/* harmony export */   Path2: () => (/* reexport safe */ _math_path_js__WEBPACK_IMPORTED_MODULE_4__.Path2),
/* harmony export */   Path3D: () => (/* reexport safe */ _math_path_js__WEBPACK_IMPORTED_MODULE_4__.Path3D),
/* harmony export */   Plane: () => (/* reexport safe */ _math_plane_js__WEBPACK_IMPORTED_MODULE_5__.Plane),
/* harmony export */   PositionNormalTextureVertex: () => (/* reexport safe */ _math_vertexFormat_js__WEBPACK_IMPORTED_MODULE_8__.PositionNormalTextureVertex),
/* harmony export */   PositionNormalVertex: () => (/* reexport safe */ _math_vertexFormat_js__WEBPACK_IMPORTED_MODULE_8__.PositionNormalVertex),
/* harmony export */   Quaternion: () => (/* reexport safe */ _math_vector_js__WEBPACK_IMPORTED_MODULE_7__.Quaternion),
/* harmony export */   Size: () => (/* reexport safe */ _math_size_js__WEBPACK_IMPORTED_MODULE_6__.Size),
/* harmony export */   Space: () => (/* reexport safe */ _math_axis_js__WEBPACK_IMPORTED_MODULE_0__.Space),
/* harmony export */   TmpColors: () => (/* reexport safe */ _math_color_js__WEBPACK_IMPORTED_MODULE_1__.TmpColors),
/* harmony export */   TmpVectors: () => (/* reexport safe */ _math_vector_js__WEBPACK_IMPORTED_MODULE_7__.TmpVectors),
/* harmony export */   ToGammaSpace: () => (/* reexport safe */ _math_constants_js__WEBPACK_IMPORTED_MODULE_2__.ToGammaSpace),
/* harmony export */   ToLinearSpace: () => (/* reexport safe */ _math_constants_js__WEBPACK_IMPORTED_MODULE_2__.ToLinearSpace),
/* harmony export */   Vector2: () => (/* reexport safe */ _math_vector_js__WEBPACK_IMPORTED_MODULE_7__.Vector2),
/* harmony export */   Vector3: () => (/* reexport safe */ _math_vector_js__WEBPACK_IMPORTED_MODULE_7__.Vector3),
/* harmony export */   Vector4: () => (/* reexport safe */ _math_vector_js__WEBPACK_IMPORTED_MODULE_7__.Vector4),
/* harmony export */   Viewport: () => (/* reexport safe */ _math_viewport_js__WEBPACK_IMPORTED_MODULE_9__.Viewport)
/* harmony export */ });
/* harmony import */ var _math_axis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.axis.js */ "./node_modules/@babylonjs/core/Maths/math.axis.js");
/* harmony import */ var _math_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.color.js */ "./node_modules/@babylonjs/core/Maths/math.color.js");
/* harmony import */ var _math_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.constants.js */ "./node_modules/@babylonjs/core/Maths/math.constants.js");
/* harmony import */ var _math_frustum_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math.frustum.js */ "./node_modules/@babylonjs/core/Maths/math.frustum.js");
/* harmony import */ var _math_path_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math.path.js */ "./node_modules/@babylonjs/core/Maths/math.path.js");
/* harmony import */ var _math_plane_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math.plane.js */ "./node_modules/@babylonjs/core/Maths/math.plane.js");
/* harmony import */ var _math_size_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./math.size.js */ "./node_modules/@babylonjs/core/Maths/math.size.js");
/* harmony import */ var _math_vector_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");
/* harmony import */ var _math_vertexFormat_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./math.vertexFormat.js */ "./node_modules/@babylonjs/core/Maths/math.vertexFormat.js");
/* harmony import */ var _math_viewport_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./math.viewport.js */ "./node_modules/@babylonjs/core/Maths/math.viewport.js");










//# sourceMappingURL=math.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Maths/math.path.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Maths/math.path.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Angle: () => (/* binding */ Angle),
/* harmony export */   Arc2: () => (/* binding */ Arc2),
/* harmony export */   BezierCurve: () => (/* binding */ BezierCurve),
/* harmony export */   Curve3: () => (/* binding */ Curve3),
/* harmony export */   Orientation: () => (/* binding */ Orientation),
/* harmony export */   Path2: () => (/* binding */ Path2),
/* harmony export */   Path3D: () => (/* binding */ Path3D)
/* harmony export */ });
/* harmony import */ var _math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.scalar.functions.js */ "./node_modules/@babylonjs/core/Maths/math.scalar.functions.js");
/* harmony import */ var _math_vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");
/* harmony import */ var _math_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.constants.js */ "./node_modules/@babylonjs/core/Maths/math.constants.js");



/**
 * Defines potential orientation for back face culling
 */
var Orientation;
(function (Orientation) {
    /**
     * Clockwise
     */
    Orientation[Orientation["CW"] = 0] = "CW";
    /** Counter clockwise */
    Orientation[Orientation["CCW"] = 1] = "CCW";
})(Orientation || (Orientation = {}));
/** Class used to represent a Bezier curve */
class BezierCurve {
    /**
     * Returns the cubic Bezier interpolated value (float) at "t" (float) from the given x1, y1, x2, y2 floats
     * @param t defines the time
     * @param x1 defines the left coordinate on X axis
     * @param y1 defines the left coordinate on Y axis
     * @param x2 defines the right coordinate on X axis
     * @param y2 defines the right coordinate on Y axis
     * @returns the interpolated value
     */
    static Interpolate(t, x1, y1, x2, y2) {
        if (t === 0) {
            return 0;
        }
        // Extract X (which is equal to time here)
        const f0 = 1 - 3 * x2 + 3 * x1;
        const f1 = 3 * x2 - 6 * x1;
        const f2 = 3 * x1;
        let refinedT = t;
        for (let i = 0; i < 5; i++) {
            const refinedT2 = refinedT * refinedT;
            const refinedT3 = refinedT2 * refinedT;
            const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;
            const slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);
            refinedT -= (x - t) * slope;
            refinedT = Math.min(1, Math.max(0, refinedT));
        }
        // Resolve cubic bezier for the given x
        return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);
    }
}
/**
 * Defines angle representation
 */
class Angle {
    /**
     * Creates an Angle object of "radians" radians (float).
     * @param radians the angle in radians
     */
    constructor(radians) {
        this._radians = radians;
        if (this._radians < 0.0) {
            this._radians += 2.0 * Math.PI;
        }
    }
    /**
     * Get value in degrees
     * @returns the Angle value in degrees (float)
     */
    degrees() {
        return (this._radians * 180.0) / Math.PI;
    }
    /**
     * Get value in radians
     * @returns the Angle value in radians (float)
     */
    radians() {
        return this._radians;
    }
    /**
     * Gets a new Angle object with a value of the angle (in radians) between the line connecting the two points and the x-axis
     * @param a defines first point as the origin
     * @param b defines point
     * @returns a new Angle
     */
    static BetweenTwoPoints(a, b) {
        const delta = b.subtract(a);
        const theta = Math.atan2(delta.y, delta.x);
        return new Angle(theta);
    }
    /**
     * Gets the angle between the two vectors
     * @param a defines first vector
     * @param b defines vector
     * @returns Returns an new Angle between 0 and PI
     */
    static BetweenTwoVectors(a, b) {
        let product = a.lengthSquared() * b.lengthSquared();
        if (product === 0) {
            return new Angle(Math.PI / 2);
        }
        product = Math.sqrt(product);
        let cosVal = a.dot(b) / product;
        cosVal = (0,_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.Clamp)(cosVal, -1, 1);
        const angle = Math.acos(cosVal);
        return new Angle(angle);
    }
    /**
     * Gets a new Angle object from the given float in radians
     * @param radians defines the angle value in radians
     * @returns a new Angle
     */
    static FromRadians(radians) {
        return new Angle(radians);
    }
    /**
     * Gets a new Angle object from the given float in degrees
     * @param degrees defines the angle value in degrees
     * @returns a new Angle
     */
    static FromDegrees(degrees) {
        return new Angle((degrees * Math.PI) / 180.0);
    }
}
/**
 * This represents an arc in a 2d space.
 */
class Arc2 {
    /**
     * Creates an Arc object from the three given points : start, middle and end.
     * @param startPoint Defines the start point of the arc
     * @param midPoint Defines the middle point of the arc
     * @param endPoint Defines the end point of the arc
     */
    constructor(
    /** Defines the start point of the arc */
    startPoint, 
    /** Defines the mid point of the arc */
    midPoint, 
    /** Defines the end point of the arc */
    endPoint) {
        this.startPoint = startPoint;
        this.midPoint = midPoint;
        this.endPoint = endPoint;
        const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);
        const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;
        const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;
        const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);
        this.centerPoint = new _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);
        this.radius = this.centerPoint.subtract(this.startPoint).length();
        this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);
        const a1 = this.startAngle.degrees();
        let a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();
        let a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();
        // angles correction
        if (a2 - a1 > +180.0) {
            a2 -= 360.0;
        }
        if (a2 - a1 < -180.0) {
            a2 += 360.0;
        }
        if (a3 - a2 > +180.0) {
            a3 -= 360.0;
        }
        if (a3 - a2 < -180.0) {
            a3 += 360.0;
        }
        this.orientation = a2 - a1 < 0 ? 0 /* Orientation.CW */ : 1 /* Orientation.CCW */;
        this.angle = Angle.FromDegrees(this.orientation === 0 /* Orientation.CW */ ? a1 - a3 : a3 - a1);
    }
}
/**
 * Represents a 2D path made up of multiple 2D points
 */
class Path2 {
    /**
     * Creates a Path2 object from the starting 2D coordinates x and y.
     * @param x the starting points x value
     * @param y the starting points y value
     */
    constructor(x, y) {
        this._points = new Array();
        this._length = 0.0;
        /**
         * If the path start and end point are the same
         */
        this.closed = false;
        this._points.push(new _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector2(x, y));
    }
    /**
     * Adds a new segment until the given coordinates (x, y) to the current Path2.
     * @param x the added points x value
     * @param y the added points y value
     * @returns the updated Path2.
     */
    addLineTo(x, y) {
        if (this.closed) {
            return this;
        }
        const newPoint = new _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector2(x, y);
        const previousPoint = this._points[this._points.length - 1];
        this._points.push(newPoint);
        this._length += newPoint.subtract(previousPoint).length();
        return this;
    }
    /**
     * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.
     * @param midX middle point x value
     * @param midY middle point y value
     * @param endX end point x value
     * @param endY end point y value
     * @param numberOfSegments (default: 36)
     * @returns the updated Path2.
     */
    addArcTo(midX, midY, endX, endY, numberOfSegments = 36) {
        if (this.closed) {
            return this;
        }
        const startPoint = this._points[this._points.length - 1];
        const midPoint = new _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector2(midX, midY);
        const endPoint = new _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector2(endX, endY);
        const arc = new Arc2(startPoint, midPoint, endPoint);
        let increment = arc.angle.radians() / numberOfSegments;
        if (arc.orientation === 0 /* Orientation.CW */) {
            increment *= -1;
        }
        let currentAngle = arc.startAngle.radians() + increment;
        for (let i = 0; i < numberOfSegments; i++) {
            const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;
            const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;
            this.addLineTo(x, y);
            currentAngle += increment;
        }
        return this;
    }
    /**
     * Adds _numberOfSegments_ segments according to the quadratic curve definition to the current Path2.
     * @param controlX control point x value
     * @param controlY control point y value
     * @param endX end point x value
     * @param endY end point y value
     * @param numberOfSegments (default: 36)
     * @returns the updated Path2.
     */
    addQuadraticCurveTo(controlX, controlY, endX, endY, numberOfSegments = 36) {
        if (this.closed) {
            return this;
        }
        const equation = (t, val0, val1, val2) => {
            const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
            return res;
        };
        const startPoint = this._points[this._points.length - 1];
        for (let i = 0; i <= numberOfSegments; i++) {
            const step = i / numberOfSegments;
            const x = equation(step, startPoint.x, controlX, endX);
            const y = equation(step, startPoint.y, controlY, endY);
            this.addLineTo(x, y);
        }
        return this;
    }
    /**
     * Adds _numberOfSegments_ segments according to the bezier curve definition to the current Path2.
     * @param originTangentX tangent vector at the origin point x value
     * @param originTangentY tangent vector at the origin point y value
     * @param destinationTangentX tangent vector at the destination point x value
     * @param destinationTangentY tangent vector at the destination point y value
     * @param endX end point x value
     * @param endY end point y value
     * @param numberOfSegments (default: 36)
     * @returns the updated Path2.
     */
    addBezierCurveTo(originTangentX, originTangentY, destinationTangentX, destinationTangentY, endX, endY, numberOfSegments = 36) {
        if (this.closed) {
            return this;
        }
        const equation = (t, val0, val1, val2, val3) => {
            const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
            return res;
        };
        const startPoint = this._points[this._points.length - 1];
        for (let i = 0; i <= numberOfSegments; i++) {
            const step = i / numberOfSegments;
            const x = equation(step, startPoint.x, originTangentX, destinationTangentX, endX);
            const y = equation(step, startPoint.y, originTangentY, destinationTangentY, endY);
            this.addLineTo(x, y);
        }
        return this;
    }
    /**
     * Defines if a given point is inside the polygon defines by the path
     * @param point defines the point to test
     * @returns true if the point is inside
     */
    isPointInside(point) {
        let isInside = false;
        const count = this._points.length;
        for (let p = count - 1, q = 0; q < count; p = q++) {
            let edgeLow = this._points[p];
            let edgeHigh = this._points[q];
            let edgeDx = edgeHigh.x - edgeLow.x;
            let edgeDy = edgeHigh.y - edgeLow.y;
            if (Math.abs(edgeDy) > Number.EPSILON) {
                // Not parallel
                if (edgeDy < 0) {
                    edgeLow = this._points[q];
                    edgeDx = -edgeDx;
                    edgeHigh = this._points[p];
                    edgeDy = -edgeDy;
                }
                if (point.y < edgeLow.y || point.y > edgeHigh.y) {
                    continue;
                }
                if (point.y === edgeLow.y && point.x === edgeLow.x) {
                    return true;
                }
                else {
                    const perpEdge = edgeDy * (point.x - edgeLow.x) - edgeDx * (point.y - edgeLow.y);
                    if (perpEdge === 0) {
                        return true;
                    }
                    if (perpEdge < 0) {
                        continue;
                    }
                    isInside = !isInside;
                }
            }
            else {
                // parallel or collinear
                if (point.y !== edgeLow.y) {
                    continue;
                }
                if ((edgeHigh.x <= point.x && point.x <= edgeLow.x) || (edgeLow.x <= point.x && point.x <= edgeHigh.x)) {
                    return true;
                }
            }
        }
        return isInside;
    }
    /**
     * Closes the Path2.
     * @returns the Path2.
     */
    close() {
        this.closed = true;
        return this;
    }
    /**
     * Gets the sum of the distance between each sequential point in the path
     * @returns the Path2 total length (float).
     */
    length() {
        let result = this._length;
        if (this.closed) {
            const lastPoint = this._points[this._points.length - 1];
            const firstPoint = this._points[0];
            result += firstPoint.subtract(lastPoint).length();
        }
        return result;
    }
    /**
     * Gets the area of the polygon defined by the path
     * @returns area value
     */
    area() {
        const n = this._points.length;
        let value = 0.0;
        for (let p = n - 1, q = 0; q < n; p = q++) {
            value += this._points[p].x * this._points[q].y - this._points[q].x * this._points[p].y;
        }
        return value * 0.5;
    }
    /**
     * Gets the points which construct the path
     * @returns the Path2 internal array of points.
     */
    getPoints() {
        return this._points;
    }
    /**
     * Retrieves the point at the distance aways from the starting point
     * @param normalizedLengthPosition the length along the path to retrieve the point from
     * @returns a new Vector2 located at a percentage of the Path2 total length on this path.
     */
    getPointAtLengthPosition(normalizedLengthPosition) {
        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {
            return _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector2.Zero();
        }
        const lengthPosition = normalizedLengthPosition * this.length();
        let previousOffset = 0;
        for (let i = 0; i < this._points.length; i++) {
            const j = (i + 1) % this._points.length;
            const a = this._points[i];
            const b = this._points[j];
            const bToA = b.subtract(a);
            const nextOffset = bToA.length() + previousOffset;
            if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {
                const dir = bToA.normalize();
                const localOffset = lengthPosition - previousOffset;
                return new _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);
            }
            previousOffset = nextOffset;
        }
        return _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector2.Zero();
    }
    /**
     * Creates a new path starting from an x and y position
     * @param x starting x value
     * @param y starting y value
     * @returns a new Path2 starting at the coordinates (x, y).
     */
    static StartingAt(x, y) {
        return new Path2(x, y);
    }
}
/**
 * Represents a 3D path made up of multiple 3D points
 * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D
 */
class Path3D {
    /**
     * new Path3D(path, normal, raw)
     * Creates a Path3D. A Path3D is a logical math object, so not a mesh.
     * please read the description in the tutorial : https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D
     * @param path an array of Vector3, the curve axis of the Path3D
     * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.
     * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.
     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.
     */
    constructor(
    /**
     * an array of Vector3, the curve axis of the Path3D
     */
    path, firstNormal = null, raw, alignTangentsWithPath = false) {
        this.path = path;
        this._curve = new Array();
        this._distances = new Array();
        this._tangents = new Array();
        this._normals = new Array();
        this._binormals = new Array();
        // holds interpolated point data
        this._pointAtData = {
            id: 0,
            point: _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(),
            previousPointArrayIndex: 0,
            position: 0,
            subPosition: 0,
            interpolateReady: false,
            interpolationMatrix: _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Matrix.Identity(),
        };
        for (let p = 0; p < path.length; p++) {
            this._curve[p] = path[p].clone(); // hard copy
        }
        this._raw = raw || false;
        this._alignTangentsWithPath = alignTangentsWithPath;
        this._compute(firstNormal, alignTangentsWithPath);
    }
    /**
     * Returns the Path3D array of successive Vector3 designing its curve.
     * @returns the Path3D array of successive Vector3 designing its curve.
     */
    getCurve() {
        return this._curve;
    }
    /**
     * Returns the Path3D array of successive Vector3 designing its curve.
     * @returns the Path3D array of successive Vector3 designing its curve.
     */
    getPoints() {
        return this._curve;
    }
    /**
     * @returns the computed length (float) of the path.
     */
    length() {
        return this._distances[this._distances.length - 1];
    }
    /**
     * Returns an array populated with tangent vectors on each Path3D curve point.
     * @returns an array populated with tangent vectors on each Path3D curve point.
     */
    getTangents() {
        return this._tangents;
    }
    /**
     * Returns an array populated with normal vectors on each Path3D curve point.
     * @returns an array populated with normal vectors on each Path3D curve point.
     */
    getNormals() {
        return this._normals;
    }
    /**
     * Returns an array populated with binormal vectors on each Path3D curve point.
     * @returns an array populated with binormal vectors on each Path3D curve point.
     */
    getBinormals() {
        return this._binormals;
    }
    /**
     * Returns an array populated with distances (float) of the i-th point from the first curve point.
     * @returns an array populated with distances (float) of the i-th point from the first curve point.
     */
    getDistances() {
        return this._distances;
    }
    /**
     * Returns an interpolated point along this path
     * @param position the position of the point along this path, from 0.0 to 1.0
     * @returns a new Vector3 as the point
     */
    getPointAt(position) {
        return this._updatePointAtData(position).point;
    }
    /**
     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.
     * @param position the position of the point along this path, from 0.0 to 1.0
     * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.
     * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.
     */
    getTangentAt(position, interpolated = false) {
        this._updatePointAtData(position, interpolated);
        return interpolated ? _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.TransformCoordinates(_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];
    }
    /**
     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.
     * @param position the position of the point along this path, from 0.0 to 1.0
     * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.
     * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.
     */
    getNormalAt(position, interpolated = false) {
        this._updatePointAtData(position, interpolated);
        return interpolated ? _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.TransformCoordinates(_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];
    }
    /**
     * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.
     * @param position the position of the point along this path, from 0.0 to 1.0
     * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.
     * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.
     */
    getBinormalAt(position, interpolated = false) {
        this._updatePointAtData(position, interpolated);
        return interpolated ? _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.TransformCoordinates(_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];
    }
    /**
     * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.
     * @param position the position of the point along this path, from 0.0 to 1.0
     * @returns the distance of the interpolated Path3D curve point at the specified position along this path.
     */
    getDistanceAt(position) {
        return this.length() * position;
    }
    /**
     * Returns the array index of the previous point of an interpolated point along this path
     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0
     * @returns the array index
     */
    getPreviousPointIndexAt(position) {
        this._updatePointAtData(position);
        return this._pointAtData.previousPointArrayIndex;
    }
    /**
     * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)
     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0
     * @returns the sub position
     */
    getSubPositionAt(position) {
        this._updatePointAtData(position);
        return this._pointAtData.subPosition;
    }
    /**
     * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0
     * @param target the vector of which to get the closest position to
     * @returns the position of the closest virtual point on this path to the target vector
     */
    getClosestPositionTo(target) {
        let smallestDistance = Number.MAX_VALUE;
        let closestPosition = 0.0;
        for (let i = 0; i < this._curve.length - 1; i++) {
            const point = this._curve[i + 0];
            const tangent = this._curve[i + 1].subtract(point).normalize();
            const subLength = this._distances[i + 1] - this._distances[i + 0];
            const subPosition = Math.min((Math.max(_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Distance(point, target)) / subLength, 1.0);
            const distance = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);
            if (distance < smallestDistance) {
                smallestDistance = distance;
                closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();
            }
        }
        return closestPosition;
    }
    /**
     * Returns a sub path (slice) of this path
     * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values
     * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values
     * @returns a sub path (slice) of this path
     */
    slice(start = 0.0, end = 1.0) {
        if (start < 0.0) {
            start = 1 - ((start * -1.0) % 1.0);
        }
        if (end < 0.0) {
            end = 1 - ((end * -1.0) % 1.0);
        }
        if (start > end) {
            const _start = start;
            start = end;
            end = _start;
        }
        const curvePoints = this.getCurve();
        const startPoint = this.getPointAt(start);
        let startIndex = this.getPreviousPointIndexAt(start);
        const endPoint = this.getPointAt(end);
        const endIndex = this.getPreviousPointIndexAt(end) + 1;
        const slicePoints = [];
        if (start !== 0.0) {
            startIndex++;
            slicePoints.push(startPoint);
        }
        slicePoints.push(...curvePoints.slice(startIndex, endIndex));
        if (end !== 1.0 || start === 1.0) {
            slicePoints.push(endPoint);
        }
        return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);
    }
    /**
     * Forces the Path3D tangent, normal, binormal and distance recomputation.
     * @param path path which all values are copied into the curves points
     * @param firstNormal which should be projected onto the curve
     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path
     * @returns the same object updated.
     */
    update(path, firstNormal = null, alignTangentsWithPath = false) {
        for (let p = 0; p < path.length; p++) {
            this._curve[p].x = path[p].x;
            this._curve[p].y = path[p].y;
            this._curve[p].z = path[p].z;
        }
        this._compute(firstNormal, alignTangentsWithPath);
        return this;
    }
    // private function compute() : computes tangents, normals and binormals
    _compute(firstNormal, alignTangentsWithPath = false) {
        const l = this._curve.length;
        if (l < 2) {
            return;
        }
        // first and last tangents
        this._tangents[0] = this._getFirstNonNullVector(0);
        if (!this._raw) {
            this._tangents[0].normalize();
        }
        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);
        if (!this._raw) {
            this._tangents[l - 1].normalize();
        }
        // normals and binormals at first point : arbitrary vector with _normalVector()
        const tg0 = this._tangents[0];
        const pp0 = this._normalVector(tg0, firstNormal);
        this._normals[0] = pp0;
        if (!this._raw) {
            this._normals[0].normalize();
        }
        this._binormals[0] = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Cross(tg0, this._normals[0]);
        if (!this._raw) {
            this._binormals[0].normalize();
        }
        this._distances[0] = 0.0;
        // normals and binormals : next points
        let prev; // previous vector (segment)
        let cur; // current vector (segment)
        let curTang; // current tangent
        // previous normal
        let prevNor; // previous normal
        let prevBinor; // previous binormal
        for (let i = 1; i < l; i++) {
            // tangents
            prev = this._getLastNonNullVector(i);
            if (i < l - 1) {
                cur = this._getFirstNonNullVector(i);
                this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);
                this._tangents[i].normalize();
            }
            this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();
            // normals and binormals
            // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html
            curTang = this._tangents[i];
            prevBinor = this._binormals[i - 1];
            this._normals[i] = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Cross(prevBinor, curTang);
            if (!this._raw) {
                if (this._normals[i].length() === 0) {
                    prevNor = this._normals[i - 1];
                    this._normals[i] = prevNor.clone();
                }
                else {
                    this._normals[i].normalize();
                }
            }
            this._binormals[i] = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Cross(curTang, this._normals[i]);
            if (!this._raw) {
                this._binormals[i].normalize();
            }
        }
        this._pointAtData.id = NaN;
    }
    // private function getFirstNonNullVector(index)
    // returns the first non null vector from index : curve[index + N].subtract(curve[index])
    _getFirstNonNullVector(index) {
        let i = 1;
        let nNVector = this._curve[index + i].subtract(this._curve[index]);
        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {
            i++;
            nNVector = this._curve[index + i].subtract(this._curve[index]);
        }
        return nNVector;
    }
    // private function getLastNonNullVector(index)
    // returns the last non null vector from index : curve[index].subtract(curve[index - N])
    _getLastNonNullVector(index) {
        let i = 1;
        let nLVector = this._curve[index].subtract(this._curve[index - i]);
        while (nLVector.length() === 0 && index > i + 1) {
            i++;
            nLVector = this._curve[index].subtract(this._curve[index - i]);
        }
        return nLVector;
    }
    // private function normalVector(v0, vt, va) :
    // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane
    // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0
    _normalVector(vt, va) {
        let normal0;
        let tgl = vt.length();
        if (tgl === 0.0) {
            tgl = 1.0;
        }
        if (va === undefined || va === null) {
            let point;
            if (!(0,_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.WithinEpsilon)(Math.abs(vt.y) / tgl, 1.0, _math_constants_js__WEBPACK_IMPORTED_MODULE_2__.Epsilon)) {
                // search for a point in the plane
                point = new _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3(0.0, -1.0, 0.0);
            }
            else if (!(0,_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.WithinEpsilon)(Math.abs(vt.x) / tgl, 1.0, _math_constants_js__WEBPACK_IMPORTED_MODULE_2__.Epsilon)) {
                point = new _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3(1.0, 0.0, 0.0);
            }
            else if (!(0,_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.WithinEpsilon)(Math.abs(vt.z) / tgl, 1.0, _math_constants_js__WEBPACK_IMPORTED_MODULE_2__.Epsilon)) {
                point = new _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3(0.0, 0.0, 1.0);
            }
            else {
                point = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero();
            }
            normal0 = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Cross(vt, point);
        }
        else {
            normal0 = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Cross(vt, va);
            _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.CrossToRef(normal0, vt, normal0);
        }
        normal0.normalize();
        return normal0;
    }
    /**
     * Updates the point at data for an interpolated point along this curve
     * @param position the position of the point along this curve, from 0.0 to 1.0
     * @param interpolateTNB
     * @interpolateTNB whether to compute the interpolated tangent, normal and binormal
     * @returns the (updated) point at data
     */
    _updatePointAtData(position, interpolateTNB = false) {
        // set an id for caching the result
        if (this._pointAtData.id === position) {
            if (!this._pointAtData.interpolateReady) {
                this._updateInterpolationMatrix();
            }
            return this._pointAtData;
        }
        else {
            this._pointAtData.id = position;
        }
        const curvePoints = this.getPoints();
        // clamp position between 0.0 and 1.0
        if (position <= 0.0) {
            return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);
        }
        else if (position >= 1.0) {
            return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);
        }
        let previousPoint = curvePoints[0];
        let currentPoint;
        let currentLength = 0.0;
        const targetLength = position * this.length();
        for (let i = 1; i < curvePoints.length; i++) {
            currentPoint = curvePoints[i];
            const distance = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Distance(previousPoint, currentPoint);
            currentLength += distance;
            if (currentLength === targetLength) {
                return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);
            }
            else if (currentLength > targetLength) {
                const toLength = currentLength - targetLength;
                const diff = toLength / distance;
                const dir = previousPoint.subtract(currentPoint);
                const point = currentPoint.add(dir.scaleInPlace(diff));
                return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);
            }
            previousPoint = currentPoint;
        }
        return this._pointAtData;
    }
    /**
     * Updates the point at data from the specified parameters
     * @param position where along the path the interpolated point is, from 0.0 to 1.0
     * @param subPosition
     * @param point the interpolated point
     * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point
     * @param interpolateTNB whether to compute the interpolated tangent, normal and binormal
     * @returns the (updated) point at data
     */
    _setPointAtData(position, subPosition, point, parentIndex, interpolateTNB) {
        this._pointAtData.point = point;
        this._pointAtData.position = position;
        this._pointAtData.subPosition = subPosition;
        this._pointAtData.previousPointArrayIndex = parentIndex;
        this._pointAtData.interpolateReady = interpolateTNB;
        if (interpolateTNB) {
            this._updateInterpolationMatrix();
        }
        return this._pointAtData;
    }
    /**
     * Updates the point at interpolation matrix for the tangents, normals and binormals
     */
    _updateInterpolationMatrix() {
        this._pointAtData.interpolationMatrix = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Matrix.Identity();
        const parentIndex = this._pointAtData.previousPointArrayIndex;
        if (parentIndex !== this._tangents.length - 1) {
            const index = parentIndex + 1;
            const tangentFrom = this._tangents[parentIndex].clone();
            const normalFrom = this._normals[parentIndex].clone();
            const binormalFrom = this._binormals[parentIndex].clone();
            const tangentTo = this._tangents[index].clone();
            const normalTo = this._normals[index].clone();
            const binormalTo = this._binormals[index].clone();
            const quatFrom = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);
            const quatTo = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);
            const quatAt = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);
            quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);
        }
    }
}
/**
 * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
 * A Curve3 is designed from a series of successive Vector3.
 * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves
 */
class Curve3 {
    /**
     * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#quadratic-bezier-curve
     * @param v0 (Vector3) the origin point of the Quadratic Bezier
     * @param v1 (Vector3) the control point
     * @param v2 (Vector3) the end point of the Quadratic Bezier
     * @param nbPoints (integer) the wanted number of points in the curve
     * @returns the created Curve3
     */
    static CreateQuadraticBezier(v0, v1, v2, nbPoints) {
        nbPoints = nbPoints > 2 ? nbPoints : 3;
        const bez = [];
        const equation = (t, val0, val1, val2) => {
            const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
            return res;
        };
        for (let i = 0; i <= nbPoints; i++) {
            bez.push(new _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));
        }
        return new Curve3(bez);
    }
    /**
     * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#cubic-bezier-curve
     * @param v0 (Vector3) the origin point of the Cubic Bezier
     * @param v1 (Vector3) the first control point
     * @param v2 (Vector3) the second control point
     * @param v3 (Vector3) the end point of the Cubic Bezier
     * @param nbPoints (integer) the wanted number of points in the curve
     * @returns the created Curve3
     */
    static CreateCubicBezier(v0, v1, v2, v3, nbPoints) {
        nbPoints = nbPoints > 3 ? nbPoints : 4;
        const bez = [];
        const equation = (t, val0, val1, val2, val3) => {
            const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
            return res;
        };
        for (let i = 0; i <= nbPoints; i++) {
            bez.push(new _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));
        }
        return new Curve3(bez);
    }
    /**
     * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#hermite-spline
     * @param p1 (Vector3) the origin point of the Hermite Spline
     * @param t1 (Vector3) the tangent vector at the origin point
     * @param p2 (Vector3) the end point of the Hermite Spline
     * @param t2 (Vector3) the tangent vector at the end point
     * @param nSeg (integer) the number of curve segments or nSeg + 1 points in the array
     * @returns the created Curve3
     */
    static CreateHermiteSpline(p1, t1, p2, t2, nSeg) {
        const hermite = [];
        const step = 1.0 / nSeg;
        for (let i = 0; i <= nSeg; i++) {
            hermite.push(_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Hermite(p1, t1, p2, t2, i * step));
        }
        return new Curve3(hermite);
    }
    /**
     * Returns a Curve3 object along a CatmullRom Spline curve :
     * @param points (array of Vector3) the points the spline must pass through. At least, four points required
     * @param nbPoints (integer) the wanted number of points between each curve control points
     * @param closed (boolean) optional with default false, when true forms a closed loop from the points
     * @returns the created Curve3
     */
    static CreateCatmullRomSpline(points, nbPoints, closed) {
        const catmullRom = [];
        const step = 1.0 / nbPoints;
        let amount = 0.0;
        if (closed) {
            const pointsCount = points.length;
            for (let i = 0; i < pointsCount; i++) {
                amount = 0;
                for (let c = 0; c < nbPoints; c++) {
                    catmullRom.push(_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));
                    amount += step;
                }
            }
            catmullRom.push(catmullRom[0]);
        }
        else {
            const totalPoints = [];
            totalPoints.push(points[0].clone());
            Array.prototype.push.apply(totalPoints, points);
            totalPoints.push(points[points.length - 1].clone());
            let i = 0;
            for (; i < totalPoints.length - 3; i++) {
                amount = 0;
                for (let c = 0; c < nbPoints; c++) {
                    catmullRom.push(_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
                    amount += step;
                }
            }
            i--;
            catmullRom.push(_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
        }
        return new Curve3(catmullRom);
    }
    /**
     * Returns a Curve3 object along an arc through three vector3 points:
     * The three points should not be colinear. When they are the Curve3 is empty.
     * @param first (Vector3) the first point the arc must pass through.
     * @param second (Vector3) the second point the arc must pass through.
     * @param third (Vector3) the third point the arc must pass through.
     * @param steps (number) the larger the number of steps the more detailed the arc.
     * @param closed (boolean) optional with default false, when true forms the chord from the first and third point
     * @param fullCircle Circle (boolean) optional with default false, when true forms the complete circle through the three points
     * @returns the created Curve3
     */
    static ArcThru3Points(first, second, third, steps = 32, closed = false, fullCircle = false) {
        const arc = [];
        const vec1 = second.subtract(first);
        const vec2 = third.subtract(second);
        const vec3 = first.subtract(third);
        const zAxis = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Cross(vec1, vec2);
        const len4 = zAxis.length();
        if (len4 < Math.pow(10, -8)) {
            return new Curve3(arc); // colinear points arc is empty
        }
        const len1Sq = vec1.lengthSquared();
        const len2Sq = vec2.lengthSquared();
        const len3Sq = vec3.lengthSquared();
        const len4Sq = zAxis.lengthSquared();
        const len1 = vec1.length();
        const len2 = vec2.length();
        const len3 = vec3.length();
        const radius = (0.5 * len1 * len2 * len3) / len4;
        const dot1 = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Dot(vec1, vec3);
        const dot2 = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Dot(vec1, vec2);
        const dot3 = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Dot(vec2, vec3);
        const a = (-0.5 * len2Sq * dot1) / len4Sq;
        const b = (-0.5 * len3Sq * dot2) / len4Sq;
        const c = (-0.5 * len1Sq * dot3) / len4Sq;
        const center = first.scale(a).add(second.scale(b)).add(third.scale(c));
        const radiusVec = first.subtract(center);
        const xAxis = radiusVec.normalize();
        const yAxis = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Cross(zAxis, xAxis).normalize();
        if (fullCircle) {
            const dStep = (2 * Math.PI) / steps;
            for (let theta = 0; theta <= 2 * Math.PI; theta += dStep) {
                arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));
            }
            arc.push(first);
        }
        else {
            const dStep = 1 / steps;
            let theta = 0;
            let point = _math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero();
            do {
                point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));
                arc.push(point);
                theta += dStep;
            } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));
            arc.push(third);
            if (closed) {
                arc.push(first);
            }
        }
        return new Curve3(arc);
    }
    /**
     * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
     * A Curve3 is designed from a series of successive Vector3.
     * Tuto : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#curve3-object
     * @param points points which make up the curve
     */
    constructor(points) {
        this._length = 0.0;
        this._points = points;
        this._length = this._computeLength(points);
    }
    /**
     * @returns the Curve3 stored array of successive Vector3
     */
    getPoints() {
        return this._points;
    }
    /**
     * @returns the computed length (float) of the curve.
     */
    length() {
        return this._length;
    }
    /**
     * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);
     * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.
     * curveA and curveB keep unchanged.
     * @param curve the curve to continue from this curve
     * @returns the newly constructed curve
     */
    continue(curve) {
        const lastPoint = this._points[this._points.length - 1];
        const continuedPoints = this._points.slice();
        const curvePoints = curve.getPoints();
        for (let i = 1; i < curvePoints.length; i++) {
            continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));
        }
        const continuedCurve = new Curve3(continuedPoints);
        return continuedCurve;
    }
    _computeLength(path) {
        let l = 0;
        for (let i = 1; i < path.length; i++) {
            l += path[i].subtract(path[i - 1]).length();
        }
        return l;
    }
}
//# sourceMappingURL=math.path.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Maths/math.vertexFormat.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Maths/math.vertexFormat.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PositionNormalTextureVertex: () => (/* binding */ PositionNormalTextureVertex),
/* harmony export */   PositionNormalVertex: () => (/* binding */ PositionNormalVertex)
/* harmony export */ });
/* harmony import */ var _math_vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");

/**
 * Contains position and normal vectors for a vertex
 */
class PositionNormalVertex {
    /**
     * Creates a PositionNormalVertex
     * @param position the position of the vertex (defaut: 0,0,0)
     * @param normal the normal of the vertex (defaut: 0,1,0)
     */
    constructor(
    /** [Vector3.Zero()] the position of the vertex (defaut: 0,0,0) */
    position = _math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), 
    /** [Vector3.Up()] the normal of the vertex (defaut: 0,1,0) */
    normal = _math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Up()) {
        this.position = position;
        this.normal = normal;
    }
    /**
     * Clones the PositionNormalVertex
     * @returns the cloned PositionNormalVertex
     */
    clone() {
        return new PositionNormalVertex(this.position.clone(), this.normal.clone());
    }
}
/**
 * Contains position, normal and uv vectors for a vertex
 */
class PositionNormalTextureVertex {
    /**
     * Creates a PositionNormalTextureVertex
     * @param position the position of the vertex (defaut: 0,0,0)
     * @param normal the normal of the vertex (defaut: 0,1,0)
     * @param uv the uv of the vertex (default: 0,0)
     */
    constructor(
    /** [Vector3.Zero()] the position of the vertex (defaut: 0,0,0) */
    position = _math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), 
    /** [Vector3.Up()] the normal of the vertex (defaut: 0,1,0) */
    normal = _math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Up(), 
    /** [Vector3.Zero()] the uv of the vertex (default: 0,0) */
    uv = _math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector2.Zero()) {
        this.position = position;
        this.normal = normal;
        this.uv = uv;
    }
    /**
     * Clones the PositionNormalTextureVertex
     * @returns the cloned PositionNormalTextureVertex
     */
    clone() {
        return new PositionNormalTextureVertex(this.position.clone(), this.normal.clone(), this.uv.clone());
    }
}
//# sourceMappingURL=math.vertexFormat.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Maths/math.viewport.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Maths/math.viewport.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Viewport: () => (/* binding */ Viewport)
/* harmony export */ });
/**
 * Class used to represent a viewport on screen
 */
class Viewport {
    /**
     * Creates a Viewport object located at (x, y) and sized (width, height)
     * @param x defines viewport left coordinate
     * @param y defines viewport top coordinate
     * @param width defines the viewport width
     * @param height defines the viewport height
     */
    constructor(
    /** viewport left coordinate */
    x, 
    /** viewport top coordinate */
    y, 
    /**viewport width */
    width, 
    /** viewport height */
    height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    /**
     * Creates a new viewport using absolute sizing (from 0-> width, 0-> height instead of 0->1)
     * @param renderWidth defines the rendering width
     * @param renderHeight defines the rendering height
     * @returns a new Viewport
     */
    toGlobal(renderWidth, renderHeight) {
        return new Viewport(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);
    }
    /**
     * Stores absolute viewport value into a target viewport (from 0-> width, 0-> height instead of 0->1)
     * @param renderWidth defines the rendering width
     * @param renderHeight defines the rendering height
     * @param ref defines the target viewport
     * @returns the current viewport
     */
    toGlobalToRef(renderWidth, renderHeight, ref) {
        ref.x = this.x * renderWidth;
        ref.y = this.y * renderHeight;
        ref.width = this.width * renderWidth;
        ref.height = this.height * renderHeight;
        return this;
    }
    /**
     * Returns a new Viewport copied from the current one
     * @returns a new Viewport
     */
    clone() {
        return new Viewport(this.x, this.y, this.width, this.height);
    }
}
//# sourceMappingURL=math.viewport.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Maths/sphericalPolynomial.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Maths/sphericalPolynomial.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SphericalHarmonics: () => (/* binding */ SphericalHarmonics),
/* harmony export */   SphericalPolynomial: () => (/* binding */ SphericalPolynomial)
/* harmony export */ });
/* harmony import */ var _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Maths/math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/@babylonjs/core/Maths/math.js");
/* eslint-disable @typescript-eslint/naming-convention */


// https://dickyjim.wordpress.com/2013/09/04/spherical-harmonics-for-beginners/
// http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf
// https://www.ppsloan.org/publications/StupidSH36.pdf
// http://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf
// https://www.ppsloan.org/publications/SHJCGT.pdf
// https://www.ppsloan.org/publications/shdering.pdf
// https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics
// https://patapom.com/blog/SHPortal/
// https://imdoingitwrong.wordpress.com/2011/04/14/spherical-harmonics-wtf/
// Using real SH basis:
//  m>0             m   m
// y   = sqrt(2) * K * P * cos(m*phi) * cos(theta)
//  l               l   l
//
//  m<0             m   |m|
// y   = sqrt(2) * K * P * sin(m*phi) * cos(theta)
//  l               l   l
//
//  m=0   0   0
// y   = K * P * trigono terms
//  l     l   l
//
//  m       (2l + 1)(l - |m|)!
// K = sqrt(------------------)
//  l           4pi(l + |m|)!
//
// and P by recursion:
//
// P00(x) = 1
// P01(x) = x
// Pll(x) = (-1^l)(2l - 1)!!(1-x*x)^(1/2)
//          ((2l - 1)x[Pl-1/m]-(l + m - 1)[Pl-2/m])
// Plm(x) = ---------------------------------------
//                         l - m
// Leaving the trigonometric terms aside we can precompute the constants to :
const SH3ylmBasisConstants = [
    Math.sqrt(1 / (4 * Math.PI)), // l00
    -Math.sqrt(3 / (4 * Math.PI)), // l1_1
    Math.sqrt(3 / (4 * Math.PI)), // l10
    -Math.sqrt(3 / (4 * Math.PI)), // l11
    Math.sqrt(15 / (4 * Math.PI)), // l2_2
    -Math.sqrt(15 / (4 * Math.PI)), // l2_1
    Math.sqrt(5 / (16 * Math.PI)), // l20
    -Math.sqrt(15 / (4 * Math.PI)), // l21
    Math.sqrt(15 / (16 * Math.PI)), // l22
];
// cm = cos(m * phi)
// sm = sin(m * phi)
// {x,y,z} = {cos(phi)sin(theta), sin(phi)sin(theta), cos(theta)}
// By recursion on using trigo identities:
const SH3ylmBasisTrigonometricTerms = [
    () => 1, // l00
    (direction) => direction.y, // l1_1
    (direction) => direction.z, // l10
    (direction) => direction.x, // l11
    (direction) => direction.x * direction.y, // l2_2
    (direction) => direction.y * direction.z, // l2_1
    (direction) => 3 * direction.z * direction.z - 1, // l20
    (direction) => direction.x * direction.z, // l21
    (direction) => direction.x * direction.x - direction.y * direction.y, // l22
];
// Wrap the full compute
const applySH3 = (lm, direction) => {
    return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);
};
// Derived from the integration of the a kernel convolution to SH.
// Great explanation here: https://patapom.com/blog/SHPortal/#about-distant-radiance-and-irradiance-environments
const SHCosKernelConvolution = [Math.PI, (2 * Math.PI) / 3, (2 * Math.PI) / 3, (2 * Math.PI) / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4];
/**
 * Class representing spherical harmonics coefficients to the 3rd degree
 */
class SphericalHarmonics {
    constructor() {
        /**
         * Defines whether or not the harmonics have been prescaled for rendering.
         */
        this.preScaled = false;
        /**
         * The l0,0 coefficients of the spherical harmonics
         */
        this.l00 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The l1,-1 coefficients of the spherical harmonics
         */
        this.l1_1 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The l1,0 coefficients of the spherical harmonics
         */
        this.l10 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The l1,1 coefficients of the spherical harmonics
         */
        this.l11 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The l2,-2 coefficients of the spherical harmonics
         */
        this.l2_2 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The l2,-1 coefficients of the spherical harmonics
         */
        this.l2_1 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The l2,0 coefficients of the spherical harmonics
         */
        this.l20 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The l2,1 coefficients of the spherical harmonics
         */
        this.l21 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The l2,2 coefficients of the spherical harmonics
         */
        this.l22 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
    }
    /**
     * Adds a light to the spherical harmonics
     * @param direction the direction of the light
     * @param color the color of the light
     * @param deltaSolidAngle the delta solid angle of the light
     */
    addLight(direction, color, deltaSolidAngle) {
        _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[0].set(color.r, color.g, color.b);
        const colorVector = _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[0];
        const c = _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[1];
        colorVector.scaleToRef(deltaSolidAngle, c);
        c.scaleToRef(applySH3(0, direction), _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        this.l00.addInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(1, direction), _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        this.l1_1.addInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(2, direction), _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        this.l10.addInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(3, direction), _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        this.l11.addInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(4, direction), _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        this.l2_2.addInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(5, direction), _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        this.l2_1.addInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(6, direction), _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        this.l20.addInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(7, direction), _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        this.l21.addInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(8, direction), _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
        this.l22.addInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[2]);
    }
    /**
     * Scales the spherical harmonics by the given amount
     * @param scale the amount to scale
     */
    scaleInPlace(scale) {
        this.l00.scaleInPlace(scale);
        this.l1_1.scaleInPlace(scale);
        this.l10.scaleInPlace(scale);
        this.l11.scaleInPlace(scale);
        this.l2_2.scaleInPlace(scale);
        this.l2_1.scaleInPlace(scale);
        this.l20.scaleInPlace(scale);
        this.l21.scaleInPlace(scale);
        this.l22.scaleInPlace(scale);
    }
    /**
     * Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.
     *
     * ```
     * E_lm = A_l * L_lm
     * ```
     *
     * In spherical harmonics this convolution amounts to scaling factors for each frequency band.
     * This corresponds to equation 5 in "An Efficient Representation for Irradiance Environment Maps", where
     * the scaling factors are given in equation 9.
     */
    convertIncidentRadianceToIrradiance() {
        // Constant (Band 0)
        this.l00.scaleInPlace(SHCosKernelConvolution[0]);
        // Linear (Band 1)
        this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);
        this.l10.scaleInPlace(SHCosKernelConvolution[2]);
        this.l11.scaleInPlace(SHCosKernelConvolution[3]);
        // Quadratic (Band 2)
        this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);
        this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);
        this.l20.scaleInPlace(SHCosKernelConvolution[6]);
        this.l21.scaleInPlace(SHCosKernelConvolution[7]);
        this.l22.scaleInPlace(SHCosKernelConvolution[8]);
    }
    /**
     * Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.
     *
     * ```
     * L = (1/pi) * E * rho
     * ```
     *
     * This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.
     */
    convertIrradianceToLambertianRadiance() {
        this.scaleInPlace(1.0 / Math.PI);
        // The resultant SH now represents outgoing radiance, so includes the Lambert 1/pi normalisation factor but without albedo (rho) applied
        // (The pixel shader must apply albedo after texture fetches, etc).
    }
    /**
     * Integrates the reconstruction coefficients directly in to the SH preventing further
     * required operations at run time.
     *
     * This is simply done by scaling back the SH with Ylm constants parameter.
     * The trigonometric part being applied by the shader at run time.
     */
    preScaleForRendering() {
        this.preScaled = true;
        this.l00.scaleInPlace(SH3ylmBasisConstants[0]);
        this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);
        this.l10.scaleInPlace(SH3ylmBasisConstants[2]);
        this.l11.scaleInPlace(SH3ylmBasisConstants[3]);
        this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);
        this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);
        this.l20.scaleInPlace(SH3ylmBasisConstants[6]);
        this.l21.scaleInPlace(SH3ylmBasisConstants[7]);
        this.l22.scaleInPlace(SH3ylmBasisConstants[8]);
    }
    /**
     * update the spherical harmonics coefficients from the given array
     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)
     * @returns the spherical harmonics (this)
     */
    updateFromArray(data) {
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[0], 0, this.l00);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[1], 0, this.l1_1);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[2], 0, this.l10);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[3], 0, this.l11);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[4], 0, this.l2_2);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[5], 0, this.l2_1);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[6], 0, this.l20);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[7], 0, this.l21);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[8], 0, this.l22);
        return this;
    }
    /**
     * update the spherical harmonics coefficients from the given floats array
     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)
     * @returns the spherical harmonics (this)
     */
    updateFromFloatsArray(data) {
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromFloatsToRef(data[0], data[1], data[2], this.l00);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromFloatsToRef(data[3], data[4], data[5], this.l1_1);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromFloatsToRef(data[6], data[7], data[8], this.l10);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromFloatsToRef(data[9], data[10], data[11], this.l11);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromFloatsToRef(data[12], data[13], data[14], this.l2_2);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromFloatsToRef(data[15], data[16], data[17], this.l2_1);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromFloatsToRef(data[18], data[19], data[20], this.l20);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromFloatsToRef(data[21], data[22], data[23], this.l21);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromFloatsToRef(data[24], data[25], data[26], this.l22);
        return this;
    }
    /**
     * Constructs a spherical harmonics from an array.
     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)
     * @returns the spherical harmonics
     */
    static FromArray(data) {
        const sh = new SphericalHarmonics();
        return sh.updateFromArray(data);
    }
    // Keep for references.
    /**
     * Gets the spherical harmonics from polynomial
     * @param polynomial the spherical polynomial
     * @returns the spherical harmonics
     */
    static FromPolynomial(polynomial) {
        const result = new SphericalHarmonics();
        result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));
        result.l1_1 = polynomial.y.scale(0.977204);
        result.l10 = polynomial.z.scale(0.977204);
        result.l11 = polynomial.x.scale(0.977204);
        result.l2_2 = polynomial.xy.scale(1.16538);
        result.l2_1 = polynomial.yz.scale(1.16538);
        result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));
        result.l21 = polynomial.zx.scale(1.16538);
        result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));
        result.l1_1.scaleInPlace(-1);
        result.l11.scaleInPlace(-1);
        result.l2_1.scaleInPlace(-1);
        result.l21.scaleInPlace(-1);
        result.scaleInPlace(Math.PI);
        return result;
    }
}
/**
 * Class representing spherical polynomial coefficients to the 3rd degree
 */
class SphericalPolynomial {
    constructor() {
        /**
         * The x coefficients of the spherical polynomial
         */
        this.x = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The y coefficients of the spherical polynomial
         */
        this.y = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The z coefficients of the spherical polynomial
         */
        this.z = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The xx coefficients of the spherical polynomial
         */
        this.xx = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The yy coefficients of the spherical polynomial
         */
        this.yy = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The zz coefficients of the spherical polynomial
         */
        this.zz = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The xy coefficients of the spherical polynomial
         */
        this.xy = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The yz coefficients of the spherical polynomial
         */
        this.yz = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
        /**
         * The zx coefficients of the spherical polynomial
         */
        this.zx = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
    }
    /**
     * The spherical harmonics used to create the polynomials.
     */
    get preScaledHarmonics() {
        if (!this._harmonics) {
            this._harmonics = SphericalHarmonics.FromPolynomial(this);
        }
        if (!this._harmonics.preScaled) {
            this._harmonics.preScaleForRendering();
        }
        return this._harmonics;
    }
    /**
     * Adds an ambient color to the spherical polynomial
     * @param color the color to add
     */
    addAmbient(color) {
        _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[0].copyFromFloats(color.r, color.g, color.b);
        const colorVector = _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[0];
        this.xx.addInPlace(colorVector);
        this.yy.addInPlace(colorVector);
        this.zz.addInPlace(colorVector);
    }
    /**
     * Scales the spherical polynomial by the given amount
     * @param scale the amount to scale
     */
    scaleInPlace(scale) {
        this.x.scaleInPlace(scale);
        this.y.scaleInPlace(scale);
        this.z.scaleInPlace(scale);
        this.xx.scaleInPlace(scale);
        this.yy.scaleInPlace(scale);
        this.zz.scaleInPlace(scale);
        this.yz.scaleInPlace(scale);
        this.zx.scaleInPlace(scale);
        this.xy.scaleInPlace(scale);
    }
    /**
     * Updates the spherical polynomial from harmonics
     * @param harmonics the spherical harmonics
     * @returns the spherical polynomial
     */
    updateFromHarmonics(harmonics) {
        this._harmonics = harmonics;
        this.x.copyFrom(harmonics.l11);
        this.x.scaleInPlace(1.02333).scaleInPlace(-1);
        this.y.copyFrom(harmonics.l1_1);
        this.y.scaleInPlace(1.02333).scaleInPlace(-1);
        this.z.copyFrom(harmonics.l10);
        this.z.scaleInPlace(1.02333);
        this.xx.copyFrom(harmonics.l00);
        _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.247708);
        _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[1].copyFrom(harmonics.l22).scaleInPlace(0.429043);
        this.xx.scaleInPlace(0.886277).subtractInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[0]).addInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[1]);
        this.yy.copyFrom(harmonics.l00);
        this.yy.scaleInPlace(0.886277).subtractInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[0]).subtractInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[1]);
        this.zz.copyFrom(harmonics.l00);
        _math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.495417);
        this.zz.scaleInPlace(0.886277).addInPlace(_math_js__WEBPACK_IMPORTED_MODULE_1__.TmpVectors.Vector3[0]);
        this.yz.copyFrom(harmonics.l2_1);
        this.yz.scaleInPlace(0.858086).scaleInPlace(-1);
        this.zx.copyFrom(harmonics.l21);
        this.zx.scaleInPlace(0.858086).scaleInPlace(-1);
        this.xy.copyFrom(harmonics.l2_2);
        this.xy.scaleInPlace(0.858086);
        this.scaleInPlace(1.0 / Math.PI);
        return this;
    }
    /**
     * Gets the spherical polynomial from harmonics
     * @param harmonics the spherical harmonics
     * @returns the spherical polynomial
     */
    static FromHarmonics(harmonics) {
        const result = new SphericalPolynomial();
        return result.updateFromHarmonics(harmonics);
    }
    /**
     * Constructs a spherical polynomial from an array.
     * @param data defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)
     * @returns the spherical polynomial
     */
    static FromArray(data) {
        const sp = new SphericalPolynomial();
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[0], 0, sp.x);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[1], 0, sp.y);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[2], 0, sp.z);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[3], 0, sp.xx);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[4], 0, sp.yy);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[5], 0, sp.zz);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[6], 0, sp.yz);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[7], 0, sp.zx);
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(data[8], 0, sp.xy);
        return sp;
    }
}
//# sourceMappingURL=sphericalPolynomial.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLDataBuffer: () => (/* binding */ WebGLDataBuffer)
/* harmony export */ });
/* harmony import */ var _Buffers_dataBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Buffers/dataBuffer.js */ "./node_modules/@babylonjs/core/Buffers/dataBuffer.js");

/** @internal */
class WebGLDataBuffer extends _Buffers_dataBuffer_js__WEBPACK_IMPORTED_MODULE_0__.DataBuffer {
    constructor(resource) {
        super();
        this._buffer = resource;
    }
    get underlyingResource() {
        return this._buffer;
    }
}
//# sourceMappingURL=webGLDataBuffer.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CubeMapToSphericalPolynomialTools: () => (/* binding */ CubeMapToSphericalPolynomialTools)
/* harmony export */ });
/* harmony import */ var _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");
/* harmony import */ var _Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Maths/math.scalar.functions.js */ "./node_modules/@babylonjs/core/Maths/math.scalar.functions.js");
/* harmony import */ var _Maths_sphericalPolynomial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Maths/sphericalPolynomial.js */ "./node_modules/@babylonjs/core/Maths/sphericalPolynomial.js");
/* harmony import */ var _Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Maths/math.constants.js */ "./node_modules/@babylonjs/core/Maths/math.constants.js");
/* harmony import */ var _Maths_math_color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Maths/math.color.js */ "./node_modules/@babylonjs/core/Maths/math.color.js");






class FileFaceOrientation {
    constructor(name, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {
        this.name = name;
        this.worldAxisForNormal = worldAxisForNormal;
        this.worldAxisForFileX = worldAxisForFileX;
        this.worldAxisForFileY = worldAxisForFileY;
    }
}
/**
 * Helper class dealing with the extraction of spherical polynomial dataArray
 * from a cube map.
 */
class CubeMapToSphericalPolynomialTools {
    /**
     * Converts a texture to the according Spherical Polynomial data.
     * This extracts the first 3 orders only as they are the only one used in the lighting.
     *
     * @param texture The texture to extract the information from.
     * @returns The Spherical Polynomial data.
     */
    static ConvertCubeMapTextureToSphericalPolynomial(texture) {
        if (!texture.isCube) {
            // Only supports cube Textures currently.
            return null;
        }
        texture.getScene()?.getEngine().flushFramebuffer();
        const size = texture.getSize().width;
        const rightPromise = texture.readPixels(0, undefined, undefined, false);
        const leftPromise = texture.readPixels(1, undefined, undefined, false);
        let upPromise;
        let downPromise;
        if (texture.isRenderTarget) {
            upPromise = texture.readPixels(3, undefined, undefined, false);
            downPromise = texture.readPixels(2, undefined, undefined, false);
        }
        else {
            upPromise = texture.readPixels(2, undefined, undefined, false);
            downPromise = texture.readPixels(3, undefined, undefined, false);
        }
        const frontPromise = texture.readPixels(4, undefined, undefined, false);
        const backPromise = texture.readPixels(5, undefined, undefined, false);
        const gammaSpace = texture.gammaSpace;
        // Always read as RGBA.
        const format = 5;
        let type = 0;
        if (texture.textureType == 1 || texture.textureType == 2) {
            type = 1;
        }
        return new Promise((resolve) => {
            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {
                const cubeInfo = {
                    size,
                    right,
                    left,
                    up,
                    down,
                    front,
                    back,
                    format,
                    type,
                    gammaSpace,
                };
                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));
            });
        });
    }
    /**
     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin
     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/
     * @param x
     * @param y
     * @returns the area
     */
    static _AreaElement(x, y) {
        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
    }
    /**
     * Converts a cubemap to the according Spherical Polynomial data.
     * This extracts the first 3 orders only as they are the only one used in the lighting.
     *
     * @param cubeInfo The Cube map to extract the information from.
     * @returns The Spherical Polynomial data.
     */
    static ConvertCubeMapToSphericalPolynomial(cubeInfo) {
        const sphericalHarmonics = new _Maths_sphericalPolynomial_js__WEBPACK_IMPORTED_MODULE_2__.SphericalHarmonics();
        let totalSolidAngle = 0.0;
        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.
        const du = 2.0 / cubeInfo.size;
        const dv = du;
        const halfTexel = 0.5 * du;
        // The (u,v) of the first texel is half a texel from the corner (-1,-1).
        const minUV = halfTexel - 1.0;
        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
            const fileFace = this._FileFaces[faceIndex];
            const dataArray = cubeInfo[fileFace.name];
            let v = minUV;
            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).
            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.
            // Because SP is still linear, so summation is fine in that basis.
            const stride = cubeInfo.format === 5 ? 4 : 3;
            for (let y = 0; y < cubeInfo.size; y++) {
                let u = minUV;
                for (let x = 0; x < cubeInfo.size; x++) {
                    // World direction (not normalised)
                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);
                    worldDirection.normalize();
                    const deltaSolidAngle = this._AreaElement(u - halfTexel, v - halfTexel) -
                        this._AreaElement(u - halfTexel, v + halfTexel) -
                        this._AreaElement(u + halfTexel, v - halfTexel) +
                        this._AreaElement(u + halfTexel, v + halfTexel);
                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];
                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];
                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];
                    // Prevent NaN harmonics with extreme HDRI data.
                    if (isNaN(r)) {
                        r = 0;
                    }
                    if (isNaN(g)) {
                        g = 0;
                    }
                    if (isNaN(b)) {
                        b = 0;
                    }
                    // Handle Integer types.
                    if (cubeInfo.type === 0) {
                        r /= 255;
                        g /= 255;
                        b /= 255;
                    }
                    // Handle Gamma space textures.
                    if (cubeInfo.gammaSpace) {
                        r = Math.pow((0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_1__.Clamp)(r), _Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_3__.ToLinearSpace);
                        g = Math.pow((0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_1__.Clamp)(g), _Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_3__.ToLinearSpace);
                        b = Math.pow((0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_1__.Clamp)(b), _Maths_math_constants_js__WEBPACK_IMPORTED_MODULE_3__.ToLinearSpace);
                    }
                    // Prevent to explode in case of really high dynamic ranges.
                    // sh 3 would not be enough to accurately represent it.
                    const max = this.MAX_HDRI_VALUE;
                    if (this.PRESERVE_CLAMPED_COLORS) {
                        const currentMax = Math.max(r, g, b);
                        if (currentMax > max) {
                            const factor = max / currentMax;
                            r *= factor;
                            g *= factor;
                            b *= factor;
                        }
                    }
                    else {
                        r = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_1__.Clamp)(r, 0, max);
                        g = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_1__.Clamp)(g, 0, max);
                        b = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_1__.Clamp)(b, 0, max);
                    }
                    const color = new _Maths_math_color_js__WEBPACK_IMPORTED_MODULE_4__.Color3(r, g, b);
                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);
                    totalSolidAngle += deltaSolidAngle;
                    u += du;
                }
                v += dv;
            }
        }
        // Solid angle for entire sphere is 4*pi
        const sphereSolidAngle = 4.0 * Math.PI;
        // Adjust the solid angle to allow for how many faces we processed.
        const facesProcessed = 6.0;
        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;
        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.
        // This is needed because the numerical integration over the cube uses a
        // small angle approximation of solid angle for each texel (see deltaSolidAngle),
        // and also to compensate for accumulative error due to float precision in the summation.
        const correctionFactor = expectedSolidAngle / totalSolidAngle;
        sphericalHarmonics.scaleInPlace(correctionFactor);
        sphericalHarmonics.convertIncidentRadianceToIrradiance();
        sphericalHarmonics.convertIrradianceToLambertianRadiance();
        return _Maths_sphericalPolynomial_js__WEBPACK_IMPORTED_MODULE_2__.SphericalPolynomial.FromHarmonics(sphericalHarmonics);
    }
}
CubeMapToSphericalPolynomialTools._FileFaces = [
    new FileFaceOrientation("right", new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0)), // +X east
    new FileFaceOrientation("left", new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0)), // -X west
    new FileFaceOrientation("up", new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1)), // +Y north
    new FileFaceOrientation("down", new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1)), // -Y south
    new FileFaceOrientation("front", new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0)), // +Z top
    new FileFaceOrientation("back", new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0)), // -Z bottom
];
/** @internal */
CubeMapToSphericalPolynomialTools.MAX_HDRI_VALUE = 4096;
/** @internal */
CubeMapToSphericalPolynomialTools.PRESERVE_CLAMPED_COLORS = false;
//# sourceMappingURL=cubemapToSphericalPolynomial.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/performanceMonitor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/performanceMonitor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerformanceMonitor: () => (/* binding */ PerformanceMonitor),
/* harmony export */   RollingAverage: () => (/* binding */ RollingAverage)
/* harmony export */ });
/* harmony import */ var _precisionDate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./precisionDate.js */ "./node_modules/@babylonjs/core/Misc/precisionDate.js");

/**
 * Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window
 */
class PerformanceMonitor {
    /**
     * constructor
     * @param frameSampleSize The number of samples required to saturate the sliding window
     */
    constructor(frameSampleSize = 30) {
        this._enabled = true;
        this._rollingFrameTime = new RollingAverage(frameSampleSize);
    }
    /**
     * Samples current frame
     * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames
     */
    sampleFrame(timeMs = _precisionDate_js__WEBPACK_IMPORTED_MODULE_0__.PrecisionDate.Now) {
        if (!this._enabled) {
            return;
        }
        if (this._lastFrameTimeMs != null) {
            const dt = timeMs - this._lastFrameTimeMs;
            this._rollingFrameTime.add(dt);
        }
        this._lastFrameTimeMs = timeMs;
    }
    /**
     * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
     */
    get averageFrameTime() {
        return this._rollingFrameTime.average;
    }
    /**
     * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
     */
    get averageFrameTimeVariance() {
        return this._rollingFrameTime.variance;
    }
    /**
     * Returns the frame time of the most recent frame
     */
    get instantaneousFrameTime() {
        return this._rollingFrameTime.history(0);
    }
    /**
     * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)
     */
    get averageFPS() {
        return 1000.0 / this._rollingFrameTime.average;
    }
    /**
     * Returns the average framerate in frames per second using the most recent frame time
     */
    get instantaneousFPS() {
        const history = this._rollingFrameTime.history(0);
        if (history === 0) {
            return 0;
        }
        return 1000.0 / history;
    }
    /**
     * Returns true if enough samples have been taken to completely fill the sliding window
     */
    get isSaturated() {
        return this._rollingFrameTime.isSaturated();
    }
    /**
     * Enables contributions to the sliding window sample set
     */
    enable() {
        this._enabled = true;
    }
    /**
     * Disables contributions to the sliding window sample set
     * Samples will not be interpolated over the disabled period
     */
    disable() {
        this._enabled = false;
        //clear last sample to avoid interpolating over the disabled period when next enabled
        this._lastFrameTimeMs = null;
    }
    /**
     * Returns true if sampling is enabled
     */
    get isEnabled() {
        return this._enabled;
    }
    /**
     * Resets performance monitor
     */
    reset() {
        //clear last sample to avoid interpolating over the disabled period when next enabled
        this._lastFrameTimeMs = null;
        //wipe record
        this._rollingFrameTime.reset();
    }
}
/**
 * RollingAverage
 *
 * Utility to efficiently compute the rolling average and variance over a sliding window of samples
 */
class RollingAverage {
    /**
     * constructor
     * @param length The number of samples required to saturate the sliding window
     */
    constructor(length) {
        this._samples = new Array(length);
        this.reset();
    }
    /**
     * Adds a sample to the sample set
     * @param v The sample value
     */
    add(v) {
        //http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
        let delta;
        //we need to check if we've already wrapped round
        if (this.isSaturated()) {
            //remove bottom of stack from mean
            const bottomValue = this._samples[this._pos];
            delta = bottomValue - this.average;
            this.average -= delta / (this._sampleCount - 1);
            this._m2 -= delta * (bottomValue - this.average);
        }
        else {
            this._sampleCount++;
        }
        //add new value to mean
        delta = v - this.average;
        this.average += delta / this._sampleCount;
        this._m2 += delta * (v - this.average);
        //set the new variance
        this.variance = this._m2 / (this._sampleCount - 1);
        this._samples[this._pos] = v;
        this._pos++;
        this._pos %= this._samples.length; //positive wrap around
    }
    /**
     * Returns previously added values or null if outside of history or outside the sliding window domain
     * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that
     * @returns Value previously recorded with add() or null if outside of range
     */
    history(i) {
        if (i >= this._sampleCount || i >= this._samples.length) {
            return 0;
        }
        const i0 = this._wrapPosition(this._pos - 1.0);
        return this._samples[this._wrapPosition(i0 - i)];
    }
    /**
     * Returns true if enough samples have been taken to completely fill the sliding window
     * @returns true if sample-set saturated
     */
    isSaturated() {
        return this._sampleCount >= this._samples.length;
    }
    /**
     * Resets the rolling average (equivalent to 0 samples taken so far)
     */
    reset() {
        this.average = 0;
        this.variance = 0;
        this._sampleCount = 0;
        this._pos = 0;
        this._m2 = 0;
    }
    /**
     * Wraps a value around the sample range boundaries
     * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.
     * @returns Wrapped position in sample range
     */
    _wrapPosition(i) {
        const max = this._samples.length;
        return ((i % max) + max) % max;
    }
}
//# sourceMappingURL=performanceMonitor.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/textureTools.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/textureTools.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApplyPostProcess: () => (/* binding */ ApplyPostProcess),
/* harmony export */   CreateResizedCopy: () => (/* binding */ CreateResizedCopy),
/* harmony export */   FromHalfFloat: () => (/* binding */ FromHalfFloat),
/* harmony export */   GetTextureDataAsync: () => (/* binding */ GetTextureDataAsync),
/* harmony export */   TextureTools: () => (/* binding */ TextureTools),
/* harmony export */   ToHalfFloat: () => (/* binding */ ToHalfFloat)
/* harmony export */ });
/* harmony import */ var _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Materials/Textures/texture.js */ "./node_modules/@babylonjs/core/Materials/Textures/texture.js");
/* harmony import */ var _Materials_Textures_renderTargetTexture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Materials/Textures/renderTargetTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js");
/* harmony import */ var _PostProcesses_passPostProcess_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PostProcesses/passPostProcess.js */ "./node_modules/@babylonjs/core/PostProcesses/passPostProcess.js");
/* harmony import */ var _PostProcesses_postProcess_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PostProcesses/postProcess.js */ "./node_modules/@babylonjs/core/PostProcesses/postProcess.js");





/**
 * Uses the GPU to create a copy texture rescaled at a given size
 * @param texture Texture to copy from
 * @param width defines the desired width
 * @param height defines the desired height
 * @param useBilinearMode defines if bilinear mode has to be used
 * @returns the generated texture
 */
function CreateResizedCopy(texture, width, height, useBilinearMode = true) {
    const scene = texture.getScene();
    const engine = scene.getEngine();
    const rtt = new _Materials_Textures_renderTargetTexture_js__WEBPACK_IMPORTED_MODULE_1__.RenderTargetTexture("resized" + texture.name, { width: width, height: height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);
    rtt.wrapU = texture.wrapU;
    rtt.wrapV = texture.wrapV;
    rtt.uOffset = texture.uOffset;
    rtt.vOffset = texture.vOffset;
    rtt.uScale = texture.uScale;
    rtt.vScale = texture.vScale;
    rtt.uAng = texture.uAng;
    rtt.vAng = texture.vAng;
    rtt.wAng = texture.wAng;
    rtt.coordinatesIndex = texture.coordinatesIndex;
    rtt.level = texture.level;
    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;
    rtt._texture.isReady = false;
    texture.wrapU = _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_0__.Texture.CLAMP_ADDRESSMODE;
    texture.wrapV = _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_0__.Texture.CLAMP_ADDRESSMODE;
    const passPostProcess = new _PostProcesses_passPostProcess_js__WEBPACK_IMPORTED_MODULE_2__.PassPostProcess("pass", 1, null, useBilinearMode ? _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_0__.Texture.BILINEAR_SAMPLINGMODE : _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_SAMPLINGMODE, engine, false, 0);
    passPostProcess.externalTextureSamplerBinding = true;
    passPostProcess.onEffectCreatedObservable.addOnce((e) => {
        e.executeWhenCompiled(() => {
            passPostProcess.onApply = function (effect) {
                effect.setTexture("textureSampler", texture);
            };
            const internalTexture = rtt.renderTarget;
            if (internalTexture) {
                scene.postProcessManager.directRender([passPostProcess], internalTexture);
                engine.unBindFramebuffer(internalTexture);
                rtt.disposeFramebufferObjects();
                passPostProcess.dispose();
                rtt.getInternalTexture().isReady = true;
            }
        });
    });
    return rtt;
}
/**
 * Apply a post process to a texture
 * @param postProcessName name of the fragment post process
 * @param internalTexture the texture to encode
 * @param scene the scene hosting the texture
 * @param type type of the output texture. If not provided, use the one from internalTexture
 * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture
 * @param format format of the output texture. If not provided, use the one from internalTexture
 * @param width width of the output texture. If not provided, use the one from internalTexture
 * @param height height of the output texture. If not provided, use the one from internalTexture
 * @returns a promise with the internalTexture having its texture replaced by the result of the processing
 */
function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format, width, height) {
    // Gets everything ready.
    const engine = internalTexture.getEngine();
    internalTexture.isReady = false;
    samplingMode = samplingMode ?? internalTexture.samplingMode;
    type = type ?? internalTexture.type;
    format = format ?? internalTexture.format;
    width = width ?? internalTexture.width;
    height = height ?? internalTexture.height;
    if (type === -1) {
        type = 0;
    }
    return new Promise((resolve) => {
        // Create the post process
        const postProcess = new _PostProcesses_postProcess_js__WEBPACK_IMPORTED_MODULE_3__.PostProcess("postprocess", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);
        postProcess.externalTextureSamplerBinding = true;
        // Hold the output of the decoding.
        const encodedTexture = engine.createRenderTargetTexture({ width: width, height: height }, {
            generateDepthBuffer: false,
            generateMipMaps: false,
            generateStencilBuffer: false,
            samplingMode,
            type,
            format,
        });
        postProcess.onEffectCreatedObservable.addOnce((e) => {
            e.executeWhenCompiled(() => {
                // PP Render Pass
                postProcess.onApply = (effect) => {
                    effect._bindTexture("textureSampler", internalTexture);
                    effect.setFloat2("scale", 1, 1);
                };
                scene.postProcessManager.directRender([postProcess], encodedTexture, true);
                // Cleanup
                engine.restoreDefaultFramebuffer();
                engine._releaseTexture(internalTexture);
                if (postProcess) {
                    postProcess.dispose();
                }
                // Internal Swap
                encodedTexture._swapAndDie(internalTexture);
                // Ready to get rolling again.
                internalTexture.type = type;
                internalTexture.format = 5;
                internalTexture.isReady = true;
                resolve(internalTexture);
            });
        });
    });
}
// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript
let floatView;
let int32View;
/**
 * Converts a number to half float
 * @param value number to convert
 * @returns converted number
 */
function ToHalfFloat(value) {
    if (!floatView) {
        floatView = new Float32Array(1);
        int32View = new Int32Array(floatView.buffer);
    }
    floatView[0] = value;
    const x = int32View[0];
    let bits = (x >> 16) & 0x8000; /* Get the sign */
    let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */
    const e = (x >> 23) & 0xff; /* Using int is faster here */
    /* If zero, or denormal, or exponent underflows too much for a denormal
     * half, return signed zero. */
    if (e < 103) {
        return bits;
    }
    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
    if (e > 142) {
        bits |= 0x7c00;
        /* If exponent was 0xff and one mantissa bit was set, it means NaN,
         * not Inf, so make sure we set one mantissa bit too. */
        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
        return bits;
    }
    /* If exponent underflows but not too much, return a denormal */
    if (e < 113) {
        m |= 0x0800;
        /* Extra rounding may overflow and set mantissa to 0 and exponent
         * to 1, which is OK. */
        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
        return bits;
    }
    bits |= ((e - 112) << 10) | (m >> 1);
    bits += m & 1;
    return bits;
}
/**
 * Converts a half float to a number
 * @param value half float to convert
 * @returns converted half float
 */
function FromHalfFloat(value) {
    const s = (value & 0x8000) >> 15;
    const e = (value & 0x7c00) >> 10;
    const f = value & 0x03ff;
    if (e === 0) {
        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
    }
    else if (e == 0x1f) {
        return f ? NaN : (s ? -1 : 1) * Infinity;
    }
    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
const ProcessAsync = async (texture, width, height, face, lod) => {
    const scene = texture.getScene();
    const engine = scene.getEngine();
    if (!engine.isWebGPU) {
        if (texture.isCube) {
            await __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_Shaders_lodCube_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../Shaders/lodCube.fragment.js */ "./node_modules/@babylonjs/core/Shaders/lodCube.fragment.js"));
        }
        else {
            await __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_Shaders_lod_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../Shaders/lod.fragment.js */ "./node_modules/@babylonjs/core/Shaders/lod.fragment.js"));
        }
    }
    else {
        if (texture.isCube) {
            await __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_ShadersWGSL_lodCube_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../ShadersWGSL/lodCube.fragment.js */ "./node_modules/@babylonjs/core/ShadersWGSL/lodCube.fragment.js"));
        }
        else {
            await __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_ShadersWGSL_lod_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../ShadersWGSL/lod.fragment.js */ "./node_modules/@babylonjs/core/ShadersWGSL/lod.fragment.js"));
        }
    }
    let lodPostProcess;
    if (!texture.isCube) {
        lodPostProcess = new _PostProcesses_postProcess_js__WEBPACK_IMPORTED_MODULE_3__.PostProcess("lod", "lod", {
            uniforms: ["lod", "gamma"],
            samplingMode: _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPNEAREST,
            engine,
            shaderLanguage: engine.isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,
        });
    }
    else {
        const faceDefines = ["#define POSITIVEX", "#define NEGATIVEX", "#define POSITIVEY", "#define NEGATIVEY", "#define POSITIVEZ", "#define NEGATIVEZ"];
        lodPostProcess = new _PostProcesses_postProcess_js__WEBPACK_IMPORTED_MODULE_3__.PostProcess("lodCube", "lodCube", {
            uniforms: ["lod", "gamma"],
            samplingMode: _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPNEAREST,
            engine,
            defines: faceDefines[face],
            shaderLanguage: engine.isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,
        });
    }
    await new Promise((resolve) => {
        lodPostProcess.onEffectCreatedObservable.addOnce((e) => {
            e.executeWhenCompiled(() => {
                resolve(0);
            });
        });
    });
    const rtt = new _Materials_Textures_renderTargetTexture_js__WEBPACK_IMPORTED_MODULE_1__.RenderTargetTexture("temp", { width: width, height: height }, scene, false);
    lodPostProcess.onApply = function (effect) {
        effect.setTexture("textureSampler", texture);
        effect.setFloat("lod", lod);
        effect.setInt("gamma", texture.gammaSpace ? 1 : 0);
    };
    const internalTexture = texture.getInternalTexture();
    try {
        if (rtt.renderTarget && internalTexture) {
            const samplingMode = internalTexture.samplingMode;
            if (lod !== 0) {
                texture.updateSamplingMode(_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPNEAREST);
            }
            else {
                texture.updateSamplingMode(_Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST);
            }
            scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);
            texture.updateSamplingMode(samplingMode);
            //Reading datas from WebGL
            const bufferView = await engine.readPixels(0, 0, width, height);
            const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);
            // Unbind
            engine.unBindFramebuffer(rtt.renderTarget);
            return data;
        }
        else {
            throw Error("Render to texture failed.");
        }
    }
    finally {
        rtt.dispose();
        lodPostProcess.dispose();
    }
};
/**
 * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.
 * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.
 * @param texture the source texture
 * @param width the width of the result, which does not have to match the source texture width
 * @param height the height of the result, which does not have to match the source texture height
 * @param face if the texture has multiple faces, the face index to use for the source
 * @param lod if the texture has multiple LODs, the lod index to use for the source
 * @returns the 8-bit texture data
 */
async function GetTextureDataAsync(texture, width, height, face = 0, lod = 0) {
    if (!texture.isReady() && texture._texture) {
        await new Promise((resolve, reject) => {
            if (texture._texture === null) {
                reject(0);
                return;
            }
            texture._texture.onLoadedObservable.addOnce(() => {
                resolve(0);
            });
        });
    }
    return await ProcessAsync(texture, width, height, face, lod);
}
/**
 * Class used to host texture specific utilities
 */
const TextureTools = {
    /**
     * Uses the GPU to create a copy texture rescaled at a given size
     * @param texture Texture to copy from
     * @param width defines the desired width
     * @param height defines the desired height
     * @param useBilinearMode defines if bilinear mode has to be used
     * @returns the generated texture
     */
    CreateResizedCopy,
    /**
     * Apply a post process to a texture
     * @param postProcessName name of the fragment post process
     * @param internalTexture the texture to encode
     * @param scene the scene hosting the texture
     * @param type type of the output texture. If not provided, use the one from internalTexture
     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture
     * @param format format of the output texture. If not provided, use the one from internalTexture
     * @returns a promise with the internalTexture having its texture replaced by the result of the processing
     */
    ApplyPostProcess,
    /**
     * Converts a number to half float
     * @param value number to convert
     * @returns converted number
     */
    ToHalfFloat,
    /**
     * Converts a half float to a number
     * @param value half float to convert
     * @returns converted half float
     */
    FromHalfFloat,
    /**
     * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.
     * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.
     * @param texture the source texture
     * @param width the width of the result, which does not have to match the source texture width
     * @param height the height of the result, which does not have to match the source texture height
     * @param face if the texture has multiple faces, the face index to use for the source
     * @param channels a filter for which of the RGBA channels to return in the result
     * @param lod if the texture has multiple LODs, the lod index to use for the source
     * @returns the 8-bit texture data
     */
    GetTextureDataAsync,
};
//# sourceMappingURL=textureTools.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/PostProcesses/passPostProcess.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/PostProcesses/passPostProcess.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PassCubePostProcess: () => (/* binding */ PassCubePostProcess),
/* harmony export */   PassPostProcess: () => (/* binding */ PassPostProcess)
/* harmony export */ });
/* harmony import */ var _tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tslib.es6.js */ "./node_modules/@babylonjs/core/tslib.es6.js");
/* harmony import */ var _postProcess_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./postProcess.js */ "./node_modules/@babylonjs/core/PostProcesses/postProcess.js");
/* harmony import */ var _Engines_abstractEngine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Engines/abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");
/* harmony import */ var _Misc_typeStore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Misc/typeStore.js */ "./node_modules/@babylonjs/core/Misc/typeStore.js");
/* harmony import */ var _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Misc/decorators.serialization.js */ "./node_modules/@babylonjs/core/Misc/decorators.serialization.js");
/* harmony import */ var _thinPassPostProcess_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./thinPassPostProcess.js */ "./node_modules/@babylonjs/core/PostProcesses/thinPassPostProcess.js");
/* harmony import */ var _Misc_decorators_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Misc/decorators.js */ "./node_modules/@babylonjs/core/Misc/decorators.js");








/**
 * PassPostProcess which produces an output the same as it's input
 */
class PassPostProcess extends _postProcess_js__WEBPACK_IMPORTED_MODULE_1__.PostProcess {
    /**
     * Gets a string identifying the name of the class
     * @returns "PassPostProcess" string
     */
    getClassName() {
        return "PassPostProcess";
    }
    /**
     * Creates the PassPostProcess
     * @param name The name of the effect.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType The type of texture to be used when performing the post processing.
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    constructor(name, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        const localOptions = {
            size: typeof options === "number" ? options : undefined,
            camera,
            samplingMode,
            engine,
            reusable,
            textureType,
            blockCompilation,
            ...options,
        };
        super(name, _thinPassPostProcess_js__WEBPACK_IMPORTED_MODULE_5__.ThinPassPostProcess.FragmentUrl, {
            effectWrapper: typeof options === "number" || !options.effectWrapper ? new _thinPassPostProcess_js__WEBPACK_IMPORTED_MODULE_5__.ThinPassPostProcess(name, engine, localOptions) : undefined,
            ...localOptions,
        });
    }
    /**
     * @internal
     */
    static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_4__.SerializationHelper.Parse(() => {
            return new PassPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
        }, parsedPostProcess, scene, rootUrl);
    }
}
(0,_Misc_typeStore_js__WEBPACK_IMPORTED_MODULE_3__.RegisterClass)("BABYLON.PassPostProcess", PassPostProcess);
/**
 * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)
 */
class PassCubePostProcess extends _postProcess_js__WEBPACK_IMPORTED_MODULE_1__.PostProcess {
    /**
     * Gets or sets the cube face to display.
     *  * 0 is +X
     *  * 1 is -X
     *  * 2 is +Y
     *  * 3 is -Y
     *  * 4 is +Z
     *  * 5 is -Z
     */
    get face() {
        return this._effectWrapper.face;
    }
    set face(value) {
        this._effectWrapper.face = value;
    }
    /**
     * Gets a string identifying the name of the class
     * @returns "PassCubePostProcess" string
     */
    getClassName() {
        return "PassCubePostProcess";
    }
    /**
     * Creates the PassCubePostProcess
     * @param name The name of the effect.
     * @param options The required width/height ratio to downsize to before computing the render pass.
     * @param camera The camera to apply the render pass to.
     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
     * @param engine The engine which the post process will be applied. (default: current engine)
     * @param reusable If the post process can be reused on the same frame. (default: false)
     * @param textureType The type of texture to be used when performing the post processing.
     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
     */
    constructor(name, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        const localOptions = {
            size: typeof options === "number" ? options : undefined,
            camera,
            samplingMode,
            engine,
            reusable,
            textureType,
            blockCompilation,
            ...options,
        };
        super(name, _thinPassPostProcess_js__WEBPACK_IMPORTED_MODULE_5__.ThinPassPostProcess.FragmentUrl, {
            effectWrapper: typeof options === "number" || !options.effectWrapper ? new _thinPassPostProcess_js__WEBPACK_IMPORTED_MODULE_5__.ThinPassCubePostProcess(name, engine, localOptions) : undefined,
            ...localOptions,
        });
    }
    /**
     * @internal
     */
    static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_4__.SerializationHelper.Parse(() => {
            return new PassCubePostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
        }, parsedPostProcess, scene, rootUrl);
    }
}
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_6__.serialize)()
], PassCubePostProcess.prototype, "face", null);
_Engines_abstractEngine_js__WEBPACK_IMPORTED_MODULE_2__.AbstractEngine._RescalePostProcessFactory = (engine) => {
    return new PassPostProcess("rescale", 1, null, 2, engine, false, 0);
};
//# sourceMappingURL=passPostProcess.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/PostProcesses/postProcess.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babylonjs/core/PostProcesses/postProcess.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PostProcess: () => (/* binding */ PostProcess)
/* harmony export */ });
/* harmony import */ var _tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tslib.es6.js */ "./node_modules/@babylonjs/core/tslib.es6.js");
/* harmony import */ var _Misc_smartArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Misc/smartArray.js */ "./node_modules/@babylonjs/core/Misc/smartArray.js");
/* harmony import */ var _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Misc/observable.js */ "./node_modules/@babylonjs/core/Misc/observable.js");
/* harmony import */ var _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Maths/math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");
/* harmony import */ var _Materials_effect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Materials/effect.js */ "./node_modules/@babylonjs/core/Materials/effect.js");
/* harmony import */ var _Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Misc/decorators.js */ "./node_modules/@babylonjs/core/Misc/decorators.js");
/* harmony import */ var _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Misc/decorators.serialization.js */ "./node_modules/@babylonjs/core/Misc/decorators.serialization.js");
/* harmony import */ var _Misc_typeStore_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Misc/typeStore.js */ "./node_modules/@babylonjs/core/Misc/typeStore.js");
/* harmony import */ var _Engines_abstractEngine_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Engines/abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");
/* harmony import */ var _Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Misc/tools.functions.js */ "./node_modules/@babylonjs/core/Misc/tools.functions.js");
/* harmony import */ var _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Materials/effectRenderer.js */ "./node_modules/@babylonjs/core/Materials/effectRenderer.js");












_Engines_abstractEngine_js__WEBPACK_IMPORTED_MODULE_8__.AbstractEngine.prototype.setTextureFromPostProcess = function (channel, postProcess, name) {
    let postProcessInput = null;
    if (postProcess) {
        if (postProcess._forcedOutputTexture) {
            postProcessInput = postProcess._forcedOutputTexture;
        }
        else if (postProcess._textures.data[postProcess._currentRenderTextureInd]) {
            postProcessInput = postProcess._textures.data[postProcess._currentRenderTextureInd];
        }
    }
    this._bindTexture(channel, postProcessInput?.texture ?? null, name);
};
_Engines_abstractEngine_js__WEBPACK_IMPORTED_MODULE_8__.AbstractEngine.prototype.setTextureFromPostProcessOutput = function (channel, postProcess, name) {
    this._bindTexture(channel, postProcess?._outputTexture?.texture ?? null, name);
};
/**
 * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)
 * @param channel Name of the sampler variable.
 * @param postProcess Post process to get the input texture from.
 */
_Materials_effect_js__WEBPACK_IMPORTED_MODULE_4__.Effect.prototype.setTextureFromPostProcess = function (channel, postProcess) {
    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);
};
/**
 * (Warning! setTextureFromPostProcessOutput may be desired instead)
 * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)
 * @param channel Name of the sampler variable.
 * @param postProcess Post process to get the output texture from.
 */
_Materials_effect_js__WEBPACK_IMPORTED_MODULE_4__.Effect.prototype.setTextureFromPostProcessOutput = function (channel, postProcess) {
    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);
};
/**
 * PostProcess can be used to apply a shader to a texture after it has been rendered
 * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses
 */
class PostProcess {
    /**
     * Force all the postprocesses to compile to glsl even on WebGPU engines.
     * False by default. This is mostly meant for backward compatibility.
     */
    static get ForceGLSL() {
        return _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_10__.EffectWrapper.ForceGLSL;
    }
    static set ForceGLSL(force) {
        _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_10__.EffectWrapper.ForceGLSL = force;
    }
    /**
     * Registers a shader code processing with a post process name.
     * @param postProcessName name of the post process. Use null for the fallback shader code processing. This is the shader code processing that will be used in case no specific shader code processing has been associated to a post process name
     * @param customShaderCodeProcessing shader code processing to associate to the post process name
     */
    static RegisterShaderCodeProcessing(postProcessName, customShaderCodeProcessing) {
        _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_10__.EffectWrapper.RegisterShaderCodeProcessing(postProcessName, customShaderCodeProcessing);
    }
    /** Name of the PostProcess. */
    get name() {
        return this._effectWrapper.name;
    }
    set name(value) {
        this._effectWrapper.name = value;
    }
    /**
     * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)
     */
    get alphaMode() {
        return this._effectWrapper.alphaMode;
    }
    set alphaMode(value) {
        this._effectWrapper.alphaMode = value;
    }
    /**
     * Number of sample textures (default: 1)
     */
    get samples() {
        return this._samples;
    }
    set samples(n) {
        this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);
        this._textures.forEach((texture) => {
            texture.setSamples(this._samples);
        });
    }
    /**
     * Gets the shader language type used to generate vertex and fragment source code.
     */
    get shaderLanguage() {
        return this._shaderLanguage;
    }
    /**
     * Returns the fragment url or shader name used in the post process.
     * @returns the fragment url or name in the shader store.
     */
    getEffectName() {
        return this._fragmentUrl;
    }
    /**
     * A function that is added to the onActivateObservable
     */
    set onActivate(callback) {
        if (this._onActivateObserver) {
            this.onActivateObservable.remove(this._onActivateObserver);
        }
        if (callback) {
            this._onActivateObserver = this.onActivateObservable.add(callback);
        }
    }
    /**
     * A function that is added to the onSizeChangedObservable
     */
    set onSizeChanged(callback) {
        if (this._onSizeChangedObserver) {
            this.onSizeChangedObservable.remove(this._onSizeChangedObserver);
        }
        this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);
    }
    /**
     * A function that is added to the onApplyObservable
     */
    set onApply(callback) {
        if (this._onApplyObserver) {
            this.onApplyObservable.remove(this._onApplyObserver);
        }
        this._onApplyObserver = this.onApplyObservable.add(callback);
    }
    /**
     * A function that is added to the onBeforeRenderObservable
     */
    set onBeforeRender(callback) {
        if (this._onBeforeRenderObserver) {
            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
        }
        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
    }
    /**
     * A function that is added to the onAfterRenderObservable
     */
    set onAfterRender(callback) {
        if (this._onAfterRenderObserver) {
            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
        }
        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
    }
    /**
     * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will
     * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.
     */
    get inputTexture() {
        return this._textures.data[this._currentRenderTextureInd];
    }
    set inputTexture(value) {
        this._forcedOutputTexture = value;
    }
    /**
     * Since inputTexture should always be defined, if we previously manually set `inputTexture`,
     * the only way to unset it is to use this function to restore its internal state
     */
    restoreDefaultInputTexture() {
        if (this._forcedOutputTexture) {
            this._forcedOutputTexture = null;
            this.markTextureDirty();
        }
    }
    /**
     * Gets the camera which post process is applied to.
     * @returns The camera the post process is applied to.
     */
    getCamera() {
        return this._camera;
    }
    /**
     * Gets the texel size of the postprocess.
     * See https://en.wikipedia.org/wiki/Texel_(graphics)
     */
    get texelSize() {
        if (this._shareOutputWithPostProcess) {
            return this._shareOutputWithPostProcess.texelSize;
        }
        if (this._forcedOutputTexture) {
            this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);
        }
        return this._texelSize;
    }
    /** @internal */
    constructor(name, fragmentUrl, parameters, samplers, _size, camera, samplingMode = 1, engine, reusable, defines = null, textureType = 0, vertexUrl = "postprocess", indexParameters, blockCompilation = false, textureFormat = 5, shaderLanguage, extraInitializations) {
        /** @internal */
        this._parentContainer = null;
        /**
         * Width of the texture to apply the post process on
         */
        this.width = -1;
        /**
         * Height of the texture to apply the post process on
         */
        this.height = -1;
        /**
         * Gets the node material used to create this postprocess (null if the postprocess was manually created)
         */
        this.nodeMaterialSource = null;
        /**
         * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)
         * @internal
         */
        this._outputTexture = null;
        /**
         * If the buffer needs to be cleared before applying the post process. (default: true)
         * Should be set to false if shader will overwrite all previous pixels.
         */
        this.autoClear = true;
        /**
         * If clearing the buffer should be forced in autoClear mode, even when alpha mode is enabled (default: false).
         * By default, the buffer will only be cleared if alpha mode is disabled (and autoClear is true).
         */
        this.forceAutoClearInAlphaMode = false;
        /**
         * Animations to be used for the post processing
         */
        this.animations = [];
        /**
         * Enable Pixel Perfect mode where texture is not scaled to be power of 2.
         * Can only be used on a single postprocess or on the last one of a chain. (default: false)
         */
        this.enablePixelPerfectMode = false;
        /**
         * Force the postprocess to be applied without taking in account viewport
         */
        this.forceFullscreenViewport = true;
        /**
         * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)
         *
         * | Value | Type                                | Description |
         * | ----- | ----------------------------------- | ----------- |
         * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |
         * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |
         * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |
         *
         */
        this.scaleMode = 1;
        /**
         * Force textures to be a power of two (default: false)
         */
        this.alwaysForcePOT = false;
        this._samples = 1;
        /**
         * Modify the scale of the post process to be the same as the viewport (default: false)
         */
        this.adaptScaleToCurrentViewport = false;
        this._webGPUReady = false;
        this._reusable = false;
        this._renderId = 0;
        /**
         * if externalTextureSamplerBinding is true, the "apply" method won't bind the textureSampler texture, it is expected to be done by the "outside" (by the onApplyObservable observer most probably).
         * counter-productive in some cases because if the texture bound by "apply" is different from the currently texture bound, (the one set by the onApplyObservable observer, for eg) some
         * internal structures (materialContext) will be dirtified, which may impact performances
         */
        this.externalTextureSamplerBinding = false;
        /**
         * Smart array of input and output textures for the post process.
         * @internal
         */
        this._textures = new _Misc_smartArray_js__WEBPACK_IMPORTED_MODULE_1__.SmartArray(2);
        /**
         * Smart array of input and output textures for the post process.
         * @internal
         */
        this._textureCache = [];
        /**
         * The index in _textures that corresponds to the output texture.
         * @internal
         */
        this._currentRenderTextureInd = 0;
        this._scaleRatio = new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Vector2(1, 1);
        this._texelSize = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Vector2.Zero();
        // Events
        /**
         * An event triggered when the postprocess is activated.
         */
        this.onActivateObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable();
        /**
         * An event triggered when the postprocess changes its size.
         */
        this.onSizeChangedObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable();
        /**
         * An event triggered when the postprocess applies its effect.
         */
        this.onApplyObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable();
        /**
         * An event triggered before rendering the postprocess
         */
        this.onBeforeRenderObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable();
        /**
         * An event triggered after rendering the postprocess
         */
        this.onAfterRenderObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable();
        /**
         * An event triggered when the post-process is disposed
         */
        this.onDisposeObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable();
        let size = 1;
        let uniformBuffers = null;
        let effectWrapper;
        if (parameters && !Array.isArray(parameters)) {
            const options = parameters;
            parameters = options.uniforms ?? null;
            samplers = options.samplers ?? null;
            size = options.size ?? 1;
            camera = options.camera ?? null;
            samplingMode = options.samplingMode ?? 1;
            engine = options.engine;
            reusable = options.reusable;
            defines = Array.isArray(options.defines) ? options.defines.join("\n") : (options.defines ?? null);
            textureType = options.textureType ?? 0;
            vertexUrl = options.vertexUrl ?? "postprocess";
            indexParameters = options.indexParameters;
            blockCompilation = options.blockCompilation ?? false;
            textureFormat = options.textureFormat ?? 5;
            shaderLanguage = options.shaderLanguage ?? 0 /* ShaderLanguage.GLSL */;
            uniformBuffers = options.uniformBuffers ?? null;
            extraInitializations = options.extraInitializations;
            effectWrapper = options.effectWrapper;
        }
        else if (_size) {
            if (typeof _size === "number") {
                size = _size;
            }
            else {
                size = { width: _size.width, height: _size.height };
            }
        }
        this._useExistingThinPostProcess = !!effectWrapper;
        this._effectWrapper =
            effectWrapper ??
                new _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_10__.EffectWrapper({
                    name,
                    useShaderStore: true,
                    useAsPostProcess: true,
                    fragmentShader: fragmentUrl,
                    engine: engine || camera?.getScene().getEngine(),
                    uniforms: parameters,
                    samplers,
                    uniformBuffers,
                    defines,
                    vertexUrl,
                    indexParameters,
                    blockCompilation: true,
                    shaderLanguage,
                    extraInitializations: undefined,
                });
        this.name = name;
        this.onEffectCreatedObservable = this._effectWrapper.onEffectCreatedObservable;
        if (camera != null) {
            this._camera = camera;
            this._scene = camera.getScene();
            camera.attachPostProcess(this);
            this._engine = this._scene.getEngine();
            this._scene.postProcesses.push(this);
            this.uniqueId = this._scene.getUniqueId();
        }
        else if (engine) {
            this._engine = engine;
            this._engine.postProcesses.push(this);
        }
        this._options = size;
        this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;
        this._reusable = reusable || false;
        this._textureType = textureType;
        this._textureFormat = textureFormat;
        this._shaderLanguage = shaderLanguage || 0 /* ShaderLanguage.GLSL */;
        this._samplers = samplers || [];
        if (this._samplers.indexOf("textureSampler") === -1) {
            this._samplers.push("textureSampler");
        }
        this._fragmentUrl = fragmentUrl;
        this._vertexUrl = vertexUrl;
        this._parameters = parameters || [];
        if (this._parameters.indexOf("scale") === -1) {
            this._parameters.push("scale");
        }
        this._uniformBuffers = uniformBuffers || [];
        this._indexParameters = indexParameters;
        if (!this._useExistingThinPostProcess) {
            this._webGPUReady = this._shaderLanguage === 1 /* ShaderLanguage.WGSL */;
            const importPromises = [];
            this._gatherImports(this._engine.isWebGPU && !PostProcess.ForceGLSL, importPromises);
            this._effectWrapper._webGPUReady = this._webGPUReady;
            this._effectWrapper._postConstructor(blockCompilation, defines, extraInitializations, importPromises);
        }
    }
    _gatherImports(useWebGPU = false, list) {
        // this._webGPUReady is used to detect when a postprocess is intended to be used with WebGPU
        if (useWebGPU && this._webGPUReady) {
            list.push(Promise.all([__webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_ShadersWGSL_postprocess_vertex_js").then(__webpack_require__.bind(__webpack_require__, /*! ../ShadersWGSL/postprocess.vertex.js */ "./node_modules/@babylonjs/core/ShadersWGSL/postprocess.vertex.js"))]));
        }
        else {
            list.push(Promise.all([Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../Shaders/postprocess.vertex.js */ "./node_modules/@babylonjs/core/Shaders/postprocess.vertex.js"))]));
        }
    }
    /**
     * Gets a string identifying the name of the class
     * @returns "PostProcess" string
     */
    getClassName() {
        return "PostProcess";
    }
    /**
     * Gets the engine which this post process belongs to.
     * @returns The engine the post process was enabled with.
     */
    getEngine() {
        return this._engine;
    }
    /**
     * The effect that is created when initializing the post process.
     * @returns The created effect corresponding to the postprocess.
     */
    getEffect() {
        return this._effectWrapper.drawWrapper.effect;
    }
    /**
     * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.
     * @param postProcess The post process to share the output with.
     * @returns This post process.
     */
    shareOutputWith(postProcess) {
        this._disposeTextures();
        this._shareOutputWithPostProcess = postProcess;
        return this;
    }
    /**
     * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.
     * This should be called if the post process that shares output with this post process is disabled/disposed.
     */
    useOwnOutput() {
        if (this._textures.length == 0) {
            this._textures = new _Misc_smartArray_js__WEBPACK_IMPORTED_MODULE_1__.SmartArray(2);
        }
        this._shareOutputWithPostProcess = null;
    }
    /**
     * Updates the effect with the current post process compile time values and recompiles the shader.
     * @param defines Define statements that should be added at the beginning of the shader. (default: null)
     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
     * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
     * @param onCompiled Called when the shader has been compiled.
     * @param onError Called if there is an error when compiling a shader.
     * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)
     * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)
     */
    updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {
        this._effectWrapper.updateEffect(defines, uniforms, samplers, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl);
        this._postProcessDefines = Array.isArray(this._effectWrapper.options.defines) ? this._effectWrapper.options.defines.join("\n") : this._effectWrapper.options.defines;
    }
    /**
     * The post process is reusable if it can be used multiple times within one frame.
     * @returns If the post process is reusable
     */
    isReusable() {
        return this._reusable;
    }
    /** invalidate frameBuffer to hint the postprocess to create a depth buffer */
    markTextureDirty() {
        this.width = -1;
    }
    _createRenderTargetTexture(textureSize, textureOptions, channel = 0) {
        for (let i = 0; i < this._textureCache.length; i++) {
            if (this._textureCache[i].texture.width === textureSize.width &&
                this._textureCache[i].texture.height === textureSize.height &&
                this._textureCache[i].postProcessChannel === channel &&
                this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer &&
                this._textureCache[i].texture.samples === textureOptions.samples) {
                return this._textureCache[i].texture;
            }
        }
        const tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);
        this._textureCache.push({ texture: tex, postProcessChannel: channel, lastUsedRenderId: -1 });
        return tex;
    }
    _flushTextureCache() {
        const currentRenderId = this._renderId;
        for (let i = this._textureCache.length - 1; i >= 0; i--) {
            if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {
                let currentlyUsed = false;
                for (let j = 0; j < this._textures.length; j++) {
                    if (this._textures.data[j] === this._textureCache[i].texture) {
                        currentlyUsed = true;
                        break;
                    }
                }
                if (!currentlyUsed) {
                    this._textureCache[i].texture.dispose();
                    this._textureCache.splice(i, 1);
                }
            }
        }
    }
    /**
     * Resizes the post-process texture
     * @param width Width of the texture
     * @param height Height of the texture
     * @param camera The camera this post-process is applied to. Pass null if the post-process is used outside the context of a camera post-process chain (default: null)
     * @param needMipMaps True if mip maps need to be generated after render (default: false)
     * @param forceDepthStencil True to force post-process texture creation with stencil depth and buffer (default: false)
     */
    resize(width, height, camera = null, needMipMaps = false, forceDepthStencil = false) {
        if (this._textures.length > 0) {
            this._textures.reset();
        }
        this.width = width;
        this.height = height;
        let firstPP = null;
        if (camera) {
            for (let i = 0; i < camera._postProcesses.length; i++) {
                if (camera._postProcesses[i] !== null) {
                    firstPP = camera._postProcesses[i];
                    break;
                }
            }
        }
        const textureSize = { width: this.width, height: this.height };
        const textureOptions = {
            generateMipMaps: needMipMaps,
            generateDepthBuffer: forceDepthStencil || firstPP === this,
            generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,
            samplingMode: this.renderTargetSamplingMode,
            type: this._textureType,
            format: this._textureFormat,
            samples: this._samples,
            label: "PostProcessRTT-" + this.name,
        };
        this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));
        if (this._reusable) {
            this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));
        }
        this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);
        this.onSizeChangedObservable.notifyObservers(this);
    }
    _getTarget() {
        let target;
        if (this._shareOutputWithPostProcess) {
            target = this._shareOutputWithPostProcess.inputTexture;
        }
        else if (this._forcedOutputTexture) {
            target = this._forcedOutputTexture;
            this.width = this._forcedOutputTexture.width;
            this.height = this._forcedOutputTexture.height;
        }
        else {
            target = this.inputTexture;
            let cache;
            for (let i = 0; i < this._textureCache.length; i++) {
                if (this._textureCache[i].texture === target) {
                    cache = this._textureCache[i];
                    break;
                }
            }
            if (cache) {
                cache.lastUsedRenderId = this._renderId;
            }
        }
        return target;
    }
    /**
     * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.
     * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.
     * @param cameraOrScene The camera that will be used in the post process. This camera will be used when calling onActivateObservable. You can also pass the scene if no camera is available.
     * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)
     * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)
     * @returns The render target wrapper that was bound to be written to.
     */
    activate(cameraOrScene, sourceTexture = null, forceDepthStencil) {
        const camera = cameraOrScene === null || cameraOrScene.cameraRigMode !== undefined ? cameraOrScene || this._camera : null;
        const scene = camera?.getScene() ?? cameraOrScene;
        const engine = scene.getEngine();
        const maxSize = engine.getCaps().maxTextureSize;
        const requiredWidth = ((sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options) | 0;
        const requiredHeight = ((sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options) | 0;
        let desiredWidth = this._options.width || requiredWidth;
        let desiredHeight = this._options.height || requiredHeight;
        const needMipMaps = this.renderTargetSamplingMode !== 7 &&
            this.renderTargetSamplingMode !== 1 &&
            this.renderTargetSamplingMode !== 2;
        let target = null;
        if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {
            if (this.adaptScaleToCurrentViewport) {
                const currentViewport = engine.currentViewport;
                if (currentViewport) {
                    desiredWidth *= currentViewport.width;
                    desiredHeight *= currentViewport.height;
                }
            }
            if (needMipMaps || this.alwaysForcePOT) {
                if (!this._options.width) {
                    desiredWidth = engine.needPOTTextures ? (0,_Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_9__.GetExponentOfTwo)(desiredWidth, maxSize, this.scaleMode) : desiredWidth;
                }
                if (!this._options.height) {
                    desiredHeight = engine.needPOTTextures ? (0,_Misc_tools_functions_js__WEBPACK_IMPORTED_MODULE_9__.GetExponentOfTwo)(desiredHeight, maxSize, this.scaleMode) : desiredHeight;
                }
            }
            if (this.width !== desiredWidth || this.height !== desiredHeight || !(target = this._getTarget())) {
                this.resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);
            }
            this._textures.forEach((texture) => {
                if (texture.samples !== this.samples) {
                    this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);
                }
            });
            this._flushTextureCache();
            this._renderId++;
        }
        if (!target) {
            target = this._getTarget();
        }
        // Bind the input of this post process to be used as the output of the previous post process.
        if (this.enablePixelPerfectMode) {
            this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);
            this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);
        }
        else {
            this._scaleRatio.copyFromFloats(1, 1);
            this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);
        }
        this._engine._debugInsertMarker?.(`post process ${this.name} input`);
        this.onActivateObservable.notifyObservers(camera);
        // Clear
        if (this.autoClear && (this.alphaMode === 0 || this.forceAutoClearInAlphaMode)) {
            this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);
        }
        if (this._reusable) {
            this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;
        }
        return target;
    }
    /**
     * If the post process is supported.
     */
    get isSupported() {
        return this._effectWrapper.drawWrapper.effect.isSupported;
    }
    /**
     * The aspect ratio of the output texture.
     */
    get aspectRatio() {
        if (this._shareOutputWithPostProcess) {
            return this._shareOutputWithPostProcess.aspectRatio;
        }
        if (this._forcedOutputTexture) {
            return this._forcedOutputTexture.width / this._forcedOutputTexture.height;
        }
        return this.width / this.height;
    }
    /**
     * Get a value indicating if the post-process is ready to be used
     * @returns true if the post-process is ready (shader is compiled)
     */
    isReady() {
        return this._effectWrapper.isReady();
    }
    /**
     * Binds all textures and uniforms to the shader, this will be run on every pass.
     * @returns the effect corresponding to this post process. Null if not compiled or not ready.
     */
    apply() {
        // Check
        if (!this._effectWrapper.isReady()) {
            return null;
        }
        // States
        this._engine.enableEffect(this._effectWrapper.drawWrapper);
        this._engine.setState(false);
        this._engine.setDepthBuffer(false);
        this._engine.setDepthWrite(false);
        // Alpha
        if (this.alphaConstants) {
            this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);
        }
        this._engine.setAlphaMode(this.alphaMode);
        // Bind the output texture of the preivous post process as the input to this post process.
        let source;
        if (this._shareOutputWithPostProcess) {
            source = this._shareOutputWithPostProcess.inputTexture;
        }
        else if (this._forcedOutputTexture) {
            source = this._forcedOutputTexture;
        }
        else {
            source = this.inputTexture;
        }
        if (!this.externalTextureSamplerBinding) {
            this._effectWrapper.drawWrapper.effect._bindTexture("textureSampler", source?.texture);
        }
        // Parameters
        this._effectWrapper.drawWrapper.effect.setVector2("scale", this._scaleRatio);
        this.onApplyObservable.notifyObservers(this._effectWrapper.drawWrapper.effect);
        this._effectWrapper.bind(true);
        return this._effectWrapper.drawWrapper.effect;
    }
    _disposeTextures() {
        if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {
            this._disposeTextureCache();
            return;
        }
        this._disposeTextureCache();
        this._textures.dispose();
    }
    _disposeTextureCache() {
        for (let i = this._textureCache.length - 1; i >= 0; i--) {
            this._textureCache[i].texture.dispose();
        }
        this._textureCache.length = 0;
    }
    /**
     * Sets the required values to the prepass renderer.
     * @param prePassRenderer defines the prepass renderer to setup.
     * @returns true if the pre pass is needed.
     */
    setPrePassRenderer(prePassRenderer) {
        if (this._prePassEffectConfiguration) {
            this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);
            this._prePassEffectConfiguration.enabled = true;
            return true;
        }
        return false;
    }
    /**
     * Disposes the post process.
     * @param camera The camera to dispose the post process on.
     */
    dispose(camera) {
        camera = camera || this._camera;
        if (!this._useExistingThinPostProcess) {
            this._effectWrapper.dispose();
        }
        this._disposeTextures();
        let index;
        if (this._scene) {
            index = this._scene.postProcesses.indexOf(this);
            if (index !== -1) {
                this._scene.postProcesses.splice(index, 1);
            }
        }
        if (this._parentContainer) {
            const index = this._parentContainer.postProcesses.indexOf(this);
            if (index > -1) {
                this._parentContainer.postProcesses.splice(index, 1);
            }
            this._parentContainer = null;
        }
        index = this._engine.postProcesses.indexOf(this);
        if (index !== -1) {
            this._engine.postProcesses.splice(index, 1);
        }
        this.onDisposeObservable.notifyObservers();
        if (!camera) {
            return;
        }
        camera.detachPostProcess(this);
        index = camera._postProcesses.indexOf(this);
        if (index === 0 && camera._postProcesses.length > 0) {
            const firstPostProcess = this._camera._getFirstPostProcess();
            if (firstPostProcess) {
                firstPostProcess.markTextureDirty();
            }
        }
        this.onActivateObservable.clear();
        this.onAfterRenderObservable.clear();
        this.onApplyObservable.clear();
        this.onBeforeRenderObservable.clear();
        this.onSizeChangedObservable.clear();
        this.onEffectCreatedObservable.clear();
    }
    /**
     * Serializes the post process to a JSON object
     * @returns the JSON object
     */
    serialize() {
        const serializationObject = _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_6__.SerializationHelper.Serialize(this);
        const camera = this.getCamera() || (this._scene && this._scene.activeCamera);
        serializationObject.customType = "BABYLON." + this.getClassName();
        serializationObject.cameraId = camera ? camera.id : null;
        serializationObject.reusable = this._reusable;
        serializationObject.textureType = this._textureType;
        serializationObject.fragmentUrl = this._fragmentUrl;
        serializationObject.parameters = this._parameters;
        serializationObject.samplers = this._samplers;
        serializationObject.uniformBuffers = this._uniformBuffers;
        serializationObject.options = this._options;
        serializationObject.defines = this._postProcessDefines;
        serializationObject.textureFormat = this._textureFormat;
        serializationObject.vertexUrl = this._vertexUrl;
        serializationObject.indexParameters = this._indexParameters;
        return serializationObject;
    }
    /**
     * Clones this post process
     * @returns a new post process similar to this one
     */
    clone() {
        const serializationObject = this.serialize();
        serializationObject._engine = this._engine;
        serializationObject.cameraId = null;
        const result = PostProcess.Parse(serializationObject, this._scene, "");
        if (!result) {
            return null;
        }
        result.onActivateObservable = this.onActivateObservable.clone();
        result.onSizeChangedObservable = this.onSizeChangedObservable.clone();
        result.onApplyObservable = this.onApplyObservable.clone();
        result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();
        result.onAfterRenderObservable = this.onAfterRenderObservable.clone();
        result._prePassEffectConfiguration = this._prePassEffectConfiguration;
        return result;
    }
    /**
     * Creates a material from parsed material data
     * @param parsedPostProcess defines parsed post process data
     * @param scene defines the hosting scene
     * @param rootUrl defines the root URL to use to load textures
     * @returns a new post process
     */
    static Parse(parsedPostProcess, scene, rootUrl) {
        const postProcessType = (0,_Misc_typeStore_js__WEBPACK_IMPORTED_MODULE_7__.GetClass)(parsedPostProcess.customType);
        if (!postProcessType || !postProcessType._Parse) {
            return null;
        }
        const camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;
        return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);
    }
    /**
     * @internal
     */
    static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_6__.SerializationHelper.Parse(() => {
            return new PostProcess(parsedPostProcess.name, parsedPostProcess.fragmentUrl, parsedPostProcess.parameters, parsedPostProcess.samplers, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable, parsedPostProcess.defines, parsedPostProcess.textureType, parsedPostProcess.vertexUrl, parsedPostProcess.indexParameters, false, parsedPostProcess.textureFormat);
        }, parsedPostProcess, scene, rootUrl);
    }
}
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "uniqueId", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "name", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "width", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "height", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "renderTargetSamplingMode", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serializeAsColor4)()
], PostProcess.prototype, "clearColor", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "autoClear", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "forceAutoClearInAlphaMode", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "alphaMode", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "alphaConstants", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "enablePixelPerfectMode", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "forceFullscreenViewport", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "scaleMode", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "alwaysForcePOT", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)("samples")
], PostProcess.prototype, "_samples", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_5__.serialize)()
], PostProcess.prototype, "adaptScaleToCurrentViewport", void 0);
(0,_Misc_typeStore_js__WEBPACK_IMPORTED_MODULE_7__.RegisterClass)("BABYLON.PostProcess", PostProcess);
//# sourceMappingURL=postProcess.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/PostProcesses/thinPassPostProcess.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/PostProcesses/thinPassPostProcess.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ThinPassCubePostProcess: () => (/* binding */ ThinPassCubePostProcess),
/* harmony export */   ThinPassPostProcess: () => (/* binding */ ThinPassPostProcess)
/* harmony export */ });
/* harmony import */ var _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Materials/effectRenderer.js */ "./node_modules/@babylonjs/core/Materials/effectRenderer.js");
/* harmony import */ var _Engines_engine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Engines/engine.js */ "./node_modules/@babylonjs/core/Engines/engine.js");


/**
 * PassPostProcess which produces an output the same as it's input
 */
class ThinPassPostProcess extends _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_0__.EffectWrapper {
    _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
            this._webGPUReady = true;
            list.push(Promise.all([__webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_ShadersWGSL_pass_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../ShadersWGSL/pass.fragment.js */ "./node_modules/@babylonjs/core/ShadersWGSL/pass.fragment.js"))]));
        }
        else {
            list.push(Promise.all([__webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_Shaders_pass_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../Shaders/pass.fragment.js */ "./node_modules/@babylonjs/core/Shaders/pass.fragment.js"))]));
        }
        super._gatherImports(useWebGPU, list);
    }
    /**
     * Constructs a new pass post process
     * @param name Name of the effect
     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
     * @param options Options to configure the effect
     */
    constructor(name, engine = null, options) {
        super({
            ...options,
            name,
            engine: engine || _Engines_engine_js__WEBPACK_IMPORTED_MODULE_1__.Engine.LastCreatedEngine,
            useShaderStore: true,
            useAsPostProcess: true,
            fragmentShader: ThinPassPostProcess.FragmentUrl,
        });
    }
}
/**
 * The fragment shader url
 */
ThinPassPostProcess.FragmentUrl = "pass";
/**
 * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)
 */
class ThinPassCubePostProcess extends _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_0__.EffectWrapper {
    _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
            this._webGPUReady = true;
            list.push(Promise.all([__webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_ShadersWGSL_passCube_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../ShadersWGSL/passCube.fragment.js */ "./node_modules/@babylonjs/core/ShadersWGSL/passCube.fragment.js"))]));
        }
        else {
            list.push(Promise.all([__webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_Shaders_passCube_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../Shaders/passCube.fragment.js */ "./node_modules/@babylonjs/core/Shaders/passCube.fragment.js"))]));
        }
        super._gatherImports(useWebGPU, list);
    }
    /**
     * Creates the PassCubePostProcess
     * @param name Name of the effect
     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
     * @param options Options to configure the effect
     */
    constructor(name, engine = null, options) {
        super({
            ...options,
            name,
            engine: engine || _Engines_engine_js__WEBPACK_IMPORTED_MODULE_1__.Engine.LastCreatedEngine,
            useShaderStore: true,
            useAsPostProcess: true,
            fragmentShader: ThinPassCubePostProcess.FragmentUrl,
            defines: "#define POSITIVEX",
        });
        this._face = 0;
    }
    /**
     * Gets or sets the cube face to display.
     *  * 0 is +X
     *  * 1 is -X
     *  * 2 is +Y
     *  * 3 is -Y
     *  * 4 is +Z
     *  * 5 is -Z
     */
    get face() {
        return this._face;
    }
    set face(value) {
        if (value < 0 || value > 5) {
            return;
        }
        this._face = value;
        switch (this._face) {
            case 0:
                this.updateEffect("#define POSITIVEX");
                break;
            case 1:
                this.updateEffect("#define NEGATIVEX");
                break;
            case 2:
                this.updateEffect("#define POSITIVEY");
                break;
            case 3:
                this.updateEffect("#define NEGATIVEY");
                break;
            case 4:
                this.updateEffect("#define POSITIVEZ");
                break;
            case 5:
                this.updateEffect("#define NEGATIVEZ");
                break;
        }
    }
}
/**
 * The fragment shader url
 */
ThinPassCubePostProcess.FragmentUrl = "passCube";
//# sourceMappingURL=thinPassPostProcess.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Rendering/objectRenderer.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Rendering/objectRenderer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectRenderer: () => (/* binding */ ObjectRenderer)
/* harmony export */ });
/* harmony import */ var _Misc_observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Misc/observable.js */ "./node_modules/@babylonjs/core/Misc/observable.js");
/* harmony import */ var _Rendering_renderingManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Rendering/renderingManager.js */ "./node_modules/@babylonjs/core/Rendering/renderingManager.js");
/* harmony import */ var _Misc_arrayTools_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Misc/arrayTools.js */ "./node_modules/@babylonjs/core/Misc/arrayTools.js");




/**
 * A class that renders objects to the currently bound render target.
 * This class only renders objects, and is not concerned with the output texture or post-processing.
 */
class ObjectRenderer {
    /**
     * Use this list to define the list of mesh you want to render.
     */
    get renderList() {
        return this._renderList;
    }
    set renderList(value) {
        if (this._renderList === value) {
            return;
        }
        if (this._unObserveRenderList) {
            this._unObserveRenderList();
            this._unObserveRenderList = null;
        }
        if (value) {
            this._unObserveRenderList = (0,_Misc_arrayTools_js__WEBPACK_IMPORTED_MODULE_2__._ObserveArray)(value, this._renderListHasChanged);
        }
        this._renderList = value;
    }
    /**
     * If true, the object renderer will render all objects without any image processing applied.
     * If false (default value), the renderer will use the current setting of the scene's image processing configuration.
     */
    get disableImageProcessing() {
        return this._disableImageProcessing;
    }
    set disableImageProcessing(value) {
        if (value === this._disableImageProcessing) {
            return;
        }
        this._disableImageProcessing = value;
        this._scene.markAllMaterialsAsDirty(64);
    }
    /**
     * Friendly name of the object renderer
     */
    get name() {
        return this._name;
    }
    set name(value) {
        if (this._name === value) {
            return;
        }
        this._name = value;
        if (!this._scene) {
            return;
        }
        const engine = this._scene.getEngine();
        for (let i = 0; i < this._renderPassIds.length; ++i) {
            const renderPassId = this._renderPassIds[i];
            engine._renderPassNames[renderPassId] = `${this._name}#${i}`;
        }
    }
    /**
     * Gets the render pass ids used by the object renderer.
     */
    get renderPassIds() {
        return this._renderPassIds;
    }
    /**
     * Gets the current value of the refreshId counter
     */
    get currentRefreshId() {
        return this._currentRefreshId;
    }
    /**
     * Sets a specific material to be used to render a mesh/a list of meshes with this object renderer
     * @param mesh mesh or array of meshes
     * @param material material or array of materials to use for this render pass. If undefined is passed, no specific material will be used but the regular material instead (mesh.material). It's possible to provide an array of materials to use a different material for each rendering pass.
     */
    setMaterialForRendering(mesh, material) {
        let meshes;
        if (!Array.isArray(mesh)) {
            meshes = [mesh];
        }
        else {
            meshes = mesh;
        }
        for (let j = 0; j < meshes.length; ++j) {
            for (let i = 0; i < this.options.numPasses; ++i) {
                let mesh = meshes[j];
                if (meshes[j].isAnInstance) {
                    mesh = meshes[j].sourceMesh;
                }
                mesh.setMaterialForRenderPass(this._renderPassIds[i], material !== undefined ? (Array.isArray(material) ? material[i] : material) : undefined);
            }
        }
    }
    /**
     * Instantiates an object renderer.
     * @param name The friendly name of the object renderer
     * @param scene The scene the renderer belongs to
     * @param options The options used to create the renderer (optional)
     */
    constructor(name, scene, options) {
        this._unObserveRenderList = null;
        this._renderListHasChanged = (_functionName, previousLength) => {
            const newLength = this._renderList ? this._renderList.length : 0;
            if ((previousLength === 0 && newLength > 0) || newLength === 0) {
                for (const mesh of this._scene.meshes) {
                    mesh._markSubMeshesAsLightDirty();
                }
            }
        };
        /**
         * Define the list of particle systems to render. If not provided, will render all the particle systems of the scene.
         * Note that the particle systems are rendered only if renderParticles is set to true.
         */
        this.particleSystemList = null;
        /**
         * Use this function to overload the renderList array at rendering time.
         * Return null to render with the current renderList, else return the list of meshes to use for rendering.
         * For 2DArray, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of
         * the cube (if the RTT is a cube, else layerOrFace=0).
         * The renderList passed to the function is the current render list (the one that will be used if the function returns null).
         * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can
         * hold dummy elements!
         */
        this.getCustomRenderList = null;
        /**
         * Define if particles should be rendered.
         */
        this.renderParticles = true;
        /**
         * Define if sprites should be rendered.
         */
        this.renderSprites = false;
        /**
         * Force checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined)
         */
        this.forceLayerMaskCheck = false;
        this._disableImageProcessing = false;
        /**
         * An event triggered before rendering the objects
         */
        this.onBeforeRenderObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * An event triggered after rendering the objects
         */
        this.onAfterRenderObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * An event triggered before the rendering group is processed
         */
        this.onBeforeRenderingManagerRenderObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * An event triggered after the rendering group is processed
         */
        this.onAfterRenderingManagerRenderObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable();
        /**
         * An event triggered when fast path rendering is used
         */
        this.onFastPathRenderObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable();
        this._currentRefreshId = -1;
        this._refreshRate = 1;
        this._currentApplyByPostProcessSetting = false;
        this._currentSceneCamera = null;
        this.name = name;
        this._scene = scene;
        this.renderList = [];
        this._renderPassIds = [];
        this.options = {
            numPasses: 1,
            doNotChangeAspectRatio: true,
            ...options,
        };
        this._createRenderPassId();
        this.renderPassId = this._renderPassIds[0];
        // Rendering groups
        this._renderingManager = new _Rendering_renderingManager_js__WEBPACK_IMPORTED_MODULE_1__.RenderingManager(scene);
        this._renderingManager._useSceneAutoClearSetup = true;
    }
    _releaseRenderPassId() {
        const engine = this._scene.getEngine();
        for (let i = 0; i < this.options.numPasses; ++i) {
            engine.releaseRenderPassId(this._renderPassIds[i]);
        }
        this._renderPassIds.length = 0;
    }
    _createRenderPassId() {
        this._releaseRenderPassId();
        const engine = this._scene.getEngine();
        for (let i = 0; i < this.options.numPasses; ++i) {
            this._renderPassIds[i] = engine.createRenderPassId(`${this.name}#${i}`);
        }
    }
    /**
     * Resets the refresh counter of the renderer and start back from scratch.
     * Could be useful to re-render if it is setup to render only once.
     */
    resetRefreshCounter() {
        this._currentRefreshId = -1;
    }
    /**
     * Defines the refresh rate of the rendering or the rendering frequency.
     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
     */
    get refreshRate() {
        return this._refreshRate;
    }
    set refreshRate(value) {
        this._refreshRate = value;
        this.resetRefreshCounter();
    }
    /**
     * Indicates if the renderer should render the current frame.
     * The output is based on the specified refresh rate.
     * @returns true if the renderer should render the current frame
     */
    shouldRender() {
        if (this._currentRefreshId === -1) {
            // At least render once
            this._currentRefreshId = 1;
            return true;
        }
        if (this.refreshRate === this._currentRefreshId) {
            this._currentRefreshId = 1;
            return true;
        }
        this._currentRefreshId++;
        return false;
    }
    /**
     * This function will check if the renderer is ready to render (textures are loaded, shaders are compiled)
     * @param viewportWidth defines the width of the viewport
     * @param viewportHeight defines the height of the viewport
     * @returns true if all required resources are ready
     */
    isReadyForRendering(viewportWidth, viewportHeight) {
        this.prepareRenderList();
        this.initRender(viewportWidth, viewportHeight);
        const isReady = this._checkReadiness();
        this.finishRender();
        return isReady;
    }
    /**
     * Makes sure the list of meshes is ready to be rendered
     * You should call this function before "initRender", but if you know the render list is ok, you may call "initRender" directly
     */
    prepareRenderList() {
        const scene = this._scene;
        if (this._waitingRenderList) {
            if (!this.renderListPredicate) {
                this.renderList = [];
                for (let index = 0; index < this._waitingRenderList.length; index++) {
                    const id = this._waitingRenderList[index];
                    const mesh = scene.getMeshById(id);
                    if (mesh) {
                        this.renderList.push(mesh);
                    }
                }
            }
            this._waitingRenderList = undefined;
        }
        // Is predicate defined?
        if (this.renderListPredicate) {
            if (this.renderList) {
                this.renderList.length = 0; // Clear previous renderList
            }
            else {
                this.renderList = [];
            }
            const sceneMeshes = this._scene.meshes;
            for (let index = 0; index < sceneMeshes.length; index++) {
                const mesh = sceneMeshes[index];
                if (this.renderListPredicate(mesh)) {
                    this.renderList.push(mesh);
                }
            }
        }
        this._currentApplyByPostProcessSetting = this._scene.imageProcessingConfiguration.applyByPostProcess;
        if (this._disableImageProcessing) {
            // we do not use the applyByPostProcess setter to avoid flagging all the materials as "image processing dirty"!
            this._scene.imageProcessingConfiguration._applyByPostProcess = this._disableImageProcessing;
        }
    }
    /**
     * This method makes sure everything is setup before "render" can be called
     * @param viewportWidth Width of the viewport to render to
     * @param viewportHeight Height of the viewport to render to
     */
    initRender(viewportWidth, viewportHeight) {
        const engine = this._scene.getEngine();
        const camera = this.activeCamera ?? this._scene.activeCamera;
        this._currentSceneCamera = this._scene.activeCamera;
        if (camera) {
            if (camera !== this._scene.activeCamera) {
                this._scene.setTransformMatrix(camera.getViewMatrix(), camera.getProjectionMatrix(true));
                this._scene.activeCamera = camera;
            }
            engine.setViewport(camera.rigParent ? camera.rigParent.viewport : camera.viewport, viewportWidth, viewportHeight);
        }
        this._defaultRenderListPrepared = false;
    }
    /**
     * This method must be called after the "render" call(s), to complete the rendering process.
     */
    finishRender() {
        const scene = this._scene;
        if (this._disableImageProcessing) {
            scene.imageProcessingConfiguration._applyByPostProcess = this._currentApplyByPostProcessSetting;
        }
        scene.activeCamera = this._currentSceneCamera;
        if (this._currentSceneCamera) {
            if (this.activeCamera && this.activeCamera !== scene.activeCamera) {
                scene.setTransformMatrix(this._currentSceneCamera.getViewMatrix(), this._currentSceneCamera.getProjectionMatrix(true));
            }
            scene.getEngine().setViewport(this._currentSceneCamera.viewport);
        }
        scene.resetCachedMaterial();
    }
    /**
     * Renders all the objects (meshes, particles systems, sprites) to the currently bound render target texture.
     * @param passIndex defines the pass index to use (default: 0)
     * @param skipOnAfterRenderObservable defines a flag to skip raising the onAfterRenderObservable
     */
    render(passIndex = 0, skipOnAfterRenderObservable = false) {
        const scene = this._scene;
        const engine = scene.getEngine();
        const currentRenderPassId = engine.currentRenderPassId;
        engine.currentRenderPassId = this._renderPassIds[passIndex];
        this.onBeforeRenderObservable.notifyObservers(passIndex);
        const fastPath = engine.snapshotRendering && engine.snapshotRenderingMode === 1;
        if (!fastPath) {
            // Get the list of meshes to render
            let currentRenderList = null;
            const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;
            const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;
            if (this.getCustomRenderList) {
                currentRenderList = this.getCustomRenderList(passIndex, defaultRenderList, defaultRenderListLength);
            }
            if (!currentRenderList) {
                // No custom render list provided, we prepare the rendering for the default list, but check
                // first if we did not already performed the preparation before so as to avoid re-doing it several times
                if (!this._defaultRenderListPrepared) {
                    this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, !this.renderList || this.forceLayerMaskCheck);
                    this._defaultRenderListPrepared = true;
                }
                currentRenderList = defaultRenderList;
            }
            else {
                // Prepare the rendering for the custom render list provided
                this._prepareRenderingManager(currentRenderList, currentRenderList.length, this.forceLayerMaskCheck);
            }
            this.onBeforeRenderingManagerRenderObservable.notifyObservers(passIndex);
            this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);
            this.onAfterRenderingManagerRenderObservable.notifyObservers(passIndex);
        }
        else {
            this.onFastPathRenderObservable.notifyObservers(passIndex);
        }
        if (!skipOnAfterRenderObservable) {
            this.onAfterRenderObservable.notifyObservers(passIndex);
        }
        engine.currentRenderPassId = currentRenderPassId;
    }
    /** @internal */
    _checkReadiness() {
        const scene = this._scene;
        const engine = scene.getEngine();
        const currentRenderPassId = engine.currentRenderPassId;
        let returnValue = true;
        if (!scene.getViewMatrix()) {
            // We probably didn't execute scene.render() yet, so make sure we have a view/projection matrix setup for the scene
            scene.updateTransformMatrix();
        }
        const numPasses = this.options.numPasses;
        for (let passIndex = 0; passIndex < numPasses && returnValue; passIndex++) {
            let currentRenderList = null;
            const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;
            const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;
            engine.currentRenderPassId = this._renderPassIds[passIndex];
            this.onBeforeRenderObservable.notifyObservers(passIndex);
            if (this.getCustomRenderList) {
                currentRenderList = this.getCustomRenderList(passIndex, defaultRenderList, defaultRenderListLength);
            }
            if (!currentRenderList) {
                currentRenderList = defaultRenderList;
            }
            if (!this.options.doNotChangeAspectRatio) {
                scene.updateTransformMatrix(true);
            }
            for (let i = 0; i < currentRenderList.length && returnValue; ++i) {
                const mesh = currentRenderList[i];
                if (!mesh.isEnabled() || mesh.isBlocked || !mesh.isVisible || !mesh.subMeshes) {
                    continue;
                }
                if (this.customIsReadyFunction) {
                    if (!this.customIsReadyFunction(mesh, this.refreshRate, true)) {
                        returnValue = false;
                        continue;
                    }
                }
                else if (!mesh.isReady(true)) {
                    returnValue = false;
                    continue;
                }
            }
            this.onAfterRenderObservable.notifyObservers(passIndex);
            if (numPasses > 1) {
                scene.incrementRenderId();
                scene.resetCachedMaterial();
            }
        }
        const particleSystems = this.particleSystemList || scene.particleSystems;
        for (const particleSystem of particleSystems) {
            if (!particleSystem.isReady()) {
                returnValue = false;
            }
        }
        engine.currentRenderPassId = currentRenderPassId;
        return returnValue;
    }
    _prepareRenderingManager(currentRenderList, currentRenderListLength, checkLayerMask) {
        const scene = this._scene;
        const camera = scene.activeCamera; // note that at this point, scene.activeCamera == this.activeCamera if defined, because initRender() has been called before
        const cameraForLOD = this.cameraForLOD ?? camera;
        this._renderingManager.reset();
        const sceneRenderId = scene.getRenderId();
        const currentFrameId = scene.getFrameId();
        for (let meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {
            const mesh = currentRenderList[meshIndex];
            if (mesh && !mesh.isBlocked) {
                if (this.customIsReadyFunction) {
                    if (!this.customIsReadyFunction(mesh, this.refreshRate, false)) {
                        this.resetRefreshCounter();
                        continue;
                    }
                }
                else if (!mesh.isReady(this.refreshRate === 0)) {
                    this.resetRefreshCounter();
                    continue;
                }
                let meshToRender = null;
                if (cameraForLOD) {
                    const meshToRenderAndFrameId = mesh._internalAbstractMeshDataInfo._currentLOD.get(cameraForLOD);
                    if (!meshToRenderAndFrameId || meshToRenderAndFrameId[1] !== currentFrameId) {
                        meshToRender = scene.customLODSelector ? scene.customLODSelector(mesh, cameraForLOD) : mesh.getLOD(cameraForLOD);
                        if (!meshToRenderAndFrameId) {
                            mesh._internalAbstractMeshDataInfo._currentLOD.set(cameraForLOD, [meshToRender, currentFrameId]);
                        }
                        else {
                            meshToRenderAndFrameId[0] = meshToRender;
                            meshToRenderAndFrameId[1] = currentFrameId;
                        }
                    }
                    else {
                        meshToRender = meshToRenderAndFrameId[0];
                    }
                }
                else {
                    meshToRender = mesh;
                }
                if (!meshToRender) {
                    continue;
                }
                if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {
                    meshToRender.computeWorldMatrix(); // Compute world matrix if LOD is billboard
                }
                meshToRender._preActivateForIntermediateRendering(sceneRenderId);
                let isMasked;
                if (checkLayerMask && camera) {
                    isMasked = (mesh.layerMask & camera.layerMask) === 0;
                }
                else {
                    isMasked = false;
                }
                if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {
                    if (meshToRender !== mesh) {
                        meshToRender._activate(sceneRenderId, true);
                    }
                    if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {
                        if (!mesh.isAnInstance) {
                            meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;
                        }
                        else {
                            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
                                meshToRender = mesh;
                            }
                        }
                        meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;
                        scene._prepareSkeleton(meshToRender);
                        for (let subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {
                            const subMesh = meshToRender.subMeshes[subIndex];
                            this._renderingManager.dispatch(subMesh, meshToRender);
                        }
                    }
                    mesh._postActivate();
                }
            }
        }
        const particleSystems = this.particleSystemList || scene.particleSystems;
        for (let particleIndex = 0; particleIndex < particleSystems.length; particleIndex++) {
            const particleSystem = particleSystems[particleIndex];
            const emitter = particleSystem.emitter;
            if (!particleSystem.isStarted() || !emitter || (emitter.position && !emitter.isEnabled())) {
                continue;
            }
            this._renderingManager.dispatchParticles(particleSystem);
        }
    }
    /**
     * Overrides the default sort function applied in the rendering group to prepare the meshes.
     * This allowed control for front to back rendering or reversely depending of the special needs.
     *
     * @param renderingGroupId The rendering group id corresponding to its index
     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
     * @param transparentSortCompareFn The transparent queue comparison function use to sort.
     */
    setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
    }
    /**
     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
     *
     * @param renderingGroupId The rendering group id corresponding to its index
     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
     * @param depth Automatically clears depth between groups if true and autoClear is true.
     * @param stencil Automatically clears stencil between groups if true and autoClear is true.
     */
    setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {
        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);
        this._renderingManager._useSceneAutoClearSetup = false;
    }
    /**
     * Clones the renderer.
     * @returns the cloned renderer
     */
    clone() {
        const newRenderer = new ObjectRenderer(this.name, this._scene, this.options);
        if (this.renderList) {
            newRenderer.renderList = this.renderList.slice(0);
        }
        return newRenderer;
    }
    /**
     * Dispose the renderer and release its associated resources.
     */
    dispose() {
        const renderList = this.renderList ? this.renderList : this._scene.getActiveMeshes().data;
        const renderListLength = this.renderList ? this.renderList.length : this._scene.getActiveMeshes().length;
        for (let i = 0; i < renderListLength; i++) {
            const mesh = renderList[i];
            if (mesh.getMaterialForRenderPass(this.renderPassId) !== undefined) {
                mesh.setMaterialForRenderPass(this.renderPassId, undefined);
            }
        }
        this.onBeforeRenderObservable.clear();
        this.onAfterRenderObservable.clear();
        this.onBeforeRenderingManagerRenderObservable.clear();
        this.onAfterRenderingManagerRenderObservable.clear();
        this.onFastPathRenderObservable.clear();
        this._releaseRenderPassId();
        this.renderList = null;
    }
    /** @internal */
    _rebuild() {
        if (this.refreshRate === ObjectRenderer.REFRESHRATE_RENDER_ONCE) {
            this.refreshRate = ObjectRenderer.REFRESHRATE_RENDER_ONCE;
        }
    }
    /**
     * Clear the info related to rendering groups preventing retention point in material dispose.
     */
    freeRenderingGroups() {
        if (this._renderingManager) {
            this._renderingManager.freeRenderingGroups();
        }
    }
}
/**
 * Objects will only be rendered once which can be useful to improve performance if everything in your render is static for instance.
 */
ObjectRenderer.REFRESHRATE_RENDER_ONCE = 0;
/**
 * Objects will be rendered every frame and is recommended for dynamic contents.
 */
ObjectRenderer.REFRESHRATE_RENDER_ONEVERYFRAME = 1;
/**
 * Objects will be rendered every 2 frames which could be enough if your dynamic objects are not
 * the central point of your effect and can save a lot of performances.
 */
ObjectRenderer.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;
//# sourceMappingURL=objectRenderer.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/postprocess.vertex.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/postprocess.vertex.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   postprocessVertexShader: () => (/* binding */ postprocessVertexShader)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "postprocessVertexShader";
const shader = `attribute vec2 position;uniform vec2 scale;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd)*scale;gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
// Sideeffect
if (!_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.ShadersStore[name]) {
    _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.ShadersStore[name] = shader;
}
/** @internal */
const postprocessVertexShader = { name, shader };
//# sourceMappingURL=postprocess.vertex.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfTWlzY19IaWdoRHluYW1pY1JhbmdlX2N1YmVtYXBUb1NwaGVyaWNhbFBvbHlub21pYWxfanMtbm9kLWU5ZTE1Yy5icm93c2VyLXBhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBc0Q7O0FBRXRELDhEQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNUJzRDtBQUN0RCw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDhEQUFjO0FBQ2Q7QUFDQTtBQUNBLDhEQUFjO0FBQ2Q7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJrRTtBQUNaO0FBQ3RELDhEQUFjO0FBQ2QsU0FBUywyRUFBbUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBYztBQUNkLFNBQVMsMkVBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhEQUFjO0FBQ3BDO0FBQ0E7QUFDQSxrQ0FBa0MsOERBQWM7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCLDhEQUFjO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRCxzQkFBc0IsOERBQWM7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7QUMvQ3NEO0FBQ3RELDhEQUFjO0FBQ2Q7QUFDQTtBQUNBLDhEQUFjO0FBQ2Q7QUFDQTtBQUNBLDhEQUFjO0FBQ2Q7QUFDQSxpQkFBaUIsOERBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsOERBQWM7QUFDZDtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQSxnQ0FBZ0MsMkJBQTJCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1QnNEOztBQUVuQjtBQUNuQyw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQSw4REFBYztBQUNkO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDekdzRDtBQUN0RCw4REFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDVnlEOztBQUV6RCw4REFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDNUZ5RDtBQUNxQjtBQUNoQzs7QUFFbUI7QUFDakUsOERBQVU7QUFDVixnQ0FBZ0MsbUZBQWU7QUFDL0M7QUFDQTtBQUNBLFFBQVEsbURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBVTtBQUNWO0FBQ0E7QUFDQSw2Q0FBNkMsMEVBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhEQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlHeUQ7QUFDekQ7QUFDQSw4REFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDaER5RDtBQUNxQjtBQUNoQzs7QUFFMkI7QUFDSDtBQUN0RSw4REFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw4RUFBbUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVyxRQUFRLG1OQUEyQjtBQUM5RDtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx5RUFBeUU7QUFDekU7QUFDQTtBQUNBLHlDQUF5QyxtRkFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyRUFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3RGOEU7QUFDaEM7O0FBRUE7QUFDa0I7QUFDaEUsc0RBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0IsbUZBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQVU7QUFDVjtBQUNBLHdCQUF3QixtRkFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1EQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1EQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlFQUFlLG1CQUFtQix5RUFBZTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlFQUFlLG1CQUFtQix5RUFBZTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQix3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRkFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQVU7QUFDVixzREFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFVO0FBQ1Ysc0RBQVU7QUFDVjs7Ozs7Ozs7Ozs7Ozs7OztBQ3pYeUQ7QUFDekQ7QUFDdUY7QUFDakQ7QUFDdEMsOERBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0dBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBVTtBQUNWO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyRDhFO0FBQ2hDO0FBQ0E7QUFDa0M7QUFDTzs7QUFFbEM7QUFDckQsc0RBQVU7QUFDViwwQkFBMEIsd0ZBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHNEQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1GQUFlO0FBQy9DO0FBQ0E7QUFDQSxRQUFRLG1EQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQU0sd0JBQXdCLG9DQUFvQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnR0FBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQy9NOEU7QUFDaEM7O0FBRUE7QUFDOUMsc0RBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1GQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xFeUQ7QUFDekQsOERBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZnlEO0FBQ2U7QUFDeEUsOERBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2RUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2RUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsOERBQVU7QUFDVjtBQUNBO0FBQ0EsOERBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN6RUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOElBQThJO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN6Q0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRGdFO0FBQ3VCO0FBQ3ZGO0FBQ08sdUNBQXVDLHdFQUFtQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdHQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3JRQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2YrRDtBQUNWO0FBQ047QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFjLCtDQUErQyw4REFBYztBQUNwRixRQUFRLDhEQUFjLGVBQWUsOERBQWM7QUFDbkQ7QUFDQSxRQUFRLDJFQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhEQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSx3REFBVywyQkFBMkIsOERBQWM7QUFDNUQsUUFBUSw4REFBYztBQUN0QixRQUFRLDhEQUFjO0FBQ3RCO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJFQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsTzJFO0FBQzVCO0FBQ0Y7O0FBRXNCO0FBQ0U7QUFDMUI7QUFDNEI7QUFDakM7QUFDSztBQUNDO0FBQ0U7QUFDRjtBQUNDO0FBQ087QUFDSDtBQUNNO0FBQ1Q7QUFDWTtBQUNWO0FBQ0c7QUFDSTtBQUNIO0FBQ0M7QUFDb0o7QUFDcEo7QUFDTztBQUM1RDtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsc0RBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyRUFBa0I7QUFDekQsOEJBQThCLDhEQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFFQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtFQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUVBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0ZBQW9CO0FBQ3hELG9DQUFvQyxtRkFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZFQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5RUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbjJCb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixnR0FBZ0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JnQjBTO0FBQ3hPO0FBQ3ZCO0FBQ29CO0FBQ1M7QUFDRTtBQUNMO0FBQ1A7QUFDVDs7QUFFa0I7QUFDSTtBQUMzQjtBQUNzQztBQUNmO0FBQzZCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUIsOERBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxRQUFRLHlEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJFQUFpQjtBQUNyQyxvQkFBb0IsbURBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkVBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsbUZBQXFCLFNBQVMsaUZBQW9CO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRCxRQUFRLG1EQUFNLDBCQUEwQixpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0VBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0NBQXNDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZFQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxRQUFRO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0ZBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0ZBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdFQUFjO0FBQzFCO0FBQ0EsMkJBQTJCLHlEQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdFQUFjO0FBQzFDO0FBQ0E7QUFDQSxlQUFlLGdGQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0VBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2RUFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3RUFBYztBQUM5QztBQUNBO0FBQ0Esd0JBQXdCLCtFQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtGQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3RUFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlGQUF1QjtBQUN0QztBQUNBO0FBQ0EsZUFBZSw4RUFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUZBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhGQUFvQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOEVBQVMsbUNBQW1DO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0ZBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFNO0FBQ2xCO0FBQ0EsK0JBQStCLCtGQUFjO0FBQzdDLDJCQUEyQixpR0FBZ0I7QUFDM0M7QUFDQSw0QkFBNEIsb0ZBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtGQUFjO0FBQzlCLHNFQUFzRSxpR0FBZ0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0ZBQWU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSwwRUFBZ0I7QUFDekYsMEVBQTBFLDBFQUFnQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUVBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseUNBQXlDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxRQUFRO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkVBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJFQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBLDBHQUEwRztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLCtDQUErQztBQUMvQztBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQU0sNkRBQTZELGFBQWEsc0JBQXNCLFdBQVc7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOERBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhEQUFjO0FBQ2pELDREQUE0RCxvQ0FBb0M7QUFDaEcsa0VBQWtFLG9DQUFvQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkdBQTJHO0FBQ2pILE1BQU0sdUZBQXVGO0FBQzdGLE1BQU0sdUZBQXVGO0FBQzdGLE1BQU0scUZBQXFGO0FBQzNGLE1BQU0scUZBQXFGO0FBQzNGLE1BQU0scUZBQXFGO0FBQzNGLE1BQU0sb0ZBQW9GO0FBQzFGLE1BQU0sb0ZBQW9GO0FBQzFGLE1BQU0sMkZBQTJGO0FBQ2pHLE1BQU0scUdBQXFHO0FBQzNHO0FBQ0EsTUFBTSx3SEFBd0g7QUFDOUg7QUFDQSxNQUFNLHdIQUF3SDtBQUM5SDtBQUNBO0FBQ0EsZ0NBQWdDLDZFQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pxSHNEO0FBQ087QUFDQztBQUNpQjs7QUFFVjtBQUMvQjtBQUNRO0FBQ3FCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLG1FQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0lBQW9JLG1FQUFPO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxtRUFBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkRBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJEQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyREFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkRBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwREFBTztBQUMxQztBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtRUFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3RUFBYztBQUNsQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1FQUFPO0FBQ3pDLHlCQUF5QixtRUFBTztBQUNoQyx5QkFBeUIsbUVBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUVBQU87QUFDOUMsc0NBQXNDLHlEQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9GQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2TkFBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9FQUFVO0FBQ2pDO0FBQ0Esd0JBQXdCLGtFQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVcsU0FBUyxNQUFNO0FBQzlFLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3RUFBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0VBQWM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0VBQWM7QUFDeEU7QUFDQSxtRUFBTztBQUNQO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ1JxRDtBQUNyRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2REFBVztBQUMzQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0RvRDtBQUNDOztBQUVGO0FBQ2Q7QUFDVTtBQUMvQztBQUMwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2REFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNERBQVksb0JBQW9CLDREQUFZLG9CQUFvQiw0REFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw0REFBWTtBQUM3RDtBQUNBO0FBQ0EsdUNBQXVDLDREQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkRBQVU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJEQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQ0FBZ0Msd0RBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMFFBQThDO0FBQ2pGO0FBQ0E7QUFDQSxtQ0FBbUMsNExBQTBDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxrR0FBa0c7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMkNBQTJDLDhDQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JaMkM7QUFDM0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDTztBQUNQO0FBQ0E7QUFDQSxhQUFhLG9EQUFPO0FBQ3BCO0FBQ0EsYUFBYSxvREFBTztBQUNwQjtBQUNBLGFBQWEsb0RBQU87QUFDcEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEMrQjtBQUNDO0FBQ0k7QUFDRjtBQUNIO0FBQ0M7QUFDRDtBQUNFO0FBQ007QUFDSjtBQUNuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWa0U7QUFDTTtBQUMxQjtBQUM5QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnRUFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9EQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0RBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvREFBTztBQUNwQyw2QkFBNkIsb0RBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1EQUFNO0FBQ3ZDO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9EQUFPLHNCQUFzQixvREFBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0RBQU8sc0JBQXNCLG9EQUFPO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvREFBTyxzQkFBc0Isb0RBQU87QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9EQUFPLDBEQUEwRCxvREFBTztBQUMzSCw2QkFBNkIsb0RBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2Qix3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0RBQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9EQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3RUFBYSw0QkFBNEIsdURBQU87QUFDakU7QUFDQSw0QkFBNEIsb0RBQU87QUFDbkM7QUFDQSxzQkFBc0Isd0VBQWEsNEJBQTRCLHVEQUFPO0FBQ3RFLDRCQUE0QixvREFBTztBQUNuQztBQUNBLHNCQUFzQix3RUFBYSw0QkFBNEIsdURBQU87QUFDdEUsNEJBQTRCLG9EQUFPO0FBQ25DO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQU87QUFDL0I7QUFDQSxzQkFBc0Isb0RBQU87QUFDN0I7QUFDQTtBQUNBLHNCQUFzQixvREFBTztBQUM3QixZQUFZLG9EQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBLDZCQUE2QixvREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbURBQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVEQUFVO0FBQ3ZDLDJCQUEyQix1REFBVTtBQUNyQywyQkFBMkIsdURBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2Qyx5QkFBeUIsb0RBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2Qyx5QkFBeUIsb0RBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkMseUJBQXlCLG9EQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBLGdDQUFnQyxjQUFjO0FBQzlDLG9DQUFvQyxvREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBLGdDQUFnQyxjQUFjO0FBQzlDLG9DQUFvQyxvREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBTztBQUM3QjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBTztBQUM1QixxQkFBcUIsb0RBQU87QUFDNUIscUJBQXFCLG9EQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBTztBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbGlDb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQU87QUFDdEI7QUFDQSxhQUFhLG9EQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFPO0FBQ3RCO0FBQ0EsYUFBYSxvREFBTztBQUNwQjtBQUNBLFNBQVMsb0RBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4REE7QUFDa0Q7QUFDWDtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLE9BQU8sR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQVU7QUFDbEIsNEJBQTRCLGdEQUFVO0FBQ3RDLGtCQUFrQixnREFBVTtBQUM1QjtBQUNBLDZDQUE2QyxnREFBVTtBQUN2RCw0QkFBNEIsZ0RBQVU7QUFDdEMsNkNBQTZDLGdEQUFVO0FBQ3ZELDZCQUE2QixnREFBVTtBQUN2Qyw2Q0FBNkMsZ0RBQVU7QUFDdkQsNEJBQTRCLGdEQUFVO0FBQ3RDLDZDQUE2QyxnREFBVTtBQUN2RCw0QkFBNEIsZ0RBQVU7QUFDdEMsNkNBQTZDLGdEQUFVO0FBQ3ZELDZCQUE2QixnREFBVTtBQUN2Qyw2Q0FBNkMsZ0RBQVU7QUFDdkQsNkJBQTZCLGdEQUFVO0FBQ3ZDLDZDQUE2QyxnREFBVTtBQUN2RCw0QkFBNEIsZ0RBQVU7QUFDdEMsNkNBQTZDLGdEQUFVO0FBQ3ZELDRCQUE0QixnREFBVTtBQUN0Qyw2Q0FBNkMsZ0RBQVU7QUFDdkQsNEJBQTRCLGdEQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFPO0FBQ2YsUUFBUSwwREFBTztBQUNmLFFBQVEsMERBQU87QUFDZixRQUFRLDBEQUFPO0FBQ2YsUUFBUSwwREFBTztBQUNmLFFBQVEsMERBQU87QUFDZixRQUFRLDBEQUFPO0FBQ2YsUUFBUSwwREFBTztBQUNmLFFBQVEsMERBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBTztBQUNmLFFBQVEsMERBQU87QUFDZixRQUFRLDBEQUFPO0FBQ2YsUUFBUSwwREFBTztBQUNmLFFBQVEsMERBQU87QUFDZixRQUFRLDBEQUFPO0FBQ2YsUUFBUSwwREFBTztBQUNmLFFBQVEsMERBQU87QUFDZixRQUFRLDBEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwREFBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQVU7QUFDbEIsNEJBQTRCLGdEQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQVU7QUFDbEIsUUFBUSxnREFBVTtBQUNsQix1REFBdUQsZ0RBQVUsd0JBQXdCLGdEQUFVO0FBQ25HO0FBQ0EsdURBQXVELGdEQUFVLDZCQUE2QixnREFBVTtBQUN4RztBQUNBLFFBQVEsZ0RBQVU7QUFDbEIsa0RBQWtELGdEQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBTztBQUNmLFFBQVEsMERBQU87QUFDZixRQUFRLDBEQUFPO0FBQ2YsUUFBUSwwREFBTztBQUNmLFFBQVEsMERBQU87QUFDZixRQUFRLDBEQUFPO0FBQ2YsUUFBUSwwREFBTztBQUNmLFFBQVEsMERBQU87QUFDZixRQUFRLDBEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzNheUQ7QUFDekQ7QUFDTyw4QkFBOEIsOERBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWHFEO0FBQ1E7QUFDZ0M7O0FBRS9CO0FBQ1g7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2RUFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNFQUFLLEtBQUssbUVBQWE7QUFDNUQscUNBQXFDLHNFQUFLLEtBQUssbUVBQWE7QUFDNUQscUNBQXFDLHNFQUFLLEtBQUssbUVBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzRUFBSztBQUNqQyw0QkFBNEIsc0VBQUs7QUFDakMsNEJBQTRCLHNFQUFLO0FBQ2pDO0FBQ0Esc0NBQXNDLHdEQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhFQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQU8sZUFBZSwwREFBTyxnQkFBZ0IsMERBQU87QUFDN0Ysd0NBQXdDLDBEQUFPLGdCQUFnQiwwREFBTyxlQUFlLDBEQUFPO0FBQzVGLHNDQUFzQywwREFBTyxlQUFlLDBEQUFPLGVBQWUsMERBQU87QUFDekYsd0NBQXdDLDBEQUFPLGdCQUFnQiwwREFBTyxlQUFlLDBEQUFPO0FBQzVGLHlDQUF5QywwREFBTyxlQUFlLDBEQUFPLGVBQWUsMERBQU87QUFDNUYsd0NBQXdDLDBEQUFPLGdCQUFnQiwwREFBTyxnQkFBZ0IsMERBQU87QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbE1tRDtBQUNuRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0REFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuTDJEO0FBQ3dCO0FBQ2I7O0FBRVI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQiwyRkFBbUIsNkJBQTZCLDhCQUE4QjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRUFBTztBQUMzQixvQkFBb0IsbUVBQU87QUFDM0IsZ0NBQWdDLDhFQUFlLG9DQUFvQyxtRUFBTyx5QkFBeUIsbUVBQU87QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0VBQVc7QUFDM0M7QUFDQTtBQUNBLGtFQUFrRSw4QkFBOEI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3UEFBd0M7QUFDMUQ7QUFDQTtBQUNBLGtCQUFrQiw0T0FBb0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb1FBQTRDO0FBQzlEO0FBQ0E7QUFDQSxrQkFBa0Isd1BBQXdDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNFQUFXO0FBQ3hDO0FBQ0EsMEJBQTBCLG1FQUFPO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNFQUFXO0FBQ3hDO0FBQ0EsMEJBQTBCLG1FQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0wsb0JBQW9CLDJGQUFtQixXQUFXLDhCQUE4QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtRUFBTztBQUNsRDtBQUNBO0FBQ0EsMkNBQTJDLG1FQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyVTZDOztBQUVFO0FBQ2U7QUFDVDtBQUNxQjtBQUNjO0FBQ3RDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNPLDhCQUE4Qix3REFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdFQUFtQjtBQUN2Qyx1RkFBdUYsd0VBQW1CO0FBQzFHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtGQUFtQjtBQUNsQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUVBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0Msd0RBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3RUFBbUI7QUFDdkMsdUZBQXVGLDRFQUF1QjtBQUM5RztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrRkFBbUI7QUFDbEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0Esc0VBQWM7QUFDZDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1SDZDO0FBQ007QUFDQTtBQUNEO0FBQ0Y7O0FBRXFCO0FBQ0s7QUFDWDtBQUNEO0FBQ0E7QUFDQztBQUMvRCxzRUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdFQUFhO0FBQzVCO0FBQ0E7QUFDQSxRQUFRLHdFQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3RUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkRBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMERBQU87QUFDdEMsMEJBQTBCLDBEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJEQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyREFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMkRBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJEQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyREFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3RUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBRQUE4QztBQUNqRjtBQUNBO0FBQ0EsbUNBQW1DLDRMQUEwQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkRBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUVBQWlFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwRUFBZ0I7QUFDNUU7QUFDQTtBQUNBLDZEQUE2RCwwRUFBZ0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxXQUFXO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0ZBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNERBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtGQUFtQjtBQUNsQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSxzRUFBaUI7QUFDckI7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLGlFQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbDRCK0Q7QUFDakI7QUFDOUM7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLHVFQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyUEFBeUM7QUFDNUU7QUFDQTtBQUNBLG1DQUFtQywrT0FBcUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQyx1RUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdVFBQTZDO0FBQ2hGO0FBQ0E7QUFDQSxtQ0FBbUMsMlBBQXlDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hIbUQ7QUFDaUI7O0FBRWQ7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrRUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBLHVEQUF1RCxXQUFXLEdBQUcsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMkRBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJEQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwyREFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMkRBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDJEQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRFQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BELGtFQUFrRSxVQUFVLEdBQUcsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0NBQXdDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQ0FBc0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBNkM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQ0FBcUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywwQ0FBMEM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNobEJBO0FBQ3dEO0FBQ3hEO0FBQ0Esd0NBQXdDLG1CQUFtQixpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsS0FBSyxnRUFBVztBQUNoQixJQUFJLGdFQUFXO0FBQ2Y7QUFDQTtBQUNPLGtDQUFrQztBQUN6QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9FbmdpbmVzL0Fic3RyYWN0RW5naW5lL2Fic3RyYWN0RW5naW5lLmFscGhhLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9FbmdpbmVzL0Fic3RyYWN0RW5naW5lL2Fic3RyYWN0RW5naW5lLmRvbS5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvRW5naW5lcy9BYnN0cmFjdEVuZ2luZS9hYnN0cmFjdEVuZ2luZS5sb2FkaW5nU2NyZWVuLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9FbmdpbmVzL0Fic3RyYWN0RW5naW5lL2Fic3RyYWN0RW5naW5lLnJlbmRlclBhc3MuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL0VuZ2luZXMvQWJzdHJhY3RFbmdpbmUvYWJzdHJhY3RFbmdpbmUuc3RhdGVzLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9FbmdpbmVzL0Fic3RyYWN0RW5naW5lL2Fic3RyYWN0RW5naW5lLnRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL0VuZ2luZXMvRXh0ZW5zaW9ucy9lbmdpbmUuYWxwaGEuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL0VuZ2luZXMvRXh0ZW5zaW9ucy9lbmdpbmUuY3ViZVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL0VuZ2luZXMvRXh0ZW5zaW9ucy9lbmdpbmUuZHluYW1pY0J1ZmZlci5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvRW5naW5lcy9FeHRlbnNpb25zL2VuZ2luZS5wcmVmaWx0ZXJlZEN1YmVUZXh0dXJlLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9FbmdpbmVzL0V4dGVuc2lvbnMvZW5naW5lLnJhd1RleHR1cmUuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL0VuZ2luZXMvRXh0ZW5zaW9ucy9lbmdpbmUucmVhZFRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL0VuZ2luZXMvRXh0ZW5zaW9ucy9lbmdpbmUucmVuZGVyVGFyZ2V0LmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9FbmdpbmVzL0V4dGVuc2lvbnMvZW5naW5lLnJlbmRlclRhcmdldEN1YmUuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL0VuZ2luZXMvRXh0ZW5zaW9ucy9lbmdpbmUucmVuZGVyVGFyZ2V0VGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvRW5naW5lcy9FeHRlbnNpb25zL2VuZ2luZS51bmlmb3JtQnVmZmVyLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9FbmdpbmVzL1dlYkdML3dlYkdMMlNoYWRlclByb2Nlc3NvcnMuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL0VuZ2luZXMvV2ViR0wvd2ViR0xIYXJkd2FyZVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL0VuZ2luZXMvV2ViR0wvd2ViR0xSZW5kZXJUYXJnZXRXcmFwcGVyLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9FbmdpbmVzL1dlYkdML3dlYkdMU2hhZGVyUHJvY2Vzc29ycy5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvRW5naW5lcy9lbmdpbmUuY29tbW9uLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9FbmdpbmVzL2VuZ2luZS5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvRW5naW5lcy9yZW5kZXJUYXJnZXRXcmFwcGVyLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9FbmdpbmVzL3RoaW5FbmdpbmUuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGVyaWFscy9UZXh0dXJlcy9yZW5kZXJUYXJnZXRUZXh0dXJlLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvdGV4dHVyZUhlbHBlci5mdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGVyaWFscy9kcmF3V3JhcHBlci5mdW5jdGlvbnMuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGVyaWFscy9kcmF3V3JhcHBlci5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWF0ZXJpYWxzL2VmZmVjdFJlbmRlcmVyLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NYXRocy9tYXRoLmF4aXMuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGhzL21hdGguanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGhzL21hdGgucGF0aC5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWF0aHMvbWF0aC52ZXJ0ZXhGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGhzL21hdGgudmlld3BvcnQuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGhzL3NwaGVyaWNhbFBvbHlub21pYWwuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01lc2hlcy9XZWJHTC93ZWJHTERhdGFCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01pc2MvSGlnaER5bmFtaWNSYW5nZS9jdWJlbWFwVG9TcGhlcmljYWxQb2x5bm9taWFsLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NaXNjL3BlcmZvcm1hbmNlTW9uaXRvci5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWlzYy90ZXh0dXJlVG9vbHMuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1Bvc3RQcm9jZXNzZXMvcGFzc1Bvc3RQcm9jZXNzLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9Qb3N0UHJvY2Vzc2VzL3Bvc3RQcm9jZXNzLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9Qb3N0UHJvY2Vzc2VzL3RoaW5QYXNzUG9zdFByb2Nlc3MuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1JlbmRlcmluZy9vYmplY3RSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9wb3N0cHJvY2Vzcy52ZXJ0ZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWJzdHJhY3RFbmdpbmUgfSBmcm9tIFwiLi4vYWJzdHJhY3RFbmdpbmUuanNcIjtcblxuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLnNldEFscGhhRXF1YXRpb24gPSBmdW5jdGlvbiAoZXF1YXRpb24pIHtcbiAgICBpZiAodGhpcy5fYWxwaGFFcXVhdGlvbiA9PT0gZXF1YXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGVxdWF0aW9uKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuc2V0QWxwaGFFcXVhdGlvblBhcmFtZXRlcnMoMzI3NzQsIDMyNzc0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLnNldEFscGhhRXF1YXRpb25QYXJhbWV0ZXJzKDMyNzc4LCAzMjc3OCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5zZXRBbHBoYUVxdWF0aW9uUGFyYW1ldGVycygzMjc3OSwgMzI3NzkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuc2V0QWxwaGFFcXVhdGlvblBhcmFtZXRlcnMoMzI3NzYsIDMyNzc2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLnNldEFscGhhRXF1YXRpb25QYXJhbWV0ZXJzKDMyNzc1LCAzMjc3NSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5zZXRBbHBoYUVxdWF0aW9uUGFyYW1ldGVycygzMjc3NSwgMzI3NzQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX2FscGhhRXF1YXRpb24gPSBlcXVhdGlvbjtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdEVuZ2luZS5hbHBoYS5qcy5tYXAiLCJpbXBvcnQgeyBBYnN0cmFjdEVuZ2luZSB9IGZyb20gXCIuLi9hYnN0cmFjdEVuZ2luZS5qc1wiO1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLmdldElucHV0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyaW5nQ2FudmFzO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5nZXRSZW5kZXJpbmdDYW52YXNDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fcmVuZGVyaW5nQ2FudmFzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyaW5nQ2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5nZXRJbnB1dEVsZW1lbnRDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fcmVuZGVyaW5nQ2FudmFzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRJbnB1dEVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuZ2V0QXNwZWN0UmF0aW8gPSBmdW5jdGlvbiAodmlld3BvcnRPd25lciwgdXNlU2NyZWVuID0gZmFsc2UpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHZpZXdwb3J0T3duZXIudmlld3BvcnQ7XG4gICAgcmV0dXJuICh0aGlzLmdldFJlbmRlcldpZHRoKHVzZVNjcmVlbikgKiB2aWV3cG9ydC53aWR0aCkgLyAodGhpcy5nZXRSZW5kZXJIZWlnaHQodXNlU2NyZWVuKSAqIHZpZXdwb3J0LmhlaWdodCk7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLmdldFNjcmVlbkFzcGVjdFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJlbmRlcldpZHRoKHRydWUpIC8gdGhpcy5nZXRSZW5kZXJIZWlnaHQodHJ1ZSk7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLl92ZXJpZnlQb2ludGVyTG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9vblBvaW50ZXJMb2NrQ2hhbmdlPy4oKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdEVuZ2luZS5kb20uanMubWFwIiwiaW1wb3J0IHsgSXNXaW5kb3dPYmplY3RFeGlzdCB9IGZyb20gXCIuLi8uLi9NaXNjL2RvbU1hbmFnZW1lbnQuanNcIjtcbmltcG9ydCB7IEFic3RyYWN0RW5naW5lIH0gZnJvbSBcIi4uL2Fic3RyYWN0RW5naW5lLmpzXCI7XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuZGlzcGxheUxvYWRpbmdVSSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUlzV2luZG93T2JqZWN0RXhpc3QoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxvYWRpbmdTY3JlZW4gPSB0aGlzLmxvYWRpbmdTY3JlZW47XG4gICAgaWYgKGxvYWRpbmdTY3JlZW4pIHtcbiAgICAgICAgbG9hZGluZ1NjcmVlbi5kaXNwbGF5TG9hZGluZ1VJKCk7XG4gICAgfVxufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5oaWRlTG9hZGluZ1VJID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghSXNXaW5kb3dPYmplY3RFeGlzdCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbG9hZGluZ1NjcmVlbiA9IHRoaXMuX2xvYWRpbmdTY3JlZW47XG4gICAgaWYgKGxvYWRpbmdTY3JlZW4pIHtcbiAgICAgICAgbG9hZGluZ1NjcmVlbi5oaWRlTG9hZGluZ1VJKCk7XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUsIFwibG9hZGluZ1NjcmVlblwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGluZ1NjcmVlbiAmJiB0aGlzLl9yZW5kZXJpbmdDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdTY3JlZW4gPSBBYnN0cmFjdEVuZ2luZS5EZWZhdWx0TG9hZGluZ1NjcmVlbkZhY3RvcnkodGhpcy5fcmVuZGVyaW5nQ2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGluZ1NjcmVlbjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xvYWRpbmdTY3JlZW4gPSB2YWx1ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLCBcImxvYWRpbmdVSVRleHRcIiwge1xuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9hZGluZ1NjcmVlbi5sb2FkaW5nVUlUZXh0ID0gdmFsdWU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0RW5naW5lLnByb3RvdHlwZSwgXCJsb2FkaW5nVUlCYWNrZ3JvdW5kQ29sb3JcIiwge1xuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9hZGluZ1NjcmVlbi5sb2FkaW5nVUlCYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdEVuZ2luZS5sb2FkaW5nU2NyZWVuLmpzLm1hcCIsImltcG9ydCB7IEFic3RyYWN0RW5naW5lIH0gZnJvbSBcIi4uL2Fic3RyYWN0RW5naW5lLmpzXCI7XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuZ2V0UmVuZGVyUGFzc05hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJQYXNzTmFtZXM7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLmdldEN1cnJlbnRSZW5kZXJQYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGFzc05hbWVzW3RoaXMuY3VycmVudFJlbmRlclBhc3NJZF07XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLmNyZWF0ZVJlbmRlclBhc3NJZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8gTm90ZTogcmVuZGVyIHBhc3MgaWQgPT0gMCBpcyBhbHdheXMgZm9yIHRoZSBtYWluIHJlbmRlciBwYXNzXG4gICAgY29uc3QgaWQgPSArK0Fic3RyYWN0RW5naW5lLl9SZW5kZXJQYXNzSWRDb3VudGVyO1xuICAgIHRoaXMuX3JlbmRlclBhc3NOYW1lc1tpZF0gPSBuYW1lID8/IFwiTk9OQU1FXCI7XG4gICAgcmV0dXJuIGlkO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5yZWxlYXNlUmVuZGVyUGFzc0lkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdGhpcy5fcmVuZGVyUGFzc05hbWVzW2lkXSA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGxldCBzID0gMDsgcyA8IHRoaXMuc2NlbmVzLmxlbmd0aDsgKytzKSB7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZXNbc107XG4gICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgc2NlbmUubWVzaGVzLmxlbmd0aDsgKyttKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNoID0gc2NlbmUubWVzaGVzW21dO1xuICAgICAgICAgICAgaWYgKG1lc2guc3ViTWVzaGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBtZXNoLnN1Yk1lc2hlcy5sZW5ndGg7ICsrYikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJNZXNoID0gbWVzaC5zdWJNZXNoZXNbYl07XG4gICAgICAgICAgICAgICAgICAgIHN1Yk1lc2guX3JlbW92ZURyYXdXcmFwcGVyKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3RFbmdpbmUucmVuZGVyUGFzcy5qcy5tYXAiLCJpbXBvcnQgeyBBYnN0cmFjdEVuZ2luZSB9IGZyb20gXCIuLi9hYnN0cmFjdEVuZ2luZS5qc1wiO1xuXG5pbXBvcnQgXCIuL2Fic3RyYWN0RW5naW5lLmFscGhhLmpzXCI7XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuZ2V0SW5wdXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJpbmdDYW52YXM7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLmdldERlcHRoRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlcHRoQ3VsbGluZ1N0YXRlLmRlcHRoRnVuYztcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuc2V0RGVwdGhGdW5jdGlvbiA9IGZ1bmN0aW9uIChkZXB0aEZ1bmMpIHtcbiAgICB0aGlzLl9kZXB0aEN1bGxpbmdTdGF0ZS5kZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLnNldERlcHRoRnVuY3Rpb25Ub0dyZWF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXREZXB0aEZ1bmN0aW9uKDUxNik7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLnNldERlcHRoRnVuY3Rpb25Ub0dyZWF0ZXJPckVxdWFsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0RGVwdGhGdW5jdGlvbig1MTgpO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5zZXREZXB0aEZ1bmN0aW9uVG9MZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0RGVwdGhGdW5jdGlvbig1MTMpO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5zZXREZXB0aEZ1bmN0aW9uVG9MZXNzT3JFcXVhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldERlcHRoRnVuY3Rpb24oNTE1KTtcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuZ2V0RGVwdGhXcml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVwdGhDdWxsaW5nU3RhdGUuZGVwdGhNYXNrO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5zZXREZXB0aFdyaXRlID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICAgIHRoaXMuX2RlcHRoQ3VsbGluZ1N0YXRlLmRlcHRoTWFzayA9IGVuYWJsZTtcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuZ2V0U3RlbmNpbEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlbmNpbFN0YXRlLnN0ZW5jaWxUZXN0O1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5zZXRTdGVuY2lsQnVmZmVyID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICAgIHRoaXMuX3N0ZW5jaWxTdGF0ZS5zdGVuY2lsVGVzdCA9IGVuYWJsZTtcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuZ2V0U3RlbmNpbE1hc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZW5jaWxTdGF0ZS5zdGVuY2lsTWFzaztcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuc2V0U3RlbmNpbE1hc2sgPSBmdW5jdGlvbiAobWFzaykge1xuICAgIHRoaXMuX3N0ZW5jaWxTdGF0ZS5zdGVuY2lsTWFzayA9IG1hc2s7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLmdldFN0ZW5jaWxGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlbmNpbFN0YXRlLnN0ZW5jaWxGdW5jO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5nZXRTdGVuY2lsRnVuY3Rpb25SZWZlcmVuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZW5jaWxTdGF0ZS5zdGVuY2lsRnVuY1JlZjtcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuZ2V0U3RlbmNpbEZ1bmN0aW9uTWFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlbmNpbFN0YXRlLnN0ZW5jaWxGdW5jTWFzaztcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuc2V0U3RlbmNpbEZ1bmN0aW9uID0gZnVuY3Rpb24gKHN0ZW5jaWxGdW5jKSB7XG4gICAgdGhpcy5fc3RlbmNpbFN0YXRlLnN0ZW5jaWxGdW5jID0gc3RlbmNpbEZ1bmM7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLnNldFN0ZW5jaWxGdW5jdGlvblJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZWZlcmVuY2UpIHtcbiAgICB0aGlzLl9zdGVuY2lsU3RhdGUuc3RlbmNpbEZ1bmNSZWYgPSByZWZlcmVuY2U7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLnNldFN0ZW5jaWxGdW5jdGlvbk1hc2sgPSBmdW5jdGlvbiAobWFzaykge1xuICAgIHRoaXMuX3N0ZW5jaWxTdGF0ZS5zdGVuY2lsRnVuY01hc2sgPSBtYXNrO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5nZXRTdGVuY2lsT3BlcmF0aW9uRmFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlbmNpbFN0YXRlLnN0ZW5jaWxPcFN0ZW5jaWxGYWlsO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5nZXRTdGVuY2lsT3BlcmF0aW9uRGVwdGhGYWlsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGVuY2lsU3RhdGUuc3RlbmNpbE9wRGVwdGhGYWlsO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5nZXRTdGVuY2lsT3BlcmF0aW9uUGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlbmNpbFN0YXRlLnN0ZW5jaWxPcFN0ZW5jaWxEZXB0aFBhc3M7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLnNldFN0ZW5jaWxPcGVyYXRpb25GYWlsID0gZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgIHRoaXMuX3N0ZW5jaWxTdGF0ZS5zdGVuY2lsT3BTdGVuY2lsRmFpbCA9IG9wZXJhdGlvbjtcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuc2V0U3RlbmNpbE9wZXJhdGlvbkRlcHRoRmFpbCA9IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICB0aGlzLl9zdGVuY2lsU3RhdGUuc3RlbmNpbE9wRGVwdGhGYWlsID0gb3BlcmF0aW9uO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5zZXRTdGVuY2lsT3BlcmF0aW9uUGFzcyA9IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICB0aGlzLl9zdGVuY2lsU3RhdGUuc3RlbmNpbE9wU3RlbmNpbERlcHRoUGFzcyA9IG9wZXJhdGlvbjtcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuY2FjaGVTdGVuY2lsU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2FjaGVkU3RlbmNpbEJ1ZmZlciA9IHRoaXMuZ2V0U3RlbmNpbEJ1ZmZlcigpO1xuICAgIHRoaXMuX2NhY2hlZFN0ZW5jaWxGdW5jdGlvbiA9IHRoaXMuZ2V0U3RlbmNpbEZ1bmN0aW9uKCk7XG4gICAgdGhpcy5fY2FjaGVkU3RlbmNpbE1hc2sgPSB0aGlzLmdldFN0ZW5jaWxNYXNrKCk7XG4gICAgdGhpcy5fY2FjaGVkU3RlbmNpbE9wZXJhdGlvblBhc3MgPSB0aGlzLmdldFN0ZW5jaWxPcGVyYXRpb25QYXNzKCk7XG4gICAgdGhpcy5fY2FjaGVkU3RlbmNpbE9wZXJhdGlvbkZhaWwgPSB0aGlzLmdldFN0ZW5jaWxPcGVyYXRpb25GYWlsKCk7XG4gICAgdGhpcy5fY2FjaGVkU3RlbmNpbE9wZXJhdGlvbkRlcHRoRmFpbCA9IHRoaXMuZ2V0U3RlbmNpbE9wZXJhdGlvbkRlcHRoRmFpbCgpO1xuICAgIHRoaXMuX2NhY2hlZFN0ZW5jaWxSZWZlcmVuY2UgPSB0aGlzLmdldFN0ZW5jaWxGdW5jdGlvblJlZmVyZW5jZSgpO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5yZXN0b3JlU3RlbmNpbFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0U3RlbmNpbEZ1bmN0aW9uKHRoaXMuX2NhY2hlZFN0ZW5jaWxGdW5jdGlvbik7XG4gICAgdGhpcy5zZXRTdGVuY2lsTWFzayh0aGlzLl9jYWNoZWRTdGVuY2lsTWFzayk7XG4gICAgdGhpcy5zZXRTdGVuY2lsQnVmZmVyKHRoaXMuX2NhY2hlZFN0ZW5jaWxCdWZmZXIpO1xuICAgIHRoaXMuc2V0U3RlbmNpbE9wZXJhdGlvblBhc3ModGhpcy5fY2FjaGVkU3RlbmNpbE9wZXJhdGlvblBhc3MpO1xuICAgIHRoaXMuc2V0U3RlbmNpbE9wZXJhdGlvbkZhaWwodGhpcy5fY2FjaGVkU3RlbmNpbE9wZXJhdGlvbkZhaWwpO1xuICAgIHRoaXMuc2V0U3RlbmNpbE9wZXJhdGlvbkRlcHRoRmFpbCh0aGlzLl9jYWNoZWRTdGVuY2lsT3BlcmF0aW9uRGVwdGhGYWlsKTtcbiAgICB0aGlzLnNldFN0ZW5jaWxGdW5jdGlvblJlZmVyZW5jZSh0aGlzLl9jYWNoZWRTdGVuY2lsUmVmZXJlbmNlKTtcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuc2V0QWxwaGFDb25zdGFudHMgPSBmdW5jdGlvbiAociwgZywgYiwgYSkge1xuICAgIHRoaXMuX2FscGhhU3RhdGUuc2V0QWxwaGFCbGVuZENvbnN0YW50cyhyLCBnLCBiLCBhKTtcbn07XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuZ2V0QWxwaGFNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9hbHBoYU1vZGU7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLmdldEFscGhhRXF1YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FscGhhRXF1YXRpb247XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3RFbmdpbmUuc3RhdGVzLmpzLm1hcCIsImltcG9ydCB7IEFic3RyYWN0RW5naW5lIH0gZnJvbSBcIi4uL2Fic3RyYWN0RW5naW5lLmpzXCI7XG5BYnN0cmFjdEVuZ2luZS5wcm90b3R5cGUuY3JlYXRlRGVwdGhTdGVuY2lsVGV4dHVyZSA9IGZ1bmN0aW9uIChzaXplLCBvcHRpb25zLCBydFdyYXBwZXIpIHtcbiAgICBpZiAob3B0aW9ucy5pc0N1YmUpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBzaXplLndpZHRoIHx8IHNpemU7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVEZXB0aFN0ZW5jaWxDdWJlVGV4dHVyZSh3aWR0aCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlRGVwdGhTdGVuY2lsVGV4dHVyZShzaXplLCBvcHRpb25zLCBydFdyYXBwZXIpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdEVuZ2luZS50ZXh0dXJlLmpzLm1hcCIsImltcG9ydCB7IFRoaW5FbmdpbmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy90aGluRW5naW5lLmpzXCI7XG5cblRoaW5FbmdpbmUucHJvdG90eXBlLnNldEFscGhhTW9kZSA9IGZ1bmN0aW9uIChtb2RlLCBub0RlcHRoV3JpdGVDaGFuZ2UgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLl9hbHBoYU1vZGUgPT09IG1vZGUpIHtcbiAgICAgICAgaWYgKCFub0RlcHRoV3JpdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzdGlsbCBoYXZlIHRoZSBjb3JyZWN0IGRlcHRoIG1hc2sgYWNjb3JkaW5nIHRvIHRoZSBhbHBoYSBtb2RlIChhIHRyYW5zcGFyZW50IG1hdGVyaWFsIGNvdWxkIGhhdmUgZm9yY2VkIHdyaXR0aW5nIHRvIHRoZSBkZXB0aCBidWZmZXIsIGZvciBpbnN0YW5jZSlcbiAgICAgICAgICAgIGNvbnN0IGRlcHRoTWFzayA9IG1vZGUgPT09IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5kZXB0aEN1bGxpbmdTdGF0ZS5kZXB0aE1hc2sgIT09IGRlcHRoTWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhDdWxsaW5nU3RhdGUuZGVwdGhNYXNrID0gZGVwdGhNYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuYWxwaGFCbGVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuc2V0QWxwaGFCbGVuZEZ1bmN0aW9uUGFyYW1ldGVycyh0aGlzLl9nbC5PTkUsIHRoaXMuX2dsLk9ORV9NSU5VU19TUkNfQUxQSEEsIHRoaXMuX2dsLk9ORSwgdGhpcy5fZ2wuT05FKTtcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuYWxwaGFCbGVuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5zZXRBbHBoYUJsZW5kRnVuY3Rpb25QYXJhbWV0ZXJzKHRoaXMuX2dsLk9ORSwgdGhpcy5fZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgdGhpcy5fZ2wuT05FLCB0aGlzLl9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuYWxwaGFCbGVuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5zZXRBbHBoYUJsZW5kRnVuY3Rpb25QYXJhbWV0ZXJzKHRoaXMuX2dsLlNSQ19BTFBIQSwgdGhpcy5fZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgdGhpcy5fZ2wuT05FLCB0aGlzLl9nbC5PTkUpO1xuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5hbHBoYUJsZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLnNldEFscGhhQmxlbmRGdW5jdGlvblBhcmFtZXRlcnModGhpcy5fZ2wuT05FLCB0aGlzLl9nbC5PTkUsIHRoaXMuX2dsLlpFUk8sIHRoaXMuX2dsLk9ORSk7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLmFscGhhQmxlbmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuc2V0QWxwaGFCbGVuZEZ1bmN0aW9uUGFyYW1ldGVycyh0aGlzLl9nbC5TUkNfQUxQSEEsIHRoaXMuX2dsLk9ORSwgdGhpcy5fZ2wuWkVSTywgdGhpcy5fZ2wuT05FKTtcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuYWxwaGFCbGVuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5zZXRBbHBoYUJsZW5kRnVuY3Rpb25QYXJhbWV0ZXJzKHRoaXMuX2dsLlpFUk8sIHRoaXMuX2dsLk9ORV9NSU5VU19TUkNfQ09MT1IsIHRoaXMuX2dsLk9ORSwgdGhpcy5fZ2wuT05FKTtcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuYWxwaGFCbGVuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5zZXRBbHBoYUJsZW5kRnVuY3Rpb25QYXJhbWV0ZXJzKHRoaXMuX2dsLkRTVF9DT0xPUiwgdGhpcy5fZ2wuWkVSTywgdGhpcy5fZ2wuT05FLCB0aGlzLl9nbC5PTkUpO1xuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5hbHBoYUJsZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLnNldEFscGhhQmxlbmRGdW5jdGlvblBhcmFtZXRlcnModGhpcy5fZ2wuU1JDX0FMUEhBLCB0aGlzLl9nbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCB0aGlzLl9nbC5PTkUsIHRoaXMuX2dsLk9ORSk7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLmFscGhhQmxlbmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuc2V0QWxwaGFCbGVuZEZ1bmN0aW9uUGFyYW1ldGVycyh0aGlzLl9nbC5DT05TVEFOVF9DT0xPUiwgdGhpcy5fZ2wuT05FX01JTlVTX0NPTlNUQU5UX0NPTE9SLCB0aGlzLl9nbC5DT05TVEFOVF9BTFBIQSwgdGhpcy5fZ2wuT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBKTtcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuYWxwaGFCbGVuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuc2V0QWxwaGFCbGVuZEZ1bmN0aW9uUGFyYW1ldGVycyh0aGlzLl9nbC5PTkUsIHRoaXMuX2dsLk9ORV9NSU5VU19TUkNfQ09MT1IsIHRoaXMuX2dsLk9ORSwgdGhpcy5fZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLmFscGhhQmxlbmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLnNldEFscGhhQmxlbmRGdW5jdGlvblBhcmFtZXRlcnModGhpcy5fZ2wuT05FLCB0aGlzLl9nbC5PTkUsIHRoaXMuX2dsLk9ORSwgdGhpcy5fZ2wuT05FKTtcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuYWxwaGFCbGVuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuc2V0QWxwaGFCbGVuZEZ1bmN0aW9uUGFyYW1ldGVycyh0aGlzLl9nbC5EU1RfQUxQSEEsIHRoaXMuX2dsLk9ORSwgdGhpcy5fZ2wuWkVSTywgdGhpcy5fZ2wuWkVSTyk7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLmFscGhhQmxlbmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLnNldEFscGhhQmxlbmRGdW5jdGlvblBhcmFtZXRlcnModGhpcy5fZ2wuT05FX01JTlVTX0RTVF9DT0xPUiwgdGhpcy5fZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgdGhpcy5fZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgdGhpcy5fZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLmFscGhhQmxlbmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLnNldEFscGhhQmxlbmRGdW5jdGlvblBhcmFtZXRlcnModGhpcy5fZ2wuT05FLCB0aGlzLl9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCB0aGlzLl9nbC5PTkUsIHRoaXMuX2dsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5hbHBoYUJsZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5zZXRBbHBoYUJsZW5kRnVuY3Rpb25QYXJhbWV0ZXJzKHRoaXMuX2dsLk9ORSwgdGhpcy5fZ2wuT05FLCB0aGlzLl9nbC5PTkUsIHRoaXMuX2dsLlpFUk8pO1xuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5hbHBoYUJsZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5zZXRBbHBoYUJsZW5kRnVuY3Rpb25QYXJhbWV0ZXJzKHRoaXMuX2dsLk9ORV9NSU5VU19EU1RfQ09MT1IsIHRoaXMuX2dsLk9ORV9NSU5VU19TUkNfQ09MT1IsIHRoaXMuX2dsLlpFUk8sIHRoaXMuX2dsLk9ORSk7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLmFscGhhQmxlbmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAvLyBTYW1lIGFzIEFMUEhBX0NPTUJJTkUgYnV0IGFjY3VtdWxhdGVzICgxIC0gYWxwaGEpIHZhbHVlcyBpbiB0aGUgYWxwaGEgY2hhbm5lbCBmb3IgYSBsYXRlciByZWFkb3V0IGluIG9yZGVyIGluZGVwZW5kYW50IHRyYW5zcGFyZW5jeVxuICAgICAgICAgICAgdGhpcy5fYWxwaGFTdGF0ZS5zZXRBbHBoYUJsZW5kRnVuY3Rpb25QYXJhbWV0ZXJzKHRoaXMuX2dsLlNSQ19BTFBIQSwgdGhpcy5fZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgdGhpcy5fZ2wuT05FLCB0aGlzLl9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgICAgIHRoaXMuX2FscGhhU3RhdGUuYWxwaGFCbGVuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFub0RlcHRoV3JpdGVDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5kZXB0aEN1bGxpbmdTdGF0ZS5kZXB0aE1hc2sgPSBtb2RlID09PSAwO1xuICAgIH1cbiAgICB0aGlzLl9hbHBoYU1vZGUgPSBtb2RlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuZ2luZS5hbHBoYS5qcy5tYXAiLCJpbXBvcnQgeyBUaGluRW5naW5lIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvdGhpbkVuZ2luZS5qc1wiO1xuaW1wb3J0IHsgSW50ZXJuYWxUZXh0dXJlIH0gZnJvbSBcIi4uLy4uL01hdGVyaWFscy9UZXh0dXJlcy9pbnRlcm5hbFRleHR1cmUuanNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi8uLi9NaXNjL2xvZ2dlci5qc1wiO1xuXG5pbXBvcnQgeyBHZXRFeHBvbmVudE9mVHdvIH0gZnJvbSBcIi4uLy4uL01pc2MvdG9vbHMuZnVuY3Rpb25zLmpzXCI7XG5UaGluRW5naW5lLnByb3RvdHlwZS5fY3JlYXRlRGVwdGhTdGVuY2lsQ3ViZVRleHR1cmUgPSBmdW5jdGlvbiAoc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGludGVybmFsVGV4dHVyZSA9IG5ldyBJbnRlcm5hbFRleHR1cmUodGhpcywgMTIgLyogSW50ZXJuYWxUZXh0dXJlU291cmNlLkRlcHRoU3RlbmNpbCAqLyk7XG4gICAgaW50ZXJuYWxUZXh0dXJlLmlzQ3ViZSA9IHRydWU7XG4gICAgaWYgKHRoaXMud2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIExvZ2dlci5FcnJvcihcIkRlcHRoIGN1YmUgdGV4dHVyZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IFdlYkdMIDEuXCIpO1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxUZXh0dXJlO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcm5hbE9wdGlvbnMgPSB7XG4gICAgICAgIGJpbGluZWFyRmlsdGVyaW5nOiBmYWxzZSxcbiAgICAgICAgY29tcGFyaXNvbkZ1bmN0aW9uOiAwLFxuICAgICAgICBnZW5lcmF0ZVN0ZW5jaWw6IGZhbHNlLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGludGVybmFsVGV4dHVyZSwgdHJ1ZSk7XG4gICAgdGhpcy5fc2V0dXBEZXB0aFN0ZW5jaWxUZXh0dXJlKGludGVybmFsVGV4dHVyZSwgc2l6ZSwgaW50ZXJuYWxPcHRpb25zLmJpbGluZWFyRmlsdGVyaW5nLCBpbnRlcm5hbE9wdGlvbnMuY29tcGFyaXNvbkZ1bmN0aW9uKTtcbiAgICAvLyBDcmVhdGUgdGhlIGRlcHRoL3N0ZW5jaWwgYnVmZmVyXG4gICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCA2OyBmYWNlKyspIHtcbiAgICAgICAgaWYgKGludGVybmFsT3B0aW9ucy5nZW5lcmF0ZVN0ZW5jaWwpIHtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgZmFjZSwgMCwgZ2wuREVQVEgyNF9TVEVOQ0lMOCwgc2l6ZSwgc2l6ZSwgMCwgZ2wuREVQVEhfU1RFTkNJTCwgZ2wuVU5TSUdORURfSU5UXzI0XzgsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBmYWNlLCAwLCBnbC5ERVBUSF9DT01QT05FTlQyNCwgc2l6ZSwgc2l6ZSwgMCwgZ2wuREVQVEhfQ09NUE9ORU5ULCBnbC5VTlNJR05FRF9JTlQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XG4gICAgdGhpcy5faW50ZXJuYWxUZXh0dXJlc0NhY2hlLnB1c2goaW50ZXJuYWxUZXh0dXJlKTtcbiAgICByZXR1cm4gaW50ZXJuYWxUZXh0dXJlO1xufTtcblRoaW5FbmdpbmUucHJvdG90eXBlLl9zZXRDdWJlTWFwVGV4dHVyZVBhcmFtcyA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBsb2FkTWlwbWFwLCBtYXhMZXZlbCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGxvYWRNaXBtYXAgPyBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiA6IGdsLkxJTkVBUik7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgdGV4dHVyZS5zYW1wbGluZ01vZGUgPSBsb2FkTWlwbWFwID8gMyA6IDI7XG4gICAgaWYgKGxvYWRNaXBtYXAgJiYgdGhpcy5nZXRDYXBzKCkudGV4dHVyZU1heExldmVsICYmIG1heExldmVsICE9PSB1bmRlZmluZWQgJiYgbWF4TGV2ZWwgPiAwKSB7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NQVhfTEVWRUwsIG1heExldmVsKTtcbiAgICAgICAgdGV4dHVyZS5fbWF4TG9kTGV2ZWwgPSBtYXhMZXZlbDtcbiAgICB9XG4gICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseShnbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcbn07XG5UaGluRW5naW5lLnByb3RvdHlwZS5jcmVhdGVDdWJlVGV4dHVyZSA9IGZ1bmN0aW9uIChyb290VXJsLCBzY2VuZSwgZmlsZXMsIG5vTWlwbWFwLCBvbkxvYWQgPSBudWxsLCBvbkVycm9yID0gbnVsbCwgZm9ybWF0LCBmb3JjZWRFeHRlbnNpb24gPSBudWxsLCBjcmVhdGVQb2x5bm9taWFscyA9IGZhbHNlLCBsb2RTY2FsZSA9IDAsIGxvZE9mZnNldCA9IDAsIGZhbGxiYWNrID0gbnVsbCwgbG9hZGVyT3B0aW9ucywgdXNlU1JHQkJ1ZmZlciA9IGZhbHNlLCBidWZmZXIgPSBudWxsKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVDdWJlVGV4dHVyZUJhc2Uocm9vdFVybCwgc2NlbmUsIGZpbGVzLCAhIW5vTWlwbWFwLCBvbkxvYWQsIG9uRXJyb3IsIGZvcm1hdCwgZm9yY2VkRXh0ZW5zaW9uLCBjcmVhdGVQb2x5bm9taWFscywgbG9kU2NhbGUsIGxvZE9mZnNldCwgZmFsbGJhY2ssICh0ZXh0dXJlKSA9PiB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIHRydWUpLCAodGV4dHVyZSwgaW1ncykgPT4ge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMubmVlZFBPVFRleHR1cmVzID8gR2V0RXhwb25lbnRPZlR3byhpbWdzWzBdLndpZHRoLCB0aGlzLl9jYXBzLm1heEN1YmVtYXBUZXh0dXJlU2l6ZSkgOiBpbWdzWzBdLndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB3aWR0aDtcbiAgICAgICAgY29uc3QgZmFjZXMgPSBbXG4gICAgICAgICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsXG4gICAgICAgICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksXG4gICAgICAgICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osXG4gICAgICAgICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsXG4gICAgICAgICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ksXG4gICAgICAgICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1osXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3VucGFja0ZsaXBZKGZhbHNlKTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSBmb3JtYXQgPyB0aGlzLl9nZXRJbnRlcm5hbEZvcm1hdChmb3JtYXQsIHRleHR1cmUuX3VzZVNSR0JCdWZmZXIpIDogdGV4dHVyZS5fdXNlU1JHQkJ1ZmZlciA/IHRoaXMuX2dsU1JHQkV4dGVuc2lvblZhbHVlcy5TUkdCOF9BTFBIQTggOiBnbC5SR0JBO1xuICAgICAgICBsZXQgdGV4ZWxGb3JtYXQgPSBmb3JtYXQgPyB0aGlzLl9nZXRJbnRlcm5hbEZvcm1hdChmb3JtYXQpIDogZ2wuUkdCQTtcbiAgICAgICAgaWYgKHRleHR1cmUuX3VzZVNSR0JCdWZmZXIgJiYgdGhpcy53ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgIHRleGVsRm9ybWF0ID0gaW50ZXJuYWxGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGZhY2VzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKGltZ3NbaW5kZXhdLndpZHRoICE9PSB3aWR0aCB8fCBpbWdzW2luZGV4XS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVXb3JraW5nQ2FudmFzKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl93b3JraW5nQ2FudmFzIHx8ICF0aGlzLl93b3JraW5nQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuV2FybihcIkNhbm5vdCBjcmVhdGUgY2FudmFzIHRvIHJlc2l6ZSB0ZXh0dXJlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl93b3JraW5nQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2luZ0NhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2luZ0NvbnRleHQuZHJhd0ltYWdlKGltZ3NbaW5kZXhdLCAwLCAwLCBpbWdzW2luZGV4XS53aWR0aCwgaW1nc1tpbmRleF0uaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGZhY2VzW2luZGV4XSwgMCwgaW50ZXJuYWxGb3JtYXQsIHRleGVsRm9ybWF0LCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLl93b3JraW5nQ2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZmFjZXNbaW5kZXhdLCAwLCBpbnRlcm5hbEZvcm1hdCwgdGV4ZWxGb3JtYXQsIGdsLlVOU0lHTkVEX0JZVEUsIGltZ3NbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vTWlwbWFwKSB7XG4gICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFX0NVQkVfTUFQKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRDdWJlTWFwVGV4dHVyZVBhcmFtcyh0ZXh0dXJlLCAhbm9NaXBtYXApO1xuICAgICAgICB0ZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0ZXh0dXJlLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0dXJlLm9uTG9hZGVkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnModGV4dHVyZSk7XG4gICAgICAgIHRleHR1cmUub25Mb2FkZWRPYnNlcnZhYmxlLmNsZWFyKCk7XG4gICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICB9XG4gICAgfSwgISF1c2VTUkdCQnVmZmVyLCBidWZmZXIpO1xufTtcblRoaW5FbmdpbmUucHJvdG90eXBlLmdlbmVyYXRlTWlwTWFwc0ZvckN1YmVtYXAgPSBmdW5jdGlvbiAodGV4dHVyZSwgdW5iaW5kID0gdHJ1ZSkge1xuICAgIGlmICh0ZXh0dXJlLmdlbmVyYXRlTWlwTWFwcykge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIHRydWUpO1xuICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFX0NVQkVfTUFQKTtcbiAgICAgICAgaWYgKHVuYmluZCkge1xuICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseShnbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmdpbmUuY3ViZVRleHR1cmUuanMubWFwIiwiaW1wb3J0IHsgVGhpbkVuZ2luZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3RoaW5FbmdpbmUuanNcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcblRoaW5FbmdpbmUucHJvdG90eXBlLnVwZGF0ZUR5bmFtaWNJbmRleEJ1ZmZlciA9IGZ1bmN0aW9uIChpbmRleEJ1ZmZlciwgaW5kaWNlcywgb2Zmc2V0ID0gMCkge1xuICAgIC8vIEZvcmNlIGNhY2hlIHVwZGF0ZVxuICAgIHRoaXMuX2N1cnJlbnRCb3VuZEJ1ZmZlclt0aGlzLl9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUl0gPSBudWxsO1xuICAgIHRoaXMuYmluZEluZGV4QnVmZmVyKGluZGV4QnVmZmVyKTtcbiAgICBsZXQgdmlldztcbiAgICBpZiAoaW5kZXhCdWZmZXIuaXMzMkJpdHMpIHtcbiAgICAgICAgLy8gYW55dGhpbmcgZWxzZSB0aGFuIFVpbnQzMkFycmF5IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBVaW50MzJBcnJheVxuICAgICAgICB2aWV3ID0gaW5kaWNlcyBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ID8gaW5kaWNlcyA6IG5ldyBVaW50MzJBcnJheShpbmRpY2VzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGFueXRoaW5nIGVsc2UgdGhhbiBVaW50MTZBcnJheSBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gVWludDE2QXJyYXlcbiAgICAgICAgdmlldyA9IGluZGljZXMgaW5zdGFuY2VvZiBVaW50MTZBcnJheSA/IGluZGljZXMgOiBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyk7XG4gICAgfVxuICAgIHRoaXMuX2dsLmJ1ZmZlckRhdGEodGhpcy5fZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHZpZXcsIHRoaXMuX2dsLkRZTkFNSUNfRFJBVyk7XG4gICAgdGhpcy5fcmVzZXRJbmRleEJ1ZmZlckJpbmRpbmcoKTtcbn07XG5UaGluRW5naW5lLnByb3RvdHlwZS51cGRhdGVEeW5hbWljVmVydGV4QnVmZmVyID0gZnVuY3Rpb24gKHZlcnRleEJ1ZmZlciwgZGF0YSwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIHRoaXMuYmluZEFycmF5QnVmZmVyKHZlcnRleEJ1ZmZlcik7XG4gICAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBieXRlT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmxlbmd0aDtcbiAgICBpZiAoYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IChieXRlTGVuZ3RoID49IGRhdGFMZW5ndGggJiYgYnl0ZU9mZnNldCA9PT0gMCkpIHtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5fZ2wuYnVmZmVyU3ViRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIGJ5dGVPZmZzZXQsIG5ldyBGbG9hdDMyQXJyYXkoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2wuYnVmZmVyU3ViRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIGJ5dGVPZmZzZXQsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5idWZmZXJTdWJEYXRhKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwgYnl0ZU9mZnNldCwgbmV3IEZsb2F0MzJBcnJheShkYXRhKS5zdWJhcnJheSgwLCBieXRlTGVuZ3RoIC8gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLCAwLCBieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2dsLmJ1ZmZlclN1YkRhdGEodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCBieXRlT2Zmc2V0LCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9yZXNldFZlcnRleEJ1ZmZlckJpbmRpbmcoKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmdpbmUuZHluYW1pY0J1ZmZlci5qcy5tYXAiLCJpbXBvcnQgeyBUaGluRW5naW5lIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvdGhpbkVuZ2luZS5qc1wiO1xuaW1wb3J0IHsgSW50ZXJuYWxUZXh0dXJlIH0gZnJvbSBcIi4uLy4uL01hdGVyaWFscy9UZXh0dXJlcy9pbnRlcm5hbFRleHR1cmUuanNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi8uLi9NaXNjL2xvZ2dlci5qc1wiO1xuXG5pbXBvcnQgeyBTcGhlcmljYWxQb2x5bm9taWFsIH0gZnJvbSBcIi4uLy4uL01hdGhzL3NwaGVyaWNhbFBvbHlub21pYWwuanNcIjtcbmltcG9ydCB7IEJhc2VUZXh0dXJlIH0gZnJvbSBcIi4uLy4uL01hdGVyaWFscy9UZXh0dXJlcy9iYXNlVGV4dHVyZS5qc1wiO1xuVGhpbkVuZ2luZS5wcm90b3R5cGUuY3JlYXRlUHJlZmlsdGVyZWRDdWJlVGV4dHVyZSA9IGZ1bmN0aW9uIChyb290VXJsLCBzY2VuZSwgbG9kU2NhbGUsIGxvZE9mZnNldCwgb25Mb2FkID0gbnVsbCwgb25FcnJvciA9IG51bGwsIGZvcm1hdCwgZm9yY2VkRXh0ZW5zaW9uID0gbnVsbCwgY3JlYXRlUG9seW5vbWlhbHMgPSB0cnVlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tBc3luYyA9IGFzeW5jIChsb2FkRGF0YSkgPT4ge1xuICAgICAgICBpZiAoIWxvYWREYXRhKSB7XG4gICAgICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgb25Mb2FkKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBsb2FkRGF0YS50ZXh0dXJlO1xuICAgICAgICBpZiAoIWNyZWF0ZVBvbHlub21pYWxzKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLl9zcGhlcmljYWxQb2x5bm9taWFsID0gbmV3IFNwaGVyaWNhbFBvbHlub21pYWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb2FkRGF0YS5pbmZvLnNwaGVyaWNhbFBvbHlub21pYWwpIHtcbiAgICAgICAgICAgIHRleHR1cmUuX3NwaGVyaWNhbFBvbHlub21pYWwgPSBsb2FkRGF0YS5pbmZvLnNwaGVyaWNhbFBvbHlub21pYWw7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dHVyZS5fc291cmNlID0gOSAvKiBJbnRlcm5hbFRleHR1cmVTb3VyY2UuQ3ViZVByZWZpbHRlcmVkICovO1xuICAgICAgICBpZiAodGhpcy5nZXRDYXBzKCkudGV4dHVyZUxPRCkge1xuICAgICAgICAgICAgLy8gRG8gbm90IGFkZCBleHRyYSBwcm9jZXNzIGlmIHRleHR1cmUgbG9kIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBvbkxvYWQodGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWlwU2xpY2VzID0gMztcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBsb2FkRGF0YS53aWR0aDtcbiAgICAgICAgaWYgKCF3aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICAgICAgY29uc3QgeyBERFNUb29scyB9ID0gYXdhaXQgaW1wb3J0KFwiLi4vLi4vTWlzYy9kZHMuanNcIik7XG4gICAgICAgIGNvbnN0IHRleHR1cmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWlwU2xpY2VzOyBpKyspIHtcbiAgICAgICAgICAgIC8vY29tcHV0ZSBMT0QgZnJvbSBldmVuIHNwYWNpbmcgaW4gc21vb3RobmVzcyAobWF0Y2hpbmcgc2hhZGVyIGNhbGN1bGF0aW9uKVxuICAgICAgICAgICAgY29uc3Qgc21vb3RobmVzcyA9IGkgLyAobWlwU2xpY2VzIC0gMSk7XG4gICAgICAgICAgICBjb25zdCByb3VnaG5lc3MgPSAxIC0gc21vb3RobmVzcztcbiAgICAgICAgICAgIGNvbnN0IG1pbkxPREluZGV4ID0gbG9kT2Zmc2V0OyAvLyByb3VnaG5lc3MgPSAwXG4gICAgICAgICAgICBjb25zdCBtYXhMT0RJbmRleCA9IE1hdGgubG9nMih3aWR0aCkgKiBsb2RTY2FsZSArIGxvZE9mZnNldDsgLy8gcm91Z2huZXNzID0gMVxuICAgICAgICAgICAgY29uc3QgbG9kSW5kZXggPSBtaW5MT0RJbmRleCArIChtYXhMT0RJbmRleCAtIG1pbkxPREluZGV4KSAqIHJvdWdobmVzcztcbiAgICAgICAgICAgIGNvbnN0IG1pcG1hcEluZGV4ID0gTWF0aC5yb3VuZChNYXRoLm1pbihNYXRoLm1heChsb2RJbmRleCwgMCksIG1heExPREluZGV4KSk7XG4gICAgICAgICAgICBjb25zdCBnbFRleHR1cmVGcm9tTG9kID0gbmV3IEludGVybmFsVGV4dHVyZSh0aGlzLCAyIC8qIEludGVybmFsVGV4dHVyZVNvdXJjZS5UZW1wICovKTtcbiAgICAgICAgICAgIGdsVGV4dHVyZUZyb21Mb2QudHlwZSA9IHRleHR1cmUudHlwZTtcbiAgICAgICAgICAgIGdsVGV4dHVyZUZyb21Mb2QuZm9ybWF0ID0gdGV4dHVyZS5mb3JtYXQ7XG4gICAgICAgICAgICBnbFRleHR1cmVGcm9tTG9kLndpZHRoID0gTWF0aC5wb3coMiwgTWF0aC5tYXgoTWF0aC5sb2cyKHdpZHRoKSAtIG1pcG1hcEluZGV4LCAwKSk7XG4gICAgICAgICAgICBnbFRleHR1cmVGcm9tTG9kLmhlaWdodCA9IGdsVGV4dHVyZUZyb21Mb2Qud2lkdGg7XG4gICAgICAgICAgICBnbFRleHR1cmVGcm9tTG9kLmlzQ3ViZSA9IHRydWU7XG4gICAgICAgICAgICBnbFRleHR1cmVGcm9tTG9kLl9jYWNoZWRXcmFwVSA9IDA7XG4gICAgICAgICAgICBnbFRleHR1cmVGcm9tTG9kLl9jYWNoZWRXcmFwViA9IDA7XG4gICAgICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsVGV4dHVyZUZyb21Mb2QsIHRydWUpO1xuICAgICAgICAgICAgZ2xUZXh0dXJlRnJvbUxvZC5zYW1wbGluZ01vZGUgPSAyO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBpZiAobG9hZERhdGEuaXNERFMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0gbG9hZERhdGEuaW5mbztcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbG9hZERhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bnBhY2tGbGlwWShpbmZvLmlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICAgICAgRERTVG9vbHMuVXBsb2FkRERTTGV2ZWxzKHRoaXMsIGdsVGV4dHVyZUZyb21Mb2QsIGRhdGEsIGluZm8sIHRydWUsIDYsIG1pcG1hcEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExvZ2dlci5XYXJuKFwiRERTIGlzIHRoZSBvbmx5IHByZWZpbHRlcmVkIGN1YmUgbWFwIHN1cHBvcnRlZCBzbyBmYXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseShnbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcbiAgICAgICAgICAgIC8vIFdyYXAgaW4gYSBiYXNlIHRleHR1cmUgZm9yIGVhc3kgYmluZGluZy5cbiAgICAgICAgICAgIGNvbnN0IGxvZFRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmUoc2NlbmUpO1xuICAgICAgICAgICAgbG9kVGV4dHVyZS5faXNDdWJlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvZFRleHR1cmUuX3RleHR1cmUgPSBnbFRleHR1cmVGcm9tTG9kO1xuICAgICAgICAgICAgZ2xUZXh0dXJlRnJvbUxvZC5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRleHR1cmVzLnB1c2gobG9kVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dHVyZS5fbG9kVGV4dHVyZUhpZ2ggPSB0ZXh0dXJlc1syXTtcbiAgICAgICAgdGV4dHVyZS5fbG9kVGV4dHVyZU1pZCA9IHRleHR1cmVzWzFdO1xuICAgICAgICB0ZXh0dXJlLl9sb2RUZXh0dXJlTG93ID0gdGV4dHVyZXNbMF07XG4gICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgIG9uTG9hZCh0ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlQ3ViZVRleHR1cmUocm9vdFVybCwgc2NlbmUsIG51bGwsIGZhbHNlLCBjYWxsYmFja0FzeW5jLCBvbkVycm9yLCBmb3JtYXQsIGZvcmNlZEV4dGVuc2lvbiwgY3JlYXRlUG9seW5vbWlhbHMsIGxvZFNjYWxlLCBsb2RPZmZzZXQpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuZ2luZS5wcmVmaWx0ZXJlZEN1YmVUZXh0dXJlLmpzLm1hcCIsImltcG9ydCB7IEludGVybmFsVGV4dHVyZSB9IGZyb20gXCIuLi8uLi9NYXRlcmlhbHMvVGV4dHVyZXMvaW50ZXJuYWxUZXh0dXJlLmpzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vLi4vTWlzYy9sb2dnZXIuanNcIjtcblxuaW1wb3J0IHsgVGhpbkVuZ2luZSB9IGZyb20gXCIuLi90aGluRW5naW5lLmpzXCI7XG5pbXBvcnQgeyBJc0V4cG9uZW50T2ZUd28gfSBmcm9tIFwiLi4vLi4vTWlzYy90b29scy5mdW5jdGlvbnMuanNcIjtcblRoaW5FbmdpbmUucHJvdG90eXBlLnVwZGF0ZVJhd1RleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgZGF0YSwgZm9ybWF0LCBpbnZlcnRZLCBjb21wcmVzc2lvbiA9IG51bGwsIHR5cGUgPSAwLCB1c2VTUkdCQnVmZmVyID0gZmFsc2UpIHtcbiAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBCYWJ5bG9uJ3MgaW50ZXJuYWxTaXplZEZvbWF0IGJ1dCBnbCdzIHRleEltYWdlMkQgaW50ZXJuYWxGb3JtYXRcbiAgICBjb25zdCBpbnRlcm5hbFNpemVkRm9tYXQgPSB0aGlzLl9nZXRSR0JBQnVmZmVySW50ZXJuYWxTaXplZEZvcm1hdCh0eXBlLCBmb3JtYXQsIHVzZVNSR0JCdWZmZXIpO1xuICAgIC8vIEJhYnlsb24ncyBpbnRlcm5hbEZvcm1hdCBidXQgZ2wncyB0ZXhJbWFnZTJEIGZvcm1hdFxuICAgIGNvbnN0IGludGVybmFsRm9ybWF0ID0gdGhpcy5fZ2V0SW50ZXJuYWxGb3JtYXQoZm9ybWF0KTtcbiAgICBjb25zdCB0ZXh0dXJlVHlwZSA9IHRoaXMuX2dldFdlYkdMVGV4dHVyZVR5cGUodHlwZSk7XG4gICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0aGlzLl9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCB0cnVlKTtcbiAgICB0aGlzLl91bnBhY2tGbGlwWShpbnZlcnRZID09PSB1bmRlZmluZWQgPyB0cnVlIDogaW52ZXJ0WSA/IHRydWUgOiBmYWxzZSk7XG4gICAgaWYgKCF0aGlzLl9kb05vdEhhbmRsZUNvbnRleHRMb3N0KSB7XG4gICAgICAgIHRleHR1cmUuX2J1ZmZlclZpZXcgPSBkYXRhO1xuICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgdGV4dHVyZS50eXBlID0gdHlwZTtcbiAgICAgICAgdGV4dHVyZS5pbnZlcnRZID0gaW52ZXJ0WTtcbiAgICAgICAgdGV4dHVyZS5fY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICB9XG4gICAgaWYgKHRleHR1cmUud2lkdGggJSA0ICE9PSAwKSB7XG4gICAgICAgIHRoaXMuX2dsLnBpeGVsU3RvcmVpKHRoaXMuX2dsLlVOUEFDS19BTElHTk1FTlQsIDEpO1xuICAgIH1cbiAgICBpZiAoY29tcHJlc3Npb24gJiYgZGF0YSkge1xuICAgICAgICB0aGlzLl9nbC5jb21wcmVzc2VkVGV4SW1hZ2UyRCh0aGlzLl9nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdldENhcHMoKS5zM3RjW2NvbXByZXNzaW9uXSwgdGV4dHVyZS53aWR0aCwgdGV4dHVyZS5oZWlnaHQsIDAsIGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fZ2wudGV4SW1hZ2UyRCh0aGlzLl9nbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbFNpemVkRm9tYXQsIHRleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0LCAwLCBpbnRlcm5hbEZvcm1hdCwgdGV4dHVyZVR5cGUsIGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMpIHtcbiAgICAgICAgdGhpcy5fZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5fZ2wuVEVYVFVSRV8yRCk7XG4gICAgfVxuICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgLy8gIHRoaXMucmVzZXRUZXh0dXJlQ2FjaGUoKTtcbiAgICB0ZXh0dXJlLmlzUmVhZHkgPSB0cnVlO1xufTtcblRoaW5FbmdpbmUucHJvdG90eXBlLmNyZWF0ZVJhd1RleHR1cmUgPSBmdW5jdGlvbiAoZGF0YSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCBnZW5lcmF0ZU1pcE1hcHMsIGludmVydFksIHNhbXBsaW5nTW9kZSwgY29tcHJlc3Npb24gPSBudWxsLCB0eXBlID0gMCwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5jcmVhdGlvbkZsYWdzID0gMCwgdXNlU1JHQkJ1ZmZlciA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBJbnRlcm5hbFRleHR1cmUodGhpcywgMyAvKiBJbnRlcm5hbFRleHR1cmVTb3VyY2UuUmF3ICovKTtcbiAgICB0ZXh0dXJlLmJhc2VXaWR0aCA9IHdpZHRoO1xuICAgIHRleHR1cmUuYmFzZUhlaWdodCA9IGhlaWdodDtcbiAgICB0ZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgdGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGV4dHVyZS5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMgPSBnZW5lcmF0ZU1pcE1hcHM7XG4gICAgdGV4dHVyZS5zYW1wbGluZ01vZGUgPSBzYW1wbGluZ01vZGU7XG4gICAgdGV4dHVyZS5pbnZlcnRZID0gaW52ZXJ0WTtcbiAgICB0ZXh0dXJlLl9jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgIHRleHR1cmUudHlwZSA9IHR5cGU7XG4gICAgdGV4dHVyZS5fdXNlU1JHQkJ1ZmZlciA9IHRoaXMuX2dldFVzZVNSR0JCdWZmZXIodXNlU1JHQkJ1ZmZlciwgIWdlbmVyYXRlTWlwTWFwcyk7XG4gICAgaWYgKCF0aGlzLl9kb05vdEhhbmRsZUNvbnRleHRMb3N0KSB7XG4gICAgICAgIHRleHR1cmUuX2J1ZmZlclZpZXcgPSBkYXRhO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVJhd1RleHR1cmUodGV4dHVyZSwgZGF0YSwgZm9ybWF0LCBpbnZlcnRZLCBjb21wcmVzc2lvbiwgdHlwZSwgdGV4dHVyZS5fdXNlU1JHQkJ1ZmZlcik7XG4gICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0aGlzLl9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCB0cnVlKTtcbiAgICAvLyBGaWx0ZXJzXG4gICAgY29uc3QgZmlsdGVycyA9IHRoaXMuX2dldFNhbXBsaW5nUGFyYW1ldGVycyhzYW1wbGluZ01vZGUsIGdlbmVyYXRlTWlwTWFwcyk7XG4gICAgdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELCB0aGlzLl9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlcnMubWFnKTtcbiAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVycy5taW4pO1xuICAgIGlmIChnZW5lcmF0ZU1pcE1hcHMpIHtcbiAgICAgICAgdGhpcy5fZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5fZ2wuVEVYVFVSRV8yRCk7XG4gICAgfVxuICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgdGhpcy5faW50ZXJuYWxUZXh0dXJlc0NhY2hlLnB1c2godGV4dHVyZSk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuVGhpbkVuZ2luZS5wcm90b3R5cGUuY3JlYXRlUmF3Q3ViZVRleHR1cmUgPSBmdW5jdGlvbiAoZGF0YSwgc2l6ZSwgZm9ybWF0LCB0eXBlLCBnZW5lcmF0ZU1pcE1hcHMsIGludmVydFksIHNhbXBsaW5nTW9kZSwgY29tcHJlc3Npb24gPSBudWxsKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IEludGVybmFsVGV4dHVyZSh0aGlzLCA4IC8qIEludGVybmFsVGV4dHVyZVNvdXJjZS5DdWJlUmF3ICovKTtcbiAgICB0ZXh0dXJlLmlzQ3ViZSA9IHRydWU7XG4gICAgdGV4dHVyZS5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGV4dHVyZS50eXBlID0gdHlwZTtcbiAgICBpZiAoIXRoaXMuX2RvTm90SGFuZGxlQ29udGV4dExvc3QpIHtcbiAgICAgICAgdGV4dHVyZS5fYnVmZmVyVmlld0FycmF5ID0gZGF0YTtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZVR5cGUgPSB0aGlzLl9nZXRXZWJHTFRleHR1cmVUeXBlKHR5cGUpO1xuICAgIGxldCBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuX2dldEludGVybmFsRm9ybWF0KGZvcm1hdCk7XG4gICAgaWYgKGludGVybmFsRm9ybWF0ID09PSBnbC5SR0IpIHtcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBO1xuICAgIH1cbiAgICAvLyBNaXBtYXAgZ2VuZXJhdGlvbiBuZWVkcyBhIHNpemVkIGludGVybmFsIGZvcm1hdCB0aGF0IGlzIGJvdGggY29sb3ItcmVuZGVyYWJsZSBhbmQgdGV4dHVyZS1maWx0ZXJhYmxlXG4gICAgaWYgKHRleHR1cmVUeXBlID09PSBnbC5GTE9BVCAmJiAhdGhpcy5fY2Fwcy50ZXh0dXJlRmxvYXRMaW5lYXJGaWx0ZXJpbmcpIHtcbiAgICAgICAgZ2VuZXJhdGVNaXBNYXBzID0gZmFsc2U7XG4gICAgICAgIHNhbXBsaW5nTW9kZSA9IDE7XG4gICAgICAgIExvZ2dlci5XYXJuKFwiRmxvYXQgdGV4dHVyZSBmaWx0ZXJpbmcgaXMgbm90IHN1cHBvcnRlZC4gTWlwbWFwIGdlbmVyYXRpb24gYW5kIHNhbXBsaW5nIG1vZGUgYXJlIGZvcmNlZCB0byBmYWxzZSBhbmQgVEVYVFVSRV9ORUFSRVNUX1NBTVBMSU5HTU9ERSwgcmVzcGVjdGl2ZWx5LlwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGV4dHVyZVR5cGUgPT09IHRoaXMuX2dsLkhBTEZfRkxPQVRfT0VTICYmICF0aGlzLl9jYXBzLnRleHR1cmVIYWxmRmxvYXRMaW5lYXJGaWx0ZXJpbmcpIHtcbiAgICAgICAgZ2VuZXJhdGVNaXBNYXBzID0gZmFsc2U7XG4gICAgICAgIHNhbXBsaW5nTW9kZSA9IDE7XG4gICAgICAgIExvZ2dlci5XYXJuKFwiSGFsZiBmbG9hdCB0ZXh0dXJlIGZpbHRlcmluZyBpcyBub3Qgc3VwcG9ydGVkLiBNaXBtYXAgZ2VuZXJhdGlvbiBhbmQgc2FtcGxpbmcgbW9kZSBhcmUgZm9yY2VkIHRvIGZhbHNlIGFuZCBURVhUVVJFX05FQVJFU1RfU0FNUExJTkdNT0RFLCByZXNwZWN0aXZlbHkuXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZXh0dXJlVHlwZSA9PT0gZ2wuRkxPQVQgJiYgIXRoaXMuX2NhcHMudGV4dHVyZUZsb2F0UmVuZGVyKSB7XG4gICAgICAgIGdlbmVyYXRlTWlwTWFwcyA9IGZhbHNlO1xuICAgICAgICBMb2dnZXIuV2FybihcIlJlbmRlciB0byBmbG9hdCB0ZXh0dXJlcyBpcyBub3Qgc3VwcG9ydGVkLiBNaXBtYXAgZ2VuZXJhdGlvbiBmb3JjZWQgdG8gZmFsc2UuXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZXh0dXJlVHlwZSA9PT0gZ2wuSEFMRl9GTE9BVCAmJiAhdGhpcy5fY2Fwcy5jb2xvckJ1ZmZlckZsb2F0KSB7XG4gICAgICAgIGdlbmVyYXRlTWlwTWFwcyA9IGZhbHNlO1xuICAgICAgICBMb2dnZXIuV2FybihcIlJlbmRlciB0byBoYWxmIGZsb2F0IHRleHR1cmVzIGlzIG5vdCBzdXBwb3J0ZWQuIE1pcG1hcCBnZW5lcmF0aW9uIGZvcmNlZCB0byBmYWxzZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gc2l6ZTtcbiAgICBjb25zdCBoZWlnaHQgPSB3aWR0aDtcbiAgICB0ZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgdGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGV4dHVyZS5pbnZlcnRZID0gaW52ZXJ0WTtcbiAgICB0ZXh0dXJlLl9jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgIC8vIERvdWJsZSBjaGVjayBvbiBQT1QgdG8gZ2VuZXJhdGUgTWlwcy5cbiAgICBjb25zdCBpc1BvdCA9ICF0aGlzLm5lZWRQT1RUZXh0dXJlcyB8fCAoSXNFeHBvbmVudE9mVHdvKHRleHR1cmUud2lkdGgpICYmIElzRXhwb25lbnRPZlR3byh0ZXh0dXJlLmhlaWdodCkpO1xuICAgIGlmICghaXNQb3QpIHtcbiAgICAgICAgZ2VuZXJhdGVNaXBNYXBzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIFVwbG9hZCBkYXRhIGlmIG5lZWRlZC4gVGhlIHRleHR1cmUgd29uJ3QgYmUgcmVhZHkgdW50aWwgdGhlbi5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVJhd0N1YmVUZXh0dXJlKHRleHR1cmUsIGRhdGEsIGZvcm1hdCwgdHlwZSwgaW52ZXJ0WSwgY29tcHJlc3Npb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxTaXplZEZvbWF0ID0gdGhpcy5fZ2V0UkdCQUJ1ZmZlckludGVybmFsU2l6ZWRGb3JtYXQodHlwZSk7XG4gICAgICAgIGNvbnN0IGxldmVsID0gMDtcbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseShnbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCB0cnVlKTtcbiAgICAgICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgNjsgZmFjZUluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChjb21wcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGZhY2VJbmRleCwgbGV2ZWwsIHRoaXMuZ2V0Q2FwcygpLnMzdGNbY29tcHJlc3Npb25dLCB0ZXh0dXJlLndpZHRoLCB0ZXh0dXJlLmhlaWdodCwgMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgZmFjZUluZGV4LCBsZXZlbCwgaW50ZXJuYWxTaXplZEZvbWF0LCB0ZXh0dXJlLndpZHRoLCB0ZXh0dXJlLmhlaWdodCwgMCwgaW50ZXJuYWxGb3JtYXQsIHRleHR1cmVUeXBlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KHRoaXMuX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuICAgIH1cbiAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KHRoaXMuX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIHRydWUpO1xuICAgIC8vIEZpbHRlcnNcbiAgICBpZiAoZGF0YSAmJiBnZW5lcmF0ZU1pcE1hcHMpIHtcbiAgICAgICAgdGhpcy5fZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5fZ2wuVEVYVFVSRV9DVUJFX01BUCk7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLl9nZXRTYW1wbGluZ1BhcmFtZXRlcnMoc2FtcGxpbmdNb2RlLCBnZW5lcmF0ZU1pcE1hcHMpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJzLm1hZyk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlcnMubWluKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBNYXBzID0gZ2VuZXJhdGVNaXBNYXBzO1xuICAgIHRleHR1cmUuc2FtcGxpbmdNb2RlID0gc2FtcGxpbmdNb2RlO1xuICAgIHRleHR1cmUuaXNSZWFkeSA9IHRydWU7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuVGhpbkVuZ2luZS5wcm90b3R5cGUudXBkYXRlUmF3Q3ViZVRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgZGF0YSwgZm9ybWF0LCB0eXBlLCBpbnZlcnRZLCBjb21wcmVzc2lvbiA9IG51bGwsIGxldmVsID0gMCkge1xuICAgIHRleHR1cmUuX2J1ZmZlclZpZXdBcnJheSA9IGRhdGE7XG4gICAgdGV4dHVyZS5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGV4dHVyZS50eXBlID0gdHlwZTtcbiAgICB0ZXh0dXJlLmludmVydFkgPSBpbnZlcnRZO1xuICAgIHRleHR1cmUuX2NvbXByZXNzaW9uID0gY29tcHJlc3Npb247XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBjb25zdCB0ZXh0dXJlVHlwZSA9IHRoaXMuX2dldFdlYkdMVGV4dHVyZVR5cGUodHlwZSk7XG4gICAgbGV0IGludGVybmFsRm9ybWF0ID0gdGhpcy5fZ2V0SW50ZXJuYWxGb3JtYXQoZm9ybWF0KTtcbiAgICBjb25zdCBpbnRlcm5hbFNpemVkRm9tYXQgPSB0aGlzLl9nZXRSR0JBQnVmZmVySW50ZXJuYWxTaXplZEZvcm1hdCh0eXBlKTtcbiAgICBsZXQgbmVlZENvbnZlcnNpb24gPSBmYWxzZTtcbiAgICBpZiAoaW50ZXJuYWxGb3JtYXQgPT09IGdsLlJHQikge1xuICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE7XG4gICAgICAgIG5lZWRDb252ZXJzaW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseShnbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCB0cnVlKTtcbiAgICB0aGlzLl91bnBhY2tGbGlwWShpbnZlcnRZID09PSB1bmRlZmluZWQgPyB0cnVlIDogaW52ZXJ0WSA/IHRydWUgOiBmYWxzZSk7XG4gICAgaWYgKHRleHR1cmUud2lkdGggJSA0ICE9PSAwKSB7XG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19BTElHTk1FTlQsIDEpO1xuICAgIH1cbiAgICAvLyBEYXRhIGFyZSBrbm93biB0byBiZSBpbiArWCArWSArWiAtWCAtWSAtWlxuICAgIGZvciAobGV0IGZhY2VJbmRleCA9IDA7IGZhY2VJbmRleCA8IDY7IGZhY2VJbmRleCsrKSB7XG4gICAgICAgIGxldCBmYWNlRGF0YSA9IGRhdGFbZmFjZUluZGV4XTtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uKSB7XG4gICAgICAgICAgICBnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRChnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBmYWNlSW5kZXgsIGxldmVsLCB0aGlzLmdldENhcHMoKS5zM3RjW2NvbXByZXNzaW9uXSwgdGV4dHVyZS53aWR0aCwgdGV4dHVyZS5oZWlnaHQsIDAsIGZhY2VEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZWVkQ29udmVyc2lvbikge1xuICAgICAgICAgICAgICAgIGZhY2VEYXRhID0gQ29udmVydFJHQnRvUkdCQVRleHR1cmVEYXRhKGZhY2VEYXRhLCB0ZXh0dXJlLndpZHRoLCB0ZXh0dXJlLmhlaWdodCwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGZhY2VJbmRleCwgbGV2ZWwsIGludGVybmFsU2l6ZWRGb21hdCwgdGV4dHVyZS53aWR0aCwgdGV4dHVyZS5oZWlnaHQsIDAsIGludGVybmFsRm9ybWF0LCB0ZXh0dXJlVHlwZSwgZmFjZURhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzUG90ID0gIXRoaXMubmVlZFBPVFRleHR1cmVzIHx8IChJc0V4cG9uZW50T2ZUd28odGV4dHVyZS53aWR0aCkgJiYgSXNFeHBvbmVudE9mVHdvKHRleHR1cmUuaGVpZ2h0KSk7XG4gICAgaWYgKGlzUG90ICYmIHRleHR1cmUuZ2VuZXJhdGVNaXBNYXBzICYmIGxldmVsID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2dsLmdlbmVyYXRlTWlwbWFwKHRoaXMuX2dsLlRFWFRVUkVfQ1VCRV9NQVApO1xuICAgIH1cbiAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KHRoaXMuX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuICAgIC8vIHRoaXMucmVzZXRUZXh0dXJlQ2FjaGUoKTtcbiAgICB0ZXh0dXJlLmlzUmVhZHkgPSB0cnVlO1xufTtcblRoaW5FbmdpbmUucHJvdG90eXBlLmNyZWF0ZVJhd0N1YmVUZXh0dXJlRnJvbVVybCA9IGZ1bmN0aW9uICh1cmwsIHNjZW5lLCBzaXplLCBmb3JtYXQsIHR5cGUsIG5vTWlwbWFwLCBjYWxsYmFjaywgbWlwbWFwR2VuZXJhdG9yLCBvbkxvYWQgPSBudWxsLCBvbkVycm9yID0gbnVsbCwgc2FtcGxpbmdNb2RlID0gMywgaW52ZXJ0WSA9IGZhbHNlKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5jcmVhdGVSYXdDdWJlVGV4dHVyZShudWxsLCBzaXplLCBmb3JtYXQsIHR5cGUsICFub01pcG1hcCwgaW52ZXJ0WSwgc2FtcGxpbmdNb2RlLCBudWxsKTtcbiAgICBzY2VuZT8uYWRkUGVuZGluZ0RhdGEodGV4dHVyZSk7XG4gICAgdGV4dHVyZS51cmwgPSB1cmw7XG4gICAgdGV4dHVyZS5pc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5faW50ZXJuYWxUZXh0dXJlc0NhY2hlLnB1c2godGV4dHVyZSk7XG4gICAgY29uc3Qgb25lcnJvciA9IChyZXF1ZXN0LCBleGNlcHRpb24pID0+IHtcbiAgICAgICAgc2NlbmU/LnJlbW92ZVBlbmRpbmdEYXRhKHRleHR1cmUpO1xuICAgICAgICBpZiAob25FcnJvciAmJiByZXF1ZXN0KSB7XG4gICAgICAgICAgICBvbkVycm9yKHJlcXVlc3Quc3RhdHVzICsgXCIgXCIgKyByZXF1ZXN0LnN0YXR1c1RleHQsIGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFsQ2FsbGJhY2sgPSAoZGF0YSkgPT4ge1xuICAgICAgICAvLyBJZiB0aGUgdGV4dHVyZSBoYXMgYmVlbiBkaXNwb3NlZFxuICAgICAgICBpZiAoIXRleHR1cmUuX2hhcmR3YXJlVGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dHVyZS53aWR0aDtcbiAgICAgICAgY29uc3QgZmFjZURhdGFBcnJheXMgPSBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgaWYgKCFmYWNlRGF0YUFycmF5cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaXBtYXBHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmVUeXBlID0gdGhpcy5fZ2V0V2ViR0xUZXh0dXJlVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIGxldCBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuX2dldEludGVybmFsRm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbFNpemVkRm9tYXQgPSB0aGlzLl9nZXRSR0JBQnVmZmVySW50ZXJuYWxTaXplZEZvcm1hdCh0eXBlKTtcbiAgICAgICAgICAgIGxldCBuZWVkQ29udmVyc2lvbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGludGVybmFsRm9ybWF0ID09PSBnbC5SR0IpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE7XG4gICAgICAgICAgICAgICAgbmVlZENvbnZlcnNpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseShnbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3VucGFja0ZsaXBZKGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IG1pcERhdGEgPSBtaXBtYXBHZW5lcmF0b3IoZmFjZURhdGFBcnJheXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IG1pcERhdGEubGVuZ3RoOyBsZXZlbCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlwU2l6ZSA9IHdpZHRoID4+IGxldmVsO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGZhY2VJbmRleCA9IDA7IGZhY2VJbmRleCA8IDY7IGZhY2VJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtaXBGYWNlRGF0YSA9IG1pcERhdGFbbGV2ZWxdW2ZhY2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWVkQ29udmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlwRmFjZURhdGEgPSBDb252ZXJ0UkdCdG9SR0JBVGV4dHVyZURhdGEobWlwRmFjZURhdGEsIG1pcFNpemUsIG1pcFNpemUsIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZmFjZUluZGV4LCBsZXZlbCwgaW50ZXJuYWxTaXplZEZvbWF0LCBtaXBTaXplLCBtaXBTaXplLCAwLCBpbnRlcm5hbEZvcm1hdCwgdGV4dHVyZVR5cGUsIG1pcEZhY2VEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSYXdDdWJlVGV4dHVyZSh0ZXh0dXJlLCBmYWNlRGF0YUFycmF5cywgZm9ybWF0LCB0eXBlLCBpbnZlcnRZKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0dXJlLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICAvLyB0aGlzLnJlc2V0VGV4dHVyZUNhY2hlKCk7XG4gICAgICAgIHNjZW5lPy5yZW1vdmVQZW5kaW5nRGF0YSh0ZXh0dXJlKTtcbiAgICAgICAgdGV4dHVyZS5vbkxvYWRlZE9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHRleHR1cmUpO1xuICAgICAgICB0ZXh0dXJlLm9uTG9hZGVkT2JzZXJ2YWJsZS5jbGVhcigpO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fbG9hZEZpbGUodXJsLCAoZGF0YSkgPT4ge1xuICAgICAgICBpbnRlcm5hbENhbGxiYWNrKGRhdGEpO1xuICAgIH0sIHVuZGVmaW5lZCwgc2NlbmU/Lm9mZmxpbmVQcm92aWRlciwgdHJ1ZSwgb25lcnJvcik7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQ29udmVydFJHQnRvUkdCQVRleHR1cmVEYXRhKHJnYkRhdGEsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmVUeXBlKSB7XG4gICAgLy8gQ3JlYXRlIG5ldyBSR0JBIGRhdGEgY29udGFpbmVyLlxuICAgIGxldCByZ2JhRGF0YTtcbiAgICBsZXQgdmFsMSA9IDE7XG4gICAgaWYgKHRleHR1cmVUeXBlID09PSAxKSB7XG4gICAgICAgIHJnYmFEYXRhID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZXh0dXJlVHlwZSA9PT0gMikge1xuICAgICAgICByZ2JhRGF0YSA9IG5ldyBVaW50MTZBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICB2YWwxID0gMTUzNjA7IC8vIDE1MzYwIGlzIHRoZSBlbmNvZGluZyBvZiAxIGluIGhhbGYgZmxvYXRcbiAgICB9XG4gICAgZWxzZSBpZiAodGV4dHVyZVR5cGUgPT09IDcpIHtcbiAgICAgICAgcmdiYURhdGEgPSBuZXcgVWludDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJnYmFEYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBlYWNoIHBpeGVsLlxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9ICh5ICogd2lkdGggKyB4KSAqIDM7XG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9ICh5ICogd2lkdGggKyB4KSAqIDQ7XG4gICAgICAgICAgICAvLyBNYXAgT2xkIFZhbHVlIHRvIG5ldyB2YWx1ZS5cbiAgICAgICAgICAgIHJnYmFEYXRhW25ld0luZGV4ICsgMF0gPSByZ2JEYXRhW2luZGV4ICsgMF07XG4gICAgICAgICAgICByZ2JhRGF0YVtuZXdJbmRleCArIDFdID0gcmdiRGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgcmdiYURhdGFbbmV3SW5kZXggKyAyXSA9IHJnYkRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICAgIC8vIEFkZCBmdWxseSBvcGFxdWUgYWxwaGEgY2hhbm5lbC5cbiAgICAgICAgICAgIHJnYmFEYXRhW25ld0luZGV4ICsgM10gPSB2YWwxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZ2JhRGF0YTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gZm9yIGNyZWF0ZVJhd1RleHR1cmUzRC9jcmVhdGVSYXdUZXh0dXJlMkRBcnJheVxuICogQHBhcmFtIGlzM0QgdHJ1ZSBmb3IgVEVYVFVSRV8zRCBhbmQgZmFsc2UgZm9yIFRFWFRVUkVfMkRfQVJSQVlcbiAqIEBpbnRlcm5hbFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5mdW5jdGlvbiBNYWtlQ3JlYXRlUmF3VGV4dHVyZUZ1bmN0aW9uKGlzM0QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBmb3JtYXQsIGdlbmVyYXRlTWlwTWFwcywgaW52ZXJ0WSwgc2FtcGxpbmdNb2RlLCBjb21wcmVzc2lvbiA9IG51bGwsIHRleHR1cmVUeXBlID0gMCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpczNEID8gdGhpcy5fZ2wuVEVYVFVSRV8zRCA6IHRoaXMuX2dsLlRFWFRVUkVfMkRfQVJSQVk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGlzM0QgPyAxMCAvKiBJbnRlcm5hbFRleHR1cmVTb3VyY2UuUmF3M0QgKi8gOiAxMSAvKiBJbnRlcm5hbFRleHR1cmVTb3VyY2UuUmF3MkRBcnJheSAqLztcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IG5ldyBJbnRlcm5hbFRleHR1cmUodGhpcywgc291cmNlKTtcbiAgICAgICAgdGV4dHVyZS5iYXNlV2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGV4dHVyZS5iYXNlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0ZXh0dXJlLmJhc2VEZXB0aCA9IGRlcHRoO1xuICAgICAgICB0ZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0ZXh0dXJlLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRleHR1cmUuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB0ZXh0dXJlLnR5cGUgPSB0ZXh0dXJlVHlwZTtcbiAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMgPSBnZW5lcmF0ZU1pcE1hcHM7XG4gICAgICAgIHRleHR1cmUuc2FtcGxpbmdNb2RlID0gc2FtcGxpbmdNb2RlO1xuICAgICAgICBpZiAoaXMzRCkge1xuICAgICAgICAgICAgdGV4dHVyZS5pczNEID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHR1cmUuaXMyREFycmF5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2RvTm90SGFuZGxlQ29udGV4dExvc3QpIHtcbiAgICAgICAgICAgIHRleHR1cmUuX2J1ZmZlclZpZXcgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpczNEKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJhd1RleHR1cmUzRCh0ZXh0dXJlLCBkYXRhLCBmb3JtYXQsIGludmVydFksIGNvbXByZXNzaW9uLCB0ZXh0dXJlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJhd1RleHR1cmUyREFycmF5KHRleHR1cmUsIGRhdGEsIGZvcm1hdCwgaW52ZXJ0WSwgY29tcHJlc3Npb24sIHRleHR1cmVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KHRhcmdldCwgdGV4dHVyZSwgdHJ1ZSk7XG4gICAgICAgIC8vIEZpbHRlcnNcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IHRoaXMuX2dldFNhbXBsaW5nUGFyYW1ldGVycyhzYW1wbGluZ01vZGUsIGdlbmVyYXRlTWlwTWFwcyk7XG4gICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCB0aGlzLl9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlcnMubWFnKTtcbiAgICAgICAgdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIHRoaXMuX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVycy5taW4pO1xuICAgICAgICBpZiAoZ2VuZXJhdGVNaXBNYXBzKSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5nZW5lcmF0ZU1pcG1hcCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGFyZ2V0LCBudWxsKTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxUZXh0dXJlc0NhY2hlLnB1c2godGV4dHVyZSk7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH07XG59XG5UaGluRW5naW5lLnByb3RvdHlwZS5jcmVhdGVSYXdUZXh0dXJlMkRBcnJheSA9IE1ha2VDcmVhdGVSYXdUZXh0dXJlRnVuY3Rpb24oZmFsc2UpO1xuVGhpbkVuZ2luZS5wcm90b3R5cGUuY3JlYXRlUmF3VGV4dHVyZTNEID0gTWFrZUNyZWF0ZVJhd1RleHR1cmVGdW5jdGlvbih0cnVlKTtcbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gZm9yIHVwZGF0ZVJhd1RleHR1cmUzRC91cGRhdGVSYXdUZXh0dXJlMkRBcnJheVxuICogQHBhcmFtIGlzM0QgdHJ1ZSBmb3IgVEVYVFVSRV8zRCBhbmQgZmFsc2UgZm9yIFRFWFRVUkVfMkRfQVJSQVlcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBNYWtlVXBkYXRlUmF3VGV4dHVyZUZ1bmN0aW9uKGlzM0QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRleHR1cmUsIGRhdGEsIGZvcm1hdCwgaW52ZXJ0WSwgY29tcHJlc3Npb24gPSBudWxsLCB0ZXh0dXJlVHlwZSA9IDApIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gaXMzRCA/IHRoaXMuX2dsLlRFWFRVUkVfM0QgOiB0aGlzLl9nbC5URVhUVVJFXzJEX0FSUkFZO1xuICAgICAgICBjb25zdCBpbnRlcm5hbFR5cGUgPSB0aGlzLl9nZXRXZWJHTFRleHR1cmVUeXBlKHRleHR1cmVUeXBlKTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLl9nZXRJbnRlcm5hbEZvcm1hdChmb3JtYXQpO1xuICAgICAgICBjb25zdCBpbnRlcm5hbFNpemVkRm9tYXQgPSB0aGlzLl9nZXRSR0JBQnVmZmVySW50ZXJuYWxTaXplZEZvcm1hdCh0ZXh0dXJlVHlwZSwgZm9ybWF0KTtcbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0YXJnZXQsIHRleHR1cmUsIHRydWUpO1xuICAgICAgICB0aGlzLl91bnBhY2tGbGlwWShpbnZlcnRZID09PSB1bmRlZmluZWQgPyB0cnVlIDogaW52ZXJ0WSA/IHRydWUgOiBmYWxzZSk7XG4gICAgICAgIGlmICghdGhpcy5fZG9Ob3RIYW5kbGVDb250ZXh0TG9zdCkge1xuICAgICAgICAgICAgdGV4dHVyZS5fYnVmZmVyVmlldyA9IGRhdGE7XG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgICAgIHRleHR1cmUuaW52ZXJ0WSA9IGludmVydFk7XG4gICAgICAgICAgICB0ZXh0dXJlLl9jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0dXJlLndpZHRoICUgNCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fZ2wucGl4ZWxTdG9yZWkodGhpcy5fZ2wuVU5QQUNLX0FMSUdOTUVOVCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzaW9uICYmIGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLmNvbXByZXNzZWRUZXhJbWFnZTNEKHRhcmdldCwgMCwgdGhpcy5nZXRDYXBzKCkuczN0Y1tjb21wcmVzc2lvbl0sIHRleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0LCB0ZXh0dXJlLmRlcHRoLCAwLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLnRleEltYWdlM0QodGFyZ2V0LCAwLCBpbnRlcm5hbFNpemVkRm9tYXQsIHRleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0LCB0ZXh0dXJlLmRlcHRoLCAwLCBpbnRlcm5hbEZvcm1hdCwgaW50ZXJuYWxUeXBlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0YXJnZXQsIG51bGwpO1xuICAgICAgICAvLyB0aGlzLnJlc2V0VGV4dHVyZUNhY2hlKCk7XG4gICAgICAgIHRleHR1cmUuaXNSZWFkeSA9IHRydWU7XG4gICAgfTtcbn1cblRoaW5FbmdpbmUucHJvdG90eXBlLnVwZGF0ZVJhd1RleHR1cmUyREFycmF5ID0gTWFrZVVwZGF0ZVJhd1RleHR1cmVGdW5jdGlvbihmYWxzZSk7XG5UaGluRW5naW5lLnByb3RvdHlwZS51cGRhdGVSYXdUZXh0dXJlM0QgPSBNYWtlVXBkYXRlUmF3VGV4dHVyZUZ1bmN0aW9uKHRydWUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5naW5lLnJhd1RleHR1cmUuanMubWFwIiwiaW1wb3J0IHsgVGhpbkVuZ2luZSB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL3RoaW5FbmdpbmUuanNcIjtcbi8vIGJhY2stY29tcGF0XG5pbXBvcnQgeyBhbGxvY2F0ZUFuZENvcHlUeXBlZEJ1ZmZlciB9IGZyb20gXCIuLi8uLi9FbmdpbmVzL2Fic3RyYWN0RW5naW5lLmZ1bmN0aW9ucy5qc1wiO1xuZXhwb3J0IHsgYWxsb2NhdGVBbmRDb3B5VHlwZWRCdWZmZXIgfTtcblRoaW5FbmdpbmUucHJvdG90eXBlLl9yZWFkVGV4dHVyZVBpeGVsc1N5bmMgPSBmdW5jdGlvbiAodGV4dHVyZSwgd2lkdGgsIGhlaWdodCwgZmFjZUluZGV4ID0gLTEsIGxldmVsID0gMCwgYnVmZmVyID0gbnVsbCwgZmx1c2hSZW5kZXJlciA9IHRydWUsIG5vRGF0YUNvbnZlcnNpb24gPSBmYWxzZSwgeCA9IDAsIHkgPSAwKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBpZiAoIWdsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuZ2luZSBkb2VzIG5vdCBoYXZlIGdsIHJlbmRlcmluZyBjb250ZXh0LlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kdW1teUZyYW1lYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGR1bW15ID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgaWYgKCFkdW1teSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSBkdW1teSBmcmFtZWJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kdW1teUZyYW1lYnVmZmVyID0gZHVtbXk7XG4gICAgfVxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5fZHVtbXlGcmFtZWJ1ZmZlcik7XG4gICAgaWYgKGZhY2VJbmRleCA+IC0xKSB7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgZmFjZUluZGV4LCB0ZXh0dXJlLl9oYXJkd2FyZVRleHR1cmU/LnVuZGVybHlpbmdSZXNvdXJjZSwgbGV2ZWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9oYXJkd2FyZVRleHR1cmU/LnVuZGVybHlpbmdSZXNvdXJjZSwgbGV2ZWwpO1xuICAgIH1cbiAgICBsZXQgcmVhZFR5cGUgPSB0ZXh0dXJlLnR5cGUgIT09IHVuZGVmaW5lZCA/IHRoaXMuX2dldFdlYkdMVGV4dHVyZVR5cGUodGV4dHVyZS50eXBlKSA6IGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgaWYgKCFub0RhdGFDb252ZXJzaW9uKSB7XG4gICAgICAgIHN3aXRjaCAocmVhZFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgZ2wuVU5TSUdORURfQllURTpcbiAgICAgICAgICAgICAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheSg0ICogd2lkdGggKiBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWFkVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIHdpZHRoICogaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVhZFR5cGUgPSBnbC5GTE9BVDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghYnVmZmVyKSB7XG4gICAgICAgIGJ1ZmZlciA9IGFsbG9jYXRlQW5kQ29weVR5cGVkQnVmZmVyKHRleHR1cmUudHlwZSwgNCAqIHdpZHRoICogaGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKGZsdXNoUmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5mbHVzaEZyYW1lYnVmZmVyKCk7XG4gICAgfVxuICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgcmVhZFR5cGUsIGJ1ZmZlcik7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jdXJyZW50RnJhbWVidWZmZXIpO1xuICAgIHJldHVybiBidWZmZXI7XG59O1xuVGhpbkVuZ2luZS5wcm90b3R5cGUuX3JlYWRUZXh0dXJlUGl4ZWxzID0gZnVuY3Rpb24gKHRleHR1cmUsIHdpZHRoLCBoZWlnaHQsIGZhY2VJbmRleCA9IC0xLCBsZXZlbCA9IDAsIGJ1ZmZlciA9IG51bGwsIGZsdXNoUmVuZGVyZXIgPSB0cnVlLCBub0RhdGFDb252ZXJzaW9uID0gZmFsc2UsIHggPSAwLCB5ID0gMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fcmVhZFRleHR1cmVQaXhlbHNTeW5jKHRleHR1cmUsIHdpZHRoLCBoZWlnaHQsIGZhY2VJbmRleCwgbGV2ZWwsIGJ1ZmZlciwgZmx1c2hSZW5kZXJlciwgbm9EYXRhQ29udmVyc2lvbiwgeCwgeSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuZ2luZS5yZWFkVGV4dHVyZS5qcy5tYXAiLCJpbXBvcnQgeyBJbnRlcm5hbFRleHR1cmUgfSBmcm9tIFwiLi4vLi4vTWF0ZXJpYWxzL1RleHR1cmVzL2ludGVybmFsVGV4dHVyZS5qc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uLy4uL01pc2MvbG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyBUaGluRW5naW5lIH0gZnJvbSBcIi4uL3RoaW5FbmdpbmUuanNcIjtcbmltcG9ydCB7IFdlYkdMUmVuZGVyVGFyZ2V0V3JhcHBlciB9IGZyb20gXCIuLi9XZWJHTC93ZWJHTFJlbmRlclRhcmdldFdyYXBwZXIuanNcIjtcbmltcG9ydCB7IEhhc1N0ZW5jaWxBc3BlY3QgfSBmcm9tIFwiLi4vLi4vTWF0ZXJpYWxzL1RleHR1cmVzL3RleHR1cmVIZWxwZXIuZnVuY3Rpb25zLmpzXCI7XG5cbmltcG9ydCBcIi4uL0Fic3RyYWN0RW5naW5lL2Fic3RyYWN0RW5naW5lLnRleHR1cmUuanNcIjtcblRoaW5FbmdpbmUucHJvdG90eXBlLl9jcmVhdGVIYXJkd2FyZVJlbmRlclRhcmdldFdyYXBwZXIgPSBmdW5jdGlvbiAoaXNNdWx0aSwgaXNDdWJlLCBzaXplKSB7XG4gICAgY29uc3QgcnRXcmFwcGVyID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0V3JhcHBlcihpc011bHRpLCBpc0N1YmUsIHNpemUsIHRoaXMsIHRoaXMuX2dsKTtcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXRXcmFwcGVyQ2FjaGUucHVzaChydFdyYXBwZXIpO1xuICAgIHJldHVybiBydFdyYXBwZXI7XG59O1xuVGhpbkVuZ2luZS5wcm90b3R5cGUuY3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uIChzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcnRXcmFwcGVyID0gdGhpcy5fY3JlYXRlSGFyZHdhcmVSZW5kZXJUYXJnZXRXcmFwcGVyKGZhbHNlLCBmYWxzZSwgc2l6ZSk7XG4gICAgbGV0IGdlbmVyYXRlRGVwdGhCdWZmZXIgPSB0cnVlO1xuICAgIGxldCBnZW5lcmF0ZVN0ZW5jaWxCdWZmZXIgPSBmYWxzZTtcbiAgICBsZXQgbm9Db2xvckF0dGFjaG1lbnQgPSBmYWxzZTtcbiAgICBsZXQgY29sb3JBdHRhY2htZW50ID0gdW5kZWZpbmVkO1xuICAgIGxldCBzYW1wbGVzID0gMTtcbiAgICBsZXQgbGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBnZW5lcmF0ZURlcHRoQnVmZmVyID0gb3B0aW9ucy5nZW5lcmF0ZURlcHRoQnVmZmVyID8/IHRydWU7XG4gICAgICAgIGdlbmVyYXRlU3RlbmNpbEJ1ZmZlciA9ICEhb3B0aW9ucy5nZW5lcmF0ZVN0ZW5jaWxCdWZmZXI7XG4gICAgICAgIG5vQ29sb3JBdHRhY2htZW50ID0gISFvcHRpb25zLm5vQ29sb3JBdHRhY2htZW50O1xuICAgICAgICBjb2xvckF0dGFjaG1lbnQgPSBvcHRpb25zLmNvbG9yQXR0YWNobWVudDtcbiAgICAgICAgc2FtcGxlcyA9IG9wdGlvbnMuc2FtcGxlcyA/PyAxO1xuICAgICAgICBsYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBjb2xvckF0dGFjaG1lbnQgfHwgKG5vQ29sb3JBdHRhY2htZW50ID8gbnVsbCA6IHRoaXMuX2NyZWF0ZUludGVybmFsVGV4dHVyZShzaXplLCBvcHRpb25zLCB0cnVlLCA1IC8qIEludGVybmFsVGV4dHVyZVNvdXJjZS5SZW5kZXJUYXJnZXQgKi8pKTtcbiAgICBjb25zdCB3aWR0aCA9IHNpemUud2lkdGggfHwgc2l6ZTtcbiAgICBjb25zdCBoZWlnaHQgPSBzaXplLmhlaWdodCB8fCBzaXplO1xuICAgIGNvbnN0IGN1cnJlbnRGcmFtZUJ1ZmZlciA9IHRoaXMuX2N1cnJlbnRGcmFtZWJ1ZmZlcjtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIC8vIENyZWF0ZSB0aGUgZnJhbWVidWZmZXJcbiAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgcnRXcmFwcGVyLl9kZXB0aFN0ZW5jaWxCdWZmZXIgPSB0aGlzLl9zZXR1cEZyYW1lYnVmZmVyRGVwdGhBdHRhY2htZW50cyhnZW5lcmF0ZVN0ZW5jaWxCdWZmZXIsIGdlbmVyYXRlRGVwdGhCdWZmZXIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIC8vIE5vIG5lZWQgdG8gcmViaW5kIG9uIGV2ZXJ5IGZyYW1lXG4gICAgaWYgKHRleHR1cmUgJiYgIXRleHR1cmUuaXMyREFycmF5ICYmICF0ZXh0dXJlLmlzM0QpIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9oYXJkd2FyZVRleHR1cmUudW5kZXJseWluZ1Jlc291cmNlLCAwKTtcbiAgICB9XG4gICAgdGhpcy5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcihjdXJyZW50RnJhbWVCdWZmZXIpO1xuICAgIHJ0V3JhcHBlci5sYWJlbCA9IGxhYmVsID8/IFwiUmVuZGVyVGFyZ2V0V3JhcHBlclwiO1xuICAgIHJ0V3JhcHBlci5fZnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcbiAgICBydFdyYXBwZXIuX2dlbmVyYXRlRGVwdGhCdWZmZXIgPSBnZW5lcmF0ZURlcHRoQnVmZmVyO1xuICAgIHJ0V3JhcHBlci5fZ2VuZXJhdGVTdGVuY2lsQnVmZmVyID0gZ2VuZXJhdGVTdGVuY2lsQnVmZmVyO1xuICAgIHJ0V3JhcHBlci5zZXRUZXh0dXJlcyh0ZXh0dXJlKTtcbiAgICBpZiAoIWNvbG9yQXR0YWNobWVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlclRhcmdldFRleHR1cmVTYW1wbGVDb3VudChydFdyYXBwZXIsIHNhbXBsZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcnRXcmFwcGVyLl9zYW1wbGVzID0gY29sb3JBdHRhY2htZW50LnNhbXBsZXM7XG4gICAgICAgIGlmIChjb2xvckF0dGFjaG1lbnQuc2FtcGxlcyA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zYWFSZW5kZXJCdWZmZXIgPSBjb2xvckF0dGFjaG1lbnQuX2hhcmR3YXJlVGV4dHVyZS5nZXRNU0FBUmVuZGVyQnVmZmVyKDApO1xuICAgICAgICAgICAgcnRXcmFwcGVyLl9NU0FBRnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICAgICAgdGhpcy5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcihydFdyYXBwZXIuX01TQUFGcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlJFTkRFUkJVRkZFUiwgbXNhYVJlbmRlckJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9iaW5kVW5ib3VuZEZyYW1lYnVmZmVyKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydFdyYXBwZXI7XG59O1xuVGhpbkVuZ2luZS5wcm90b3R5cGUuX2NyZWF0ZURlcHRoU3RlbmNpbFRleHR1cmUgPSBmdW5jdGlvbiAoc2l6ZSwgb3B0aW9ucywgcnRXcmFwcGVyKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBjb25zdCBsYXllcnMgPSBzaXplLmxheWVycyB8fCAwO1xuICAgIGNvbnN0IGRlcHRoID0gc2l6ZS5kZXB0aCB8fCAwO1xuICAgIGxldCB0YXJnZXQgPSBnbC5URVhUVVJFXzJEO1xuICAgIGlmIChsYXllcnMgIT09IDApIHtcbiAgICAgICAgdGFyZ2V0ID0gZ2wuVEVYVFVSRV8yRF9BUlJBWTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVwdGggIT09IDApIHtcbiAgICAgICAgdGFyZ2V0ID0gZ2wuVEVYVFVSRV8zRDtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJuYWxUZXh0dXJlID0gbmV3IEludGVybmFsVGV4dHVyZSh0aGlzLCAxMiAvKiBJbnRlcm5hbFRleHR1cmVTb3VyY2UuRGVwdGhTdGVuY2lsICovKTtcbiAgICBpbnRlcm5hbFRleHR1cmUubGFiZWwgPSBvcHRpb25zLmxhYmVsO1xuICAgIGlmICghdGhpcy5fY2Fwcy5kZXB0aFRleHR1cmVFeHRlbnNpb24pIHtcbiAgICAgICAgTG9nZ2VyLkVycm9yKFwiRGVwdGggdGV4dHVyZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlciBvciBoYXJkd2FyZS5cIik7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbFRleHR1cmU7XG4gICAgfVxuICAgIGNvbnN0IGludGVybmFsT3B0aW9ucyA9IHtcbiAgICAgICAgYmlsaW5lYXJGaWx0ZXJpbmc6IGZhbHNlLFxuICAgICAgICBjb21wYXJpc29uRnVuY3Rpb246IDAsXG4gICAgICAgIGdlbmVyYXRlU3RlbmNpbDogZmFsc2UsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KHRhcmdldCwgaW50ZXJuYWxUZXh0dXJlLCB0cnVlKTtcbiAgICB0aGlzLl9zZXR1cERlcHRoU3RlbmNpbFRleHR1cmUoaW50ZXJuYWxUZXh0dXJlLCBzaXplLCBpbnRlcm5hbE9wdGlvbnMuY29tcGFyaXNvbkZ1bmN0aW9uID09PSAwID8gZmFsc2UgOiBpbnRlcm5hbE9wdGlvbnMuYmlsaW5lYXJGaWx0ZXJpbmcsIGludGVybmFsT3B0aW9ucy5jb21wYXJpc29uRnVuY3Rpb24sIGludGVybmFsT3B0aW9ucy5zYW1wbGVzKTtcbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLmRlcHRoVGV4dHVyZUZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbE9wdGlvbnMuZGVwdGhUZXh0dXJlRm9ybWF0ICE9PSAxNSAmJlxuICAgICAgICAgICAgaW50ZXJuYWxPcHRpb25zLmRlcHRoVGV4dHVyZUZvcm1hdCAhPT0gMTYgJiZcbiAgICAgICAgICAgIGludGVybmFsT3B0aW9ucy5kZXB0aFRleHR1cmVGb3JtYXQgIT09IDE3ICYmXG4gICAgICAgICAgICBpbnRlcm5hbE9wdGlvbnMuZGVwdGhUZXh0dXJlRm9ybWF0ICE9PSAxMyAmJlxuICAgICAgICAgICAgaW50ZXJuYWxPcHRpb25zLmRlcHRoVGV4dHVyZUZvcm1hdCAhPT0gMTQgJiZcbiAgICAgICAgICAgIGludGVybmFsT3B0aW9ucy5kZXB0aFRleHR1cmVGb3JtYXQgIT09IDE4KSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYERlcHRoIHRleHR1cmUgJHtpbnRlcm5hbE9wdGlvbnMuZGVwdGhUZXh0dXJlRm9ybWF0fSBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbFRleHR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJuYWxUZXh0dXJlLmZvcm1hdCA9IGludGVybmFsT3B0aW9ucy5kZXB0aFRleHR1cmVGb3JtYXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnRlcm5hbFRleHR1cmUuZm9ybWF0ID0gaW50ZXJuYWxPcHRpb25zLmdlbmVyYXRlU3RlbmNpbCA/IDEzIDogMTY7XG4gICAgfVxuICAgIGNvbnN0IGhhc1N0ZW5jaWwgPSBIYXNTdGVuY2lsQXNwZWN0KGludGVybmFsVGV4dHVyZS5mb3JtYXQpO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLl9nZXRXZWJHTFRleHR1cmVUeXBlRnJvbURlcHRoVGV4dHVyZUZvcm1hdChpbnRlcm5hbFRleHR1cmUuZm9ybWF0KTtcbiAgICBjb25zdCBmb3JtYXQgPSBoYXNTdGVuY2lsID8gZ2wuREVQVEhfU1RFTkNJTCA6IGdsLkRFUFRIX0NPTVBPTkVOVDtcbiAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuX2dldEludGVybmFsRm9ybWF0RnJvbURlcHRoVGV4dHVyZUZvcm1hdChpbnRlcm5hbFRleHR1cmUuZm9ybWF0LCB0cnVlLCBoYXNTdGVuY2lsKTtcbiAgICBpZiAoaW50ZXJuYWxUZXh0dXJlLmlzMkRBcnJheSkge1xuICAgICAgICBnbC50ZXhJbWFnZTNEKHRhcmdldCwgMCwgaW50ZXJuYWxGb3JtYXQsIGludGVybmFsVGV4dHVyZS53aWR0aCwgaW50ZXJuYWxUZXh0dXJlLmhlaWdodCwgbGF5ZXJzLCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnRlcm5hbFRleHR1cmUuaXMzRCkge1xuICAgICAgICBnbC50ZXhJbWFnZTNEKHRhcmdldCwgMCwgaW50ZXJuYWxGb3JtYXQsIGludGVybmFsVGV4dHVyZS53aWR0aCwgaW50ZXJuYWxUZXh0dXJlLmhlaWdodCwgZGVwdGgsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgMCwgaW50ZXJuYWxGb3JtYXQsIGludGVybmFsVGV4dHVyZS53aWR0aCwgaW50ZXJuYWxUZXh0dXJlLmhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICB9XG4gICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0YXJnZXQsIG51bGwpO1xuICAgIHRoaXMuX2ludGVybmFsVGV4dHVyZXNDYWNoZS5wdXNoKGludGVybmFsVGV4dHVyZSk7XG4gICAgaWYgKHJ0V3JhcHBlci5fZGVwdGhTdGVuY2lsQnVmZmVyKSB7XG4gICAgICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihydFdyYXBwZXIuX2RlcHRoU3RlbmNpbEJ1ZmZlcik7XG4gICAgICAgIHJ0V3JhcHBlci5fZGVwdGhTdGVuY2lsQnVmZmVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcihydFdyYXBwZXIuX01TQUFGcmFtZWJ1ZmZlciA/PyBydFdyYXBwZXIuX2ZyYW1lYnVmZmVyKTtcbiAgICBydFdyYXBwZXIuX2dlbmVyYXRlU3RlbmNpbEJ1ZmZlciA9IGhhc1N0ZW5jaWw7XG4gICAgcnRXcmFwcGVyLl9kZXB0aFN0ZW5jaWxUZXh0dXJlV2l0aFN0ZW5jaWwgPSBoYXNTdGVuY2lsO1xuICAgIHJ0V3JhcHBlci5fZGVwdGhTdGVuY2lsQnVmZmVyID0gdGhpcy5fc2V0dXBGcmFtZWJ1ZmZlckRlcHRoQXR0YWNobWVudHMocnRXcmFwcGVyLl9nZW5lcmF0ZVN0ZW5jaWxCdWZmZXIsIHJ0V3JhcHBlci5fZ2VuZXJhdGVEZXB0aEJ1ZmZlciwgcnRXcmFwcGVyLndpZHRoLCBydFdyYXBwZXIuaGVpZ2h0LCBydFdyYXBwZXIuc2FtcGxlcywgaW50ZXJuYWxUZXh0dXJlLmZvcm1hdCk7XG4gICAgdGhpcy5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcihudWxsKTtcbiAgICByZXR1cm4gaW50ZXJuYWxUZXh0dXJlO1xufTtcblRoaW5FbmdpbmUucHJvdG90eXBlLnVwZGF0ZVJlbmRlclRhcmdldFRleHR1cmVTYW1wbGVDb3VudCA9IGZ1bmN0aW9uIChydFdyYXBwZXIsIHNhbXBsZXMpIHtcbiAgICBpZiAodGhpcy53ZWJHTFZlcnNpb24gPCAyIHx8ICFydFdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChydFdyYXBwZXIuc2FtcGxlcyA9PT0gc2FtcGxlcykge1xuICAgICAgICByZXR1cm4gc2FtcGxlcztcbiAgICB9XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBzYW1wbGVzID0gTWF0aC5taW4oc2FtcGxlcywgdGhpcy5nZXRDYXBzKCkubWF4TVNBQVNhbXBsZXMpO1xuICAgIC8vIERpc3Bvc2UgcHJldmlvdXMgcmVuZGVyIGJ1ZmZlcnNcbiAgICBpZiAocnRXcmFwcGVyLl9kZXB0aFN0ZW5jaWxCdWZmZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHJ0V3JhcHBlci5fZGVwdGhTdGVuY2lsQnVmZmVyKTtcbiAgICAgICAgcnRXcmFwcGVyLl9kZXB0aFN0ZW5jaWxCdWZmZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAocnRXcmFwcGVyLl9NU0FBRnJhbWVidWZmZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIocnRXcmFwcGVyLl9NU0FBRnJhbWVidWZmZXIpO1xuICAgICAgICBydFdyYXBwZXIuX01TQUFGcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGhhcmR3YXJlVGV4dHVyZSA9IHJ0V3JhcHBlci50ZXh0dXJlPy5faGFyZHdhcmVUZXh0dXJlO1xuICAgIGhhcmR3YXJlVGV4dHVyZT8ucmVsZWFzZU1TQUFSZW5kZXJCdWZmZXJzKCk7XG4gICAgaWYgKHJ0V3JhcHBlci50ZXh0dXJlICYmIHNhbXBsZXMgPiAxICYmIHR5cGVvZiBnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgIGlmICghZnJhbWVidWZmZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgbXVsdGkgc2FtcGxlZCBmcmFtZWJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBydFdyYXBwZXIuX01TQUFGcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xuICAgICAgICB0aGlzLl9iaW5kVW5ib3VuZEZyYW1lYnVmZmVyKHJ0V3JhcHBlci5fTVNBQUZyYW1lYnVmZmVyKTtcbiAgICAgICAgY29uc3QgY29sb3JSZW5kZXJidWZmZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJCdWZmZXIocnRXcmFwcGVyLnRleHR1cmUud2lkdGgsIHJ0V3JhcHBlci50ZXh0dXJlLmhlaWdodCwgc2FtcGxlcywgLTEgLyogbm90IHVzZWQgKi8sIHRoaXMuX2dldFJHQkFCdWZmZXJJbnRlcm5hbFNpemVkRm9ybWF0KHJ0V3JhcHBlci50ZXh0dXJlLnR5cGUsIHJ0V3JhcHBlci50ZXh0dXJlLmZvcm1hdCwgcnRXcmFwcGVyLnRleHR1cmUuX3VzZVNSR0JCdWZmZXIpLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZmFsc2UpO1xuICAgICAgICBpZiAoIWNvbG9yUmVuZGVyYnVmZmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIG11bHRpIHNhbXBsZWQgZnJhbWVidWZmZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaGFyZHdhcmVUZXh0dXJlPy5hZGRNU0FBUmVuZGVyQnVmZmVyKGNvbG9yUmVuZGVyYnVmZmVyKTtcbiAgICB9XG4gICAgdGhpcy5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcihydFdyYXBwZXIuX01TQUFGcmFtZWJ1ZmZlciA/PyBydFdyYXBwZXIuX2ZyYW1lYnVmZmVyKTtcbiAgICBpZiAocnRXcmFwcGVyLnRleHR1cmUpIHtcbiAgICAgICAgcnRXcmFwcGVyLnRleHR1cmUuc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgfVxuICAgIHJ0V3JhcHBlci5fc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgY29uc3QgZGVwdGhGb3JtYXQgPSBydFdyYXBwZXIuX2RlcHRoU3RlbmNpbFRleHR1cmUgPyBydFdyYXBwZXIuX2RlcHRoU3RlbmNpbFRleHR1cmUuZm9ybWF0IDogdW5kZWZpbmVkO1xuICAgIHJ0V3JhcHBlci5fZGVwdGhTdGVuY2lsQnVmZmVyID0gdGhpcy5fc2V0dXBGcmFtZWJ1ZmZlckRlcHRoQXR0YWNobWVudHMocnRXcmFwcGVyLl9nZW5lcmF0ZVN0ZW5jaWxCdWZmZXIsIHJ0V3JhcHBlci5fZ2VuZXJhdGVEZXB0aEJ1ZmZlciwgcnRXcmFwcGVyLndpZHRoLCBydFdyYXBwZXIuaGVpZ2h0LCBzYW1wbGVzLCBkZXB0aEZvcm1hdCk7XG4gICAgdGhpcy5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcihudWxsKTtcbiAgICByZXR1cm4gc2FtcGxlcztcbn07XG5UaGluRW5naW5lLnByb3RvdHlwZS5fc2V0dXBEZXB0aFN0ZW5jaWxUZXh0dXJlID0gZnVuY3Rpb24gKGludGVybmFsVGV4dHVyZSwgc2l6ZSwgYmlsaW5lYXJGaWx0ZXJpbmcsIGNvbXBhcmlzb25GdW5jdGlvbiwgc2FtcGxlcyA9IDEpIHtcbiAgICBjb25zdCB3aWR0aCA9IHNpemUud2lkdGggPz8gc2l6ZTtcbiAgICBjb25zdCBoZWlnaHQgPSBzaXplLmhlaWdodCA/PyBzaXplO1xuICAgIGNvbnN0IGxheWVycyA9IHNpemUubGF5ZXJzIHx8IDA7XG4gICAgY29uc3QgZGVwdGggPSBzaXplLmRlcHRoIHx8IDA7XG4gICAgaW50ZXJuYWxUZXh0dXJlLmJhc2VXaWR0aCA9IHdpZHRoO1xuICAgIGludGVybmFsVGV4dHVyZS5iYXNlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGludGVybmFsVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xuICAgIGludGVybmFsVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgaW50ZXJuYWxUZXh0dXJlLmlzMkRBcnJheSA9IGxheWVycyA+IDA7XG4gICAgaW50ZXJuYWxUZXh0dXJlLmRlcHRoID0gbGF5ZXJzIHx8IGRlcHRoO1xuICAgIGludGVybmFsVGV4dHVyZS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICBpbnRlcm5hbFRleHR1cmUuc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgaW50ZXJuYWxUZXh0dXJlLmdlbmVyYXRlTWlwTWFwcyA9IGZhbHNlO1xuICAgIGludGVybmFsVGV4dHVyZS5zYW1wbGluZ01vZGUgPSBiaWxpbmVhckZpbHRlcmluZyA/IDIgOiAxO1xuICAgIGludGVybmFsVGV4dHVyZS50eXBlID0gMDtcbiAgICBpbnRlcm5hbFRleHR1cmUuX2NvbXBhcmlzb25GdW5jdGlvbiA9IGNvbXBhcmlzb25GdW5jdGlvbjtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2dldFRleHR1cmVUYXJnZXQoaW50ZXJuYWxUZXh0dXJlKTtcbiAgICBjb25zdCBzYW1wbGluZ1BhcmFtZXRlcnMgPSB0aGlzLl9nZXRTYW1wbGluZ1BhcmFtZXRlcnMoaW50ZXJuYWxUZXh0dXJlLnNhbXBsaW5nTW9kZSwgZmFsc2UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBnbC5URVhUVVJFX01BR19GSUxURVIsIHNhbXBsaW5nUGFyYW1ldGVycy5tYWcpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHNhbXBsaW5nUGFyYW1ldGVycy5taW4pO1xuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAvLyBURVhUVVJFX0NPTVBBUkVfRlVOQy9NT0RFIGFyZSBvbmx5IGF2YWlsYmxlIGluIFdlYkdMMi5cbiAgICBpZiAodGhpcy53ZWJHTFZlcnNpb24gPiAxKSB7XG4gICAgICAgIGlmIChjb21wYXJpc29uRnVuY3Rpb24gPT09IDApIHtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBnbC5URVhUVVJFX0NPTVBBUkVfRlVOQywgNTE1KTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBnbC5URVhUVVJFX0NPTVBBUkVfTU9ERSwgZ2wuTk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgZ2wuVEVYVFVSRV9DT01QQVJFX0ZVTkMsIGNvbXBhcmlzb25GdW5jdGlvbik7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgZ2wuVEVYVFVSRV9DT01QQVJFX01PREUsIGdsLkNPTVBBUkVfUkVGX1RPX1RFWFRVUkUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuZ2luZS5yZW5kZXJUYXJnZXQuanMubWFwIiwiaW1wb3J0IHsgSW50ZXJuYWxUZXh0dXJlIH0gZnJvbSBcIi4uLy4uL01hdGVyaWFscy9UZXh0dXJlcy9pbnRlcm5hbFRleHR1cmUuanNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi8uLi9NaXNjL2xvZ2dlci5qc1wiO1xuXG5pbXBvcnQgeyBUaGluRW5naW5lIH0gZnJvbSBcIi4uL3RoaW5FbmdpbmUuanNcIjtcblRoaW5FbmdpbmUucHJvdG90eXBlLmNyZWF0ZVJlbmRlclRhcmdldEN1YmVUZXh0dXJlID0gZnVuY3Rpb24gKHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBydFdyYXBwZXIgPSB0aGlzLl9jcmVhdGVIYXJkd2FyZVJlbmRlclRhcmdldFdyYXBwZXIoZmFsc2UsIHRydWUsIHNpemUpO1xuICAgIGNvbnN0IGZ1bGxPcHRpb25zID0ge1xuICAgICAgICBnZW5lcmF0ZU1pcE1hcHM6IHRydWUsXG4gICAgICAgIGdlbmVyYXRlRGVwdGhCdWZmZXI6IHRydWUsXG4gICAgICAgIGdlbmVyYXRlU3RlbmNpbEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgIHR5cGU6IDAsXG4gICAgICAgIHNhbXBsaW5nTW9kZTogMyxcbiAgICAgICAgZm9ybWF0OiA1LFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgZnVsbE9wdGlvbnMuZ2VuZXJhdGVTdGVuY2lsQnVmZmVyID0gZnVsbE9wdGlvbnMuZ2VuZXJhdGVEZXB0aEJ1ZmZlciAmJiBmdWxsT3B0aW9ucy5nZW5lcmF0ZVN0ZW5jaWxCdWZmZXI7XG4gICAgaWYgKGZ1bGxPcHRpb25zLnR5cGUgPT09IDEgJiYgIXRoaXMuX2NhcHMudGV4dHVyZUZsb2F0TGluZWFyRmlsdGVyaW5nKSB7XG4gICAgICAgIC8vIGlmIGZsb2F0aW5nIHBvaW50IGxpbmVhciAoZ2wuRkxPQVQpIHRoZW4gZm9yY2UgdG8gTkVBUkVTVF9TQU1QTElOR01PREVcbiAgICAgICAgZnVsbE9wdGlvbnMuc2FtcGxpbmdNb2RlID0gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZnVsbE9wdGlvbnMudHlwZSA9PT0gMiAmJiAhdGhpcy5fY2Fwcy50ZXh0dXJlSGFsZkZsb2F0TGluZWFyRmlsdGVyaW5nKSB7XG4gICAgICAgIC8vIGlmIGZsb2F0aW5nIHBvaW50IGxpbmVhciAoSEFMRl9GTE9BVCkgdGhlbiBmb3JjZSB0byBORUFSRVNUX1NBTVBMSU5HTU9ERVxuICAgICAgICBmdWxsT3B0aW9ucy5zYW1wbGluZ01vZGUgPSAxO1xuICAgIH1cbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgSW50ZXJuYWxUZXh0dXJlKHRoaXMsIDUgLyogSW50ZXJuYWxUZXh0dXJlU291cmNlLlJlbmRlclRhcmdldCAqLyk7XG4gICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseShnbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCB0cnVlKTtcbiAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5fZ2V0U2FtcGxpbmdQYXJhbWV0ZXJzKGZ1bGxPcHRpb25zLnNhbXBsaW5nTW9kZSwgZnVsbE9wdGlvbnMuZ2VuZXJhdGVNaXBNYXBzKTtcbiAgICBpZiAoZnVsbE9wdGlvbnMudHlwZSA9PT0gMSAmJiAhdGhpcy5fY2Fwcy50ZXh0dXJlRmxvYXQpIHtcbiAgICAgICAgZnVsbE9wdGlvbnMudHlwZSA9IDA7XG4gICAgICAgIExvZ2dlci5XYXJuKFwiRmxvYXQgdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQuIEN1YmUgcmVuZGVyIHRhcmdldCBmb3JjZWQgdG8gVEVYVFVSRVRZUEVfVU5FU0lHTkVEX0JZVEUgdHlwZVwiKTtcbiAgICB9XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlcnMubWFnKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVycy5taW4pO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgNjsgZmFjZSsrKSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgZmFjZSwgMCwgdGhpcy5fZ2V0UkdCQUJ1ZmZlckludGVybmFsU2l6ZWRGb3JtYXQoZnVsbE9wdGlvbnMudHlwZSwgZnVsbE9wdGlvbnMuZm9ybWF0KSwgc2l6ZSwgc2l6ZSwgMCwgdGhpcy5fZ2V0SW50ZXJuYWxGb3JtYXQoZnVsbE9wdGlvbnMuZm9ybWF0KSwgdGhpcy5fZ2V0V2ViR0xUZXh0dXJlVHlwZShmdWxsT3B0aW9ucy50eXBlKSwgbnVsbCk7XG4gICAgfVxuICAgIC8vIENyZWF0ZSB0aGUgZnJhbWVidWZmZXJcbiAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgcnRXcmFwcGVyLl9kZXB0aFN0ZW5jaWxCdWZmZXIgPSB0aGlzLl9zZXR1cEZyYW1lYnVmZmVyRGVwdGhBdHRhY2htZW50cyhmdWxsT3B0aW9ucy5nZW5lcmF0ZVN0ZW5jaWxCdWZmZXIsIGZ1bGxPcHRpb25zLmdlbmVyYXRlRGVwdGhCdWZmZXIsIHNpemUsIHNpemUpO1xuICAgIC8vIE1pcE1hcHNcbiAgICBpZiAoZnVsbE9wdGlvbnMuZ2VuZXJhdGVNaXBNYXBzKSB7XG4gICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfQ1VCRV9NQVApO1xuICAgIH1cbiAgICAvLyBVbmJpbmRcbiAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuICAgIHRoaXMuX2JpbmRVbmJvdW5kRnJhbWVidWZmZXIobnVsbCk7XG4gICAgcnRXcmFwcGVyLl9mcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xuICAgIHJ0V3JhcHBlci5fZ2VuZXJhdGVEZXB0aEJ1ZmZlciA9IGZ1bGxPcHRpb25zLmdlbmVyYXRlRGVwdGhCdWZmZXI7XG4gICAgcnRXcmFwcGVyLl9nZW5lcmF0ZVN0ZW5jaWxCdWZmZXIgPSBmdWxsT3B0aW9ucy5nZW5lcmF0ZVN0ZW5jaWxCdWZmZXI7XG4gICAgdGV4dHVyZS53aWR0aCA9IHNpemU7XG4gICAgdGV4dHVyZS5oZWlnaHQgPSBzaXplO1xuICAgIHRleHR1cmUuaXNSZWFkeSA9IHRydWU7XG4gICAgdGV4dHVyZS5pc0N1YmUgPSB0cnVlO1xuICAgIHRleHR1cmUuc2FtcGxlcyA9IDE7XG4gICAgdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMgPSBmdWxsT3B0aW9ucy5nZW5lcmF0ZU1pcE1hcHM7XG4gICAgdGV4dHVyZS5zYW1wbGluZ01vZGUgPSBmdWxsT3B0aW9ucy5zYW1wbGluZ01vZGU7XG4gICAgdGV4dHVyZS50eXBlID0gZnVsbE9wdGlvbnMudHlwZTtcbiAgICB0ZXh0dXJlLmZvcm1hdCA9IGZ1bGxPcHRpb25zLmZvcm1hdDtcbiAgICB0aGlzLl9pbnRlcm5hbFRleHR1cmVzQ2FjaGUucHVzaCh0ZXh0dXJlKTtcbiAgICBydFdyYXBwZXIuc2V0VGV4dHVyZXModGV4dHVyZSk7XG4gICAgcmV0dXJuIHJ0V3JhcHBlcjtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmdpbmUucmVuZGVyVGFyZ2V0Q3ViZS5qcy5tYXAiLCJpbXBvcnQgeyBUaGluRW5naW5lIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvdGhpbkVuZ2luZS5qc1wiO1xuVGhpbkVuZ2luZS5wcm90b3R5cGUuc2V0RGVwdGhTdGVuY2lsVGV4dHVyZSA9IGZ1bmN0aW9uIChjaGFubmVsLCB1bmlmb3JtLCB0ZXh0dXJlLCBuYW1lKSB7XG4gICAgaWYgKGNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1bmlmb3JtKSB7XG4gICAgICAgIHRoaXMuX2JvdW5kVW5pZm9ybXNbY2hhbm5lbF0gPSB1bmlmb3JtO1xuICAgIH1cbiAgICBpZiAoIXRleHR1cmUgfHwgIXRleHR1cmUuZGVwdGhTdGVuY2lsVGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9zZXRUZXh0dXJlKGNoYW5uZWwsIG51bGwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldFRleHR1cmUoY2hhbm5lbCwgdGV4dHVyZSwgZmFsc2UsIHRydWUsIG5hbWUpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmdpbmUucmVuZGVyVGFyZ2V0VGV4dHVyZS5qcy5tYXAiLCJpbXBvcnQgeyBUaGluRW5naW5lIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvdGhpbkVuZ2luZS5qc1wiO1xuaW1wb3J0IHsgV2ViR0xEYXRhQnVmZmVyIH0gZnJvbSBcIi4uLy4uL01lc2hlcy9XZWJHTC93ZWJHTERhdGFCdWZmZXIuanNcIjtcblRoaW5FbmdpbmUucHJvdG90eXBlLmNyZWF0ZVVuaWZvcm1CdWZmZXIgPSBmdW5jdGlvbiAoZWxlbWVudHMsIF9sYWJlbCkge1xuICAgIGNvbnN0IHVibyA9IHRoaXMuX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGlmICghdWJvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgdW5pZm9ybSBidWZmZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBXZWJHTERhdGFCdWZmZXIodWJvKTtcbiAgICB0aGlzLmJpbmRVbmlmb3JtQnVmZmVyKHJlc3VsdCk7XG4gICAgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgIHRoaXMuX2dsLmJ1ZmZlckRhdGEodGhpcy5fZ2wuVU5JRk9STV9CVUZGRVIsIGVsZW1lbnRzLCB0aGlzLl9nbC5TVEFUSUNfRFJBVyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX2dsLlVOSUZPUk1fQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KGVsZW1lbnRzKSwgdGhpcy5fZ2wuU1RBVElDX0RSQVcpO1xuICAgIH1cbiAgICB0aGlzLmJpbmRVbmlmb3JtQnVmZmVyKG51bGwpO1xuICAgIHJlc3VsdC5yZWZlcmVuY2VzID0gMTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblRoaW5FbmdpbmUucHJvdG90eXBlLmNyZWF0ZUR5bmFtaWNVbmlmb3JtQnVmZmVyID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBfbGFiZWwpIHtcbiAgICBjb25zdCB1Ym8gPSB0aGlzLl9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIXVibykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIGR5bmFtaWMgdW5pZm9ybSBidWZmZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBXZWJHTERhdGFCdWZmZXIodWJvKTtcbiAgICB0aGlzLmJpbmRVbmlmb3JtQnVmZmVyKHJlc3VsdCk7XG4gICAgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgIHRoaXMuX2dsLmJ1ZmZlckRhdGEodGhpcy5fZ2wuVU5JRk9STV9CVUZGRVIsIGVsZW1lbnRzLCB0aGlzLl9nbC5EWU5BTUlDX0RSQVcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fZ2wuYnVmZmVyRGF0YSh0aGlzLl9nbC5VTklGT1JNX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShlbGVtZW50cyksIHRoaXMuX2dsLkRZTkFNSUNfRFJBVyk7XG4gICAgfVxuICAgIHRoaXMuYmluZFVuaWZvcm1CdWZmZXIobnVsbCk7XG4gICAgcmVzdWx0LnJlZmVyZW5jZXMgPSAxO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuVGhpbkVuZ2luZS5wcm90b3R5cGUudXBkYXRlVW5pZm9ybUJ1ZmZlciA9IGZ1bmN0aW9uICh1bmlmb3JtQnVmZmVyLCBlbGVtZW50cywgb2Zmc2V0LCBjb3VudCkge1xuICAgIHRoaXMuYmluZFVuaWZvcm1CdWZmZXIodW5pZm9ybUJ1ZmZlcik7XG4gICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChlbGVtZW50cyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5fZ2wuYnVmZmVyU3ViRGF0YSh0aGlzLl9nbC5VTklGT1JNX0JVRkZFUiwgb2Zmc2V0LCBlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5idWZmZXJTdWJEYXRhKHRoaXMuX2dsLlVOSUZPUk1fQlVGRkVSLCBvZmZzZXQsIG5ldyBGbG9hdDMyQXJyYXkoZWxlbWVudHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5idWZmZXJTdWJEYXRhKHRoaXMuX2dsLlVOSUZPUk1fQlVGRkVSLCAwLCBlbGVtZW50cy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGNvdW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5idWZmZXJTdWJEYXRhKHRoaXMuX2dsLlVOSUZPUk1fQlVGRkVSLCAwLCBuZXcgRmxvYXQzMkFycmF5KGVsZW1lbnRzKS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGNvdW50KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5iaW5kVW5pZm9ybUJ1ZmZlcihudWxsKTtcbn07XG5UaGluRW5naW5lLnByb3RvdHlwZS5iaW5kVW5pZm9ybUJ1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICB0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLlVOSUZPUk1fQlVGRkVSLCBidWZmZXIgPyBidWZmZXIudW5kZXJseWluZ1Jlc291cmNlIDogbnVsbCk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuVGhpbkVuZ2luZS5wcm90b3R5cGUuYmluZFVuaWZvcm1CdWZmZXJCYXNlID0gZnVuY3Rpb24gKGJ1ZmZlciwgbG9jYXRpb24sIG5hbWUpIHtcbiAgICB0aGlzLl9nbC5iaW5kQnVmZmVyQmFzZSh0aGlzLl9nbC5VTklGT1JNX0JVRkZFUiwgbG9jYXRpb24sIGJ1ZmZlciA/IGJ1ZmZlci51bmRlcmx5aW5nUmVzb3VyY2UgOiBudWxsKTtcbn07XG5UaGluRW5naW5lLnByb3RvdHlwZS5iaW5kVW5pZm9ybUJsb2NrID0gZnVuY3Rpb24gKHBpcGVsaW5lQ29udGV4dCwgYmxvY2tOYW1lLCBpbmRleCkge1xuICAgIGNvbnN0IHByb2dyYW0gPSBwaXBlbGluZUNvbnRleHQucHJvZ3JhbTtcbiAgICBjb25zdCB1bmlmb3JtTG9jYXRpb24gPSB0aGlzLl9nbC5nZXRVbmlmb3JtQmxvY2tJbmRleChwcm9ncmFtLCBibG9ja05hbWUpO1xuICAgIGlmICh1bmlmb3JtTG9jYXRpb24gIT09IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybUJsb2NrQmluZGluZyhwcm9ncmFtLCB1bmlmb3JtTG9jYXRpb24sIGluZGV4KTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5naW5lLnVuaWZvcm1CdWZmZXIuanMubWFwIiwiY29uc3QgVmFyeWluZ1JlZ2V4ID0gLyhmbGF0XFxzKT9cXHMqdmFyeWluZ1xccyouKi87XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgV2ViR0wyU2hhZGVyUHJvY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaGFkZXJMYW5ndWFnZSA9IDAgLyogU2hhZGVyTGFuZ3VhZ2UuR0xTTCAqLztcbiAgICB9XG4gICAgYXR0cmlidXRlUHJvY2Vzc29yKGF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlLnJlcGxhY2UoXCJhdHRyaWJ1dGVcIiwgXCJpblwiKTtcbiAgICB9XG4gICAgdmFyeWluZ0NoZWNrKHZhcnlpbmcsIF9pc0ZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBWYXJ5aW5nUmVnZXgudGVzdCh2YXJ5aW5nKTtcbiAgICB9XG4gICAgdmFyeWluZ1Byb2Nlc3Nvcih2YXJ5aW5nLCBpc0ZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiB2YXJ5aW5nLnJlcGxhY2UoXCJ2YXJ5aW5nXCIsIGlzRnJhZ21lbnQgPyBcImluXCIgOiBcIm91dFwiKTtcbiAgICB9XG4gICAgcG9zdFByb2Nlc3Nvcihjb2RlLCBkZWZpbmVzLCBpc0ZyYWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGhhc0RyYXdCdWZmZXJzRXh0ZW5zaW9uID0gY29kZS5zZWFyY2goLyNleHRlbnNpb24uK0dMX0VYVF9kcmF3X2J1ZmZlcnMuK3JlcXVpcmUvKSAhPT0gLTE7XG4gICAgICAgIC8vIFJlbW92ZSBleHRlbnNpb25zXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gLyNleHRlbnNpb24uKyhHTF9PVlJfbXVsdGl2aWV3MnxHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXN8R0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZHxHTF9FWFRfZnJhZ19kZXB0aHxHTF9FWFRfZHJhd19idWZmZXJzKS4rKGVuYWJsZXxyZXF1aXJlKS9nO1xuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlZ2V4LCBcIlwiKTtcbiAgICAgICAgLy8gUmVwbGFjZSBpbnN0cnVjdGlvbnNcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZSgvdGV4dHVyZTJEXFxzKlxcKC9nLCBcInRleHR1cmUoXCIpO1xuICAgICAgICBpZiAoaXNGcmFnbWVudCkge1xuICAgICAgICAgICAgY29uc3QgaGFzT3V0cHV0ID0gY29kZS5zZWFyY2goL2xheW91dCAqXFwobG9jYXRpb24gKj0gKjBcXCkgKm91dC9nKSAhPT0gLTE7XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC90ZXh0dXJlMkRMb2RFWFRcXHMqXFwoL2csIFwidGV4dHVyZUxvZChcIik7XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC90ZXh0dXJlQ3ViZUxvZEVYVFxccypcXCgvZywgXCJ0ZXh0dXJlTG9kKFwiKTtcbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL3RleHR1cmVDdWJlXFxzKlxcKC9nLCBcInRleHR1cmUoXCIpO1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZSgvZ2xfRnJhZ0RlcHRoRVhUL2csIFwiZ2xfRnJhZ0RlcHRoXCIpO1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZSgvZ2xfRnJhZ0NvbG9yL2csIFwiZ2xGcmFnQ29sb3JcIik7XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9nbF9GcmFnRGF0YS9nLCBcImdsRnJhZ0RhdGFcIik7XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC92b2lkXFxzKz9tYWluXFxzKlxcKC9nLCAoaGFzRHJhd0J1ZmZlcnNFeHRlbnNpb24gfHwgaGFzT3V0cHV0ID8gXCJcIiA6IFwibGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgZ2xGcmFnQ29sb3I7XFxuXCIpICsgXCJ2b2lkIG1haW4oXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGFzTXVsdGl2aWV3RXh0ZW5zaW9uID0gZGVmaW5lcy5pbmRleE9mKFwiI2RlZmluZSBNVUxUSVZJRVdcIikgIT09IC0xO1xuICAgICAgICAgICAgaWYgKGhhc011bHRpdmlld0V4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIiNleHRlbnNpb24gR0xfT1ZSX211bHRpdmlldzIgOiByZXF1aXJlXFxubGF5b3V0IChudW1fdmlld3MgPSAyKSBpbjtcXG5cIiArIGNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViR0wyU2hhZGVyUHJvY2Vzc29ycy5qcy5tYXAiLCIvKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgV2ViR0xIYXJkd2FyZVRleHR1cmUge1xuICAgIGdldCB1bmRlcmx5aW5nUmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWJHTFRleHR1cmU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGV4aXN0aW5nVGV4dHVyZSA9IG51bGwsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gVGhlcmUgY2FuIGJlIG11bHRpcGxlIGJ1ZmZlcnMgZm9yIGEgc2luZ2xlIFdlYkdMIHRleHR1cmUgYmVjYXVzZSBkaWZmZXJlbnQgbGF5ZXJzIG9mIGEgMkRBcnJheVRleHR1cmUgLyAzRFRleHR1cmVcbiAgICAgICAgLy8gb3IgZGlmZmVyZW50IGZhY2VzIG9mIGEgY3ViZSB0ZXh0dXJlIGNhbiBiZSBib3VuZCB0byBkaWZmZXJlbnQgcmVuZGVyIHRhcmdldHMgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgICAgICB0aGlzLl9NU0FBUmVuZGVyQnVmZmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBpZiAoIWV4aXN0aW5nVGV4dHVyZSkge1xuICAgICAgICAgICAgZXhpc3RpbmdUZXh0dXJlID0gY29udGV4dC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgd2ViR0wgdGV4dHVyZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldChleGlzdGluZ1RleHR1cmUpO1xuICAgIH1cbiAgICBzZXRVc2FnZSgpIHsgfVxuICAgIHNldChoYXJkd2FyZVRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fd2ViR0xUZXh0dXJlID0gaGFyZHdhcmVUZXh0dXJlO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fd2ViR0xUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fTVNBQVJlbmRlckJ1ZmZlcnMgPSBudWxsO1xuICAgIH1cbiAgICBhZGRNU0FBUmVuZGVyQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICBpZiAoIXRoaXMuX01TQUFSZW5kZXJCdWZmZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9NU0FBUmVuZGVyQnVmZmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX01TQUFSZW5kZXJCdWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICB9XG4gICAgcmVsZWFzZU1TQUFSZW5kZXJCdWZmZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5fTVNBQVJlbmRlckJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHRoaXMuX01TQUFSZW5kZXJCdWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kZWxldGVSZW5kZXJidWZmZXIoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX01TQUFSZW5kZXJCdWZmZXJzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNU0FBUmVuZGVyQnVmZmVyKGluZGV4ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fTVNBQVJlbmRlckJ1ZmZlcnM/LltpbmRleF0gPz8gbnVsbDtcbiAgICB9XG4gICAgcmVsZWFzZSgpIHtcbiAgICAgICAgdGhpcy5yZWxlYXNlTVNBQVJlbmRlckJ1ZmZlcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3dlYkdMVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kZWxldGVUZXh0dXJlKHRoaXMuX3dlYkdMVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYkdMSGFyZHdhcmVUZXh0dXJlLmpzLm1hcCIsIlxuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0V3JhcHBlciB9IGZyb20gXCIuLi9yZW5kZXJUYXJnZXRXcmFwcGVyLmpzXCI7XG5pbXBvcnQgeyBIYXNTdGVuY2lsQXNwZWN0IH0gZnJvbSBcIi4uLy4uL01hdGVyaWFscy9UZXh0dXJlcy90ZXh0dXJlSGVscGVyLmZ1bmN0aW9ucy5qc1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIFdlYkdMUmVuZGVyVGFyZ2V0V3JhcHBlciBleHRlbmRzIFJlbmRlclRhcmdldFdyYXBwZXIge1xuICAgIHNldERlcHRoU3RlbmNpbFRleHR1cmUodGV4dHVyZSwgZGlzcG9zZUV4aXN0aW5nID0gdHJ1ZSkge1xuICAgICAgICBzdXBlci5zZXREZXB0aFN0ZW5jaWxUZXh0dXJlKHRleHR1cmUsIGRpc3Bvc2VFeGlzdGluZyk7XG4gICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX2VuZ2luZTtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBjb25zdCBoYXJkd2FyZVRleHR1cmUgPSB0ZXh0dXJlLl9oYXJkd2FyZVRleHR1cmU7XG4gICAgICAgIGlmIChoYXJkd2FyZVRleHR1cmUgJiYgdGV4dHVyZS5fYXV0b01TQUFNYW5hZ2VtZW50ICYmIHRoaXMuX01TQUFGcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEZiID0gZW5naW5lLl9jdXJyZW50RnJhbWVidWZmZXI7XG4gICAgICAgICAgICBlbmdpbmUuX2JpbmRVbmJvdW5kRnJhbWVidWZmZXIodGhpcy5fTVNBQUZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBIYXNTdGVuY2lsQXNwZWN0KHRleHR1cmUuZm9ybWF0KSA/IGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA6IGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgaGFyZHdhcmVUZXh0dXJlLmdldE1TQUFSZW5kZXJCdWZmZXIoKSk7XG4gICAgICAgICAgICBlbmdpbmUuX2JpbmRVbmJvdW5kRnJhbWVidWZmZXIoY3VycmVudEZiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihpc011bHRpLCBpc0N1YmUsIHNpemUsIGVuZ2luZSwgY29udGV4dCkge1xuICAgICAgICBzdXBlcihpc011bHRpLCBpc0N1YmUsIHNpemUsIGVuZ2luZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZyYW1lYnVmZmVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGVwdGhTdGVuY2lsQnVmZmVyID0gbnVsbDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgICAgIHRoaXMuX01TQUFGcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgICAgIC8vIE11bHRpdmlld1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb2xvclRleHR1cmVBcnJheSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmVBcnJheSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VPbmx5RnJhbWVidWZmZXJzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2N1cnJlbnRMT0QgPSAwO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgX2Nsb25lUmVuZGVyVGFyZ2V0V3JhcHBlcigpIHtcbiAgICAgICAgbGV0IHJ0dyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9jb2xvclRleHR1cmVBcnJheSAmJiB0aGlzLl9kZXB0aFN0ZW5jaWxUZXh0dXJlQXJyYXkpIHtcbiAgICAgICAgICAgIHJ0dyA9IHRoaXMuX2VuZ2luZS5jcmVhdGVNdWx0aXZpZXdSZW5kZXJUYXJnZXRUZXh0dXJlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHJ0dy50ZXh0dXJlLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcnR3ID0gc3VwZXIuX2Nsb25lUmVuZGVyVGFyZ2V0V3JhcHBlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydHc7XG4gICAgfVxuICAgIF9zd2FwUmVuZGVyVGFyZ2V0V3JhcHBlcih0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIuX3N3YXBSZW5kZXJUYXJnZXRXcmFwcGVyKHRhcmdldCk7XG4gICAgICAgIHRhcmdldC5fZnJhbWVidWZmZXIgPSB0aGlzLl9mcmFtZWJ1ZmZlcjtcbiAgICAgICAgdGFyZ2V0Ll9kZXB0aFN0ZW5jaWxCdWZmZXIgPSB0aGlzLl9kZXB0aFN0ZW5jaWxCdWZmZXI7XG4gICAgICAgIHRhcmdldC5fTVNBQUZyYW1lYnVmZmVyID0gdGhpcy5fTVNBQUZyYW1lYnVmZmVyO1xuICAgICAgICB0YXJnZXQuX2NvbG9yVGV4dHVyZUFycmF5ID0gdGhpcy5fY29sb3JUZXh0dXJlQXJyYXk7XG4gICAgICAgIHRhcmdldC5fZGVwdGhTdGVuY2lsVGV4dHVyZUFycmF5ID0gdGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZUFycmF5O1xuICAgICAgICB0aGlzLl9mcmFtZWJ1ZmZlciA9IHRoaXMuX2RlcHRoU3RlbmNpbEJ1ZmZlciA9IHRoaXMuX01TQUFGcmFtZWJ1ZmZlciA9IHRoaXMuX2NvbG9yVGV4dHVyZUFycmF5ID0gdGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZUFycmF5ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZGVwdGgvc3RlbmNpbCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGNvbXBhcmlzb25GdW5jdGlvbiBDb21wYXJpc29uIGZ1bmN0aW9uIHRvIHVzZSBmb3IgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gYmlsaW5lYXJGaWx0ZXJpbmcgdHJ1ZSBpZiBiaWxpbmVhciBmaWx0ZXJpbmcgc2hvdWxkIGJlIHVzZWQgd2hlbiBzYW1wbGluZyB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBnZW5lcmF0ZVN0ZW5jaWwgdHJ1ZSBpZiB0aGUgc3RlbmNpbCBhc3BlY3Qgc2hvdWxkIGFsc28gYmUgY3JlYXRlZFxuICAgICAqIEBwYXJhbSBzYW1wbGVzIHNhbXBsZSBjb3VudCB0byB1c2Ugd2hlbiBjcmVhdGluZyB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBmb3JtYXQgZm9ybWF0IG9mIHRoZSBkZXB0aCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGxhYmVsIGRlZmluZXMgdGhlIGxhYmVsIHRvIHVzZSBmb3IgdGhlIHRleHR1cmUgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZSBvbmx5KVxuICAgICAqIEByZXR1cm5zIHRoZSBkZXB0aC9zdGVuY2lsIGNyZWF0ZWQgdGV4dHVyZVxuICAgICAqL1xuICAgIGNyZWF0ZURlcHRoU3RlbmNpbFRleHR1cmUoY29tcGFyaXNvbkZ1bmN0aW9uID0gMCwgYmlsaW5lYXJGaWx0ZXJpbmcgPSB0cnVlLCBnZW5lcmF0ZVN0ZW5jaWwgPSBmYWxzZSwgc2FtcGxlcyA9IDEsIGZvcm1hdCA9IDE0LCBsYWJlbCkge1xuICAgICAgICBpZiAodGhpcy5fZGVwdGhTdGVuY2lsQnVmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9lbmdpbmU7XG4gICAgICAgICAgICAvLyBEaXNwb3NlIHByZXZpb3VzIGRlcHRoL3N0ZW5jaWwgcmVuZGVyIGJ1ZmZlcnMgYW5kIGNsZWFyIHRoZSBjb3JyZXNwb25kaW5nIGF0dGFjaG1lbnQuXG4gICAgICAgICAgICAvLyBOZXh0IHRpbWUgdGhpcyBmcmFtZWJ1ZmZlciBpcyBib3VuZCwgdGhlIG5ldyBkZXB0aC9zdGVuY2lsIHRleHR1cmUgd2lsbCBiZSBhdHRhY2hlZC5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZUJ1ZmZlciA9IGVuZ2luZS5fY3VycmVudEZyYW1lYnVmZmVyO1xuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICAgICAgZW5naW5lLl9iaW5kVW5ib3VuZEZyYW1lYnVmZmVyKHRoaXMuX2ZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICAgICAgICBlbmdpbmUuX2JpbmRVbmJvdW5kRnJhbWVidWZmZXIoY3VycmVudEZyYW1lQnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcih0aGlzLl9kZXB0aFN0ZW5jaWxCdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fZGVwdGhTdGVuY2lsQnVmZmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlRGVwdGhTdGVuY2lsVGV4dHVyZShjb21wYXJpc29uRnVuY3Rpb24sIGJpbGluZWFyRmlsdGVyaW5nLCBnZW5lcmF0ZVN0ZW5jaWwsIHNhbXBsZXMsIGZvcm1hdCwgbGFiZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGFyZXMgdGhlIGRlcHRoIGJ1ZmZlciBvZiB0aGlzIHJlbmRlciB0YXJnZXQgd2l0aCBhbm90aGVyIHJlbmRlciB0YXJnZXQuXG4gICAgICogQHBhcmFtIHJlbmRlclRhcmdldCBEZXN0aW5hdGlvbiByZW5kZXJUYXJnZXRcbiAgICAgKi9cbiAgICBzaGFyZURlcHRoKHJlbmRlclRhcmdldCkge1xuICAgICAgICBzdXBlci5zaGFyZURlcHRoKHJlbmRlclRhcmdldCk7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgY29uc3QgZGVwdGhidWZmZXIgPSB0aGlzLl9kZXB0aFN0ZW5jaWxCdWZmZXI7XG4gICAgICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0Ll9NU0FBRnJhbWVidWZmZXIgfHwgcmVuZGVyVGFyZ2V0Ll9mcmFtZWJ1ZmZlcjtcbiAgICAgICAgY29uc3QgZW5naW5lID0gdGhpcy5fZW5naW5lO1xuICAgICAgICBpZiAocmVuZGVyVGFyZ2V0Ll9kZXB0aFN0ZW5jaWxCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0Ll9kZXB0aFN0ZW5jaWxCdWZmZXIgIT09IGRlcHRoYnVmZmVyKSB7XG4gICAgICAgICAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0Ll9kZXB0aFN0ZW5jaWxCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlclRhcmdldC5fZGVwdGhTdGVuY2lsQnVmZmVyID0gZGVwdGhidWZmZXI7XG4gICAgICAgIGNvbnN0IGF0dGFjaG1lbnQgPSByZW5kZXJUYXJnZXQuX2dlbmVyYXRlU3RlbmNpbEJ1ZmZlciA/IGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA6IGdsLkRFUFRIX0FUVEFDSE1FTlQ7XG4gICAgICAgIGVuZ2luZS5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCBnbC5SRU5ERVJCVUZGRVIsIGRlcHRoYnVmZmVyKTtcbiAgICAgICAgZW5naW5lLl9iaW5kVW5ib3VuZEZyYW1lYnVmZmVyKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kcyBhIHRleHR1cmUgdG8gdGhpcyByZW5kZXIgdGFyZ2V0IG9uIGEgc3BlY2lmaWMgYXR0YWNobWVudFxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIFRoZSB0ZXh0dXJlIHRvIGJpbmQgdG8gdGhlIGZyYW1lYnVmZmVyXG4gICAgICogQHBhcmFtIGF0dGFjaG1lbnRJbmRleCBJbmRleCBvZiB0aGUgYXR0YWNobWVudFxuICAgICAqIEBwYXJhbSBmYWNlSW5kZXhPckxheWVyIFRoZSBmYWNlIG9yIGxheWVyIG9mIHRoZSB0ZXh0dXJlIHRvIHJlbmRlciB0byBpbiBjYXNlIG9mIGN1YmUgdGV4dHVyZSBvciBhcnJheSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGxvZExldmVsIGRlZmluZXMgdGhlIGxvZCBsZXZlbCB0byBiaW5kIHRvIHRoZSBmcmFtZSBidWZmZXJcbiAgICAgKi9cbiAgICBfYmluZFRleHR1cmVSZW5kZXJUYXJnZXQodGV4dHVyZSwgYXR0YWNobWVudEluZGV4ID0gMCwgZmFjZUluZGV4T3JMYXllciwgbG9kTGV2ZWwgPSAwKSB7XG4gICAgICAgIGNvbnN0IGhhcmR3YXJlVGV4dHVyZSA9IHRleHR1cmUuX2hhcmR3YXJlVGV4dHVyZTtcbiAgICAgICAgaWYgKCFoYXJkd2FyZVRleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IHRoaXMuX2ZyYW1lYnVmZmVyO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9lbmdpbmU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGYiA9IGVuZ2luZS5fY3VycmVudEZyYW1lYnVmZmVyO1xuICAgICAgICBlbmdpbmUuX2JpbmRVbmJvdW5kRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpO1xuICAgICAgICBsZXQgYXR0YWNobWVudDtcbiAgICAgICAgaWYgKGVuZ2luZS53ZWJHTFZlcnNpb24gPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgICAgICBhdHRhY2htZW50ID0gZ2xbXCJDT0xPUl9BVFRBQ0hNRU5UXCIgKyBhdHRhY2htZW50SW5kZXhdO1xuICAgICAgICAgICAgaWYgKHRleHR1cmUuaXMyREFycmF5IHx8IHRleHR1cmUuaXMzRCkge1xuICAgICAgICAgICAgICAgIGZhY2VJbmRleE9yTGF5ZXIgPSBmYWNlSW5kZXhPckxheWVyID8/IHRoaXMubGF5ZXJJbmRpY2VzPy5bYXR0YWNobWVudEluZGV4XSA/PyAwO1xuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKGdsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCBoYXJkd2FyZVRleHR1cmUudW5kZXJseWluZ1Jlc291cmNlLCBsb2RMZXZlbCwgZmFjZUluZGV4T3JMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0dXJlLmlzQ3ViZSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGZhY2UgaW5kZXggaXMgbm90IHNwZWNpZmllZCwgdHJ5IHRvIHF1ZXJ5IGl0IGZyb20gZmFjZUluZGljZXNcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGlzIGZhY2UgMFxuICAgICAgICAgICAgICAgIGZhY2VJbmRleE9yTGF5ZXIgPSBmYWNlSW5kZXhPckxheWVyID8/IHRoaXMuZmFjZUluZGljZXM/LlthdHRhY2htZW50SW5kZXhdID8/IDA7XG4gICAgICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnQsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGZhY2VJbmRleE9yTGF5ZXIsIGhhcmR3YXJlVGV4dHVyZS51bmRlcmx5aW5nUmVzb3VyY2UsIGxvZExldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCBnbC5URVhUVVJFXzJELCBoYXJkd2FyZVRleHR1cmUudW5kZXJseWluZ1Jlc291cmNlLCBsb2RMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIChXZWJHTClcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQgPSBnbFtcIkNPTE9SX0FUVEFDSE1FTlRcIiArIGF0dGFjaG1lbnRJbmRleCArIFwiX1dFQkdMXCJdO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZmFjZUluZGV4T3JMYXllciAhPT0gdW5kZWZpbmVkID8gZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgZmFjZUluZGV4T3JMYXllciA6IGdsLlRFWFRVUkVfMkQ7XG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgdGFyZ2V0LCBoYXJkd2FyZVRleHR1cmUudW5kZXJseWluZ1Jlc291cmNlLCBsb2RMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHR1cmUuX2F1dG9NU0FBTWFuYWdlbWVudCAmJiB0aGlzLl9NU0FBRnJhbWVidWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgICAgIGVuZ2luZS5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcih0aGlzLl9NU0FBRnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnQsIGdsLlJFTkRFUkJVRkZFUiwgaGFyZHdhcmVUZXh0dXJlLmdldE1TQUFSZW5kZXJCdWZmZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5naW5lLl9iaW5kVW5ib3VuZEZyYW1lYnVmZmVyKGN1cnJlbnRGYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIHRleHR1cmUgaW4gdGhlIHRleHR1cmVzIGFycmF5XG4gICAgICogQHBhcmFtIHRleHR1cmUgdGhlIHRleHR1cmUgdG8gc2V0XG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCBpbiB0aGUgdGV4dHVyZXMgYXJyYXkgdG8gc2V0XG4gICAgICogQHBhcmFtIGRpc3Bvc2VQcmV2aW91cyBJZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBkaXNwb3NlIHRoZSBwcmV2aW91cyB0ZXh0dXJlXG4gICAgICovXG4gICAgc2V0VGV4dHVyZSh0ZXh0dXJlLCBpbmRleCA9IDAsIGRpc3Bvc2VQcmV2aW91cyA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIuc2V0VGV4dHVyZSh0ZXh0dXJlLCBpbmRleCwgZGlzcG9zZVByZXZpb3VzKTtcbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVSZW5kZXJUYXJnZXQodGV4dHVyZSwgaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsYXllciBhbmQgZmFjZSBpbmRpY2VzIG9mIGV2ZXJ5IHJlbmRlciB0YXJnZXQgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBsYXllcnMgVGhlIGxheWVyIG9mIHRoZSB0ZXh0dXJlIHRvIGJlIHNldCAobWFrZSBuZWdhdGl2ZSB0byBub3QgbW9kaWZ5KVxuICAgICAqIEBwYXJhbSBmYWNlcyBUaGUgZmFjZSBvZiB0aGUgdGV4dHVyZSB0byBiZSBzZXQgKG1ha2UgbmVnYXRpdmUgdG8gbm90IG1vZGlmeSlcbiAgICAgKi9cbiAgICBzZXRMYXllckFuZEZhY2VJbmRpY2VzKGxheWVycywgZmFjZXMpIHtcbiAgICAgICAgc3VwZXIuc2V0TGF5ZXJBbmRGYWNlSW5kaWNlcyhsYXllcnMsIGZhY2VzKTtcbiAgICAgICAgaWYgKCF0aGlzLnRleHR1cmVzIHx8ICF0aGlzLmxheWVySW5kaWNlcyB8fCAhdGhpcy5mYWNlSW5kaWNlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBsZW5ndGggb2YgdGhpcy5fYXR0YWNobWVudHMgaXMgdGhlIHJpZ2h0IG9uZSBhcyBpdCBkb2VzIG5vdCBjb3VudCB0aGUgZGVwdGggdGV4dHVyZSwgaW4gY2FzZSB3ZSBnZW5lcmF0ZWQgaXRcbiAgICAgICAgY29uc3QgdGV4dHVyZUNvdW50ID0gdGhpcy5fYXR0YWNobWVudHM/Lmxlbmd0aCA/PyB0aGlzLnRleHR1cmVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRleHR1cmVDb3VudDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCB0eXBlIHdhcyBwcm9iYWJseSAtMSBhdCBjcmVhdGlvbiB0aW1lIGFuZCBzZXRUZXh0dXJlIGhhcyBub3QgYmVlbiBjYWxsZWQgeWV0IGZvciB0aGlzIGluZGV4XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGV4dHVyZS5pczJEQXJyYXkgfHwgdGV4dHVyZS5pczNEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmVSZW5kZXJUYXJnZXQodGV4dHVyZSwgaW5kZXgsIHRoaXMubGF5ZXJJbmRpY2VzW2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0dXJlLmlzQ3ViZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlUmVuZGVyVGFyZ2V0KHRleHR1cmUsIGluZGV4LCB0aGlzLmZhY2VJbmRpY2VzW2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZVJlbmRlclRhcmdldCh0ZXh0dXJlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmYWNlIGFuZCBsYXllciBpbmRpY2VzIG9mIGEgdGV4dHVyZSBpbiB0aGUgdGV4dHVyZXMgYXJyYXlcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0ZXh0dXJlIGluIHRoZSB0ZXh0dXJlcyBhcnJheSB0byBtb2RpZnlcbiAgICAgKiBAcGFyYW0gbGF5ZXIgVGhlIGxheWVyIG9mIHRoZSB0ZXh0dXJlIHRvIGJlIHNldFxuICAgICAqIEBwYXJhbSBmYWNlIFRoZSBmYWNlIG9mIHRoZSB0ZXh0dXJlIHRvIGJlIHNldFxuICAgICAqL1xuICAgIHNldExheWVyQW5kRmFjZUluZGV4KGluZGV4ID0gMCwgbGF5ZXIsIGZhY2UpIHtcbiAgICAgICAgc3VwZXIuc2V0TGF5ZXJBbmRGYWNlSW5kZXgoaW5kZXgsIGxheWVyLCBmYWNlKTtcbiAgICAgICAgaWYgKCF0aGlzLnRleHR1cmVzIHx8ICF0aGlzLmxheWVySW5kaWNlcyB8fCAhdGhpcy5mYWNlSW5kaWNlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmVzW2luZGV4XTtcbiAgICAgICAgaWYgKHRleHR1cmUuaXMyREFycmF5IHx8IHRleHR1cmUuaXMzRCkge1xuICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmVSZW5kZXJUYXJnZXQodGhpcy50ZXh0dXJlc1tpbmRleF0sIGluZGV4LCB0aGlzLmxheWVySW5kaWNlc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHR1cmUuaXNDdWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZVJlbmRlclRhcmdldCh0aGlzLnRleHR1cmVzW2luZGV4XSwgaW5kZXgsIHRoaXMuZmFjZUluZGljZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlTVNBQVRleHR1cmVzKCkge1xuICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9lbmdpbmU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZWJ1ZmZlciA9IGVuZ2luZS5fY3VycmVudEZyYW1lYnVmZmVyO1xuICAgICAgICBlbmdpbmUuX2JpbmRVbmJvdW5kRnJhbWVidWZmZXIodGhpcy5fTVNBQUZyYW1lYnVmZmVyKTtcbiAgICAgICAgc3VwZXIucmVzb2x2ZU1TQUFUZXh0dXJlcygpO1xuICAgICAgICBlbmdpbmUuX2JpbmRVbmJvdW5kRnJhbWVidWZmZXIoY3VycmVudEZyYW1lYnVmZmVyKTtcbiAgICB9XG4gICAgZGlzcG9zZShkaXNwb3NlT25seUZyYW1lYnVmZmVycyA9IHRoaXMuX2Rpc3Bvc2VPbmx5RnJhbWVidWZmZXJzKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgaWYgKCFkaXNwb3NlT25seUZyYW1lYnVmZmVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbG9yVGV4dHVyZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kZWxldGVUZXh0dXJlKHRoaXMuX2NvbG9yVGV4dHVyZUFycmF5KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvclRleHR1cmVBcnJheSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kZWxldGVUZXh0dXJlKHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmVBcnJheSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZUFycmF5ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZnJhbWVidWZmZXIpIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuX2ZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lYnVmZmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVwdGhTdGVuY2lsQnVmZmVyKSB7XG4gICAgICAgICAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIodGhpcy5fZGVwdGhTdGVuY2lsQnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoU3RlbmNpbEJ1ZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX01TQUFGcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5fTVNBQUZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX01TQUFGcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGlzcG9zZShkaXNwb3NlT25seUZyYW1lYnVmZmVycyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViR0xSZW5kZXJUYXJnZXRXcmFwcGVyLmpzLm1hcCIsIi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBXZWJHTFNoYWRlclByb2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2hhZGVyTGFuZ3VhZ2UgPSAwIC8qIFNoYWRlckxhbmd1YWdlLkdMU0wgKi87XG4gICAgfVxuICAgIHBvc3RQcm9jZXNzb3IoY29kZSwgZGVmaW5lcywgaXNGcmFnbWVudCwgcHJvY2Vzc2luZ0NvbnRleHQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV4dGVuc2lvbnNcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMuZHJhd0J1ZmZlcnNFeHRlbnNpb25EaXNhYmxlZCkge1xuICAgICAgICAgICAgLy8gZXZlbiBpZiBlbmNsb3NlZCBpbiAjaWYvI2VuZGlmLCBJRTExIGRvZXMgcGFyc2UgdGhlICNleHRlbnNpb24gZGVjbGFyYXRpb24sIHNvIHdlIG5lZWQgdG8gcmVtb3ZlIGl0IGFsdG9nZXRoZXJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gLyNleHRlbnNpb24uK0dMX0VYVF9kcmF3X2J1ZmZlcnMuKyhlbmFibGV8cmVxdWlyZSkvZztcbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmVnZXgsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYkdMU2hhZGVyUHJvY2Vzc29ycy5qcy5tYXAiLCJpbXBvcnQgeyBJc0RvY3VtZW50QXZhaWxhYmxlIH0gZnJvbSBcIi4uL01pc2MvZG9tTWFuYWdlbWVudC5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RFbmdpbmUgfSBmcm9tIFwiLi9hYnN0cmFjdEVuZ2luZS5qc1wiO1xuaW1wb3J0IHsgRW5naW5lU3RvcmUgfSBmcm9tIFwiLi9lbmdpbmVTdG9yZS5qc1wiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gRGlzYWJsZVRvdWNoQWN0aW9uKGNhbnZhcykge1xuICAgIGlmICghY2FudmFzIHx8ICFjYW52YXMuc2V0QXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIik7XG4gICAgY2FudmFzLnN0eWxlLnRvdWNoQWN0aW9uID0gXCJub25lXCI7XG4gICAgY2FudmFzLnN0eWxlLndlYmtpdFRhcEhpZ2hsaWdodENvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9Db21tb25Jbml0KGNvbW1vbkVuZ2luZSwgY2FudmFzLCBjcmVhdGlvbk9wdGlvbnMpIHtcbiAgICBjb21tb25FbmdpbmUuX29uQ2FudmFzRm9jdXMgPSAoKSA9PiB7XG4gICAgICAgIGNvbW1vbkVuZ2luZS5vbkNhbnZhc0ZvY3VzT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoY29tbW9uRW5naW5lKTtcbiAgICB9O1xuICAgIGNvbW1vbkVuZ2luZS5fb25DYW52YXNCbHVyID0gKCkgPT4ge1xuICAgICAgICBjb21tb25FbmdpbmUub25DYW52YXNCbHVyT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoY29tbW9uRW5naW5lKTtcbiAgICB9O1xuICAgIGNvbW1vbkVuZ2luZS5fb25DYW52YXNDb250ZXh0TWVudSA9IChldnQpID0+IHtcbiAgICAgICAgaWYgKGNvbW1vbkVuZ2luZS5kaXNhYmxlQ29udGV4dE1lbnUpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGNvbW1vbkVuZ2luZS5fb25DYW52YXNGb2N1cyk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGNvbW1vbkVuZ2luZS5fb25DYW52YXNCbHVyKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIGNvbW1vbkVuZ2luZS5fb25DYW52YXNDb250ZXh0TWVudSk7XG4gICAgY29tbW9uRW5naW5lLl9vbkJsdXIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjb21tb25FbmdpbmUuZGlzYWJsZVBlcmZvcm1hbmNlTW9uaXRvckluQmFja2dyb3VuZCkge1xuICAgICAgICAgICAgY29tbW9uRW5naW5lLnBlcmZvcm1hbmNlTW9uaXRvci5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbW9uRW5naW5lLl93aW5kb3dJc0JhY2tncm91bmQgPSB0cnVlO1xuICAgIH07XG4gICAgY29tbW9uRW5naW5lLl9vbkZvY3VzID0gKCkgPT4ge1xuICAgICAgICBpZiAoY29tbW9uRW5naW5lLmRpc2FibGVQZXJmb3JtYW5jZU1vbml0b3JJbkJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIGNvbW1vbkVuZ2luZS5wZXJmb3JtYW5jZU1vbml0b3IuZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbW9uRW5naW5lLl93aW5kb3dJc0JhY2tncm91bmQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbW1vbkVuZ2luZS5fb25DYW52YXNQb2ludGVyT3V0ID0gKGV2KSA9PiB7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGVsZW1lbnQgYXQgdGhlIHBvaW50IG9mIHRoZSBwb2ludGVyIG91dCBpc24ndCB0aGUgY2FudmFzIGFuZCBpZiBpdCBpc24ndCwgbm90aWZ5IG9ic2VydmVyc1xuICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgYSBidWcgd2l0aCBTYWZhcmlcbiAgICAgICAgaWYgKGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXYuY2xpZW50WCwgZXYuY2xpZW50WSkgIT09IGNhbnZhcykge1xuICAgICAgICAgICAgY29tbW9uRW5naW5lLm9uQ2FudmFzUG9pbnRlck91dE9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaG9zdFdpbmRvdyA9IGNvbW1vbkVuZ2luZS5nZXRIb3N0V2luZG93KCk7IC8vIGl0IGNhbGxzIElzV2luZG93T2JqZWN0RXhpc3QoKVxuICAgIGlmIChob3N0V2luZG93ICYmIHR5cGVvZiBob3N0V2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBob3N0V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGNvbW1vbkVuZ2luZS5fb25CbHVyKTtcbiAgICAgICAgaG9zdFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgY29tbW9uRW5naW5lLl9vbkZvY3VzKTtcbiAgICB9XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyb3V0XCIsIGNvbW1vbkVuZ2luZS5fb25DYW52YXNQb2ludGVyT3V0KTtcbiAgICBpZiAoIWNyZWF0aW9uT3B0aW9ucy5kb05vdEhhbmRsZVRvdWNoQWN0aW9uKSB7XG4gICAgICAgIERpc2FibGVUb3VjaEFjdGlvbihjYW52YXMpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgQXVkaW8gRW5naW5lIGlmIG5lZWRlZC5cbiAgICBpZiAoIUFic3RyYWN0RW5naW5lLmF1ZGlvRW5naW5lICYmIGNyZWF0aW9uT3B0aW9ucy5hdWRpb0VuZ2luZSAmJiBBYnN0cmFjdEVuZ2luZS5BdWRpb0VuZ2luZUZhY3RvcnkpIHtcbiAgICAgICAgQWJzdHJhY3RFbmdpbmUuYXVkaW9FbmdpbmUgPSBBYnN0cmFjdEVuZ2luZS5BdWRpb0VuZ2luZUZhY3RvcnkoY29tbW9uRW5naW5lLmdldFJlbmRlcmluZ0NhbnZhcygpLCBjb21tb25FbmdpbmUuZ2V0QXVkaW9Db250ZXh0KCksIGNvbW1vbkVuZ2luZS5nZXRBdWRpb0Rlc3RpbmF0aW9uKCkpO1xuICAgIH1cbiAgICBpZiAoSXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgIC8vIEZ1bGxzY3JlZW5cbiAgICAgICAgY29tbW9uRW5naW5lLl9vbkZ1bGxzY3JlZW5DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb21tb25FbmdpbmUuaXNGdWxsc2NyZWVuID0gISFkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudDtcbiAgICAgICAgICAgIC8vIFBvaW50ZXIgbG9ja1xuICAgICAgICAgICAgaWYgKGNvbW1vbkVuZ2luZS5pc0Z1bGxzY3JlZW4gJiYgY29tbW9uRW5naW5lLl9wb2ludGVyTG9ja1JlcXVlc3RlZCAmJiBjYW52YXMpIHtcbiAgICAgICAgICAgICAgICBSZXF1ZXN0UG9pbnRlcmxvY2soY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgY29tbW9uRW5naW5lLl9vbkZ1bGxzY3JlZW5DaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIiwgY29tbW9uRW5naW5lLl9vbkZ1bGxzY3JlZW5DaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgLy8gUG9pbnRlciBsb2NrXG4gICAgICAgIGNvbW1vbkVuZ2luZS5fb25Qb2ludGVyTG9ja0NoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbW1vbkVuZ2luZS5pc1BvaW50ZXJMb2NrID0gZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50ID09PSBjYW52YXM7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybG9ja2NoYW5nZVwiLCBjb21tb25FbmdpbmUuX29uUG9pbnRlckxvY2tDaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdHBvaW50ZXJsb2NrY2hhbmdlXCIsIGNvbW1vbkVuZ2luZS5fb25Qb2ludGVyTG9ja0NoYW5nZSwgZmFsc2UpO1xuICAgIH1cbiAgICBjb21tb25FbmdpbmUuZW5hYmxlT2ZmbGluZVN1cHBvcnQgPSBBYnN0cmFjdEVuZ2luZS5PZmZsaW5lUHJvdmlkZXJGYWN0b3J5ICE9PSB1bmRlZmluZWQ7XG4gICAgY29tbW9uRW5naW5lLl9kZXRlcm1pbmlzdGljTG9ja3N0ZXAgPSAhIWNyZWF0aW9uT3B0aW9ucy5kZXRlcm1pbmlzdGljTG9ja3N0ZXA7XG4gICAgY29tbW9uRW5naW5lLl9sb2Nrc3RlcE1heFN0ZXBzID0gY3JlYXRpb25PcHRpb25zLmxvY2tzdGVwTWF4U3RlcHMgfHwgMDtcbiAgICBjb21tb25FbmdpbmUuX3RpbWVTdGVwID0gY3JlYXRpb25PcHRpb25zLnRpbWVTdGVwIHx8IDEgLyA2MDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBfQ29tbW9uRGlzcG9zZShjb21tb25FbmdpbmUsIGNhbnZhcykge1xuICAgIC8vIFJlbGVhc2UgYXVkaW8gZW5naW5lXG4gICAgaWYgKEVuZ2luZVN0b3JlLkluc3RhbmNlcy5sZW5ndGggPT09IDEgJiYgQWJzdHJhY3RFbmdpbmUuYXVkaW9FbmdpbmUpIHtcbiAgICAgICAgQWJzdHJhY3RFbmdpbmUuYXVkaW9FbmdpbmUuZGlzcG9zZSgpO1xuICAgICAgICBBYnN0cmFjdEVuZ2luZS5hdWRpb0VuZ2luZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIEV2ZW50c1xuICAgIGNvbnN0IGhvc3RXaW5kb3cgPSBjb21tb25FbmdpbmUuZ2V0SG9zdFdpbmRvdygpOyAvLyBpdCBjYWxscyBJc1dpbmRvd09iamVjdEV4aXN0KClcbiAgICBpZiAoaG9zdFdpbmRvdyAmJiB0eXBlb2YgaG9zdFdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaG9zdFdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBjb21tb25FbmdpbmUuX29uQmx1cik7XG4gICAgICAgIGhvc3RXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGNvbW1vbkVuZ2luZS5fb25Gb2N1cyk7XG4gICAgfVxuICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBjb21tb25FbmdpbmUuX29uQ2FudmFzRm9jdXMpO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgY29tbW9uRW5naW5lLl9vbkNhbnZhc0JsdXIpO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJvdXRcIiwgY29tbW9uRW5naW5lLl9vbkNhbnZhc1BvaW50ZXJPdXQpO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIGNvbW1vbkVuZ2luZS5fb25DYW52YXNDb250ZXh0TWVudSk7XG4gICAgfVxuICAgIGlmIChJc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgY29tbW9uRW5naW5lLl9vbkZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLCBjb21tb25FbmdpbmUuX29uRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsIGNvbW1vbkVuZ2luZS5fb25GdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1zZnVsbHNjcmVlbmNoYW5nZVwiLCBjb21tb25FbmdpbmUuX29uRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybG9ja2NoYW5nZVwiLCBjb21tb25FbmdpbmUuX29uUG9pbnRlckxvY2tDaGFuZ2UpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibXNwb2ludGVybG9ja2NoYW5nZVwiLCBjb21tb25FbmdpbmUuX29uUG9pbnRlckxvY2tDaGFuZ2UpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW96cG9pbnRlcmxvY2tjaGFuZ2VcIiwgY29tbW9uRW5naW5lLl9vblBvaW50ZXJMb2NrQ2hhbmdlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmtpdHBvaW50ZXJsb2NrY2hhbmdlXCIsIGNvbW1vbkVuZ2luZS5fb25Qb2ludGVyTG9ja0NoYW5nZSk7XG4gICAgfVxufVxuLyoqXG4gKiBHZXQgRm9udCBzaXplIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0gZm9udCBmb250IG5hbWVcbiAqIEByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGFzY2VudCwgaGVpZ2h0IGFuZCBkZXNjZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRGb250T2Zmc2V0KGZvbnQpIHtcbiAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdGV4dC50ZXh0Q29udGVudCA9IFwiSGdcIjtcbiAgICB0ZXh0LnN0eWxlLmZvbnQgPSBmb250O1xuICAgIGNvbnN0IGJsb2NrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBibG9jay5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICBibG9jay5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XG4gICAgYmxvY2suc3R5bGUuaGVpZ2h0ID0gXCIwcHhcIjtcbiAgICBibG9jay5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJib3R0b21cIjtcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS53aGl0ZVNwYWNlID0gXCJub3dyYXBcIjtcbiAgICBkaXYuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGJsb2NrKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgbGV0IGZvbnRBc2NlbnQgPSAwO1xuICAgIGxldCBmb250SGVpZ2h0ID0gMDtcbiAgICB0cnkge1xuICAgICAgICBmb250SGVpZ2h0ID0gYmxvY2suZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gdGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgIGJsb2NrLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcImJhc2VsaW5lXCI7XG4gICAgICAgIGZvbnRBc2NlbnQgPSBibG9jay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSB0ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgYXNjZW50OiBmb250QXNjZW50LCBoZWlnaHQ6IGZvbnRIZWlnaHQsIGRlc2NlbnQ6IGZvbnRIZWlnaHQgLSBmb250QXNjZW50IH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gQ3JlYXRlSW1hZ2VCaXRtYXBGcm9tU291cmNlKGVuZ2luZSwgaW1hZ2VTb3VyY2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpbWFnZS5kZWNvZGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBlbmdpbmUuY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2UsIG9wdGlvbnMpLnRoZW4oKGltYWdlQml0bWFwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW1hZ2VCaXRtYXApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGltYWdlLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoYEVycm9yIGxvYWRpbmcgaW1hZ2UgJHtpbWFnZS5zcmN9YCk7XG4gICAgICAgIH07XG4gICAgICAgIGltYWdlLnNyYyA9IGltYWdlU291cmNlO1xuICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlc2l6ZUltYWdlQml0bWFwKGVuZ2luZSwgaW1hZ2UsIGJ1ZmZlcldpZHRoLCBidWZmZXJIZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBlbmdpbmUuY3JlYXRlQ2FudmFzKGJ1ZmZlcldpZHRoLCBidWZmZXJIZWlnaHQpO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZ2V0IDJkIGNvbnRleHQgZm9yIHJlc2l6ZUltYWdlQml0bWFwXCIpO1xuICAgIH1cbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgLy8gQ3JlYXRlIFZlcnRleERhdGEgZnJvbSBtYXAgZGF0YVxuICAgIC8vIENhc3QgaXMgZHVlIHRvIHdyb25nIGRlZmluaXRpb24gaW4gbGliLmQudHMgZnJvbSB0cyAxLjMgLSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzk0OVxuICAgIGNvbnN0IGJ1ZmZlciA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGJ1ZmZlcldpZHRoLCBidWZmZXJIZWlnaHQpLmRhdGE7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8qKlxuICogQXNrIHRoZSBicm93c2VyIHRvIHByb21vdGUgdGhlIGN1cnJlbnQgZWxlbWVudCB0byBmdWxsc2NyZWVuIHJlbmRlcmluZyBtb2RlXG4gKiBAcGFyYW0gZWxlbWVudCBkZWZpbmVzIHRoZSBET00gZWxlbWVudCB0byBwcm9tb3RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZXF1ZXN0RnVsbHNjcmVlbihlbGVtZW50KSB7XG4gICAgY29uc3QgcmVxdWVzdEZ1bmN0aW9uID0gZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbiB8fCBlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuO1xuICAgIGlmICghcmVxdWVzdEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVxdWVzdEZ1bmN0aW9uLmNhbGwoZWxlbWVudCk7XG59XG4vKipcbiAqIEFza3MgdGhlIGJyb3dzZXIgdG8gZXhpdCBmdWxsc2NyZWVuIG1vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEV4aXRGdWxsc2NyZWVuKCkge1xuICAgIGNvbnN0IGFueURvYyA9IGRvY3VtZW50O1xuICAgIGlmIChkb2N1bWVudC5leGl0RnVsbHNjcmVlbikge1xuICAgICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhbnlEb2Mud2Via2l0Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgICAgICBhbnlEb2Mud2Via2l0Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgIH1cbn1cbi8qKlxuICogQXNrIHRoZSBicm93c2VyIHRvIHByb21vdGUgdGhlIGN1cnJlbnQgZWxlbWVudCB0byBwb2ludGVybG9jayBtb2RlXG4gKiBAcGFyYW0gZWxlbWVudCBkZWZpbmVzIHRoZSBET00gZWxlbWVudCB0byBwcm9tb3RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZXF1ZXN0UG9pbnRlcmxvY2soZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LnJlcXVlc3RQb2ludGVyTG9jaykge1xuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCByZXF1ZXN0UG9pbnRlckxvY2sgcmV0dXJucyBhIHByb21pc2UuXG4gICAgICAgIC8vIEhhbmRsZSBwb3NzaWJsZSByZWplY3Rpb25zIHRvIGF2b2lkIGFuIHVuaGFuZGxlZCB0b3AtbGV2ZWwgZXhjZXB0aW9uLlxuICAgICAgICBjb25zdCBwcm9taXNlID0gZWxlbWVudC5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFza3MgdGhlIGJyb3dzZXIgdG8gZXhpdCBwb2ludGVybG9jayBtb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBFeGl0UG9pbnRlcmxvY2soKSB7XG4gICAgaWYgKGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaykge1xuICAgICAgICBkb2N1bWVudC5leGl0UG9pbnRlckxvY2soKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmdpbmUuY29tbW9uLmpzLm1hcCIsImltcG9ydCB7IEludGVybmFsVGV4dHVyZSB9IGZyb20gXCIuLi9NYXRlcmlhbHMvVGV4dHVyZXMvaW50ZXJuYWxUZXh0dXJlLmpzXCI7XG5pbXBvcnQgeyBFbmdpbmVTdG9yZSB9IGZyb20gXCIuL2VuZ2luZVN0b3JlLmpzXCI7XG5pbXBvcnQgeyBUaGluRW5naW5lIH0gZnJvbSBcIi4vdGhpbkVuZ2luZS5qc1wiO1xuXG5pbXBvcnQgeyBQZXJmb3JtYW5jZU1vbml0b3IgfSBmcm9tIFwiLi4vTWlzYy9wZXJmb3JtYW5jZU1vbml0b3IuanNcIjtcbmltcG9ydCB7IFdlYkdMRGF0YUJ1ZmZlciB9IGZyb20gXCIuLi9NZXNoZXMvV2ViR0wvd2ViR0xEYXRhQnVmZmVyLmpzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vTWlzYy9sb2dnZXIuanNcIjtcbmltcG9ydCB7IFdlYkdMSGFyZHdhcmVUZXh0dXJlIH0gZnJvbSBcIi4vV2ViR0wvd2ViR0xIYXJkd2FyZVRleHR1cmUuanNcIjtcbmltcG9ydCBcIi4vRXh0ZW5zaW9ucy9lbmdpbmUuYWxwaGEuanNcIjtcbmltcG9ydCBcIi4vRXh0ZW5zaW9ucy9lbmdpbmUucmF3VGV4dHVyZS5qc1wiO1xuaW1wb3J0IFwiLi9FeHRlbnNpb25zL2VuZ2luZS5yZWFkVGV4dHVyZS5qc1wiO1xuaW1wb3J0IFwiLi9FeHRlbnNpb25zL2VuZ2luZS5keW5hbWljQnVmZmVyLmpzXCI7XG5pbXBvcnQgXCIuL0V4dGVuc2lvbnMvZW5naW5lLmN1YmVUZXh0dXJlLmpzXCI7XG5pbXBvcnQgXCIuL0V4dGVuc2lvbnMvZW5naW5lLnJlbmRlclRhcmdldC5qc1wiO1xuaW1wb3J0IFwiLi9FeHRlbnNpb25zL2VuZ2luZS5yZW5kZXJUYXJnZXRUZXh0dXJlLmpzXCI7XG5pbXBvcnQgXCIuL0V4dGVuc2lvbnMvZW5naW5lLnJlbmRlclRhcmdldEN1YmUuanNcIjtcbmltcG9ydCBcIi4vRXh0ZW5zaW9ucy9lbmdpbmUucHJlZmlsdGVyZWRDdWJlVGV4dHVyZS5qc1wiO1xuaW1wb3J0IFwiLi9FeHRlbnNpb25zL2VuZ2luZS51bmlmb3JtQnVmZmVyLmpzXCI7XG5pbXBvcnQgXCIuL0Fic3RyYWN0RW5naW5lL2Fic3RyYWN0RW5naW5lLmxvYWRpbmdTY3JlZW4uanNcIjtcbmltcG9ydCBcIi4vQWJzdHJhY3RFbmdpbmUvYWJzdHJhY3RFbmdpbmUuZG9tLmpzXCI7XG5pbXBvcnQgXCIuL0Fic3RyYWN0RW5naW5lL2Fic3RyYWN0RW5naW5lLnN0YXRlcy5qc1wiO1xuaW1wb3J0IFwiLi9BYnN0cmFjdEVuZ2luZS9hYnN0cmFjdEVuZ2luZS5yZW5kZXJQYXNzLmpzXCI7XG5pbXBvcnQgXCIuL0Fic3RyYWN0RW5naW5lL2Fic3RyYWN0RW5naW5lLnRleHR1cmUuanNcIjtcbmltcG9ydCB7IEFic3RyYWN0RW5naW5lIH0gZnJvbSBcIi4vYWJzdHJhY3RFbmdpbmUuanNcIjtcbmltcG9ydCB7IENyZWF0ZUltYWdlQml0bWFwRnJvbVNvdXJjZSwgRXhpdEZ1bGxzY3JlZW4sIEV4aXRQb2ludGVybG9jaywgR2V0Rm9udE9mZnNldCwgUmVxdWVzdEZ1bGxzY3JlZW4sIFJlcXVlc3RQb2ludGVybG9jaywgUmVzaXplSW1hZ2VCaXRtYXAsIF9Db21tb25EaXNwb3NlLCBfQ29tbW9uSW5pdCwgfSBmcm9tIFwiLi9lbmdpbmUuY29tbW9uLmpzXCI7XG5pbXBvcnQgeyBQZXJmQ291bnRlciB9IGZyb20gXCIuLi9NaXNjL3BlcmZDb3VudGVyLmpzXCI7XG5pbXBvcnQgeyBfUmV0cnlXaXRoSW50ZXJ2YWwgfSBmcm9tIFwiLi4vTWlzYy90aW1pbmdUb29scy5qc1wiO1xuLyoqXG4gKiBUaGUgZW5naW5lIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBpbnRlcmZhY2luZyB3aXRoIGFsbCBsb3dlci1sZXZlbCBBUElzIHN1Y2ggYXMgV2ViR0wgYW5kIEF1ZGlvXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmdpbmUgZXh0ZW5kcyBUaGluRW5naW5lIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5wbSBwYWNrYWdlIG9mIHRoZSBzZGtcbiAgICAgKi9cbiAgICAvLyBOb3QgbWl4ZWQgd2l0aCBWZXJzaW9uIGZvciB0b29saW5nIHB1cnBvc2UuXG4gICAgc3RhdGljIGdldCBOcG1QYWNrYWdlKCkge1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RFbmdpbmUuTnBtUGFja2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIHRoZSBmcmFtZXdvcmtcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiBBYnN0cmFjdEVuZ2luZS5WZXJzaW9uO1xuICAgIH1cbiAgICAvKiogR2V0cyB0aGUgbGlzdCBvZiBjcmVhdGVkIGVuZ2luZXMgKi9cbiAgICBzdGF0aWMgZ2V0IEluc3RhbmNlcygpIHtcbiAgICAgICAgcmV0dXJuIEVuZ2luZVN0b3JlLkluc3RhbmNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGF0ZXN0IGNyZWF0ZWQgZW5naW5lXG4gICAgICovXG4gICAgc3RhdGljIGdldCBMYXN0Q3JlYXRlZEVuZ2luZSgpIHtcbiAgICAgICAgcmV0dXJuIEVuZ2luZVN0b3JlLkxhc3RDcmVhdGVkRW5naW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXRlc3QgY3JlYXRlZCBzY2VuZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTGFzdENyZWF0ZWRTY2VuZSgpIHtcbiAgICAgICAgcmV0dXJuIEVuZ2luZVN0b3JlLkxhc3RDcmVhdGVkU2NlbmU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1yZXR1cm5zLWNoZWNrXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGNhbGxlZCB0byBjcmVhdGUgdGhlIGRlZmF1bHQgbG9hZGluZyBzY3JlZW4uXG4gICAgICogVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBpbiB5b3VyIG93biBhcHAuXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgcmVuZGVyaW5nIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHJldHVybnMgVGhlIGxvYWRpbmcgc2NyZWVuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHN0YXRpYyBEZWZhdWx0TG9hZGluZ1NjcmVlbkZhY3RvcnkoY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBBYnN0cmFjdEVuZ2luZS5EZWZhdWx0TG9hZGluZ1NjcmVlbkZhY3RvcnkoY2FudmFzKTtcbiAgICB9XG4gICAgZ2V0IF9zdXBwb3J0c0hhcmR3YXJlVGV4dHVyZVJlc2NhbGluZygpIHtcbiAgICAgICAgcmV0dXJuICEhRW5naW5lLl9SZXNjYWxlUG9zdFByb2Nlc3NGYWN0b3J5O1xuICAgIH1cbiAgICBfbWVhc3VyZUZwcygpIHtcbiAgICAgICAgdGhpcy5fcGVyZm9ybWFuY2VNb25pdG9yLnNhbXBsZUZyYW1lKCk7XG4gICAgICAgIHRoaXMuX2ZwcyA9IHRoaXMuX3BlcmZvcm1hbmNlTW9uaXRvci5hdmVyYWdlRlBTO1xuICAgICAgICB0aGlzLl9kZWx0YVRpbWUgPSB0aGlzLl9wZXJmb3JtYW5jZU1vbml0b3IuaW5zdGFudGFuZW91c0ZyYW1lVGltZSB8fCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwZXJmb3JtYW5jZSBtb25pdG9yIGF0dGFjaGVkIHRvIHRoaXMgZW5naW5lXG4gICAgICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL2ZlYXR1cmVzL2ZlYXR1cmVzRGVlcERpdmUvc2NlbmUvb3B0aW1pemVfeW91cl9zY2VuZSNlbmdpbmVpbnN0cnVtZW50YXRpb25cbiAgICAgKi9cbiAgICBnZXQgcGVyZm9ybWFuY2VNb25pdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybWFuY2VNb25pdG9yO1xuICAgIH1cbiAgICAvLyBFdmVudHNcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGVuZ2luZVxuICAgICAqIEBwYXJhbSBjYW52YXNPckNvbnRleHQgZGVmaW5lcyB0aGUgY2FudmFzIG9yIFdlYkdMIGNvbnRleHQgdG8gdXNlIGZvciByZW5kZXJpbmcuIElmIHlvdSBwcm92aWRlIGEgV2ViR0wgY29udGV4dCwgQmFieWxvbi5qcyB3aWxsIG5vdCBob29rIGV2ZW50cyBvbiB0aGUgY2FudmFzIChsaWtlIHBvaW50ZXJzLCBrZXlib2FyZHMsIGV0Yy4uLikgc28gbm8gZXZlbnQgb2JzZXJ2YWJsZXMgd2lsbCBiZSBhdmFpbGFibGUuIFRoaXMgaXMgbW9zdGx5IHVzZWQgd2hlbiBCYWJ5bG9uLmpzIGlzIHVzZWQgYXMgYSBwbHVnaW4gb24gYSBzeXN0ZW0gd2hpY2ggYWxyZWFkeSB1c2VkIHRoZSBXZWJHTCBjb250ZXh0XG4gICAgICogQHBhcmFtIGFudGlhbGlhcyBkZWZpbmVzIGVuYWJsZSBhbnRpYWxpYXNpbmcgKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAqIEBwYXJhbSBvcHRpb25zIGRlZmluZXMgZnVydGhlciBvcHRpb25zIHRvIGJlIHNlbnQgdG8gdGhlIGdldENvbnRleHQoKSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBhZGFwdFRvRGV2aWNlUmF0aW8gZGVmaW5lcyB3aGV0aGVyIHRvIGFkYXB0IHRvIHRoZSBkZXZpY2UncyB2aWV3cG9ydCBjaGFyYWN0ZXJpc3RpY3MgKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhc09yQ29udGV4dCwgYW50aWFsaWFzLCBvcHRpb25zLCBhZGFwdFRvRGV2aWNlUmF0aW8gPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihjYW52YXNPckNvbnRleHQsIGFudGlhbGlhcywgb3B0aW9ucywgYWRhcHRUb0RldmljZVJhdGlvKTtcbiAgICAgICAgLy8gTWVtYmVyc1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0LCB3aWxsIGJlIHVzZWQgdG8gcmVxdWVzdCB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUgZm9yIHRoZSByZW5kZXIgbG9vcFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXN0b21BbmltYXRpb25GcmFtZVJlcXVlc3RlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BlcmZvcm1hbmNlTW9uaXRvciA9IG5ldyBQZXJmb3JtYW5jZU1vbml0b3IoKTtcbiAgICAgICAgdGhpcy5fZHJhd0NhbGxzID0gbmV3IFBlcmZDb3VudGVyKCk7XG4gICAgICAgIGlmICghY2FudmFzT3JDb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmVhdHVyZXMuc3VwcG9ydFJlbmRlclBhc3NlcyA9IHRydWU7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9jcmVhdGlvbk9wdGlvbnM7XG4gICAgfVxuICAgIF9pbml0R0xDb250ZXh0KCkge1xuICAgICAgICBzdXBlci5faW5pdEdMQ29udGV4dCgpO1xuICAgICAgICB0aGlzLl9yZXNjYWxlUG9zdFByb2Nlc3MgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGFyZWQgaW5pdGlhbGl6YXRpb24gYWNyb3NzIGVuZ2luZXMgdHlwZXMuXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgY2FudmFzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlIG9mIHRoZSBlbmdpbmUuXG4gICAgICovXG4gICAgX3NoYXJlZEluaXQoY2FudmFzKSB7XG4gICAgICAgIHN1cGVyLl9zaGFyZWRJbml0KGNhbnZhcyk7XG4gICAgICAgIF9Db21tb25Jbml0KHRoaXMsIGNhbnZhcywgdGhpcy5fY3JlYXRpb25PcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzaXplIGFuIGltYWdlIGFuZCByZXR1cm5zIHRoZSBpbWFnZSBkYXRhIGFzIGFuIHVpbnQ4YXJyYXlcbiAgICAgKiBAcGFyYW0gaW1hZ2UgaW1hZ2UgdG8gcmVzaXplXG4gICAgICogQHBhcmFtIGJ1ZmZlcldpZHRoIGRlc3RpbmF0aW9uIGJ1ZmZlciB3aWR0aFxuICAgICAqIEBwYXJhbSBidWZmZXJIZWlnaHQgZGVzdGluYXRpb24gYnVmZmVyIGhlaWdodFxuICAgICAqIEByZXR1cm5zIGFuIHVpbnQ4YXJyYXkgY29udGFpbmluZyBSR0JBIHZhbHVlcyBvZiBidWZmZXJXaWR0aCAqIGJ1ZmZlckhlaWdodCBzaXplXG4gICAgICovXG4gICAgcmVzaXplSW1hZ2VCaXRtYXAoaW1hZ2UsIGJ1ZmZlcldpZHRoLCBidWZmZXJIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFJlc2l6ZUltYWdlQml0bWFwKHRoaXMsIGltYWdlLCBidWZmZXJXaWR0aCwgYnVmZmVySGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5naW5lIGFic3RyYWN0aW9uIGZvciBsb2FkaW5nIGFuZCBjcmVhdGluZyBhbiBpbWFnZSBiaXRtYXAgZnJvbSBhIGdpdmVuIHNvdXJjZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIGltYWdlU291cmNlIHNvdXJjZSB0byBsb2FkIHRoZSBpbWFnZSBmcm9tLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFuIG9iamVjdCB0aGF0IHNldHMgb3B0aW9ucyBmb3IgdGhlIGltYWdlJ3MgZXh0cmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBJbWFnZUJpdG1hcFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBhc3luYyBfY3JlYXRlSW1hZ2VCaXRtYXBGcm9tU291cmNlKGltYWdlU291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBDcmVhdGVJbWFnZUJpdG1hcEZyb21Tb3VyY2UodGhpcywgaW1hZ2VTb3VyY2UsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgZnVsbCBzY3JlZW4gbW9kZVxuICAgICAqIEBwYXJhbSByZXF1ZXN0UG9pbnRlckxvY2sgZGVmaW5lcyBpZiBhIHBvaW50ZXIgbG9jayBzaG91bGQgYmUgcmVxdWVzdGVkIGZyb20gdGhlIHVzZXJcbiAgICAgKi9cbiAgICBzd2l0Y2hGdWxsc2NyZWVuKHJlcXVlc3RQb2ludGVyTG9jaykge1xuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIHRoaXMuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJGdWxsc2NyZWVuKHJlcXVlc3RQb2ludGVyTG9jayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW50ZXJzIGZ1bGwgc2NyZWVuIG1vZGVcbiAgICAgKiBAcGFyYW0gcmVxdWVzdFBvaW50ZXJMb2NrIGRlZmluZXMgaWYgYSBwb2ludGVyIGxvY2sgc2hvdWxkIGJlIHJlcXVlc3RlZCBmcm9tIHRoZSB1c2VyXG4gICAgICovXG4gICAgZW50ZXJGdWxsc2NyZWVuKHJlcXVlc3RQb2ludGVyTG9jaykge1xuICAgICAgICBpZiAoIXRoaXMuaXNGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludGVyTG9ja1JlcXVlc3RlZCA9IHJlcXVlc3RQb2ludGVyTG9jaztcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJpbmdDYW52YXMpIHtcbiAgICAgICAgICAgICAgICBSZXF1ZXN0RnVsbHNjcmVlbih0aGlzLl9yZW5kZXJpbmdDYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4aXRzIGZ1bGwgc2NyZWVuIG1vZGVcbiAgICAgKi9cbiAgICBleGl0RnVsbHNjcmVlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICBFeGl0RnVsbHNjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTdGF0ZXMgKi9cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBkaXRoZXJpbmcgc3RhdGUgaXMgZW5hYmxlZCBvciBkaXNhYmxlZFxuICAgICAqIEBwYXJhbSB2YWx1ZSBkZWZpbmVzIHRoZSBkaXRoZXJpbmcgc3RhdGVcbiAgICAgKi9cbiAgICBzZXREaXRoZXJpbmdTdGF0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLmVuYWJsZSh0aGlzLl9nbC5ESVRIRVIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2wuZGlzYWJsZSh0aGlzLl9nbC5ESVRIRVIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIHJhc3Rlcml6ZXIgc3RhdGUgaXMgZW5hYmxlZCBvciBkaXNhYmxlZFxuICAgICAqIEBwYXJhbSB2YWx1ZSBkZWZpbmVzIHRoZSByYXN0ZXJpemVyIHN0YXRlXG4gICAgICovXG4gICAgc2V0UmFzdGVyaXplclN0YXRlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZ2wuZGlzYWJsZSh0aGlzLl9nbC5SQVNURVJJWkVSX0RJU0NBUkQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2wuZW5hYmxlKHRoaXMuX2dsLlJBU1RFUklaRVJfRElTQ0FSRCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlyZWN0bHkgc2V0IHRoZSBXZWJHTCBWaWV3cG9ydFxuICAgICAqIEBwYXJhbSB4IGRlZmluZXMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgdmlld3BvcnQgKGluIHNjcmVlbiBzcGFjZSlcbiAgICAgKiBAcGFyYW0geSBkZWZpbmVzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHZpZXdwb3J0IChpbiBzY3JlZW4gc3BhY2UpXG4gICAgICogQHBhcmFtIHdpZHRoIGRlZmluZXMgdGhlIHdpZHRoIG9mIHRoZSB2aWV3cG9ydCAoaW4gc2NyZWVuIHNwYWNlKVxuICAgICAqIEBwYXJhbSBoZWlnaHQgZGVmaW5lcyB0aGUgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydCAoaW4gc2NyZWVuIHNwYWNlKVxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHZpZXdwb3J0IE9iamVjdCAoaWYgYW55KSB0aGF0IGlzIGJlaW5nIHJlcGxhY2VkIGJ5IHRoaXMgY2FsbC4gWW91IGNhbiByZXN0b3JlIHRoaXMgdmlld3BvcnQgbGF0ZXIgb24gdG8gZ28gYmFjayB0byB0aGUgb3JpZ2luYWwgc3RhdGVcbiAgICAgKi9cbiAgICBzZXREaXJlY3RWaWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWaWV3cG9ydCA9IHRoaXMuX2NhY2hlZFZpZXdwb3J0O1xuICAgICAgICB0aGlzLl9jYWNoZWRWaWV3cG9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gY3VycmVudFZpZXdwb3J0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIHNjaXNzb3IgY2xlYXIgKGllLiBhIGNsZWFyIG9uIGEgc3BlY2lmaWMgcG9ydGlvbiBvZiB0aGUgc2NyZWVuKVxuICAgICAqIEBwYXJhbSB4IGRlZmluZXMgdGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBjbGVhciByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0geSBkZWZpbmVzIHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNvcm5lciBvZiB0aGUgY2xlYXIgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHdpZHRoIGRlZmluZXMgdGhlIHdpZHRoIG9mIHRoZSBjbGVhciByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IGRlZmluZXMgdGhlIGhlaWdodCBvZiB0aGUgY2xlYXIgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNsZWFyQ29sb3IgZGVmaW5lcyB0aGUgY2xlYXIgY29sb3JcbiAgICAgKi9cbiAgICBzY2lzc29yQ2xlYXIoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2xlYXJDb2xvcikge1xuICAgICAgICB0aGlzLmVuYWJsZVNjaXNzb3IoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuY2xlYXIoY2xlYXJDb2xvciwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZVNjaXNzb3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIHNjaXNzb3IgdGVzdCBvbiBhIHNwZWNpZmljIHJlY3RhbmdsZSAoaWUuIHJlbmRlciB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYSBzcGVjaWZpYyBwb3J0aW9uIG9mIHRoZSBzY3JlZW4pXG4gICAgICogQHBhcmFtIHggZGVmaW5lcyB0aGUgeC1jb29yZGluYXRlIG9mIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIGNsZWFyIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5IGRlZmluZXMgdGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY29ybmVyIG9mIHRoZSBjbGVhciByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gd2lkdGggZGVmaW5lcyB0aGUgd2lkdGggb2YgdGhlIGNsZWFyIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgZGVmaW5lcyB0aGUgaGVpZ2h0IG9mIHRoZSBjbGVhciByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBlbmFibGVTY2lzc29yKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgLy8gQ2hhbmdlIHN0YXRlXG4gICAgICAgIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgICAgICBnbC5zY2lzc29yKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHByZXZpb3VzbHkgc2V0IHNjaXNzb3IgdGVzdCByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBkaXNhYmxlU2Npc3NvcigpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfbG9hZEZpbGVBc3luYyh1cmwsIG9mZmxpbmVQcm92aWRlciwgdXNlQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRGaWxlKHVybCwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCBvZmZsaW5lUHJvdmlkZXIsIHVzZUFycmF5QnVmZmVyLCAocmVxdWVzdCwgZXhjZXB0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNvdXJjZSBjb2RlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyIGFzc29jaWF0ZWQgd2l0aCBhIHNwZWNpZmljIHdlYkdMIHByb2dyYW1cbiAgICAgKiBAcGFyYW0gcHJvZ3JhbSBkZWZpbmVzIHRoZSBwcm9ncmFtIHRvIHVzZVxuICAgICAqIEByZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHNvdXJjZSBjb2RlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvZ3JhbVxuICAgICAqL1xuICAgIGdldFZlcnRleFNoYWRlclNvdXJjZShwcm9ncmFtKSB7XG4gICAgICAgIGNvbnN0IHNoYWRlcnMgPSB0aGlzLl9nbC5nZXRBdHRhY2hlZFNoYWRlcnMocHJvZ3JhbSk7XG4gICAgICAgIGlmICghc2hhZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsLmdldFNoYWRlclNvdXJjZShzaGFkZXJzWzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc291cmNlIGNvZGUgb2YgdGhlIGZyYWdtZW50IHNoYWRlciBhc3NvY2lhdGVkIHdpdGggYSBzcGVjaWZpYyB3ZWJHTCBwcm9ncmFtXG4gICAgICogQHBhcmFtIHByb2dyYW0gZGVmaW5lcyB0aGUgcHJvZ3JhbSB0byB1c2VcbiAgICAgKiBAcmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBzb3VyY2UgY29kZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvZ3JhbVxuICAgICAqL1xuICAgIGdldEZyYWdtZW50U2hhZGVyU291cmNlKHByb2dyYW0pIHtcbiAgICAgICAgY29uc3Qgc2hhZGVycyA9IHRoaXMuX2dsLmdldEF0dGFjaGVkU2hhZGVycyhwcm9ncmFtKTtcbiAgICAgICAgaWYgKCFzaGFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2wuZ2V0U2hhZGVyU291cmNlKHNoYWRlcnNbMV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBvYmplY3QgZnJvbSB3aGljaCB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgYmUgdGFrZW4gZnJvbSB3aGVuIGdldHRpbmcgcmVuZGVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKiBXaWxsIGZhbGxiYWNrIHRvIHRoZSBnbCBvYmplY3RcbiAgICAgKiBAcGFyYW0gZGltZW5zaW9ucyB0aGUgZnJhbWVidWZmZXIgd2lkdGggYW5kIGhlaWdodCB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBzZXQgZnJhbWVidWZmZXJEaW1lbnNpb25zT2JqZWN0KGRpbWVuc2lvbnMpIHtcbiAgICAgICAgdGhpcy5fZnJhbWVidWZmZXJEaW1lbnNpb25zT2JqZWN0ID0gZGltZW5zaW9ucztcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lYnVmZmVyRGltZW5zaW9uc09iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5vblJlc2l6ZU9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZWJ1aWxkQnVmZmVycygpIHtcbiAgICAgICAgLy8gSW5kZXggLyBWZXJ0ZXhcbiAgICAgICAgZm9yIChjb25zdCBzY2VuZSBvZiB0aGlzLnNjZW5lcykge1xuICAgICAgICAgICAgc2NlbmUucmVzZXRDYWNoZWRNYXRlcmlhbCgpO1xuICAgICAgICAgICAgc2NlbmUuX3JlYnVpbGRHZW9tZXRyaWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzY2VuZSBvZiB0aGlzLl92aXJ0dWFsU2NlbmVzKSB7XG4gICAgICAgICAgICBzY2VuZS5yZXNldENhY2hlZE1hdGVyaWFsKCk7XG4gICAgICAgICAgICBzY2VuZS5fcmVidWlsZEdlb21ldHJpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5fcmVidWlsZEJ1ZmZlcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEZvbnQgc2l6ZSBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSBmb250IGZvbnQgbmFtZVxuICAgICAqIEByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGFzY2VudCwgaGVpZ2h0IGFuZCBkZXNjZW50XG4gICAgICovXG4gICAgZ2V0Rm9udE9mZnNldChmb250KSB7XG4gICAgICAgIHJldHVybiBHZXRGb250T2Zmc2V0KGZvbnQpO1xuICAgIH1cbiAgICBfY2FuY2VsRnJhbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbUFuaW1hdGlvbkZyYW1lUmVxdWVzdGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZnJhbWVIYW5kbGVyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhbWVIYW5kbGVyID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNhbmNlbEFuaW1hdGlvbkZyYW1lIH0gPSB0aGlzLmN1c3RvbUFuaW1hdGlvbkZyYW1lUmVxdWVzdGVyO1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmN1c3RvbUFuaW1hdGlvbkZyYW1lUmVxdWVzdGVyLnJlcXVlc3RJRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuX2NhbmNlbEZyYW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3JlbmRlckxvb3AodGltZXN0YW1wKSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NGcmFtZSh0aW1lc3RhbXApO1xuICAgICAgICAvLyBUaGUgZmlyc3QgY29uZGl0aW9uIHByZXZlbnRzIHF1ZXVpbmcgYW5vdGhlciBmcmFtZSBpZiB3ZSBubyBsb25nZXIgaGF2ZSBhY3RpdmUgcmVuZGVyIGxvb3BzIChlLmcuLCBpZlxuICAgICAgICAvLyBgc3RvcFJlbmRlckxvb3BgIGlzIGNhbGxlZCBtaWQgZnJhbWUpLiBUaGUgc2Vjb25kIGNvbmRpdGlvbiBwcmV2ZW50cyBxdWV1aW5nIGFub3RoZXIgZnJhbWUgaWYgb25lIGhhc1xuICAgICAgICAvLyBhbHJlYWR5IGJlZW4gcXVldWVkIChlLmcuLCBpZiBgc3RvcFJlbmRlckxvb3BgIGFuZCBgcnVuUmVuZGVyTG9vcGAgaXMgY2FsbGVkIG1pZCBmcmFtZSkuXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVSZW5kZXJMb29wcy5sZW5ndGggPiAwICYmIHRoaXMuX2ZyYW1lSGFuZGxlciA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tQW5pbWF0aW9uRnJhbWVSZXF1ZXN0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUFuaW1hdGlvbkZyYW1lUmVxdWVzdGVyLnJlcXVlc3RJRCA9IHRoaXMuX3F1ZXVlTmV3RnJhbWUodGhpcy5jdXN0b21BbmltYXRpb25GcmFtZVJlcXVlc3Rlci5yZW5kZXJGdW5jdGlvbiB8fCB0aGlzLl9ib3VuZFJlbmRlckZ1bmN0aW9uLCB0aGlzLmN1c3RvbUFuaW1hdGlvbkZyYW1lUmVxdWVzdGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmFtZUhhbmRsZXIgPSB0aGlzLmN1c3RvbUFuaW1hdGlvbkZyYW1lUmVxdWVzdGVyLnJlcXVlc3RJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZyYW1lSGFuZGxlciA9IHRoaXMuX3F1ZXVlTmV3RnJhbWUodGhpcy5fYm91bmRSZW5kZXJGdW5jdGlvbiwgdGhpcy5nZXRIb3N0V2luZG93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVudGVycyBQb2ludGVybG9jayBtb2RlXG4gICAgICovXG4gICAgZW50ZXJQb2ludGVybG9jaygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmluZ0NhbnZhcykge1xuICAgICAgICAgICAgUmVxdWVzdFBvaW50ZXJsb2NrKHRoaXMuX3JlbmRlcmluZ0NhbnZhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhpdHMgUG9pbnRlcmxvY2sgbW9kZVxuICAgICAqL1xuICAgIGV4aXRQb2ludGVybG9jaygpIHtcbiAgICAgICAgRXhpdFBvaW50ZXJsb2NrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJlZ2luIGEgbmV3IGZyYW1lXG4gICAgICovXG4gICAgYmVnaW5GcmFtZSgpIHtcbiAgICAgICAgdGhpcy5fbWVhc3VyZUZwcygpO1xuICAgICAgICBzdXBlci5iZWdpbkZyYW1lKCk7XG4gICAgfVxuICAgIF9kZWxldGVQaXBlbGluZUNvbnRleHQocGlwZWxpbmVDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHdlYkdMUGlwZWxpbmVDb250ZXh0ID0gcGlwZWxpbmVDb250ZXh0O1xuICAgICAgICBpZiAod2ViR0xQaXBlbGluZUNvbnRleHQgJiYgd2ViR0xQaXBlbGluZUNvbnRleHQucHJvZ3JhbSkge1xuICAgICAgICAgICAgaWYgKHdlYkdMUGlwZWxpbmVDb250ZXh0LnRyYW5zZm9ybUZlZWRiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVUcmFuc2Zvcm1GZWVkYmFjayh3ZWJHTFBpcGVsaW5lQ29udGV4dC50cmFuc2Zvcm1GZWVkYmFjayk7XG4gICAgICAgICAgICAgICAgd2ViR0xQaXBlbGluZUNvbnRleHQudHJhbnNmb3JtRmVlZGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLl9kZWxldGVQaXBlbGluZUNvbnRleHQocGlwZWxpbmVDb250ZXh0KTtcbiAgICB9XG4gICAgY3JlYXRlU2hhZGVyUHJvZ3JhbShwaXBlbGluZUNvbnRleHQsIHZlcnRleENvZGUsIGZyYWdtZW50Q29kZSwgZGVmaW5lcywgY29udGV4dCwgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyA9IG51bGwpIHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcy5fZ2w7XG4gICAgICAgIHRoaXMub25CZWZvcmVTaGFkZXJDb21waWxhdGlvbk9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0gc3VwZXIuY3JlYXRlU2hhZGVyUHJvZ3JhbShwaXBlbGluZUNvbnRleHQsIHZlcnRleENvZGUsIGZyYWdtZW50Q29kZSwgZGVmaW5lcywgY29udGV4dCwgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyk7XG4gICAgICAgIHRoaXMub25BZnRlclNoYWRlckNvbXBpbGF0aW9uT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnModGhpcyk7XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgICBfY3JlYXRlU2hhZGVyUHJvZ3JhbShwaXBlbGluZUNvbnRleHQsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIGNvbnRleHQsIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHNoYWRlclByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgcGlwZWxpbmVDb250ZXh0LnByb2dyYW0gPSBzaGFkZXJQcm9ncmFtO1xuICAgICAgICBpZiAoIXNoYWRlclByb2dyYW0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgcHJvZ3JhbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgICBjb250ZXh0LmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICAgIGlmICh0aGlzLndlYkdMVmVyc2lvbiA+IDEgJiYgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncykge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtRmVlZGJhY2sgPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrKCk7XG4gICAgICAgICAgICB0aGlzLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayh0cmFuc2Zvcm1GZWVkYmFjayk7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5mb3JtRmVlZGJhY2tWYXJ5aW5ncyhzaGFkZXJQcm9ncmFtLCB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKTtcbiAgICAgICAgICAgIHBpcGVsaW5lQ29udGV4dC50cmFuc2Zvcm1GZWVkYmFjayA9IHRyYW5zZm9ybUZlZWRiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubGlua1Byb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG4gICAgICAgIGlmICh0aGlzLndlYkdMVmVyc2lvbiA+IDEgJiYgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncykge1xuICAgICAgICAgICAgdGhpcy5iaW5kVHJhbnNmb3JtRmVlZGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcGlwZWxpbmVDb250ZXh0LmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBwaXBlbGluZUNvbnRleHQudmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyO1xuICAgICAgICBwaXBlbGluZUNvbnRleHQuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcbiAgICAgICAgaWYgKCFwaXBlbGluZUNvbnRleHQuaXNQYXJhbGxlbENvbXBpbGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6ZVBpcGVsaW5lQ29udGV4dChwaXBlbGluZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkZXJQcm9ncmFtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfcmVsZWFzZVRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICBzdXBlci5fcmVsZWFzZVRleHR1cmUodGV4dHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9yZWxlYXNlUmVuZGVyVGFyZ2V0V3JhcHBlcihydFdyYXBwZXIpIHtcbiAgICAgICAgc3VwZXIuX3JlbGVhc2VSZW5kZXJUYXJnZXRXcmFwcGVyKHJ0V3JhcHBlcik7XG4gICAgICAgIC8vIFNldCBvdXRwdXQgdGV4dHVyZSBvZiBwb3N0IHByb2Nlc3MgdG8gbnVsbCBpZiB0aGUgZnJhbWVidWZmZXIgaGFzIGJlZW4gcmVsZWFzZWQvZGlzcG9zZWRcbiAgICAgICAgZm9yIChjb25zdCBzY2VuZSBvZiB0aGlzLnNjZW5lcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwb3N0UHJvY2VzcyBvZiBzY2VuZS5wb3N0UHJvY2Vzc2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3RQcm9jZXNzLl9vdXRwdXRUZXh0dXJlID09PSBydFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdFByb2Nlc3MuX291dHB1dFRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FtZXJhIG9mIHNjZW5lLmNhbWVyYXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvc3RQcm9jZXNzIG9mIGNhbWVyYS5fcG9zdFByb2Nlc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zdFByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3N0UHJvY2Vzcy5fb3V0cHV0VGV4dHVyZSA9PT0gcnRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdFByb2Nlc3MuX291dHB1dFRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIFJlc2NhbGVzIGEgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBzb3VyY2UgaW5wdXQgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvbiBkZXN0aW5hdGlvbiB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHNjZW5lIHNjZW5lIHRvIHVzZSB0byByZW5kZXIgdGhlIHJlc2l6ZVxuICAgICAqIEBwYXJhbSBpbnRlcm5hbEZvcm1hdCBmb3JtYXQgdG8gdXNlIHdoZW4gcmVzaXppbmdcbiAgICAgKiBAcGFyYW0gb25Db21wbGV0ZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiByZXNpemUgaGFzIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIF9yZXNjYWxlVGV4dHVyZShzb3VyY2UsIGRlc3RpbmF0aW9uLCBzY2VuZSwgaW50ZXJuYWxGb3JtYXQsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELCB0aGlzLl9nbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuX2dsLkxJTkVBUik7XG4gICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9nbC5MSU5FQVIpO1xuICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl9nbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELCB0aGlzLl9nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGNvbnN0IHJ0dCA9IHRoaXMuY3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZSh7XG4gICAgICAgICAgICB3aWR0aDogZGVzdGluYXRpb24ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGRlc3RpbmF0aW9uLmhlaWdodCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZ2VuZXJhdGVNaXBNYXBzOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6IDAsXG4gICAgICAgICAgICBzYW1wbGluZ01vZGU6IDIsXG4gICAgICAgICAgICBnZW5lcmF0ZURlcHRoQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGdlbmVyYXRlU3RlbmNpbEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc2NhbGVQb3N0UHJvY2VzcyAmJiBFbmdpbmUuX1Jlc2NhbGVQb3N0UHJvY2Vzc0ZhY3RvcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2NhbGVQb3N0UHJvY2VzcyA9IEVuZ2luZS5fUmVzY2FsZVBvc3RQcm9jZXNzRmFjdG9yeSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVzY2FsZVBvc3RQcm9jZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNjYWxlUG9zdFByb2Nlc3MuZXh0ZXJuYWxUZXh0dXJlU2FtcGxlckJpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgb25Db21waWxlZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNjYWxlUG9zdFByb2Nlc3Mub25BcHBseSA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0Ll9iaW5kVGV4dHVyZShcInRleHR1cmVTYW1wbGVyXCIsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsZXQgaG9zdGluZ1NjZW5lID0gc2NlbmU7XG4gICAgICAgICAgICAgICAgaWYgKCFob3N0aW5nU2NlbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdGluZ1NjZW5lID0gdGhpcy5zY2VuZXNbdGhpcy5zY2VuZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3RpbmdTY2VuZS5wb3N0UHJvY2Vzc01hbmFnZXIuZGlyZWN0UmVuZGVyKFt0aGlzLl9yZXNjYWxlUG9zdFByb2Nlc3NdLCBydHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgZGVzdGluYXRpb24sIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLmNvcHlUZXhJbWFnZTJEKHRoaXMuX2dsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCAwLCAwLCBkZXN0aW5hdGlvbi53aWR0aCwgZGVzdGluYXRpb24uaGVpZ2h0LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuQmluZEZyYW1lYnVmZmVyKHJ0dCk7XG4gICAgICAgICAgICAgICAgcnR0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdCA9IHRoaXMuX3Jlc2NhbGVQb3N0UHJvY2Vzcy5nZXRFZmZlY3QoKTtcbiAgICAgICAgICAgIGlmIChlZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBlZmZlY3QuZXhlY3V0ZVdoZW5Db21waWxlZChvbkNvbXBpbGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2NhbGVQb3N0UHJvY2Vzcy5vbkVmZmVjdENyZWF0ZWRPYnNlcnZhYmxlLmFkZE9uY2UoKGVmZmVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3QuZXhlY3V0ZVdoZW5Db21waWxlZChvbkNvbXBpbGVkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcmFwcyBhbiBleHRlcm5hbCB3ZWIgZ2wgdGV4dHVyZSBpbiBhIEJhYnlsb24gdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSBleHRlcm5hbCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGhhc01pcE1hcHMgZGVmaW5lcyB3aGV0aGVyIHRoZSBleHRlcm5hbCB0ZXh0dXJlIGhhcyBtaXAgbWFwcyAoZGVmYXVsdDogZmFsc2UpXG4gICAgICogQHBhcmFtIHNhbXBsaW5nTW9kZSBkZWZpbmVzIHRoZSBzYW1wbGluZyBtb2RlIGZvciB0aGUgZXh0ZXJuYWwgdGV4dHVyZSAoZGVmYXVsdDogMylcbiAgICAgKiBAcGFyYW0gd2lkdGggZGVmaW5lcyB0aGUgd2lkdGggZm9yIHRoZSBleHRlcm5hbCB0ZXh0dXJlIChkZWZhdWx0OiAwKVxuICAgICAqIEBwYXJhbSBoZWlnaHQgZGVmaW5lcyB0aGUgaGVpZ2h0IGZvciB0aGUgZXh0ZXJuYWwgdGV4dHVyZSAoZGVmYXVsdDogMClcbiAgICAgKiBAcmV0dXJucyB0aGUgYmFieWxvbiBpbnRlcm5hbCB0ZXh0dXJlXG4gICAgICovXG4gICAgd3JhcFdlYkdMVGV4dHVyZSh0ZXh0dXJlLCBoYXNNaXBNYXBzID0gZmFsc2UsIHNhbXBsaW5nTW9kZSA9IDMsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICAgICAgICBjb25zdCBoYXJkd2FyZVRleHR1cmUgPSBuZXcgV2ViR0xIYXJkd2FyZVRleHR1cmUodGV4dHVyZSwgdGhpcy5fZ2wpO1xuICAgICAgICBjb25zdCBpbnRlcm5hbFRleHR1cmUgPSBuZXcgSW50ZXJuYWxUZXh0dXJlKHRoaXMsIDAgLyogSW50ZXJuYWxUZXh0dXJlU291cmNlLlVua25vd24gKi8sIHRydWUpO1xuICAgICAgICBpbnRlcm5hbFRleHR1cmUuX2hhcmR3YXJlVGV4dHVyZSA9IGhhcmR3YXJlVGV4dHVyZTtcbiAgICAgICAgaW50ZXJuYWxUZXh0dXJlLmJhc2VXaWR0aCA9IHdpZHRoO1xuICAgICAgICBpbnRlcm5hbFRleHR1cmUuYmFzZUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgaW50ZXJuYWxUZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGludGVybmFsVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGludGVybmFsVGV4dHVyZS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgaW50ZXJuYWxUZXh0dXJlLnVzZU1pcE1hcHMgPSBoYXNNaXBNYXBzO1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmVTYW1wbGluZ01vZGUoc2FtcGxpbmdNb2RlLCBpbnRlcm5hbFRleHR1cmUpO1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxUZXh0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfdXBsb2FkSW1hZ2VUb1RleHR1cmUodGV4dHVyZSwgaW1hZ2UsIGZhY2VJbmRleCA9IDAsIGxvZCA9IDApIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgY29uc3QgdGV4dHVyZVR5cGUgPSB0aGlzLl9nZXRXZWJHTFRleHR1cmVUeXBlKHRleHR1cmUudHlwZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuX2dldEludGVybmFsRm9ybWF0KHRleHR1cmUuZm9ybWF0KTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLl9nZXRSR0JBQnVmZmVySW50ZXJuYWxTaXplZEZvcm1hdCh0ZXh0dXJlLnR5cGUsIGZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGJpbmRUYXJnZXQgPSB0ZXh0dXJlLmlzQ3ViZSA/IGdsLlRFWFRVUkVfQ1VCRV9NQVAgOiBnbC5URVhUVVJFXzJEO1xuICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KGJpbmRUYXJnZXQsIHRleHR1cmUsIHRydWUpO1xuICAgICAgICB0aGlzLl91bnBhY2tGbGlwWSh0ZXh0dXJlLmludmVydFkpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gZ2wuVEVYVFVSRV8yRDtcbiAgICAgICAgaWYgKHRleHR1cmUuaXNDdWJlKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBmYWNlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIGxvZCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdGV4dHVyZVR5cGUsIGltYWdlKTtcbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseShiaW5kVGFyZ2V0LCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIGRlcHRoIHRleHR1cmUgQ29tcGFyaXNvbiBNb2RlIGFuZCBGdW5jdGlvbi5cbiAgICAgKiBJZiB0aGUgY29tcGFyaXNvbiBGdW5jdGlvbiBpcyBlcXVhbCB0byAwLCB0aGUgbW9kZSB3aWxsIGJlIHNldCB0byBub25lLlxuICAgICAqIE90aGVyd2lzZSwgdGhpcyBvbmx5IHdvcmtzIGluIHdlYmdsIDIgYW5kIHJlcXVpcmVzIGEgc2hhZG93IHNhbXBsZXIgaW4gdGhlIHNoYWRlci5cbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBUaGUgdGV4dHVyZSB0byBzZXQgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yXG4gICAgICogQHBhcmFtIGNvbXBhcmlzb25GdW5jdGlvbiBUaGUgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBzZXQsIDAgaWYgbm8gY29tcGFyaXNvbiByZXF1aXJlZFxuICAgICAqL1xuICAgIHVwZGF0ZVRleHR1cmVDb21wYXJpc29uRnVuY3Rpb24odGV4dHVyZSwgY29tcGFyaXNvbkZ1bmN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLndlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFwiV2ViR0wgMSBkb2VzIG5vdCBzdXBwb3J0IHRleHR1cmUgY29tcGFyaXNvbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgaWYgKHRleHR1cmUuaXNDdWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KHRoaXMuX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmlzb25GdW5jdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9DT01QQVJFX0ZVTkMsIDUxNSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX0NPTVBBUkVfTU9ERSwgZ2wuTk9ORSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfQ09NUEFSRV9GVU5DLCBjb21wYXJpc29uRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9DT01QQVJFX01PREUsIGdsLkNPTVBBUkVfUkVGX1RPX1RFWFRVUkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0aGlzLl9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyaXNvbkZ1bmN0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX0NPTVBBUkVfRlVOQywgNTE1KTtcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfQ09NUEFSRV9NT0RFLCBnbC5OT05FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9DT01QQVJFX0ZVTkMsIGNvbXBhcmlzb25GdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX0NPTVBBUkVfTU9ERSwgZ2wuQ09NUEFSRV9SRUZfVE9fVEVYVFVSRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KHRoaXMuX2dsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRleHR1cmUuX2NvbXBhcmlzb25GdW5jdGlvbiA9IGNvbXBhcmlzb25GdW5jdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHdlYkdMIGJ1ZmZlciB0byB1c2Ugd2l0aCBpbnN0YW50aWF0aW9uXG4gICAgICogQHBhcmFtIGNhcGFjaXR5IGRlZmluZXMgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlclxuICAgICAqIEByZXR1cm5zIHRoZSB3ZWJHTCBidWZmZXJcbiAgICAgKi9cbiAgICBjcmVhdGVJbnN0YW5jZXNCdWZmZXIoY2FwYWNpdHkpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIGluc3RhbmNlIGJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgV2ViR0xEYXRhQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIHJlc3VsdC5jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgICAgICB0aGlzLmJpbmRBcnJheUJ1ZmZlcihyZXN1bHQpO1xuICAgICAgICB0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwgY2FwYWNpdHksIHRoaXMuX2dsLkRZTkFNSUNfRFJBVyk7XG4gICAgICAgIHJlc3VsdC5yZWZlcmVuY2VzID0gMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgd2ViR0wgYnVmZmVyIHVzZWQgd2l0aCBpbnN0YW50aWF0aW9uXG4gICAgICogQHBhcmFtIGJ1ZmZlciBkZWZpbmVzIHRoZSB3ZWJHTCBidWZmZXIgdG8gZGVsZXRlXG4gICAgICovXG4gICAgZGVsZXRlSW5zdGFuY2VzQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLl9nbC5kZWxldGVCdWZmZXIoYnVmZmVyKTtcbiAgICB9XG4gICAgYXN5bmMgX2NsaWVudFdhaXRBc3luYyhzeW5jLCBmbGFncyA9IDAsIGludGVydmFsbXMgPSAxMCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgX1JldHJ5V2l0aEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBnbC5jbGllbnRXYWl0U3luYyhzeW5jLCBmbGFncywgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcyA9PSBnbC5XQUlUX0ZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbGllbnRXYWl0U3luYyBmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXMgPT0gZ2wuVElNRU9VVF9FWFBJUkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LCByZXNvbHZlLCByZWplY3QsIGludGVydmFsbXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBtaWdodCByZXR1cm4gbnVsbCBzeW5jaHJvbm91c2x5LCBzbyBpdCBpcyB0ZWNobmljYWxseSBub3QgYXN5bmMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgX3JlYWRQaXhlbHNBc3luYyh4LCB5LCB3LCBoLCBmb3JtYXQsIHR5cGUsIG91dHB1dEJ1ZmZlcikge1xuICAgICAgICBpZiAodGhpcy5fd2ViR0xWZXJzaW9uIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3JlYWRQaXhlbHNBc3luYyBvbmx5IHdvcmsgb24gV2ViR0wyK1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICBjb25zdCBidWYgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5QSVhFTF9QQUNLX0JVRkZFUiwgb3V0cHV0QnVmZmVyLmJ5dGVMZW5ndGgsIGdsLlNUUkVBTV9SRUFEKTtcbiAgICAgICAgZ2wucmVhZFBpeGVscyh4LCB5LCB3LCBoLCBmb3JtYXQsIHR5cGUsIDApO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBudWxsKTtcbiAgICAgICAgY29uc3Qgc3luYyA9IGdsLmZlbmNlU3luYyhnbC5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwgMCk7XG4gICAgICAgIGlmICghc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZ2wuZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudFdhaXRBc3luYyhzeW5jLCAwLCAxMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBnbC5kZWxldGVTeW5jKHN5bmMpO1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmKTtcbiAgICAgICAgICAgIGdsLmdldEJ1ZmZlclN1YkRhdGEoZ2wuUElYRUxfUEFDS19CVUZGRVIsIDAsIG91dHB1dEJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBudWxsKTtcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcihidWYpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEJ1ZmZlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuaGlkZUxvYWRpbmdVSSgpO1xuICAgICAgICAvLyBSZXNjYWxlIFBQXG4gICAgICAgIGlmICh0aGlzLl9yZXNjYWxlUG9zdFByb2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2NhbGVQb3N0UHJvY2Vzcy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgX0NvbW1vbkRpc3Bvc2UodGhpcywgdGhpcy5fcmVuZGVyaW5nQ2FudmFzKTtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbn1cbi8vIENvbnN0IHN0YXRpY3Ncbi8qKiBEZWZpbmVzIHRoYXQgYWxwaGEgYmxlbmRpbmcgaXMgZGlzYWJsZWQgKi9cbkVuZ2luZS5BTFBIQV9ESVNBQkxFID0gMDtcbi8qKiBEZWZpbmVzIHRoYXQgYWxwaGEgYmxlbmRpbmcgdG8gU1JDIEFMUEhBICogU1JDICsgREVTVCAqL1xuRW5naW5lLkFMUEhBX0FERCA9IDE7XG4vKiogRGVmaW5lcyB0aGF0IGFscGhhIGJsZW5kaW5nIHRvIFNSQyBBTFBIQSAqIFNSQyArICgxIC0gU1JDIEFMUEhBKSAqIERFU1QgKi9cbkVuZ2luZS5BTFBIQV9DT01CSU5FID0gMjtcbi8qKiBEZWZpbmVzIHRoYXQgYWxwaGEgYmxlbmRpbmcgdG8gREVTVCAtIFNSQyAqIERFU1QgKi9cbkVuZ2luZS5BTFBIQV9TVUJUUkFDVCA9IDM7XG4vKiogRGVmaW5lcyB0aGF0IGFscGhhIGJsZW5kaW5nIHRvIFNSQyAqIERFU1QgKi9cbkVuZ2luZS5BTFBIQV9NVUxUSVBMWSA9IDQ7XG4vKiogRGVmaW5lcyB0aGF0IGFscGhhIGJsZW5kaW5nIHRvIFNSQyBBTFBIQSAqIFNSQyArICgxIC0gU1JDKSAqIERFU1QgKi9cbkVuZ2luZS5BTFBIQV9NQVhJTUlaRUQgPSA1O1xuLyoqIERlZmluZXMgdGhhdCBhbHBoYSBibGVuZGluZyB0byBTUkMgKyBERVNUICovXG5FbmdpbmUuQUxQSEFfT05FT05FID0gNjtcbi8qKiBEZWZpbmVzIHRoYXQgYWxwaGEgYmxlbmRpbmcgdG8gU1JDICsgKDEgLSBTUkMgQUxQSEEpICogREVTVCAqL1xuRW5naW5lLkFMUEhBX1BSRU1VTFRJUExJRUQgPSA3O1xuLyoqXG4gKiBEZWZpbmVzIHRoYXQgYWxwaGEgYmxlbmRpbmcgdG8gU1JDICsgKDEgLSBTUkMgQUxQSEEpICogREVTVFxuICogQWxwaGEgd2lsbCBiZSBzZXQgdG8gKDEgLSBTUkMgQUxQSEEpICogREVTVCBBTFBIQVxuICovXG5FbmdpbmUuQUxQSEFfUFJFTVVMVElQTElFRF9QT1JURVJEVUZGID0gODtcbi8qKiBEZWZpbmVzIHRoYXQgYWxwaGEgYmxlbmRpbmcgdG8gQ1NUICogU1JDICsgKDEgLSBDU1QpICogREVTVCAqL1xuRW5naW5lLkFMUEhBX0lOVEVSUE9MQVRFID0gOTtcbi8qKlxuICogRGVmaW5lcyB0aGF0IGFscGhhIGJsZW5kaW5nIHRvIFNSQyArICgxIC0gU1JDKSAqIERFU1RcbiAqIEFscGhhIHdpbGwgYmUgc2V0IHRvIFNSQyBBTFBIQSArICgxIC0gU1JDIEFMUEhBKSAqIERFU1QgQUxQSEFcbiAqL1xuRW5naW5lLkFMUEhBX1NDUkVFTk1PREUgPSAxMDtcbi8qKiBEZWZpbmVzIHRoYXQgdGhlIHJlc291cmNlIGlzIG5vdCBkZWxheWVkKi9cbkVuZ2luZS5ERUxBWUxPQURTVEFURV9OT05FID0gMDtcbi8qKiBEZWZpbmVzIHRoYXQgdGhlIHJlc291cmNlIHdhcyBzdWNjZXNzZnVsbHkgZGVsYXkgbG9hZGVkICovXG5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTE9BREVEID0gMTtcbi8qKiBEZWZpbmVzIHRoYXQgdGhlIHJlc291cmNlIGlzIGN1cnJlbnRseSBkZWxheSBsb2FkaW5nICovXG5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTE9BRElORyA9IDI7XG4vKiogRGVmaW5lcyB0aGF0IHRoZSByZXNvdXJjZSBpcyBkZWxheWVkIGFuZCBoYXMgbm90IHN0YXJ0ZWQgbG9hZGluZyAqL1xuRW5naW5lLkRFTEFZTE9BRFNUQVRFX05PVExPQURFRCA9IDQ7XG4vLyBEZXBodCBvciBTdGVuY2lsIHRlc3QgQ29uc3RhbnRzLlxuLyoqIFBhc3NlZCB0byBkZXB0aEZ1bmN0aW9uIG9yIHN0ZW5jaWxGdW5jdGlvbiB0byBzcGVjaWZ5IGRlcHRoIG9yIHN0ZW5jaWwgdGVzdHMgd2lsbCBuZXZlciBwYXNzLiBpLmUuIE5vdGhpbmcgd2lsbCBiZSBkcmF3biAqL1xuRW5naW5lLk5FVkVSID0gNTEyO1xuLyoqIFBhc3NlZCB0byBkZXB0aEZ1bmN0aW9uIG9yIHN0ZW5jaWxGdW5jdGlvbiB0byBzcGVjaWZ5IGRlcHRoIG9yIHN0ZW5jaWwgdGVzdHMgd2lsbCBhbHdheXMgcGFzcy4gaS5lLiBQaXhlbHMgd2lsbCBiZSBkcmF3biBpbiB0aGUgb3JkZXIgdGhleSBhcmUgZHJhd24gKi9cbkVuZ2luZS5BTFdBWVMgPSA1MTk7XG4vKiogUGFzc2VkIHRvIGRlcHRoRnVuY3Rpb24gb3Igc3RlbmNpbEZ1bmN0aW9uIHRvIHNwZWNpZnkgZGVwdGggb3Igc3RlbmNpbCB0ZXN0cyB3aWxsIHBhc3MgaWYgdGhlIG5ldyBkZXB0aCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHN0b3JlZCB2YWx1ZSAqL1xuRW5naW5lLkxFU1MgPSA1MTM7XG4vKiogUGFzc2VkIHRvIGRlcHRoRnVuY3Rpb24gb3Igc3RlbmNpbEZ1bmN0aW9uIHRvIHNwZWNpZnkgZGVwdGggb3Igc3RlbmNpbCB0ZXN0cyB3aWxsIHBhc3MgaWYgdGhlIG5ldyBkZXB0aCB2YWx1ZSBpcyBlcXVhbHMgdG8gdGhlIHN0b3JlZCB2YWx1ZSAqL1xuRW5naW5lLkVRVUFMID0gNTE0O1xuLyoqIFBhc3NlZCB0byBkZXB0aEZ1bmN0aW9uIG9yIHN0ZW5jaWxGdW5jdGlvbiB0byBzcGVjaWZ5IGRlcHRoIG9yIHN0ZW5jaWwgdGVzdHMgd2lsbCBwYXNzIGlmIHRoZSBuZXcgZGVwdGggdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzdG9yZWQgdmFsdWUgKi9cbkVuZ2luZS5MRVFVQUwgPSA1MTU7XG4vKiogUGFzc2VkIHRvIGRlcHRoRnVuY3Rpb24gb3Igc3RlbmNpbEZ1bmN0aW9uIHRvIHNwZWNpZnkgZGVwdGggb3Igc3RlbmNpbCB0ZXN0cyB3aWxsIHBhc3MgaWYgdGhlIG5ldyBkZXB0aCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHN0b3JlZCB2YWx1ZSAqL1xuRW5naW5lLkdSRUFURVIgPSA1MTY7XG4vKiogUGFzc2VkIHRvIGRlcHRoRnVuY3Rpb24gb3Igc3RlbmNpbEZ1bmN0aW9uIHRvIHNwZWNpZnkgZGVwdGggb3Igc3RlbmNpbCB0ZXN0cyB3aWxsIHBhc3MgaWYgdGhlIG5ldyBkZXB0aCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHN0b3JlZCB2YWx1ZSAqL1xuRW5naW5lLkdFUVVBTCA9IDUxODtcbi8qKiBQYXNzZWQgdG8gZGVwdGhGdW5jdGlvbiBvciBzdGVuY2lsRnVuY3Rpb24gdG8gc3BlY2lmeSBkZXB0aCBvciBzdGVuY2lsIHRlc3RzIHdpbGwgcGFzcyBpZiB0aGUgbmV3IGRlcHRoIHZhbHVlIGlzIG5vdCBlcXVhbCB0byB0aGUgc3RvcmVkIHZhbHVlICovXG5FbmdpbmUuTk9URVFVQUwgPSA1MTc7XG4vLyBTdGVuY2lsIEFjdGlvbnMgQ29uc3RhbnRzLlxuLyoqIFBhc3NlZCB0byBzdGVuY2lsT3BlcmF0aW9uIHRvIHNwZWNpZnkgdGhhdCBzdGVuY2lsIHZhbHVlIG11c3QgYmUga2VwdCAqL1xuRW5naW5lLktFRVAgPSA3NjgwO1xuLyoqIFBhc3NlZCB0byBzdGVuY2lsT3BlcmF0aW9uIHRvIHNwZWNpZnkgdGhhdCBzdGVuY2lsIHZhbHVlIG11c3QgYmUgcmVwbGFjZWQgKi9cbkVuZ2luZS5SRVBMQUNFID0gNzY4MTtcbi8qKiBQYXNzZWQgdG8gc3RlbmNpbE9wZXJhdGlvbiB0byBzcGVjaWZ5IHRoYXQgc3RlbmNpbCB2YWx1ZSBtdXN0IGJlIGluY3JlbWVudGVkICovXG5FbmdpbmUuSU5DUiA9IDc2ODI7XG4vKiogUGFzc2VkIHRvIHN0ZW5jaWxPcGVyYXRpb24gdG8gc3BlY2lmeSB0aGF0IHN0ZW5jaWwgdmFsdWUgbXVzdCBiZSBkZWNyZW1lbnRlZCAqL1xuRW5naW5lLkRFQ1IgPSA3NjgzO1xuLyoqIFBhc3NlZCB0byBzdGVuY2lsT3BlcmF0aW9uIHRvIHNwZWNpZnkgdGhhdCBzdGVuY2lsIHZhbHVlIG11c3QgYmUgaW52ZXJ0ZWQgKi9cbkVuZ2luZS5JTlZFUlQgPSA1Mzg2O1xuLyoqIFBhc3NlZCB0byBzdGVuY2lsT3BlcmF0aW9uIHRvIHNwZWNpZnkgdGhhdCBzdGVuY2lsIHZhbHVlIG11c3QgYmUgaW5jcmVtZW50ZWQgd2l0aCB3cmFwcGluZyAqL1xuRW5naW5lLklOQ1JfV1JBUCA9IDM0MDU1O1xuLyoqIFBhc3NlZCB0byBzdGVuY2lsT3BlcmF0aW9uIHRvIHNwZWNpZnkgdGhhdCBzdGVuY2lsIHZhbHVlIG11c3QgYmUgZGVjcmVtZW50ZWQgd2l0aCB3cmFwcGluZyAqL1xuRW5naW5lLkRFQ1JfV1JBUCA9IDM0MDU2O1xuLyoqIFRleHR1cmUgaXMgbm90IHJlcGVhdGluZyBvdXRzaWRlIG9mIDAuLjEgVVZzICovXG5FbmdpbmUuVEVYVFVSRV9DTEFNUF9BRERSRVNTTU9ERSA9IDA7XG4vKiogVGV4dHVyZSBpcyByZXBlYXRpbmcgb3V0c2lkZSBvZiAwLi4xIFVWcyAqL1xuRW5naW5lLlRFWFRVUkVfV1JBUF9BRERSRVNTTU9ERSA9IDE7XG4vKiogVGV4dHVyZSBpcyByZXBlYXRpbmcgYW5kIG1pcnJvcmVkICovXG5FbmdpbmUuVEVYVFVSRV9NSVJST1JfQUREUkVTU01PREUgPSAyO1xuLyoqIEFMUEhBICovXG5FbmdpbmUuVEVYVFVSRUZPUk1BVF9BTFBIQSA9IDA7XG4vKiogTFVNSU5BTkNFICovXG5FbmdpbmUuVEVYVFVSRUZPUk1BVF9MVU1JTkFOQ0UgPSAxO1xuLyoqIExVTUlOQU5DRV9BTFBIQSAqL1xuRW5naW5lLlRFWFRVUkVGT1JNQVRfTFVNSU5BTkNFX0FMUEhBID0gMjtcbi8qKiBSR0IgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVuZ2luZS5URVhUVVJFRk9STUFUX1JHQiA9IDQ7XG4vKiogUkdCQSAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRW5naW5lLlRFWFRVUkVGT1JNQVRfUkdCQSA9IDU7XG4vKiogUkVEICovXG5FbmdpbmUuVEVYVFVSRUZPUk1BVF9SRUQgPSA2O1xuLyoqIFJFRCAoMm5kIHJlZmVyZW5jZSkgKi9cbkVuZ2luZS5URVhUVVJFRk9STUFUX1IgPSA2O1xuLyoqIFJFRCB1bnNpZ25lZCBzaG9ydCBub3JtZWQgdG8gWzAsIDFdICoqL1xuRW5naW5lLlRFWFRVUkVGT1JNQVRfUjE2X1VOT1JNID0gMzMzMjI7XG4vKiogUkcgdW5zaWduZWQgc2hvcnQgbm9ybWVkIHRvIFswLCAxXSAqKi9cbkVuZ2luZS5URVhUVVJFRk9STUFUX1JHMTZfVU5PUk0gPSAzMzMyNDtcbi8qKiBSR0IgdW5zaWduZWQgc2hvcnQgbm9ybWVkIHRvIFswLCAxXSAqKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVuZ2luZS5URVhUVVJFRk9STUFUX1JHQjE2X1VOT1JNID0gMzI4NTI7XG4vKiogUkdCQSB1bnNpZ25lZCBzaG9ydCBub3JtZWQgdG8gWzAsIDFdICoqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRW5naW5lLlRFWFRVUkVGT1JNQVRfUkdCQTE2X1VOT1JNID0gMzI4NTk7XG4vKiogUkVEIHNpZ25lZCBzaG9ydCBub3JtZWQgdG8gWy0xLCAxXSAqKi9cbkVuZ2luZS5URVhUVVJFRk9STUFUX1IxNl9TTk9STSA9IDM2NzYwO1xuLyoqIFJHIHNpZ25lZCBzaG9ydCBub3JtZWQgdG8gWy0xLCAxXSAqKi9cbkVuZ2luZS5URVhUVVJFRk9STUFUX1JHMTZfU05PUk0gPSAzNjc2MTtcbi8qKiBSR0Igc2lnbmVkIHNob3J0IG5vcm1lZCB0byBbLTEsIDFdICoqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRW5naW5lLlRFWFRVUkVGT1JNQVRfUkdCMTZfU05PUk0gPSAzNjc2Mjtcbi8qKiBSR0JBIHNpZ25lZCBzaG9ydCBub3JtZWQgdG8gWy0xLCAxXSAqKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVuZ2luZS5URVhUVVJFRk9STUFUX1JHQkExNl9TTk9STSA9IDM2NzYzO1xuLyoqIFJHICovXG5FbmdpbmUuVEVYVFVSRUZPUk1BVF9SRyA9IDc7XG4vKiogUkVEX0lOVEVHRVIgKi9cbkVuZ2luZS5URVhUVVJFRk9STUFUX1JFRF9JTlRFR0VSID0gODtcbi8qKiBSRURfSU5URUdFUiAoMm5kIHJlZmVyZW5jZSkgKi9cbkVuZ2luZS5URVhUVVJFRk9STUFUX1JfSU5URUdFUiA9IDg7XG4vKiogUkdfSU5URUdFUiAqL1xuRW5naW5lLlRFWFRVUkVGT1JNQVRfUkdfSU5URUdFUiA9IDk7XG4vKiogUkdCX0lOVEVHRVIgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVuZ2luZS5URVhUVVJFRk9STUFUX1JHQl9JTlRFR0VSID0gMTA7XG4vKiogUkdCQV9JTlRFR0VSICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FbmdpbmUuVEVYVFVSRUZPUk1BVF9SR0JBX0lOVEVHRVIgPSAxMTtcbi8qKiBVTlNJR05FRF9CWVRFICovXG5FbmdpbmUuVEVYVFVSRVRZUEVfVU5TSUdORURfQllURSA9IDA7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIG1vcmUgZXhwbGljaXQgVEVYVFVSRVRZUEVfVU5TSUdORURfQllURSBpbnN0ZWFkLiBVc2UgVEVYVFVSRVRZUEVfVU5TSUdORURfSU5URUdFUiBmb3IgMzJiaXRzIHZhbHVlcy4qL1xuRW5naW5lLlRFWFRVUkVUWVBFX1VOU0lHTkVEX0lOVCA9IDA7XG4vKiogRkxPQVQgKi9cbkVuZ2luZS5URVhUVVJFVFlQRV9GTE9BVCA9IDE7XG4vKiogSEFMRl9GTE9BVCAqL1xuRW5naW5lLlRFWFRVUkVUWVBFX0hBTEZfRkxPQVQgPSAyO1xuLyoqIEJZVEUgKi9cbkVuZ2luZS5URVhUVVJFVFlQRV9CWVRFID0gMztcbi8qKiBTSE9SVCAqL1xuRW5naW5lLlRFWFRVUkVUWVBFX1NIT1JUID0gNDtcbi8qKiBVTlNJR05FRF9TSE9SVCAqL1xuRW5naW5lLlRFWFRVUkVUWVBFX1VOU0lHTkVEX1NIT1JUID0gNTtcbi8qKiBJTlQgKi9cbkVuZ2luZS5URVhUVVJFVFlQRV9JTlQgPSA2O1xuLyoqIFVOU0lHTkVEX0lOVCAqL1xuRW5naW5lLlRFWFRVUkVUWVBFX1VOU0lHTkVEX0lOVEVHRVIgPSA3O1xuLyoqIFVOU0lHTkVEX1NIT1JUXzRfNF80XzQgKi9cbkVuZ2luZS5URVhUVVJFVFlQRV9VTlNJR05FRF9TSE9SVF80XzRfNF80ID0gODtcbi8qKiBVTlNJR05FRF9TSE9SVF81XzVfNV8xICovXG5FbmdpbmUuVEVYVFVSRVRZUEVfVU5TSUdORURfU0hPUlRfNV81XzVfMSA9IDk7XG4vKiogVU5TSUdORURfU0hPUlRfNV82XzUgKi9cbkVuZ2luZS5URVhUVVJFVFlQRV9VTlNJR05FRF9TSE9SVF81XzZfNSA9IDEwO1xuLyoqIFVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFViAqL1xuRW5naW5lLlRFWFRVUkVUWVBFX1VOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFViA9IDExO1xuLyoqIFVOU0lHTkVEX0lOVF8yNF84ICovXG5FbmdpbmUuVEVYVFVSRVRZUEVfVU5TSUdORURfSU5UXzI0XzggPSAxMjtcbi8qKiBVTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWICovXG5FbmdpbmUuVEVYVFVSRVRZUEVfVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFViA9IDEzO1xuLyoqIFVOU0lHTkVEX0lOVF81XzlfOV85X1JFViAqL1xuRW5naW5lLlRFWFRVUkVUWVBFX1VOU0lHTkVEX0lOVF81XzlfOV85X1JFViA9IDE0O1xuLyoqIEZMT0FUXzMyX1VOU0lHTkVEX0lOVF8yNF84X1JFViAqL1xuRW5naW5lLlRFWFRVUkVUWVBFX0ZMT0FUXzMyX1VOU0lHTkVEX0lOVF8yNF84X1JFViA9IDE1O1xuLyoqIG5lYXJlc3QgaXMgbWFnID0gbmVhcmVzdCBhbmQgbWluID0gbmVhcmVzdCBhbmQgbWlwID0gbm9uZSAqL1xuRW5naW5lLlRFWFRVUkVfTkVBUkVTVF9TQU1QTElOR01PREUgPSAxO1xuLyoqIEJpbGluZWFyIGlzIG1hZyA9IGxpbmVhciBhbmQgbWluID0gbGluZWFyIGFuZCBtaXAgPSBuZWFyZXN0ICovXG5FbmdpbmUuVEVYVFVSRV9CSUxJTkVBUl9TQU1QTElOR01PREUgPSAyO1xuLyoqIFRyaWxpbmVhciBpcyBtYWcgPSBsaW5lYXIgYW5kIG1pbiA9IGxpbmVhciBhbmQgbWlwID0gbGluZWFyICovXG5FbmdpbmUuVEVYVFVSRV9UUklMSU5FQVJfU0FNUExJTkdNT0RFID0gMztcbi8qKiBuZWFyZXN0IGlzIG1hZyA9IG5lYXJlc3QgYW5kIG1pbiA9IG5lYXJlc3QgYW5kIG1pcCA9IGxpbmVhciAqL1xuRW5naW5lLlRFWFRVUkVfTkVBUkVTVF9ORUFSRVNUX01JUExJTkVBUiA9IDg7XG4vKiogQmlsaW5lYXIgaXMgbWFnID0gbGluZWFyIGFuZCBtaW4gPSBsaW5lYXIgYW5kIG1pcCA9IG5lYXJlc3QgKi9cbkVuZ2luZS5URVhUVVJFX0xJTkVBUl9MSU5FQVJfTUlQTkVBUkVTVCA9IDExO1xuLyoqIFRyaWxpbmVhciBpcyBtYWcgPSBsaW5lYXIgYW5kIG1pbiA9IGxpbmVhciBhbmQgbWlwID0gbGluZWFyICovXG5FbmdpbmUuVEVYVFVSRV9MSU5FQVJfTElORUFSX01JUExJTkVBUiA9IDM7XG4vKiogbWFnID0gbmVhcmVzdCBhbmQgbWluID0gbmVhcmVzdCBhbmQgbWlwID0gbmVhcmVzdCAqL1xuRW5naW5lLlRFWFRVUkVfTkVBUkVTVF9ORUFSRVNUX01JUE5FQVJFU1QgPSA0O1xuLyoqIG1hZyA9IG5lYXJlc3QgYW5kIG1pbiA9IGxpbmVhciBhbmQgbWlwID0gbmVhcmVzdCAqL1xuRW5naW5lLlRFWFRVUkVfTkVBUkVTVF9MSU5FQVJfTUlQTkVBUkVTVCA9IDU7XG4vKiogbWFnID0gbmVhcmVzdCBhbmQgbWluID0gbGluZWFyIGFuZCBtaXAgPSBsaW5lYXIgKi9cbkVuZ2luZS5URVhUVVJFX05FQVJFU1RfTElORUFSX01JUExJTkVBUiA9IDY7XG4vKiogbWFnID0gbmVhcmVzdCBhbmQgbWluID0gbGluZWFyIGFuZCBtaXAgPSBub25lICovXG5FbmdpbmUuVEVYVFVSRV9ORUFSRVNUX0xJTkVBUiA9IDc7XG4vKiogbWFnID0gbmVhcmVzdCBhbmQgbWluID0gbmVhcmVzdCBhbmQgbWlwID0gbm9uZSAqL1xuRW5naW5lLlRFWFRVUkVfTkVBUkVTVF9ORUFSRVNUID0gMTtcbi8qKiBtYWcgPSBsaW5lYXIgYW5kIG1pbiA9IG5lYXJlc3QgYW5kIG1pcCA9IG5lYXJlc3QgKi9cbkVuZ2luZS5URVhUVVJFX0xJTkVBUl9ORUFSRVNUX01JUE5FQVJFU1QgPSA5O1xuLyoqIG1hZyA9IGxpbmVhciBhbmQgbWluID0gbmVhcmVzdCBhbmQgbWlwID0gbGluZWFyICovXG5FbmdpbmUuVEVYVFVSRV9MSU5FQVJfTkVBUkVTVF9NSVBMSU5FQVIgPSAxMDtcbi8qKiBtYWcgPSBsaW5lYXIgYW5kIG1pbiA9IGxpbmVhciBhbmQgbWlwID0gbm9uZSAqL1xuRW5naW5lLlRFWFRVUkVfTElORUFSX0xJTkVBUiA9IDI7XG4vKiogbWFnID0gbGluZWFyIGFuZCBtaW4gPSBuZWFyZXN0IGFuZCBtaXAgPSBub25lICovXG5FbmdpbmUuVEVYVFVSRV9MSU5FQVJfTkVBUkVTVCA9IDEyO1xuLyoqIEV4cGxpY2l0IGNvb3JkaW5hdGVzIG1vZGUgKi9cbkVuZ2luZS5URVhUVVJFX0VYUExJQ0lUX01PREUgPSAwO1xuLyoqIFNwaGVyaWNhbCBjb29yZGluYXRlcyBtb2RlICovXG5FbmdpbmUuVEVYVFVSRV9TUEhFUklDQUxfTU9ERSA9IDE7XG4vKiogUGxhbmFyIGNvb3JkaW5hdGVzIG1vZGUgKi9cbkVuZ2luZS5URVhUVVJFX1BMQU5BUl9NT0RFID0gMjtcbi8qKiBDdWJpYyBjb29yZGluYXRlcyBtb2RlICovXG5FbmdpbmUuVEVYVFVSRV9DVUJJQ19NT0RFID0gMztcbi8qKiBQcm9qZWN0aW9uIGNvb3JkaW5hdGVzIG1vZGUgKi9cbkVuZ2luZS5URVhUVVJFX1BST0pFQ1RJT05fTU9ERSA9IDQ7XG4vKiogU2t5Ym94IGNvb3JkaW5hdGVzIG1vZGUgKi9cbkVuZ2luZS5URVhUVVJFX1NLWUJPWF9NT0RFID0gNTtcbi8qKiBJbnZlcnNlIEN1YmljIGNvb3JkaW5hdGVzIG1vZGUgKi9cbkVuZ2luZS5URVhUVVJFX0lOVkNVQklDX01PREUgPSA2O1xuLyoqIEVxdWlyZWN0YW5ndWxhciBjb29yZGluYXRlcyBtb2RlICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FbmdpbmUuVEVYVFVSRV9FUVVJUkVDVEFOR1VMQVJfTU9ERSA9IDc7XG4vKiogRXF1aXJlY3Rhbmd1bGFyIEZpeGVkIGNvb3JkaW5hdGVzIG1vZGUgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVuZ2luZS5URVhUVVJFX0ZJWEVEX0VRVUlSRUNUQU5HVUxBUl9NT0RFID0gODtcbi8qKiBFcXVpcmVjdGFuZ3VsYXIgRml4ZWQgTWlycm9yZWQgY29vcmRpbmF0ZXMgbW9kZSAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRW5naW5lLlRFWFRVUkVfRklYRURfRVFVSVJFQ1RBTkdVTEFSX01JUlJPUkVEX01PREUgPSA5O1xuLy8gVGV4dHVyZSByZXNjYWxpbmcgbW9kZVxuLyoqIERlZmluZXMgdGhhdCB0ZXh0dXJlIHJlc2NhbGluZyB3aWxsIHVzZSBhIGZsb29yIHRvIGZpbmQgdGhlIGNsb3NlciBwb3dlciBvZiAyIHNpemUgKi9cbkVuZ2luZS5TQ0FMRU1PREVfRkxPT1IgPSAxO1xuLyoqIERlZmluZXMgdGhhdCB0ZXh0dXJlIHJlc2NhbGluZyB3aWxsIGxvb2sgZm9yIHRoZSBuZWFyZXN0IHBvd2VyIG9mIDIgc2l6ZSAqL1xuRW5naW5lLlNDQUxFTU9ERV9ORUFSRVNUID0gMjtcbi8qKiBEZWZpbmVzIHRoYXQgdGV4dHVyZSByZXNjYWxpbmcgd2lsbCB1c2UgYSBjZWlsIHRvIGZpbmQgdGhlIGNsb3NlciBwb3dlciBvZiAyIHNpemUgKi9cbkVuZ2luZS5TQ0FMRU1PREVfQ0VJTElORyA9IDM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmdpbmUuanMubWFwIiwiXG5pbXBvcnQgeyBIYXNTdGVuY2lsQXNwZWN0IH0gZnJvbSBcIi4uL01hdGVyaWFscy9UZXh0dXJlcy90ZXh0dXJlSGVscGVyLmZ1bmN0aW9ucy5qc1wiO1xuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBhIHJlbmRlciB0YXJnZXQgKGVpdGhlciBzaW5nbGUgb3IgbXVsdGkgdGV4dHVyZXMpXG4gKi9cbmV4cG9ydCBjbGFzcyBSZW5kZXJUYXJnZXRXcmFwcGVyIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZXB0aC9zdGVuY2lsIHRleHR1cmVcbiAgICAgKi9cbiAgICBnZXQgZGVwdGhTdGVuY2lsVGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlcHRoL3N0ZW5jaWwgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIFRoZSBkZXB0aC9zdGVuY2lsIHRleHR1cmUgdG8gc2V0XG4gICAgICogQHBhcmFtIGRpc3Bvc2VFeGlzdGluZyBUcnVlIHRvIGRpc3Bvc2UgdGhlIGV4aXN0aW5nIGRlcHRoL3N0ZW5jaWwgdGV4dHVyZSAoaWYgYW55KSBiZWZvcmUgcmVwbGFjaW5nIGl0IChkZWZhdWx0OiB0cnVlKVxuICAgICAqL1xuICAgIHNldERlcHRoU3RlbmNpbFRleHR1cmUodGV4dHVyZSwgZGlzcG9zZUV4aXN0aW5nID0gdHJ1ZSkge1xuICAgICAgICBpZiAoZGlzcG9zZUV4aXN0aW5nICYmIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICB0aGlzLl9nZW5lcmF0ZURlcHRoQnVmZmVyID0gdGhpcy5fZ2VuZXJhdGVTdGVuY2lsQnVmZmVyID0gdGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZVdpdGhTdGVuY2lsID0gZmFsc2U7XG4gICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZURlcHRoQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlU3RlbmNpbEJ1ZmZlciA9IHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmVXaXRoU3RlbmNpbCA9IEhhc1N0ZW5jaWxBc3BlY3QodGV4dHVyZS5mb3JtYXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgZGVwdGgvc3RlbmNpbCB0ZXh0dXJlIGhhcyBhIHN0ZW5jaWwgYXNwZWN0XG4gICAgICovXG4gICAgZ2V0IGRlcHRoU3RlbmNpbFRleHR1cmVXaXRoU3RlbmNpbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmVXaXRoU3RlbmNpbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBpZiB0aGUgcmVuZGVyIHRhcmdldCB3cmFwcGVyIGlzIGZvciBhIGN1YmUgdGV4dHVyZSBvciBpZiBmYWxzZSBhIDJkIHRleHR1cmVcbiAgICAgKi9cbiAgICBnZXQgaXNDdWJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDdWJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGlmIHRoZSByZW5kZXIgdGFyZ2V0IHdyYXBwZXIgaXMgZm9yIGEgc2luZ2xlIG9yIG11bHRpIHRhcmdldCByZW5kZXIgd3JhcHBlclxuICAgICAqL1xuICAgIGdldCBpc011bHRpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNNdWx0aTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBpZiB0aGUgcmVuZGVyIHRhcmdldCB3cmFwcGVyIGlzIGZvciBhIHNpbmdsZSBvciBhbiBhcnJheSBvZiB0ZXh0dXJlc1xuICAgICAqL1xuICAgIGdldCBpczJEQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVycyA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgaWYgdGhlIHJlbmRlciB0YXJnZXQgd3JhcHBlciBpcyBmb3IgYSAzRCB0ZXh0dXJlXG4gICAgICovXG4gICAgZ2V0IGlzM0QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHRoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgcmVuZGVyIHRhcmdldCB3cmFwcGVyICh1c2VkIGZvciBjdWJlcywgYXMgd2lkdGg9aGVpZ2h0IGluIHRoaXMgY2FzZSlcbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSByZW5kZXIgdGFyZ2V0IHdyYXBwZXJcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplLndpZHRoID8/IHRoaXMuX3NpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRhcmdldCB3cmFwcGVyXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemUuaGVpZ2h0ID8/IHRoaXMuX3NpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBsYXllcnMgb2YgdGhlIHJlbmRlciB0YXJnZXQgd3JhcHBlciAob25seSB1c2VkIGlmIGlzMkRBcnJheSBpcyB0cnVlIGFuZCB3cmFwcGVyIGlzIG5vdCBhIG11bHRpIHJlbmRlciB0YXJnZXQpXG4gICAgICovXG4gICAgZ2V0IGxheWVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemUubGF5ZXJzIHx8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlcHRoIG9mIHRoZSByZW5kZXIgdGFyZ2V0IHdyYXBwZXIgKG9ubHkgdXNlZCBpZiBpczNEIGlzIHRydWUgYW5kIHdyYXBwZXIgaXMgbm90IGEgbXVsdGkgcmVuZGVyIHRhcmdldClcbiAgICAgKi9cbiAgICBnZXQgZGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplLmRlcHRoIHx8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlbmRlciB0ZXh0dXJlLiBJZiB0aGlzIGlzIGEgbXVsdGkgcmVuZGVyIHRhcmdldCwgZ2V0cyB0aGUgZmlyc3QgdGV4dHVyZVxuICAgICAqL1xuICAgIGdldCB0ZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZXM/LlswXSA/PyBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IG9mIHJlbmRlciB0ZXh0dXJlcy4gSWYgd2UgYXJlIG5vdCBpbiBhIG11bHRpIHJlbmRlciB0YXJnZXQsIHRoZSBsaXN0IHdpbGwgYmUgbnVsbCAodXNlIHRoZSB0ZXh0dXJlIGdldHRlciBpbnN0ZWFkKVxuICAgICAqL1xuICAgIGdldCB0ZXh0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmYWNlIGluZGljZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBsaXN0IG9mIHJlbmRlciB0ZXh0dXJlcy4gSWYgd2UgYXJlIG5vdCBpbiBhIG11bHRpIHJlbmRlciB0YXJnZXQsIHRoZSBsaXN0IHdpbGwgYmUgbnVsbFxuICAgICAqL1xuICAgIGdldCBmYWNlSW5kaWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhY2VJbmRpY2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXllciBpbmRpY2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgbGlzdCBvZiByZW5kZXIgdGV4dHVyZXMuIElmIHdlIGFyZSBub3QgaW4gYSBtdWx0aSByZW5kZXIgdGFyZ2V0LCB0aGUgbGlzdCB3aWxsIGJlIG51bGxcbiAgICAgKi9cbiAgICBnZXQgbGF5ZXJJbmRpY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJJbmRpY2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBiYXNlIGFycmF5IGxheWVyIG9mIGEgdGV4dHVyZSBpbiB0aGUgdGV4dHVyZXMgYXJyYXlcbiAgICAgKiBUaGlzIGlzIGFuIG51bWJlciB0aGF0IGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGxheWVyIGFuZCBmYWNlIGluZGljZXMgc2V0IGZvciB0aGlzIHRleHR1cmUgYXQgdGhhdCBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRleHR1cmUgaW4gdGhlIHRleHR1cmVzIGFycmF5IHRvIGdldCB0aGUgYmFzZSBhcnJheSBsYXllciBmb3JcbiAgICAgKiBAcmV0dXJucyB0aGUgYmFzZSBhcnJheSBsYXllciBvZiB0aGUgdGV4dHVyZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICAgKi9cbiAgICBnZXRCYXNlQXJyYXlMYXllcihpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmVzW2luZGV4XTtcbiAgICAgICAgY29uc3QgbGF5ZXJJbmRleCA9IHRoaXMuX2xheWVySW5kaWNlcz8uW2luZGV4XSA/PyAwO1xuICAgICAgICBjb25zdCBmYWNlSW5kZXggPSB0aGlzLl9mYWNlSW5kaWNlcz8uW2luZGV4XSA/PyAwO1xuICAgICAgICByZXR1cm4gdGV4dHVyZS5pc0N1YmUgPyBsYXllckluZGV4ICogNiArIGZhY2VJbmRleCA6IHRleHR1cmUuaXMzRCA/IDAgOiBsYXllckluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzYW1wbGUgY291bnQgb2YgdGhlIHJlbmRlciB0YXJnZXRcbiAgICAgKi9cbiAgICBnZXQgc2FtcGxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhbXBsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNhbXBsZSBjb3VudCBvZiB0aGUgcmVuZGVyIHRhcmdldFxuICAgICAqIEBwYXJhbSB2YWx1ZSBzYW1wbGUgY291bnRcbiAgICAgKiBAcGFyYW0gaW5pdGlhbGl6ZUJ1ZmZlcnMgSWYgc2V0IHRvIHRydWUsIHRoZSBlbmdpbmUgd2lsbCBtYWtlIGFuIGluaXRpYWxpemluZyBjYWxsIHRvIGRyYXdCdWZmZXJzIChvbmx5IHVzZWQgd2hlbiBpc011bHRpPXRydWUpLlxuICAgICAqIEBwYXJhbSBmb3JjZSB0cnVlIHRvIGZvcmNlIGNhbGxpbmcgdGhlIHVwZGF0ZSBzYW1wbGUgY291bnQgZW5naW5lIGZ1bmN0aW9uIGV2ZW4gaWYgdGhlIGN1cnJlbnQgc2FtcGxlIGNvdW50IGlzIGVxdWFsIHRvIHZhbHVlXG4gICAgICogQHJldHVybnMgdGhlIHNhbXBsZSBjb3VudCB0aGF0IGhhcyBiZWVuIHNldFxuICAgICAqL1xuICAgIHNldFNhbXBsZXModmFsdWUsIGluaXRpYWxpemVCdWZmZXJzID0gdHJ1ZSwgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5zYW1wbGVzID09PSB2YWx1ZSAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9pc011bHRpXG4gICAgICAgICAgICA/IHRoaXMuX2VuZ2luZS51cGRhdGVNdWx0aXBsZVJlbmRlclRhcmdldFRleHR1cmVTYW1wbGVDb3VudCh0aGlzLCB2YWx1ZSwgaW5pdGlhbGl6ZUJ1ZmZlcnMpXG4gICAgICAgICAgICA6IHRoaXMuX2VuZ2luZS51cGRhdGVSZW5kZXJUYXJnZXRUZXh0dXJlU2FtcGxlQ291bnQodGhpcywgdmFsdWUpO1xuICAgICAgICB0aGlzLl9zYW1wbGVzID0gdmFsdWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBNU0FBIHRleHR1cmVzIGludG8gdGhlaXIgbm9uLU1TQUEgdmVyc2lvbi5cbiAgICAgKiBOb3RlIHRoYXQgaWYgc2FtcGxlcyBlcXVhbHMgMSAobm8gTVNBQSksIG5vIHJlc29sdmUgaXMgcGVyZm9ybWVkLlxuICAgICAqL1xuICAgIHJlc29sdmVNU0FBVGV4dHVyZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTXVsdGkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5yZXNvbHZlTXVsdGlGcmFtZWJ1ZmZlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5yZXNvbHZlRnJhbWVidWZmZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIG1pcG1hcHMgZm9yIGVhY2ggdGV4dHVyZSBvZiB0aGUgcmVuZGVyIHRhcmdldFxuICAgICAqL1xuICAgIGdlbmVyYXRlTWlwTWFwcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VuZ2luZS5fY3VycmVudFJlbmRlclRhcmdldCA9PT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnVuQmluZEZyYW1lYnVmZmVyKHRoaXMsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzTXVsdGkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5nZW5lcmF0ZU1pcE1hcHNNdWx0aUZyYW1lYnVmZmVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lLmdlbmVyYXRlTWlwTWFwc0ZyYW1lYnVmZmVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSByZW5kZXIgdGFyZ2V0IHdyYXBwZXJcbiAgICAgKiBAcGFyYW0gaXNNdWx0aSB0cnVlIGlmIHRoZSB3cmFwcGVyIGlzIGEgbXVsdGkgcmVuZGVyIHRhcmdldFxuICAgICAqIEBwYXJhbSBpc0N1YmUgdHJ1ZSBpZiB0aGUgd3JhcHBlciBzaG91bGQgcmVuZGVyIHRvIGEgY3ViZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHNpemUgc2l6ZSBvZiB0aGUgcmVuZGVyIHRhcmdldCAod2lkdGgvaGVpZ2h0L2xheWVycylcbiAgICAgKiBAcGFyYW0gZW5naW5lIGVuZ2luZSB1c2VkIHRvIGNyZWF0ZSB0aGUgcmVuZGVyIHRhcmdldFxuICAgICAqIEBwYXJhbSBsYWJlbCBkZWZpbmVzIHRoZSBsYWJlbCB0byB1c2UgZm9yIHRoZSB3cmFwcGVyIChmb3IgZGVidWdnaW5nIHB1cnBvc2Ugb25seSlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihpc011bHRpLCBpc0N1YmUsIHNpemUsIGVuZ2luZSwgbGFiZWwpIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9mYWNlSW5kaWNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVySW5kaWNlcyA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fc2FtcGxlcyA9IDE7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fYXR0YWNobWVudHMgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2dlbmVyYXRlU3RlbmNpbEJ1ZmZlciA9IGZhbHNlO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2dlbmVyYXRlRGVwdGhCdWZmZXIgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9kZXB0aFN0ZW5jaWxUZXh0dXJlV2l0aFN0ZW5jaWwgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhpcyBwcm9wZXJ0eSB0byB0cnVlIHRvIGRpc2FibGUgdGhlIGF1dG9tYXRpYyBNU0FBIHJlc29sdmUgdGhhdCBoYXBwZW5zIHdoZW4gdGhlIHJlbmRlciB0YXJnZXQgd3JhcHBlciBpcyB1bmJvdW5kIChkZWZhdWx0IGlzIGZhbHNlKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlQXV0b21hdGljTVNBQVJlc29sdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyBpZiBNU0FBIGNvbG9yIHRleHR1cmUocykgc2hvdWxkIGJlIHJlc29sdmVkIHdoZW4gYSByZXNvbHZlIG9jY3VyIChlaXRoZXIgYXV0b21hdGljYWxseSBieSB0aGUgZW5naW5lIG9yIG1hbnVhbGx5IGJ5IHRoZSB1c2VyKSAoZGVmYXVsdCBpcyB0cnVlKVxuICAgICAgICAgKiBOb3RlIHRoYXQgeW91IGNhbiB0cmlnZ2VyIGEgTVNBQSByZXNvbHZlIGF0IGFueSB0aW1lIGJ5IGNhbGxpbmcgcmVzb2x2ZU1TQUFUZXh0dXJlcygpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc29sdmVNU0FBQ29sb3JzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyBpZiBNU0FBIGRlcHRoIHRleHR1cmUgc2hvdWxkIGJlIHJlc29sdmVkIHdoZW4gYSByZXNvbHZlIG9jY3VyIChlaXRoZXIgYXV0b21hdGljYWxseSBieSB0aGUgZW5naW5lIG9yIG1hbnVhbGx5IGJ5IHRoZSB1c2VyKSAoZGVmYXVsdCBpcyBmYWxzZSlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb2x2ZU1TQUFEZXB0aCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIE1TQUEgc3RlbmNpbCB0ZXh0dXJlIHNob3VsZCBiZSByZXNvbHZlZCB3aGVuIGEgcmVzb2x2ZSBvY2N1ciAoZWl0aGVyIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGVuZ2luZSBvciBtYW51YWxseSBieSB0aGUgdXNlcikgKGRlZmF1bHQgaXMgZmFsc2UpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc29sdmVNU0FBU3RlbmNpbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc011bHRpID0gaXNNdWx0aTtcbiAgICAgICAgdGhpcy5faXNDdWJlID0gaXNDdWJlO1xuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICB0aGlzLl9kZXB0aFN0ZW5jaWxUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZW5kZXIgdGFyZ2V0IHRleHR1cmUocylcbiAgICAgKiBAcGFyYW0gdGV4dHVyZXMgdGV4dHVyZShzKSB0byBzZXRcbiAgICAgKi9cbiAgICBzZXRUZXh0dXJlcyh0ZXh0dXJlcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0dXJlcykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzID0gdGV4dHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dHVyZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzID0gW3RleHR1cmVzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSB0ZXh0dXJlIGluIHRoZSB0ZXh0dXJlcyBhcnJheVxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIFRoZSB0ZXh0dXJlIHRvIHNldFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggaW4gdGhlIHRleHR1cmVzIGFycmF5IHRvIHNldFxuICAgICAqIEBwYXJhbSBkaXNwb3NlUHJldmlvdXMgSWYgdGhpcyBmdW5jdGlvbiBzaG91bGQgZGlzcG9zZSB0aGUgcHJldmlvdXMgdGV4dHVyZVxuICAgICAqL1xuICAgIHNldFRleHR1cmUodGV4dHVyZSwgaW5kZXggPSAwLCBkaXNwb3NlUHJldmlvdXMgPSB0cnVlKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dHVyZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmVzW2luZGV4XSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlc1tpbmRleF0gJiYgZGlzcG9zZVByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlc1tpbmRleF0uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RleHR1cmVzW2luZGV4XSA9IHRleHR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxheWVyIGFuZCBmYWNlIGluZGljZXMgb2YgZXZlcnkgcmVuZGVyIHRhcmdldCB0ZXh0dXJlIGJvdW5kIHRvIGVhY2ggY29sb3IgYXR0YWNobWVudFxuICAgICAqIEBwYXJhbSBsYXllcnMgVGhlIGxheWVycyBvZiBlYWNoIHRleHR1cmUgdG8gYmUgc2V0XG4gICAgICogQHBhcmFtIGZhY2VzIFRoZSBmYWNlcyBvZiBlYWNoIHRleHR1cmUgdG8gYmUgc2V0XG4gICAgICovXG4gICAgc2V0TGF5ZXJBbmRGYWNlSW5kaWNlcyhsYXllcnMsIGZhY2VzKSB7XG4gICAgICAgIHRoaXMuX2xheWVySW5kaWNlcyA9IGxheWVycztcbiAgICAgICAgdGhpcy5fZmFjZUluZGljZXMgPSBmYWNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGF5ZXIgYW5kIGZhY2UgaW5kaWNlcyBvZiBhIHRleHR1cmUgaW4gdGhlIHRleHR1cmVzIGFycmF5IHRoYXQgc2hvdWxkIGJlIGJvdW5kIHRvIGVhY2ggY29sb3IgYXR0YWNobWVudFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRleHR1cmUgaW4gdGhlIHRleHR1cmVzIGFycmF5IHRvIG1vZGlmeVxuICAgICAqIEBwYXJhbSBsYXllciBUaGUgbGF5ZXIgb2YgdGhlIHRleHR1cmUgdG8gYmUgc2V0XG4gICAgICogQHBhcmFtIGZhY2UgVGhlIGZhY2Ugb2YgdGhlIHRleHR1cmUgdG8gYmUgc2V0XG4gICAgICovXG4gICAgc2V0TGF5ZXJBbmRGYWNlSW5kZXgoaW5kZXggPSAwLCBsYXllciwgZmFjZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xheWVySW5kaWNlcykge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJJbmRpY2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9mYWNlSW5kaWNlcykge1xuICAgICAgICAgICAgdGhpcy5fZmFjZUluZGljZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5ZXIgIT09IHVuZGVmaW5lZCAmJiBsYXllciA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllckluZGljZXNbaW5kZXhdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhY2UgIT09IHVuZGVmaW5lZCAmJiBmYWNlID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2ZhY2VJbmRpY2VzW2luZGV4XSA9IGZhY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZGVwdGgvc3RlbmNpbCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGNvbXBhcmlzb25GdW5jdGlvbiBDb21wYXJpc29uIGZ1bmN0aW9uIHRvIHVzZSBmb3IgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gYmlsaW5lYXJGaWx0ZXJpbmcgdHJ1ZSBpZiBiaWxpbmVhciBmaWx0ZXJpbmcgc2hvdWxkIGJlIHVzZWQgd2hlbiBzYW1wbGluZyB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBnZW5lcmF0ZVN0ZW5jaWwgTm90IHVzZWQgYW55bW9yZS4gXCJmb3JtYXRcIiB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHN0ZW5jaWwgc2hvdWxkIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0gc2FtcGxlcyBzYW1wbGUgY291bnQgdG8gdXNlIHdoZW4gY3JlYXRpbmcgdGhlIHRleHR1cmUgKGRlZmF1bHQ6IDEpXG4gICAgICogQHBhcmFtIGZvcm1hdCBmb3JtYXQgb2YgdGhlIGRlcHRoIHRleHR1cmUgKGRlZmF1bHQ6IDE0KVxuICAgICAqIEBwYXJhbSBsYWJlbCBkZWZpbmVzIHRoZSBsYWJlbCB0byB1c2UgZm9yIHRoZSB0ZXh0dXJlIChmb3IgZGVidWdnaW5nIHB1cnBvc2Ugb25seSlcbiAgICAgKiBAcmV0dXJucyB0aGUgZGVwdGgvc3RlbmNpbCBjcmVhdGVkIHRleHR1cmVcbiAgICAgKi9cbiAgICBjcmVhdGVEZXB0aFN0ZW5jaWxUZXh0dXJlKGNvbXBhcmlzb25GdW5jdGlvbiA9IDAsIGJpbGluZWFyRmlsdGVyaW5nID0gdHJ1ZSwgZ2VuZXJhdGVTdGVuY2lsID0gZmFsc2UsIHNhbXBsZXMgPSAxLCBmb3JtYXQgPSAxNCwgbGFiZWwpIHtcbiAgICAgICAgdGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZT8uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9kZXB0aFN0ZW5jaWxUZXh0dXJlV2l0aFN0ZW5jaWwgPSBnZW5lcmF0ZVN0ZW5jaWw7XG4gICAgICAgIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmVMYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLl9kZXB0aFN0ZW5jaWxUZXh0dXJlID0gdGhpcy5fZW5naW5lLmNyZWF0ZURlcHRoU3RlbmNpbFRleHR1cmUodGhpcy5fc2l6ZSwge1xuICAgICAgICAgICAgYmlsaW5lYXJGaWx0ZXJpbmcsXG4gICAgICAgICAgICBjb21wYXJpc29uRnVuY3Rpb24sXG4gICAgICAgICAgICBnZW5lcmF0ZVN0ZW5jaWwsXG4gICAgICAgICAgICBpc0N1YmU6IHRoaXMuX2lzQ3ViZSxcbiAgICAgICAgICAgIHNhbXBsZXMsXG4gICAgICAgICAgICBkZXB0aFRleHR1cmVGb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBzaGFyZURlcHRoIGluc3RlYWRcbiAgICAgKiBAcGFyYW0gcmVuZGVyVGFyZ2V0IERlc3RpbmF0aW9uIHJlbmRlclRhcmdldFxuICAgICAqL1xuICAgIF9zaGFyZURlcHRoKHJlbmRlclRhcmdldCkge1xuICAgICAgICB0aGlzLnNoYXJlRGVwdGgocmVuZGVyVGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hhcmVzIHRoZSBkZXB0aCBidWZmZXIgb2YgdGhpcyByZW5kZXIgdGFyZ2V0IHdpdGggYW5vdGhlciByZW5kZXIgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSByZW5kZXJUYXJnZXQgRGVzdGluYXRpb24gcmVuZGVyVGFyZ2V0XG4gICAgICovXG4gICAgc2hhcmVEZXB0aChyZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmUpIHtcbiAgICAgICAgICAgIGlmIChyZW5kZXJUYXJnZXQuX2RlcHRoU3RlbmNpbFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXQuX2RlcHRoU3RlbmNpbFRleHR1cmUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0Ll9kZXB0aFN0ZW5jaWxUZXh0dXJlID0gdGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZTtcbiAgICAgICAgICAgIHJlbmRlclRhcmdldC5fZGVwdGhTdGVuY2lsVGV4dHVyZVdpdGhTdGVuY2lsID0gdGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZVdpdGhTdGVuY2lsO1xuICAgICAgICAgICAgdGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZS5pbmNyZW1lbnRSZWZlcmVuY2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3N3YXBBbmREaWUodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS5fc3dhcEFuZERpZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RleHR1cmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwb3NlKHRydWUpO1xuICAgIH1cbiAgICBfY2xvbmVSZW5kZXJUYXJnZXRXcmFwcGVyKCkge1xuICAgICAgICBsZXQgcnR3ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX2lzTXVsdGkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmVBcnJheSA9IHRoaXMudGV4dHVyZXM7XG4gICAgICAgICAgICBpZiAodGV4dHVyZUFycmF5ICYmIHRleHR1cmVBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdlbmVyYXRlRGVwdGhUZXh0dXJlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHRleHR1cmVDb3VudCA9IHRleHR1cmVBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGRlcHRoVGV4dHVyZUZvcm1hdCA9IC0xO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RUZXh0dXJlU291cmNlID0gdGV4dHVyZUFycmF5W3RleHR1cmVBcnJheS5sZW5ndGggLSAxXS5fc291cmNlO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VGV4dHVyZVNvdXJjZSA9PT0gMTQgLyogSW50ZXJuYWxUZXh0dXJlU291cmNlLkRlcHRoICovIHx8IGxhc3RUZXh0dXJlU291cmNlID09PSAxMiAvKiBJbnRlcm5hbFRleHR1cmVTb3VyY2UuRGVwdGhTdGVuY2lsICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRGVwdGhUZXh0dXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGhUZXh0dXJlRm9ybWF0ID0gdGV4dHVyZUFycmF5W3RleHR1cmVBcnJheS5sZW5ndGggLSAxXS5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVDb3VudC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzYW1wbGluZ01vZGVzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXRzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VHlwZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWNlSW5kZXggPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllckluZGV4ID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJDb3VudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbFRleHR1cmUySW5kZXggPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHR1cmVDb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSB0ZXh0dXJlQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsaW5nTW9kZXMucHVzaCh0ZXh0dXJlLnNhbXBsaW5nTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2godGV4dHVyZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0cy5wdXNoKHRleHR1cmUuZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpbnRlcm5hbFRleHR1cmUySW5kZXhbdGV4dHVyZS51bmlxdWVJZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRUeXBlcy5wdXNoKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyQ291bnRzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUySW5kZXhbdGV4dHVyZS51bmlxdWVJZF0gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHR1cmUuaXMyREFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VHlwZXMucHVzaCgzNTg2Nik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb3VudHMucHVzaCh0ZXh0dXJlLmRlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHR1cmUuaXNDdWJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VHlwZXMucHVzaCgzNDA2Nyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb3VudHMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLyplbHNlIGlmICh0ZXh0dXJlLmlzQ3ViZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VHlwZXMucHVzaCgzNzM1OTI4NTU5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllckNvdW50cy5wdXNoKHRleHR1cmUuZGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ZXh0dXJlLmlzM0QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRUeXBlcy5wdXNoKDMyODc5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllckNvdW50cy5wdXNoKHRleHR1cmUuZGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VHlwZXMucHVzaCgzNTUzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllckNvdW50cy5wdXNoKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mYWNlSW5kaWNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4LnB1c2godGhpcy5fZmFjZUluZGljZXNbaV0gPz8gMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVySW5kaWNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJbmRleC5wdXNoKHRoaXMuX2xheWVySW5kaWNlc1tpXSA/PyAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zTVJUID0ge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGluZ01vZGVzLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pcE1hcHM6IHRleHR1cmVBcnJheVswXS5nZW5lcmF0ZU1pcE1hcHMsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRGVwdGhCdWZmZXI6IHRoaXMuX2dlbmVyYXRlRGVwdGhCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlU3RlbmNpbEJ1ZmZlcjogdGhpcy5fZ2VuZXJhdGVTdGVuY2lsQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZURlcHRoVGV4dHVyZSxcbiAgICAgICAgICAgICAgICAgICAgZGVwdGhUZXh0dXJlRm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0cyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50LFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRUeXBlcyxcbiAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBsYXllckluZGV4LFxuICAgICAgICAgICAgICAgICAgICBsYXllckNvdW50cyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMubGFiZWwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgZGVwdGg6IHRoaXMuZGVwdGgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBydHcgPSB0aGlzLl9lbmdpbmUuY3JlYXRlTXVsdGlwbGVSZW5kZXJUYXJnZXQoc2l6ZSwgb3B0aW9uc01SVCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0VHlwZXNbaV0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGludGVybmFsVGV4dHVyZTJJbmRleFt0ZXh0dXJlQXJyYXlbaV0udW5pcXVlSWRdO1xuICAgICAgICAgICAgICAgICAgICBydHcuc2V0VGV4dHVyZShydHcudGV4dHVyZXNbaW5kZXhdLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgICAgICBvcHRpb25zLmdlbmVyYXRlRGVwdGhCdWZmZXIgPSB0aGlzLl9nZW5lcmF0ZURlcHRoQnVmZmVyO1xuICAgICAgICAgICAgb3B0aW9ucy5nZW5lcmF0ZU1pcE1hcHMgPSB0aGlzLnRleHR1cmU/LmdlbmVyYXRlTWlwTWFwcyA/PyBmYWxzZTtcbiAgICAgICAgICAgIG9wdGlvbnMuZ2VuZXJhdGVTdGVuY2lsQnVmZmVyID0gdGhpcy5fZ2VuZXJhdGVTdGVuY2lsQnVmZmVyO1xuICAgICAgICAgICAgb3B0aW9ucy5zYW1wbGluZ01vZGUgPSB0aGlzLnRleHR1cmU/LnNhbXBsaW5nTW9kZTtcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9IHRoaXMudGV4dHVyZT8udHlwZTtcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gdGhpcy50ZXh0dXJlPy5mb3JtYXQ7XG4gICAgICAgICAgICBvcHRpb25zLm5vQ29sb3JBdHRhY2htZW50ID0gIXRoaXMuX3RleHR1cmVzO1xuICAgICAgICAgICAgb3B0aW9ucy5sYWJlbCA9IHRoaXMubGFiZWw7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0N1YmUpIHtcbiAgICAgICAgICAgICAgICBydHcgPSB0aGlzLl9lbmdpbmUuY3JlYXRlUmVuZGVyVGFyZ2V0Q3ViZVRleHR1cmUodGhpcy53aWR0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJzOiB0aGlzLmlzMkRBcnJheSB8fCB0aGlzLmlzM0QgPyB0aGlzLnRleHR1cmU/LmRlcHRoIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcnR3ID0gdGhpcy5fZW5naW5lLmNyZWF0ZVJlbmRlclRhcmdldFRleHR1cmUoc2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnR3LnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBydHcudGV4dHVyZS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnR3O1xuICAgIH1cbiAgICBfc3dhcFJlbmRlclRhcmdldFdyYXBwZXIodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlcyAmJiB0YXJnZXQuX3RleHR1cmVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RleHR1cmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXNbaV0uX3N3YXBBbmREaWUodGFyZ2V0Ll90ZXh0dXJlc1tpXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5fdGV4dHVyZXNbaV0uaXNSZWFkeSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmUgJiYgdGFyZ2V0Ll9kZXB0aFN0ZW5jaWxUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXB0aFN0ZW5jaWxUZXh0dXJlLl9zd2FwQW5kRGllKHRhcmdldC5fZGVwdGhTdGVuY2lsVGV4dHVyZSk7XG4gICAgICAgICAgICB0YXJnZXQuX2RlcHRoU3RlbmNpbFRleHR1cmUuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZXB0aFN0ZW5jaWxUZXh0dXJlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9yZWJ1aWxkKCkge1xuICAgICAgICBjb25zdCBydHcgPSB0aGlzLl9jbG9uZVJlbmRlclRhcmdldFdyYXBwZXIoKTtcbiAgICAgICAgaWYgKCFydHcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZSkge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxpbmdNb2RlID0gdGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZS5zYW1wbGluZ01vZGU7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLl9kZXB0aFN0ZW5jaWxUZXh0dXJlLmZvcm1hdDtcbiAgICAgICAgICAgIGNvbnN0IGJpbGluZWFyID0gc2FtcGxpbmdNb2RlID09PSAyIHx8XG4gICAgICAgICAgICAgICAgc2FtcGxpbmdNb2RlID09PSAzIHx8XG4gICAgICAgICAgICAgICAgc2FtcGxpbmdNb2RlID09PSAxMTtcbiAgICAgICAgICAgIHJ0dy5jcmVhdGVEZXB0aFN0ZW5jaWxUZXh0dXJlKHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmUuX2NvbXBhcmlzb25GdW5jdGlvbiwgYmlsaW5lYXIsIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmVXaXRoU3RlbmNpbCwgdGhpcy5fZGVwdGhTdGVuY2lsVGV4dHVyZS5zYW1wbGVzLCBmb3JtYXQsIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmVMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2FtcGxlcyA+IDEpIHtcbiAgICAgICAgICAgIHJ0dy5zZXRTYW1wbGVzKHRoaXMuc2FtcGxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcnR3Ll9zd2FwUmVuZGVyVGFyZ2V0V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcnR3LmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgdGhlIGludGVybmFsIHJlbmRlciB0ZXh0dXJlc1xuICAgICAqL1xuICAgIHJlbGVhc2VUZXh0dXJlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RleHR1cmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXNbaV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RleHR1cmVzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgdGhlIHdob2xlIHJlbmRlciB0YXJnZXQgd3JhcHBlclxuICAgICAqIEBwYXJhbSBkaXNwb3NlT25seUZyYW1lYnVmZmVycyB0cnVlIGlmIG9ubHkgdGhlIGZyYW1lIGJ1ZmZlcnMgc2hvdWxkIGJlIHJlbGVhc2VkICh1c2VkIGZvciB0aGUgV2ViR0wgZW5naW5lKS4gSWYgZmFsc2UsIGFsbCB0aGUgdGV4dHVyZXMgd2lsbCBhbHNvIGJlIHJlbGVhc2VkXG4gICAgICovXG4gICAgZGlzcG9zZShkaXNwb3NlT25seUZyYW1lYnVmZmVycyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghZGlzcG9zZU9ubHlGcmFtZWJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoU3RlbmNpbFRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlVGV4dHVyZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbmdpbmUuX3JlbGVhc2VSZW5kZXJUYXJnZXRXcmFwcGVyKHRoaXMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlclRhcmdldFdyYXBwZXIuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlUGlwZWxpbmVDb250ZXh0LCBjcmVhdGVSYXdTaGFkZXJQcm9ncmFtLCBjcmVhdGVTaGFkZXJQcm9ncmFtLCBfZmluYWxpemVQaXBlbGluZUNvbnRleHQsIF9wcmVwYXJlUGlwZWxpbmVDb250ZXh0LCBfc2V0UHJvZ3JhbSwgX2V4ZWN1dGVXaGVuUmVuZGVyaW5nU3RhdGVJc0NvbXBpbGVkLCBnZXRTdGF0ZU9iamVjdCwgX2NyZWF0ZVNoYWRlclByb2dyYW0sIGRlbGV0ZVN0YXRlT2JqZWN0LCBfaXNSZW5kZXJpbmdTdGF0ZUNvbXBpbGVkLCB9IGZyb20gXCIuL3RoaW5FbmdpbmUuZnVuY3Rpb25zLmpzXCI7XG5pbXBvcnQgeyBJc1dyYXBwZXIgfSBmcm9tIFwiLi4vTWF0ZXJpYWxzL2RyYXdXcmFwcGVyLmZ1bmN0aW9ucy5qc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL01pc2MvbG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyBJc1dpbmRvd09iamVjdEV4aXN0IH0gZnJvbSBcIi4uL01pc2MvZG9tTWFuYWdlbWVudC5qc1wiO1xuaW1wb3J0IHsgV2ViR0xTaGFkZXJQcm9jZXNzb3IgfSBmcm9tIFwiLi9XZWJHTC93ZWJHTFNoYWRlclByb2Nlc3NvcnMuanNcIjtcbmltcG9ydCB7IFdlYkdMMlNoYWRlclByb2Nlc3NvciB9IGZyb20gXCIuL1dlYkdML3dlYkdMMlNoYWRlclByb2Nlc3NvcnMuanNcIjtcbmltcG9ydCB7IFdlYkdMRGF0YUJ1ZmZlciB9IGZyb20gXCIuLi9NZXNoZXMvV2ViR0wvd2ViR0xEYXRhQnVmZmVyLmpzXCI7XG5pbXBvcnQgeyBHZXRFeHBvbmVudE9mVHdvIH0gZnJvbSBcIi4uL01pc2MvdG9vbHMuZnVuY3Rpb25zLmpzXCI7XG5pbXBvcnQgeyBBYnN0cmFjdEVuZ2luZSB9IGZyb20gXCIuL2Fic3RyYWN0RW5naW5lLmpzXCI7XG5cbmltcG9ydCB7IFdlYkdMSGFyZHdhcmVUZXh0dXJlIH0gZnJvbSBcIi4vV2ViR0wvd2ViR0xIYXJkd2FyZVRleHR1cmUuanNcIjtcbmltcG9ydCB7IEludGVybmFsVGV4dHVyZSB9IGZyb20gXCIuLi9NYXRlcmlhbHMvVGV4dHVyZXMvaW50ZXJuYWxUZXh0dXJlLmpzXCI7XG5pbXBvcnQgeyBFZmZlY3QgfSBmcm9tIFwiLi4vTWF0ZXJpYWxzL2VmZmVjdC5qc1wiO1xuaW1wb3J0IHsgX0NvbmNhdGVuYXRlU2hhZGVyLCBfR2V0R2xvYmFsRGVmaW5lcyB9IGZyb20gXCIuL2Fic3RyYWN0RW5naW5lLmZ1bmN0aW9ucy5qc1wiO1xuaW1wb3J0IHsgcmVzZXRDYWNoZWRQaXBlbGluZSB9IGZyb20gXCIuLi9NYXRlcmlhbHMvZWZmZWN0LmZ1bmN0aW9ucy5qc1wiO1xuaW1wb3J0IHsgSGFzU3RlbmNpbEFzcGVjdCwgSXNEZXB0aFRleHR1cmUgfSBmcm9tIFwiLi4vTWF0ZXJpYWxzL1RleHR1cmVzL3RleHR1cmVIZWxwZXIuZnVuY3Rpb25zLmpzXCI7XG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIGFsbCB0aGUgYnVmZmVyIGluZm8gdXNlZCBpbiBlbmdpbmUuXG4gKi9cbmNsYXNzIEJ1ZmZlclBvaW50ZXIge1xufVxuLyoqXG4gKiBUaGUgYmFzZSBlbmdpbmUgY2xhc3MgKHJvb3Qgb2YgYWxsIGVuZ2luZXMpXG4gKi9cbmV4cG9ydCBjbGFzcyBUaGluRW5naW5lIGV4dGVuZHMgQWJzdHJhY3RFbmdpbmUge1xuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbmFtZSBvZiB0aGUgZW5naW5lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICBzZXQgbmFtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZlcnNpb24gb2YgdGhlIGVuZ2luZVxuICAgICAqL1xuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2ViR0xWZXJzaW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHJlbGF0aXZlIHVybCB1c2VkIHRvIGxvYWQgc2hhZGVycyBpZiB1c2luZyB0aGUgZW5naW5lIGluIG5vbi1taW5pZmllZCBtb2RlXG4gICAgICovXG4gICAgc3RhdGljIGdldCBTaGFkZXJzUmVwb3NpdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIEVmZmVjdC5TaGFkZXJzUmVwb3NpdG9yeTtcbiAgICB9XG4gICAgc3RhdGljIHNldCBTaGFkZXJzUmVwb3NpdG9yeSh2YWx1ZSkge1xuICAgICAgICBFZmZlY3QuU2hhZGVyc1JlcG9zaXRvcnkgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBlbmdpbmUgc3VwcG9ydHMgdW5pZm9ybSBidWZmZXJzXG4gICAgICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL3NldHVwL3N1cHBvcnQvd2ViR0wyI3VuaWZvcm0tYnVmZmVyLW9iamV0c1xuICAgICAqL1xuICAgIGdldCBzdXBwb3J0c1VuaWZvcm1CdWZmZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWJHTFZlcnNpb24gPiAxICYmICF0aGlzLmRpc2FibGVVbmlmb3JtQnVmZmVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IG9ubHkgcG93ZXIgb2YgMiB0ZXh0dXJlcyBhcmUgc3VwcG9ydGVkXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCB5b3UgY2FuIHN0aWxsIHVzZSBub24gcG93ZXIgb2YgMiB0ZXh0dXJlcyBidXQgaW4gdGhpcyBjYXNlIHRoZSBlbmdpbmUgd2lsbCBmb3JjZWZ1bGx5IGNvbnZlcnQgdGhlbVxuICAgICAqL1xuICAgIGdldCBuZWVkUE9UVGV4dHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWJHTFZlcnNpb24gPCAyIHx8IHRoaXMuZm9yY2VQT1RUZXh0dXJlcztcbiAgICB9XG4gICAgZ2V0IF9zdXBwb3J0c0hhcmR3YXJlVGV4dHVyZVJlc2NhbGluZygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBvYmplY3QgZnJvbSB3aGljaCB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgYmUgdGFrZW4gZnJvbSB3aGVuIGdldHRpbmcgcmVuZGVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKiBXaWxsIGZhbGxiYWNrIHRvIHRoZSBnbCBvYmplY3RcbiAgICAgKiBAcGFyYW0gZGltZW5zaW9ucyB0aGUgZnJhbWVidWZmZXIgd2lkdGggYW5kIGhlaWdodCB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBzZXQgZnJhbWVidWZmZXJEaW1lbnNpb25zT2JqZWN0KGRpbWVuc2lvbnMpIHtcbiAgICAgICAgdGhpcy5fZnJhbWVidWZmZXJEaW1lbnNpb25zT2JqZWN0ID0gZGltZW5zaW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzbmFwc2hvdCBhdCB0aGUgbmV4dCBmcmFtZSB1c2luZyB0aGUgY3VycmVudCBzbmFwc2hvdFJlbmRlcmluZ01vZGVcbiAgICAgKi9cbiAgICBzbmFwc2hvdFJlbmRlcmluZ1Jlc2V0KCkge1xuICAgICAgICB0aGlzLnNuYXBzaG90UmVuZGVyaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZW5naW5lXG4gICAgICogQHBhcmFtIGNhbnZhc09yQ29udGV4dCBkZWZpbmVzIHRoZSBjYW52YXMgb3IgV2ViR0wgY29udGV4dCB0byB1c2UgZm9yIHJlbmRlcmluZy4gSWYgeW91IHByb3ZpZGUgYSBXZWJHTCBjb250ZXh0LCBCYWJ5bG9uLmpzIHdpbGwgbm90IGhvb2sgZXZlbnRzIG9uIHRoZSBjYW52YXMgKGxpa2UgcG9pbnRlcnMsIGtleWJvYXJkcywgZXRjLi4uKSBzbyBubyBldmVudCBvYnNlcnZhYmxlcyB3aWxsIGJlIGF2YWlsYWJsZS4gVGhpcyBpcyBtb3N0bHkgdXNlZCB3aGVuIEJhYnlsb24uanMgaXMgdXNlZCBhcyBhIHBsdWdpbiBvbiBhIHN5c3RlbSB3aGljaCBhbHJlYWR5IHVzZWQgdGhlIFdlYkdMIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gYW50aWFsaWFzIGRlZmluZXMgd2hldGhlciBhbnRpLWFsaWFzaW5nIHNob3VsZCBiZSBlbmFibGVkIChkZWZhdWx0IHZhbHVlIGlzIFwidW5kZWZpbmVkXCIsIG1lYW5pbmcgdGhhdCB0aGUgYnJvd3NlciBtYXkgb3IgbWF5IG5vdCBlbmFibGUgaXQpXG4gICAgICogQHBhcmFtIG9wdGlvbnMgZGVmaW5lcyBmdXJ0aGVyIG9wdGlvbnMgdG8gYmUgc2VudCB0byB0aGUgZ2V0Q29udGV4dCgpIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGFkYXB0VG9EZXZpY2VSYXRpbyBkZWZpbmVzIHdoZXRoZXIgdG8gYWRhcHQgdG8gdGhlIGRldmljZSdzIHZpZXdwb3J0IGNoYXJhY3RlcmlzdGljcyAoZGVmYXVsdDogZmFsc2UpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FudmFzT3JDb250ZXh0LCBhbnRpYWxpYXMsIG9wdGlvbnMsIGFkYXB0VG9EZXZpY2VSYXRpbykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgc3VwZXIoYW50aWFsaWFzID8/IG9wdGlvbnMuYW50aWFsaWFzLCBvcHRpb25zLCBhZGFwdFRvRGV2aWNlUmF0aW8pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25hbWUgPSBcIldlYkdMXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgYSBib29sZWFuIHRoYXQgaW5kaWNhdGVzIGlmIHRleHR1cmVzIG11c3QgYmUgZm9yY2VkIHRvIHBvd2VyIG9mIDIgc2l6ZSBldmVuIGlmIG5vdCByZXF1aXJlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JjZVBPVFRleHR1cmVzID0gZmFsc2U7XG4gICAgICAgIC8qKiBHZXRzIG9yIHNldHMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGVuZ2luZSBzaG91bGQgdmFsaWRhdGUgcHJvZ3JhbXMgYWZ0ZXIgY29tcGlsYXRpb24gKi9cbiAgICAgICAgdGhpcy52YWxpZGF0ZVNoYWRlclByb2dyYW1zID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgYSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB1bmlmb3JtIGJ1ZmZlcnMgbXVzdCBiZSBkaXNhYmxlZCBldmVuIGlmIHRoZXkgYXJlIHN1cHBvcnRlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlVW5pZm9ybUJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl93ZWJHTFZlcnNpb24gPSAxLjA7XG4gICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYkFycmF5c0VuYWJsZWQgPSBbXTtcbiAgICAgICAgdGhpcy5fdWludEluZGljZXNDdXJyZW50bHlTZXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3VycmVudEJvdW5kQnVmZmVyID0gbmV3IEFycmF5KCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lYnVmZmVyID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9kdW1teUZyYW1lYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudEJ1ZmZlclBvaW50ZXJzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0YW5jZUxvY2F0aW9ucyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50SW5zdGFuY2VCdWZmZXJzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuX3Zhb1JlY29yZEluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbXVzdFdpcGVWZXJ0ZXhBdHRyaWJ1dGVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25leHRGcmVlVGV4dHVyZVNsb3RzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuX21heFNpbXVsdGFuZW91c1RleHR1cmVzID0gMDtcbiAgICAgICAgdGhpcy5fbWF4TVNBQVNhbXBsZXNPdmVycmlkZSA9IG51bGw7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICAgICAgdGhpcy5fdW5wYWNrRmxpcFlDYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW4gY2FzZSB5b3UgYXJlIHNoYXJpbmcgdGhlIGNvbnRleHQgd2l0aCBvdGhlciBhcHBsaWNhdGlvbnMsIGl0IG1pZ2h0XG4gICAgICAgICAqIGJlIGludGVyZXN0ZWQgdG8gbm90IGNhY2hlIHRoZSB1bnBhY2sgZmxpcCB5IHN0YXRlIHRvIGVuc3VyZSBhIGNvbnNpc3RlbnRcbiAgICAgICAgICogdmFsdWUgd291bGQgYmUgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgICAgICB0aGlzLmVuYWJsZVVucGFja0ZsaXBZQ2FjaGVkID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYm91bmRVbmlmb3JtcyA9IHt9O1xuICAgICAgICBpZiAoIWNhbnZhc09yQ29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYW52YXMgPSBudWxsO1xuICAgICAgICBpZiAoY2FudmFzT3JDb250ZXh0LmdldENvbnRleHQpIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IGNhbnZhc09yQ29udGV4dDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnhyQ29tcGF0aWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy54ckNvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4Y2VwdGlvbnNcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldHVwTW9iaWxlQ2hlY2tzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXhjZXB0aW9uIG9mIFRoaW5FbmdpbmUuRXhjZXB0aW9uTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBleGNlcHRpb24ua2V5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRzID0gZXhjZXB0aW9uLnRhcmdldHM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gbmV3IFJlZ0V4cChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2sudGVzdCh1YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGNlcHRpb24uY2FwdHVyZSAmJiBleGNlcHRpb24uY2FwdHVyZUNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlID0gZXhjZXB0aW9uLmNhcHR1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludCA9IGV4Y2VwdGlvbi5jYXB0dXJlQ29uc3RyYWludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoY2FwdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHJlZ2V4LmV4ZWModWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlZFZhbHVlID0gcGFyc2VJbnQobWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmVkVmFsdWUgPj0gY29uc3RyYWludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuaWZvcm1CdWZmZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZVVuaWZvcm1CdWZmZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidmFvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVWZXJ0ZXhBcnJheU9iamVjdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhbnRpYWxpYXNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYW50aWFsaWFzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1heE1TQUFTYW1wbGVzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXhNU0FBU2FtcGxlc092ZXJyaWRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnRleHQgbG9zdFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb05vdEhhbmRsZUNvbnRleHRMb3N0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Db250ZXh0TG9zdCA9IChldnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRXYXNMb3N0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlU3RhdGVPYmplY3QodGhpcy5fZ2wpO1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuV2FybihcIldlYkdMIGNvbnRleHQgbG9zdC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Db250ZXh0TG9zdE9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Db250ZXh0UmVzdG9yZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVFbmdpbmVBZnRlckNvbnRleHRMb3N0KCgpID0+IHRoaXMuX2luaXRHTENvbnRleHQoKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsIHRoaXMuX29uQ29udGV4dFJlc3RvcmVkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wb3dlclByZWZlcmVuY2UgPSBvcHRpb25zLnBvd2VyUHJlZmVyZW5jZSB8fCBcImhpZ2gtcGVyZm9ybWFuY2VcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uQ29udGV4dExvc3QgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVN0YXRlT2JqZWN0KHRoaXMuX2dsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHRoaXMuX29uQ29udGV4dExvc3QsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9iYWREZXNrdG9wT1MpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnhyQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR0xcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kaXNhYmxlV2ViR0wyU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsID0gKGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIG9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsMlwiLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9nbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2ViR0xWZXJzaW9uID0gMi4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hhZGVyUGxhdGZvcm1OYW1lID0gXCJXRUJHTDJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgd2VpcmQgYnJvd3NlcnMgdG8gbGllICh5ZWFoIHRoYXQgaGFwcGVucyEpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2dsLmRlbGV0ZVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2ViR0xWZXJzaW9uID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRlclBsYXRmb3JtTmFtZSA9IFwiV0VCR0wxXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fZ2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgY2FudmFzIGlzIG51bGwgb3IgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wgPSAoY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBvcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYkdMIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9nbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYkdMIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nbCA9IGNhbnZhc09yQ29udGV4dDtcbiAgICAgICAgICAgIGNhbnZhcyA9IHRoaXMuX2dsLmNhbnZhcztcbiAgICAgICAgICAgIGlmICh0aGlzLl9nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWJHTFZlcnNpb24gPSAyLjA7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hhZGVyUGxhdGZvcm1OYW1lID0gXCJXRUJHTDJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRlclBsYXRmb3JtTmFtZSA9IFwiV0VCR0wxXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5fZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdGVuY2lsID0gYXR0cmlidXRlcy5zdGVuY2lsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NoYXJlZEluaXQoY2FudmFzKTtcbiAgICAgICAgLy8gRW5zdXJlcyBhIGNvbnNpc3RlbnQgY29sb3Igc3BhY2UgdW5wYWNraW5nIG9mIHRleHR1cmVzIGNyb3NzIGJyb3dzZXIuXG4gICAgICAgIHRoaXMuX2dsLnBpeGVsU3RvcmVpKHRoaXMuX2dsLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsIHRoaXMuX2dsLk5PTkUpO1xuICAgICAgICBpZiAob3B0aW9ucy51c2VIaWdoUHJlY2lzaW9uRmxvYXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hQcmVjaXNpb25TaGFkZXJzQWxsb3dlZCA9IG9wdGlvbnMudXNlSGlnaFByZWNpc2lvbkZsb2F0cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLl9pbml0R0xDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuX2luaXRGZWF0dXJlcygpO1xuICAgICAgICAvLyBQcmVwYXJlIGJ1ZmZlciBwb2ludGVyc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NhcHMubWF4VmVydGV4QXR0cmliczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50QnVmZmVyUG9pbnRlcnNbaV0gPSBuZXcgQnVmZmVyUG9pbnRlcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNoYWRlciBwcm9jZXNzb3JcbiAgICAgICAgdGhpcy5fc2hhZGVyUHJvY2Vzc29yID0gdGhpcy53ZWJHTFZlcnNpb24gPiAxID8gbmV3IFdlYkdMMlNoYWRlclByb2Nlc3NvcigpIDogbmV3IFdlYkdMU2hhZGVyUHJvY2Vzc29yKCk7XG4gICAgICAgIC8vIFN0YXJ0aW5nIHdpdGggaU9TIDE0LCB3ZSBjYW4gdHJ1c3QgdGhlIGJyb3dzZXJcbiAgICAgICAgLy8gbGV0IG1hdGNoZXMgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCspLyk7XG4gICAgICAgIC8vIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIC8vICAgICBpZiAocGFyc2VJbnQobWF0Y2hlc1sxXSkgPj0gMTQpIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLl9iYWRPUyA9IGZhbHNlO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0IHZlcnNpb25Ub0xvZyA9IGBCYWJ5bG9uLmpzIHYke1RoaW5FbmdpbmUuVmVyc2lvbn1gO1xuICAgICAgICBMb2dnZXIuTG9nKHZlcnNpb25Ub0xvZyArIGAgLSAke3RoaXMuZGVzY3JpcHRpb259YCk7XG4gICAgICAgIC8vIENoZWNrIHNldEF0dHJpYnV0ZSBpbiBjYXNlIG9mIHdvcmtlcnNcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmluZ0NhbnZhcyAmJiB0aGlzLl9yZW5kZXJpbmdDYW52YXMuc2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJpbmdDYW52YXMuc2V0QXR0cmlidXRlKFwiZGF0YS1lbmdpbmVcIiwgdmVyc2lvblRvTG9nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZU9iamVjdCA9IGdldFN0YXRlT2JqZWN0KHRoaXMuX2dsKTtcbiAgICAgICAgLy8gdXBkYXRlIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IGVuZ2luZSBzdGF0ZVxuICAgICAgICBzdGF0ZU9iamVjdC52YWxpZGF0ZVNoYWRlclByb2dyYW1zID0gdGhpcy52YWxpZGF0ZVNoYWRlclByb2dyYW1zO1xuICAgICAgICBzdGF0ZU9iamVjdC5wYXJhbGxlbFNoYWRlckNvbXBpbGUgPSB0aGlzLl9jYXBzLnBhcmFsbGVsU2hhZGVyQ29tcGlsZTtcbiAgICB9XG4gICAgX2NsZWFyRW1wdHlSZXNvdXJjZXMoKSB7XG4gICAgICAgIHRoaXMuX2R1bW15RnJhbWVidWZmZXIgPSBudWxsO1xuICAgICAgICBzdXBlci5fY2xlYXJFbXB0eVJlc291cmNlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfZ2V0U2hhZGVyUHJvY2Vzc2luZ0NvbnRleHQoc2hhZGVyTGFuZ3VhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgYWxsIGNyZWF0ZWQgZWZmZWN0cyBhcmUgcmVhZHlcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGFsbCBlZmZlY3RzIGFyZSByZWFkeVxuICAgICAqL1xuICAgIGFyZUFsbEVmZmVjdHNSZWFkeSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5fY29tcGlsZWRFZmZlY3RzKSB7XG4gICAgICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9jb21waWxlZEVmZmVjdHNba2V5XTtcbiAgICAgICAgICAgIGlmICghZWZmZWN0LmlzUmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2luaXRHTENvbnRleHQoKSB7XG4gICAgICAgIC8vIENhcHNcbiAgICAgICAgdGhpcy5fY2FwcyA9IHtcbiAgICAgICAgICAgIG1heFRleHR1cmVzSW1hZ2VVbml0czogdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSxcbiAgICAgICAgICAgIG1heENvbWJpbmVkVGV4dHVyZXNJbWFnZVVuaXRzOiB0aGlzLl9nbC5nZXRQYXJhbWV0ZXIodGhpcy5fZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpLFxuICAgICAgICAgICAgbWF4VmVydGV4VGV4dHVyZUltYWdlVW5pdHM6IHRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9nbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLFxuICAgICAgICAgICAgbWF4VGV4dHVyZVNpemU6IHRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9nbC5NQVhfVEVYVFVSRV9TSVpFKSxcbiAgICAgICAgICAgIG1heFNhbXBsZXM6IHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEgPyB0aGlzLl9nbC5nZXRQYXJhbWV0ZXIodGhpcy5fZ2wuTUFYX1NBTVBMRVMpIDogMSxcbiAgICAgICAgICAgIG1heEN1YmVtYXBUZXh0dXJlU2l6ZTogdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUpLFxuICAgICAgICAgICAgbWF4UmVuZGVyVGV4dHVyZVNpemU6IHRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9nbC5NQVhfUkVOREVSQlVGRkVSX1NJWkUpLFxuICAgICAgICAgICAgbWF4VmVydGV4QXR0cmliczogdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLk1BWF9WRVJURVhfQVRUUklCUyksXG4gICAgICAgICAgICBtYXhWYXJ5aW5nVmVjdG9yczogdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLk1BWF9WQVJZSU5HX1ZFQ1RPUlMpLFxuICAgICAgICAgICAgbWF4RnJhZ21lbnRVbmlmb3JtVmVjdG9yczogdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMpLFxuICAgICAgICAgICAgbWF4VmVydGV4VW5pZm9ybVZlY3RvcnM6IHRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9nbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyksXG4gICAgICAgICAgICBwYXJhbGxlbFNoYWRlckNvbXBpbGU6IHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIktIUl9wYXJhbGxlbF9zaGFkZXJfY29tcGlsZVwiKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGFuZGFyZERlcml2YXRpdmVzOiB0aGlzLl93ZWJHTFZlcnNpb24gPiAxIHx8IHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1wiKSAhPT0gbnVsbCxcbiAgICAgICAgICAgIG1heEFuaXNvdHJvcHk6IDEsXG4gICAgICAgICAgICBhc3RjOiB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0Y1wiKSB8fCB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGNcIiksXG4gICAgICAgICAgICBicHRjOiB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9icHRjXCIpIHx8IHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIldFQktJVF9FWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9icHRjXCIpLFxuICAgICAgICAgICAgczN0YzogdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIikgfHwgdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgICAgICAgICAgczN0Y19zcmdiOiB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiXCIpIHx8IHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiXCIpLFxuICAgICAgICAgICAgcHZydGM6IHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1wiKSB8fCB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpLFxuICAgICAgICAgICAgZXRjMTogdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzFcIikgfHwgdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxXCIpLFxuICAgICAgICAgICAgZXRjMjogdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0Y1wiKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjXCIpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2VzM18wXCIpLCAvLyBhbHNvIGEgcmVxdWlyZW1lbnQgb2YgT3BlbkdMIEVTIDNcbiAgICAgICAgICAgIHRleHR1cmVBbmlzb3Ryb3BpY0ZpbHRlckV4dGVuc2lvbjogdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIiksXG4gICAgICAgICAgICB1aW50SW5kaWNlczogdGhpcy5fd2ViR0xWZXJzaW9uID4gMSB8fCB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJPRVNfZWxlbWVudF9pbmRleF91aW50XCIpICE9PSBudWxsLFxuICAgICAgICAgICAgZnJhZ21lbnREZXB0aFN1cHBvcnRlZDogdGhpcy5fd2ViR0xWZXJzaW9uID4gMSB8fCB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJFWFRfZnJhZ19kZXB0aFwiKSAhPT0gbnVsbCxcbiAgICAgICAgICAgIGhpZ2hQcmVjaXNpb25TaGFkZXJTdXBwb3J0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgdGltZXJRdWVyeTogdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSB8fCB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlcIiksXG4gICAgICAgICAgICBzdXBwb3J0T2NjbHVzaW9uUXVlcnk6IHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEsXG4gICAgICAgICAgICBjYW5Vc2VUaW1lc3RhbXBGb3JUaW1lclF1ZXJ5OiBmYWxzZSxcbiAgICAgICAgICAgIGRyYXdCdWZmZXJzRXh0ZW5zaW9uOiBmYWxzZSxcbiAgICAgICAgICAgIG1heE1TQUFTYW1wbGVzOiAxLFxuICAgICAgICAgICAgY29sb3JCdWZmZXJGbG9hdDogISEodGhpcy5fd2ViR0xWZXJzaW9uID4gMSAmJiB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKSxcbiAgICAgICAgICAgIHN1cHBvcnRGbG9hdFRleHR1cmVzUmVzb2x2ZTogZmFsc2UsXG4gICAgICAgICAgICByZzExYjEwdWZDb2xvclJlbmRlcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29sb3JCdWZmZXJIYWxmRmxvYXQ6ICEhKHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEgJiYgdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpKSxcbiAgICAgICAgICAgIHRleHR1cmVGbG9hdDogdGhpcy5fd2ViR0xWZXJzaW9uID4gMSB8fCB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgIHRleHR1cmVIYWxmRmxvYXQ6IHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEgfHwgdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgIHRleHR1cmVIYWxmRmxvYXRSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgdGV4dHVyZUZsb2F0TGluZWFyRmlsdGVyaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHRleHR1cmVGbG9hdFJlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0dXJlSGFsZkZsb2F0TGluZWFyRmlsdGVyaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHZlcnRleEFycmF5T2JqZWN0OiBmYWxzZSxcbiAgICAgICAgICAgIGluc3RhbmNlZEFycmF5czogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0dXJlTE9EOiB0aGlzLl93ZWJHTFZlcnNpb24gPiAxIHx8IHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIkVYVF9zaGFkZXJfdGV4dHVyZV9sb2RcIikgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICB0ZXhlbEZldGNoOiB0aGlzLl93ZWJHTFZlcnNpb24gIT09IDEsXG4gICAgICAgICAgICBibGVuZE1pbk1heDogZmFsc2UsXG4gICAgICAgICAgICBtdWx0aXZpZXc6IHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIk9WUl9tdWx0aXZpZXcyXCIpLFxuICAgICAgICAgICAgb2N1bHVzTXVsdGl2aWV3OiB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJPQ1VMVVNfbXVsdGl2aWV3XCIpLFxuICAgICAgICAgICAgZGVwdGhUZXh0dXJlRXh0ZW5zaW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGNhblVzZUdMSW5zdGFuY2VJRDogdGhpcy5fd2ViR0xWZXJzaW9uID4gMSxcbiAgICAgICAgICAgIGNhblVzZUdMVmVydGV4SUQ6IHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEsXG4gICAgICAgICAgICBzdXBwb3J0Q29tcHV0ZVNoYWRlcnM6IGZhbHNlLFxuICAgICAgICAgICAgc3VwcG9ydFNSR0JCdWZmZXJzOiBmYWxzZSxcbiAgICAgICAgICAgIHN1cHBvcnRUcmFuc2Zvcm1GZWVkYmFja3M6IHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEsXG4gICAgICAgICAgICB0ZXh0dXJlTWF4TGV2ZWw6IHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEsXG4gICAgICAgICAgICB0ZXh0dXJlMkRBcnJheU1heExheWVyQ291bnQ6IHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEgPyB0aGlzLl9nbC5nZXRQYXJhbWV0ZXIodGhpcy5fZ2wuTUFYX0FSUkFZX1RFWFRVUkVfTEFZRVJTKSA6IDEyOCxcbiAgICAgICAgICAgIGRpc2FibGVNb3JwaFRhcmdldFRleHR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgdGV4dHVyZU5vcm0xNjogdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfbm9ybTE2XCIpID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jYXBzLnN1cHBvcnRGbG9hdFRleHR1cmVzUmVzb2x2ZSA9IHRoaXMuX2NhcHMuY29sb3JCdWZmZXJGbG9hdDtcbiAgICAgICAgdGhpcy5fY2Fwcy5yZzExYjEwdWZDb2xvclJlbmRlcmFibGUgPSB0aGlzLl9jYXBzLmNvbG9yQnVmZmVyRmxvYXQ7XG4gICAgICAgIC8vIEluZm9zXG4gICAgICAgIHRoaXMuX2dsVmVyc2lvbiA9IHRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9nbC5WRVJTSU9OKTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXJJbmZvID0gdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mb1wiKTtcbiAgICAgICAgaWYgKHJlbmRlcmVySW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9nbFJlbmRlcmVyID0gdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHJlbmRlcmVySW5mby5VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCk7XG4gICAgICAgICAgICB0aGlzLl9nbFZlbmRvciA9IHRoaXMuX2dsLmdldFBhcmFtZXRlcihyZW5kZXJlckluZm8uVU5NQVNLRURfVkVORE9SX1dFQkdMKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2dsVmVuZG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9nbFZlbmRvciA9IHRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9nbC5WRU5ET1IpIHx8IFwiVW5rbm93biB2ZW5kb3JcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2dsUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsUmVuZGVyZXIgPSB0aGlzLl9nbC5nZXRQYXJhbWV0ZXIodGhpcy5fZ2wuUkVOREVSRVIpIHx8IFwiVW5rbm93biByZW5kZXJlclwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnN0YW50c1xuICAgICAgICBpZiAodGhpcy5fZ2wuSEFMRl9GTE9BVF9PRVMgIT09IDB4OGQ2MSkge1xuICAgICAgICAgICAgdGhpcy5fZ2wuSEFMRl9GTE9BVF9PRVMgPSAweDhkNjE7IC8vIEhhbGYgZmxvYXRpbmctcG9pbnQgdHlwZSAoMTYtYml0KS5cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZ2wuUkdCQTE2RiAhPT0gMHg4ODFhKSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5SR0JBMTZGID0gMHg4ODFhOyAvLyBSR0JBIDE2LWJpdCBmbG9hdGluZy1wb2ludCBjb2xvci1yZW5kZXJhYmxlIGludGVybmFsIHNpemVkIGZvcm1hdC5cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZ2wuUkdCQTMyRiAhPT0gMHg4ODE0KSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5SR0JBMzJGID0gMHg4ODE0OyAvLyBSR0JBIDMyLWJpdCBmbG9hdGluZy1wb2ludCBjb2xvci1yZW5kZXJhYmxlIGludGVybmFsIHNpemVkIGZvcm1hdC5cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZ2wuREVQVEgyNF9TVEVOQ0lMOCAhPT0gMzUwNTYpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLkRFUFRIMjRfU1RFTkNJTDggPSAzNTA1NjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRlbnNpb25zXG4gICAgICAgIGlmICh0aGlzLl9jYXBzLnRpbWVyUXVlcnkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl93ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5nZXRRdWVyeSA9IHRoaXMuX2NhcHMudGltZXJRdWVyeS5nZXRRdWVyeUVYVC5iaW5kKHRoaXMuX2NhcHMudGltZXJRdWVyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZWJHTFF1ZXJ5IGNhc3RlZCB0byBudW1iZXIgdG8gYXZvaWQgVFMgZXJyb3JcbiAgICAgICAgICAgIHRoaXMuX2NhcHMuY2FuVXNlVGltZXN0YW1wRm9yVGltZXJRdWVyeSA9ICh0aGlzLl9nbC5nZXRRdWVyeSh0aGlzLl9jYXBzLnRpbWVyUXVlcnkuVElNRVNUQU1QX0VYVCwgdGhpcy5fY2Fwcy50aW1lclF1ZXJ5LlFVRVJZX0NPVU5URVJfQklUU19FWFQpID8/IDApID4gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYXBzLm1heEFuaXNvdHJvcHkgPSB0aGlzLl9jYXBzLnRleHR1cmVBbmlzb3Ryb3BpY0ZpbHRlckV4dGVuc2lvblxuICAgICAgICAgICAgPyB0aGlzLl9nbC5nZXRQYXJhbWV0ZXIodGhpcy5fY2Fwcy50ZXh0dXJlQW5pc290cm9waWNGaWx0ZXJFeHRlbnNpb24uTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKVxuICAgICAgICAgICAgOiAwO1xuICAgICAgICB0aGlzLl9jYXBzLnRleHR1cmVGbG9hdExpbmVhckZpbHRlcmluZyA9IHRoaXMuX2NhcHMudGV4dHVyZUZsb2F0ICYmIHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2Fwcy50ZXh0dXJlRmxvYXRSZW5kZXIgPSB0aGlzLl9jYXBzLnRleHR1cmVGbG9hdCAmJiB0aGlzLl9jYW5SZW5kZXJUb0Zsb2F0RnJhbWVidWZmZXIoKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2Fwcy50ZXh0dXJlSGFsZkZsb2F0TGluZWFyRmlsdGVyaW5nID1cbiAgICAgICAgICAgIHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEgfHwgKHRoaXMuX2NhcHMudGV4dHVyZUhhbGZGbG9hdCAmJiB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhclwiKSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9jYXBzLnRleHR1cmVOb3JtMTYpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLlIxNl9FWFQgPSAweDgyMmE7XG4gICAgICAgICAgICB0aGlzLl9nbC5SRzE2X0VYVCA9IDB4ODIyYztcbiAgICAgICAgICAgIHRoaXMuX2dsLlJHQjE2X0VYVCA9IDB4ODA1NDtcbiAgICAgICAgICAgIHRoaXMuX2dsLlJHQkExNl9FWFQgPSAweDgwNWI7XG4gICAgICAgICAgICB0aGlzLl9nbC5SMTZfU05PUk1fRVhUID0gMHg4Zjk4O1xuICAgICAgICAgICAgdGhpcy5fZ2wuUkcxNl9TTk9STV9FWFQgPSAweDhmOTk7XG4gICAgICAgICAgICB0aGlzLl9nbC5SR0IxNl9TTk9STV9FWFQgPSAweDhmOWE7XG4gICAgICAgICAgICB0aGlzLl9nbC5SR0JBMTZfU05PUk1fRVhUID0gMHg4ZjliO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzZWQgZm9ybWF0c1xuICAgICAgICBpZiAodGhpcy5fY2Fwcy5hc3RjKSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzR4NF9LSFIgPSB0aGlzLl9jYXBzLmFzdGMuQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ180eDRfS0hSO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXBzLmJwdGMpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9CUFRDX1VOT1JNX0VYVCA9IHRoaXMuX2NhcHMuYnB0Yy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfQlBUQ19VTk9STV9FWFQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NhcHMuczN0Y19zcmdiKSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5DT01QUkVTU0VEX1NSR0JfUzNUQ19EWFQxX0VYVCA9IHRoaXMuX2NhcHMuczN0Y19zcmdiLkNPTVBSRVNTRURfU1JHQl9TM1RDX0RYVDFfRVhUO1xuICAgICAgICAgICAgdGhpcy5fZ2wuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFQgPSB0aGlzLl9jYXBzLnMzdGNfc3JnYi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVDtcbiAgICAgICAgICAgIHRoaXMuX2dsLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDVfRVhUID0gdGhpcy5fY2Fwcy5zM3RjX3NyZ2IuQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUNV9FWFQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NhcHMuZXRjMikge1xuICAgICAgICAgICAgdGhpcy5fZ2wuQ09NUFJFU1NFRF9TUkdCOF9FVEMyID0gdGhpcy5fY2Fwcy5ldGMyLkNPTVBSRVNTRURfU1JHQjhfRVRDMjtcbiAgICAgICAgICAgIHRoaXMuX2dsLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0VUQzJfRUFDID0gdGhpcy5fY2Fwcy5ldGMyLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0VUQzJfRUFDO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrcyBpZiBzb21lIG9mIHRoZSBmb3JtYXQgcmVuZGVycyBmaXJzdCB0byBhbGxvdyB0aGUgdXNlIG9mIHdlYmdsIGluc3BlY3Rvci5cbiAgICAgICAgaWYgKHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nbC5IQUxGX0ZMT0FUX09FUyAhPT0gMHgxNDBiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuSEFMRl9GTE9BVF9PRVMgPSAweDE0MGI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2Fwcy50ZXh0dXJlSGFsZkZsb2F0UmVuZGVyID0gdGhpcy5fY2Fwcy50ZXh0dXJlSGFsZkZsb2F0ICYmIHRoaXMuX2NhblJlbmRlclRvSGFsZkZsb2F0RnJhbWVidWZmZXIoKTtcbiAgICAgICAgLy8gRHJhdyBidWZmZXJzXG4gICAgICAgIGlmICh0aGlzLl93ZWJHTFZlcnNpb24gPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXBzLmRyYXdCdWZmZXJzRXh0ZW5zaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NhcHMubWF4TVNBQVNhbXBsZXMgPSB0aGlzLl9tYXhNU0FBU2FtcGxlc092ZXJyaWRlICE9PSBudWxsID8gdGhpcy5fbWF4TVNBQVNhbXBsZXNPdmVycmlkZSA6IHRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9nbC5NQVhfU0FNUExFUyk7XG4gICAgICAgICAgICB0aGlzLl9jYXBzLm1heERyYXdCdWZmZXJzID0gdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLk1BWF9EUkFXX0JVRkZFUlMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZHJhd0J1ZmZlcnNFeHRlbnNpb24gPSB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9kcmF3X2J1ZmZlcnNcIik7XG4gICAgICAgICAgICBpZiAoZHJhd0J1ZmZlcnNFeHRlbnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYXBzLmRyYXdCdWZmZXJzRXh0ZW5zaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5kcmF3QnVmZmVycyA9IGRyYXdCdWZmZXJzRXh0ZW5zaW9uLmRyYXdCdWZmZXJzV0VCR0wuYmluZChkcmF3QnVmZmVyc0V4dGVuc2lvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2Fwcy5tYXhEcmF3QnVmZmVycyA9IHRoaXMuX2dsLmdldFBhcmFtZXRlcihkcmF3QnVmZmVyc0V4dGVuc2lvbi5NQVhfRFJBV19CVUZGRVJTX1dFQkdMKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5EUkFXX0ZSQU1FQlVGRkVSID0gdGhpcy5fZ2wuRlJBTUVCVUZGRVI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsW1wiQ09MT1JfQVRUQUNITUVOVFwiICsgaSArIFwiX1dFQkdMXCJdID0gZHJhd0J1ZmZlcnNFeHRlbnNpb25bXCJDT0xPUl9BVFRBQ0hNRU5UXCIgKyBpICsgXCJfV0VCR0xcIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERlcHRoIFRleHR1cmVcbiAgICAgICAgaWYgKHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhcHMuZGVwdGhUZXh0dXJlRXh0ZW5zaW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcHRoVGV4dHVyZUV4dGVuc2lvbiA9IHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIldFQkdMX2RlcHRoX3RleHR1cmVcIik7XG4gICAgICAgICAgICBpZiAoZGVwdGhUZXh0dXJlRXh0ZW5zaW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYXBzLmRlcHRoVGV4dHVyZUV4dGVuc2lvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuVU5TSUdORURfSU5UXzI0XzggPSBkZXB0aFRleHR1cmVFeHRlbnNpb24uVU5TSUdORURfSU5UXzI0XzhfV0VCR0w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmVydGV4IGFycmF5IG9iamVjdFxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlVmVydGV4QXJyYXlPYmplY3RzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXBzLnZlcnRleEFycmF5T2JqZWN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fd2ViR0xWZXJzaW9uID4gMSkge1xuICAgICAgICAgICAgdGhpcy5fY2Fwcy52ZXJ0ZXhBcnJheU9iamVjdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJ0ZXhBcnJheU9iamVjdEV4dGVuc2lvbiA9IHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIk9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpO1xuICAgICAgICAgICAgaWYgKHZlcnRleEFycmF5T2JqZWN0RXh0ZW5zaW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYXBzLnZlcnRleEFycmF5T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5jcmVhdGVWZXJ0ZXhBcnJheSA9IHZlcnRleEFycmF5T2JqZWN0RXh0ZW5zaW9uLmNyZWF0ZVZlcnRleEFycmF5T0VTLmJpbmQodmVydGV4QXJyYXlPYmplY3RFeHRlbnNpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLmJpbmRWZXJ0ZXhBcnJheSA9IHZlcnRleEFycmF5T2JqZWN0RXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUy5iaW5kKHZlcnRleEFycmF5T2JqZWN0RXh0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5kZWxldGVWZXJ0ZXhBcnJheSA9IHZlcnRleEFycmF5T2JqZWN0RXh0ZW5zaW9uLmRlbGV0ZVZlcnRleEFycmF5T0VTLmJpbmQodmVydGV4QXJyYXlPYmplY3RFeHRlbnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluc3RhbmNlcyBjb3VudFxuICAgICAgICBpZiAodGhpcy5fd2ViR0xWZXJzaW9uID4gMSkge1xuICAgICAgICAgICAgdGhpcy5fY2Fwcy5pbnN0YW5jZWRBcnJheXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VFeHRlbnNpb24gPSB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlRXh0ZW5zaW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYXBzLmluc3RhbmNlZEFycmF5cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuZHJhd0FycmF5c0luc3RhbmNlZCA9IGluc3RhbmNlRXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRS5iaW5kKGluc3RhbmNlRXh0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQgPSBpbnN0YW5jZUV4dGVuc2lvbi5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRS5iaW5kKGluc3RhbmNlRXh0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJEaXZpc29yID0gaW5zdGFuY2VFeHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFLmJpbmQoaW5zdGFuY2VFeHRlbnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2Fwcy5pbnN0YW5jZWRBcnJheXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJ0ZXhoaWdocCA9IHRoaXMuX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCh0aGlzLl9nbC5WRVJURVhfU0hBREVSLCB0aGlzLl9nbC5ISUdIX0ZMT0FUKTtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50aGlnaHAgPSB0aGlzLl9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQodGhpcy5fZ2wuRlJBR01FTlRfU0hBREVSLCB0aGlzLl9nbC5ISUdIX0ZMT0FUKTtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhoaWdocCAmJiBmcmFnbWVudGhpZ2hwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2Fwcy5oaWdoUHJlY2lzaW9uU2hhZGVyU3VwcG9ydGVkID0gdmVydGV4aGlnaHAucHJlY2lzaW9uICE9PSAwICYmIGZyYWdtZW50aGlnaHAucHJlY2lzaW9uICE9PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl93ZWJHTFZlcnNpb24gPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXBzLmJsZW5kTWluTWF4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJsZW5kTWluTWF4RXh0ZW5zaW9uID0gdGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2JsZW5kX21pbm1heFwiKTtcbiAgICAgICAgICAgIGlmIChibGVuZE1pbk1heEV4dGVuc2lvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2Fwcy5ibGVuZE1pbk1heCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuTUFYID0gYmxlbmRNaW5NYXhFeHRlbnNpb24uTUFYX0VYVDtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5NSU4gPSBibGVuZE1pbk1heEV4dGVuc2lvbi5NSU5fRVhUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNSR0IgYnVmZmVyc1xuICAgICAgICAvLyBvbmx5IHJ1biB0aGlzIGlmIG5vdCBhbHJlYWR5IHNldCB0byB0cnVlIChpbiB0aGUgY29uc3RydWN0b3IsIGZvciBleGFtcGxlKVxuICAgICAgICBpZiAoIXRoaXMuX2NhcHMuc3VwcG9ydFNSR0JCdWZmZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fd2ViR0xWZXJzaW9uID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhcHMuc3VwcG9ydFNSR0JCdWZmZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbFNSR0JFeHRlbnNpb25WYWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIFNSR0I6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1JHQixcbiAgICAgICAgICAgICAgICAgICAgU1JHQjg6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1JHQjgsXG4gICAgICAgICAgICAgICAgICAgIFNSR0I4X0FMUEhBODogV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TUkdCOF9BTFBIQTgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNSR0JFeHRlbnNpb24gPSB0aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJFWFRfc1JHQlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc1JHQkV4dGVuc2lvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhcHMuc3VwcG9ydFNSR0JCdWZmZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2xTUkdCRXh0ZW5zaW9uVmFsdWVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgU1JHQjogc1JHQkV4dGVuc2lvbi5TUkdCX0VYVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFNSR0I4OiBzUkdCRXh0ZW5zaW9uLlNSR0JfQUxQSEFfRVhULFxuICAgICAgICAgICAgICAgICAgICAgICAgU1JHQjhfQUxQSEE4OiBzUkdCRXh0ZW5zaW9uLlNSR0JfQUxQSEFfRVhULFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IHRoZSBmb3JjZWQgc3RhdGUgdGhhdCB3YXMgcHJvdmlkZWQgaW4gb3B0aW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NyZWF0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcmNlU1JHQkJ1ZmZlclN1cHBvcnRTdGF0ZSA9IHRoaXMuX2NyZWF0aW9uT3B0aW9ucy5mb3JjZVNSR0JCdWZmZXJTdXBwb3J0U3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlU1JHQkJ1ZmZlclN1cHBvcnRTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhcHMuc3VwcG9ydFNSR0JCdWZmZXJzID0gdGhpcy5fY2Fwcy5zdXBwb3J0U1JHQkJ1ZmZlcnMgJiYgZm9yY2VTUkdCQnVmZmVyU3VwcG9ydFN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZXB0aCBidWZmZXJcbiAgICAgICAgdGhpcy5fZGVwdGhDdWxsaW5nU3RhdGUuZGVwdGhUZXN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGVwdGhDdWxsaW5nU3RhdGUuZGVwdGhGdW5jID0gdGhpcy5fZ2wuTEVRVUFMO1xuICAgICAgICB0aGlzLl9kZXB0aEN1bGxpbmdTdGF0ZS5kZXB0aE1hc2sgPSB0cnVlO1xuICAgICAgICAvLyBUZXh0dXJlIG1hcHNcbiAgICAgICAgdGhpcy5fbWF4U2ltdWx0YW5lb3VzVGV4dHVyZXMgPSB0aGlzLl9jYXBzLm1heENvbWJpbmVkVGV4dHVyZXNJbWFnZVVuaXRzO1xuICAgICAgICBmb3IgKGxldCBzbG90ID0gMDsgc2xvdCA8IHRoaXMuX21heFNpbXVsdGFuZW91c1RleHR1cmVzOyBzbG90KyspIHtcbiAgICAgICAgICAgIHRoaXMuX25leHRGcmVlVGV4dHVyZVNsb3RzLnB1c2goc2xvdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2dsUmVuZGVyZXIgPT09IFwiTWFsaS1HNzJcIikge1xuICAgICAgICAgICAgLy8gT3ZlcmNvbWUgYSBidWcgd2hlbiB1c2luZyBhIHRleHR1cmUgdG8gc3RvcmUgbW9ycGggdGFyZ2V0cyBvbiBNYWxpLUc3MlxuICAgICAgICAgICAgdGhpcy5fY2Fwcy5kaXNhYmxlTW9ycGhUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW5pdEZlYXR1cmVzKCkge1xuICAgICAgICB0aGlzLl9mZWF0dXJlcyA9IHtcbiAgICAgICAgICAgIGZvcmNlQml0bWFwT3ZlckhUTUxJbWFnZUVsZW1lbnQ6IHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ID09PSBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgc3VwcG9ydFJlbmRlckFuZENvcHlUb0xvZEZvckZsb2F0VGV4dHVyZXM6IHRoaXMuX3dlYkdMVmVyc2lvbiAhPT0gMSxcbiAgICAgICAgICAgIHN1cHBvcnREZXB0aFN0ZW5jaWxUZXh0dXJlOiB0aGlzLl93ZWJHTFZlcnNpb24gIT09IDEsXG4gICAgICAgICAgICBzdXBwb3J0U2hhZG93U2FtcGxlcnM6IHRoaXMuX3dlYkdMVmVyc2lvbiAhPT0gMSxcbiAgICAgICAgICAgIHVuaWZvcm1CdWZmZXJIYXJkQ2hlY2tNYXRyaXg6IGZhbHNlLFxuICAgICAgICAgICAgYWxsb3dUZXh0dXJlUHJlZmlsdGVyaW5nOiB0aGlzLl93ZWJHTFZlcnNpb24gIT09IDEsXG4gICAgICAgICAgICB0cmFja1Vib3NJbkZyYW1lOiBmYWxzZSxcbiAgICAgICAgICAgIGNoZWNrVWJvc0NvbnRlbnRCZWZvcmVVcGxvYWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3VwcG9ydENTTTogdGhpcy5fd2ViR0xWZXJzaW9uICE9PSAxLFxuICAgICAgICAgICAgYmFzaXNOZWVkc1BPVDogdGhpcy5fd2ViR0xWZXJzaW9uID09PSAxLFxuICAgICAgICAgICAgc3VwcG9ydDNEVGV4dHVyZXM6IHRoaXMuX3dlYkdMVmVyc2lvbiAhPT0gMSxcbiAgICAgICAgICAgIG5lZWRUeXBlU3VmZml4SW5TaGFkZXJDb25zdGFudHM6IHRoaXMuX3dlYkdMVmVyc2lvbiAhPT0gMSxcbiAgICAgICAgICAgIHN1cHBvcnRNU0FBOiB0aGlzLl93ZWJHTFZlcnNpb24gIT09IDEsXG4gICAgICAgICAgICBzdXBwb3J0U1NBTzI6IHRoaXMuX3dlYkdMVmVyc2lvbiAhPT0gMSxcbiAgICAgICAgICAgIHN1cHBvcnRJQkxTaGFkb3dzOiB0aGlzLl93ZWJHTFZlcnNpb24gIT09IDEsXG4gICAgICAgICAgICBzdXBwb3J0RXh0ZW5kZWRUZXh0dXJlRm9ybWF0czogdGhpcy5fd2ViR0xWZXJzaW9uICE9PSAxLFxuICAgICAgICAgICAgc3VwcG9ydFN3aXRjaENhc2VJblNoYWRlcjogdGhpcy5fd2ViR0xWZXJzaW9uICE9PSAxLFxuICAgICAgICAgICAgc3VwcG9ydFN5bmNUZXh0dXJlUmVhZDogdHJ1ZSxcbiAgICAgICAgICAgIG5lZWRzSW52ZXJ0aW5nQml0bWFwOiB0cnVlLFxuICAgICAgICAgICAgdXNlVUJPQmluZGluZ0NhY2hlOiB0cnVlLFxuICAgICAgICAgICAgbmVlZFNoYWRlckNvZGVJbmxpbmluZzogZmFsc2UsXG4gICAgICAgICAgICBuZWVkVG9BbHdheXNCaW5kVW5pZm9ybUJ1ZmZlcnM6IGZhbHNlLFxuICAgICAgICAgICAgc3VwcG9ydFJlbmRlclBhc3NlczogZmFsc2UsXG4gICAgICAgICAgICBzdXBwb3J0U3ByaXRlSW5zdGFuY2luZzogdHJ1ZSxcbiAgICAgICAgICAgIGZvcmNlVmVydGV4QnVmZmVyU3RyaWRlQW5kT2Zmc2V0TXVsdGlwbGU0Qnl0ZXM6IGZhbHNlLFxuICAgICAgICAgICAgX2NoZWNrTm9uRmxvYXRWZXJ0ZXhCdWZmZXJzRG9udFJlY3JlYXRlUGlwZWxpbmVDb250ZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIF9jb2xsZWN0VWJvc1VwZGF0ZWRJbkZyYW1lOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IHdlYkdMIGNvbnRleHRcbiAgICAgKiBLZWVwIGl0IGZvciBiYWNrIGNvbXBhdCAtIHVzZSB2ZXJzaW9uIGluc3RlYWRcbiAgICAgKi9cbiAgICBnZXQgd2ViR0xWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2ViR0xWZXJzaW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgICAqIEByZXR1cm5zIFwiRW5naW5lXCIgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJUaGluRW5naW5lXCI7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcHJlcGFyZVdvcmtpbmdDYW52YXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3JraW5nQ2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya2luZ0NhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKDEsIDEpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fd29ya2luZ0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl93b3JraW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBlbmdpbmUgY29udGV4dFxuICAgICAqIEByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB2ZW5kb3IsIHRoZSByZW5kZXJlciBhbmQgdGhlIHZlcnNpb24gb2YgdGhlIGN1cnJlbnQgZW5naW5lIGNvbnRleHRcbiAgICAgKi9cbiAgICBnZXRJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHbEluZm8oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCB3ZWJHTCBjb250ZXh0XG4gICAgICogQHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHZlbmRvciwgdGhlIHJlbmRlcmVyIGFuZCB0aGUgdmVyc2lvbiBvZiB0aGUgY3VycmVudCB3ZWJHTCBjb250ZXh0XG4gICAgICovXG4gICAgZ2V0R2xJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVuZG9yOiB0aGlzLl9nbFZlbmRvcixcbiAgICAgICAgICAgIHJlbmRlcmVyOiB0aGlzLl9nbFJlbmRlcmVyLFxuICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5fZ2xWZXJzaW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipHZXRzIGRyaXZlciBpbmZvIGlmIGF2YWlsYWJsZSAqL1xuICAgIGV4dHJhY3REcml2ZXJJbmZvKCkge1xuICAgICAgICBjb25zdCBnbEluZm8gPSB0aGlzLmdldEdsSW5mbygpO1xuICAgICAgICBpZiAoZ2xJbmZvICYmIGdsSW5mby5yZW5kZXJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGdsSW5mby5yZW5kZXJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCByZW5kZXIgd2lkdGhcbiAgICAgKiBAcGFyYW0gdXNlU2NyZWVuIGRlZmluZXMgaWYgc2NyZWVuIHNpemUgbXVzdCBiZSB1c2VkIChvciB0aGUgY3VycmVudCByZW5kZXIgdGFyZ2V0IGlmIGFueSlcbiAgICAgKiBAcmV0dXJucyBhIG51bWJlciBkZWZpbmluZyB0aGUgY3VycmVudCByZW5kZXIgd2lkdGhcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJXaWR0aCh1c2VTY3JlZW4gPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXVzZVNjcmVlbiAmJiB0aGlzLl9jdXJyZW50UmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFJlbmRlclRhcmdldC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVidWZmZXJEaW1lbnNpb25zT2JqZWN0ID8gdGhpcy5fZnJhbWVidWZmZXJEaW1lbnNpb25zT2JqZWN0LmZyYW1lYnVmZmVyV2lkdGggOiB0aGlzLl9nbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgcmVuZGVyIGhlaWdodFxuICAgICAqIEBwYXJhbSB1c2VTY3JlZW4gZGVmaW5lcyBpZiBzY3JlZW4gc2l6ZSBtdXN0IGJlIHVzZWQgKG9yIHRoZSBjdXJyZW50IHJlbmRlciB0YXJnZXQgaWYgYW55KVxuICAgICAqIEByZXR1cm5zIGEgbnVtYmVyIGRlZmluaW5nIHRoZSBjdXJyZW50IHJlbmRlciBoZWlnaHRcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJIZWlnaHQodXNlU2NyZWVuID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF1c2VTY3JlZW4gJiYgdGhpcy5fY3VycmVudFJlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZWJ1ZmZlckRpbWVuc2lvbnNPYmplY3QgPyB0aGlzLl9mcmFtZWJ1ZmZlckRpbWVuc2lvbnNPYmplY3QuZnJhbWVidWZmZXJIZWlnaHQgOiB0aGlzLl9nbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY3VycmVudCByZW5kZXIgYnVmZmVyIG9yIHRoZSBjdXJyZW50IHJlbmRlciB0YXJnZXQgKGlmIGFueSBpcyBzZXQgdXApXG4gICAgICogQHBhcmFtIGNvbG9yIGRlZmluZXMgdGhlIGNvbG9yIHRvIHVzZVxuICAgICAqIEBwYXJhbSBiYWNrQnVmZmVyIGRlZmluZXMgaWYgdGhlIGJhY2sgYnVmZmVyIG11c3QgYmUgY2xlYXJlZFxuICAgICAqIEBwYXJhbSBkZXB0aCBkZWZpbmVzIGlmIHRoZSBkZXB0aCBidWZmZXIgbXVzdCBiZSBjbGVhcmVkXG4gICAgICogQHBhcmFtIHN0ZW5jaWwgZGVmaW5lcyBpZiB0aGUgc3RlbmNpbCBidWZmZXIgbXVzdCBiZSBjbGVhcmVkXG4gICAgICovXG4gICAgY2xlYXIoY29sb3IsIGJhY2tCdWZmZXIsIGRlcHRoLCBzdGVuY2lsID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdXNlU3RlbmNpbEdsb2JhbE9ubHkgPSB0aGlzLnN0ZW5jaWxTdGF0ZUNvbXBvc2VyLnVzZVN0ZW5jaWxHbG9iYWxPbmx5O1xuICAgICAgICB0aGlzLnN0ZW5jaWxTdGF0ZUNvbXBvc2VyLnVzZVN0ZW5jaWxHbG9iYWxPbmx5ID0gdHJ1ZTsgLy8gbWFrZSBzdXJlIHRoZSBzdGVuY2lsIG1hc2sgaXMgY29taW5nIGZyb20gdGhlIGdsb2JhbCBzdGVuY2lsIGFuZCBub3QgZnJvbSBhIG1hdGVyaWFsIChlZmZlY3QpIHdoaWNoIHdvdWxkIGN1cnJlbnRseSBiZSBpbiBlZmZlY3RcbiAgICAgICAgdGhpcy5hcHBseVN0YXRlcygpO1xuICAgICAgICB0aGlzLnN0ZW5jaWxTdGF0ZUNvbXBvc2VyLnVzZVN0ZW5jaWxHbG9iYWxPbmx5ID0gdXNlU3RlbmNpbEdsb2JhbE9ubHk7XG4gICAgICAgIGxldCBtb2RlID0gMDtcbiAgICAgICAgaWYgKGJhY2tCdWZmZXIgJiYgY29sb3IpIHtcbiAgICAgICAgICAgIGxldCBzZXRCYWNrQnVmZmVyQ29sb3IgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlRm9ybWF0ID0gdGhpcy5fY3VycmVudFJlbmRlclRhcmdldC50ZXh0dXJlPy5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmVGb3JtYXQgPT09IDggfHxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZUZvcm1hdCA9PT0gOSB8fFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlRm9ybWF0ID09PSAxMCB8fFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlRm9ybWF0ID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlVHlwZSA9IHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQudGV4dHVyZT8udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHR1cmVUeXBlID09PSA3IHx8IHRleHR1cmVUeXBlID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBUaGluRW5naW5lLl9UZW1wQ2xlYXJDb2xvclVpbnQzMlswXSA9IGNvbG9yLnIgKiAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICBUaGluRW5naW5lLl9UZW1wQ2xlYXJDb2xvclVpbnQzMlsxXSA9IGNvbG9yLmcgKiAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICBUaGluRW5naW5lLl9UZW1wQ2xlYXJDb2xvclVpbnQzMlsyXSA9IGNvbG9yLmIgKiAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICBUaGluRW5naW5lLl9UZW1wQ2xlYXJDb2xvclVpbnQzMlszXSA9IGNvbG9yLmEgKiAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5jbGVhckJ1ZmZlcnVpdih0aGlzLl9nbC5DT0xPUiwgMCwgVGhpbkVuZ2luZS5fVGVtcENsZWFyQ29sb3JVaW50MzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QmFja0J1ZmZlckNvbG9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBUaGluRW5naW5lLl9UZW1wQ2xlYXJDb2xvckludDMyWzBdID0gY29sb3IuciAqIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRoaW5FbmdpbmUuX1RlbXBDbGVhckNvbG9ySW50MzJbMV0gPSBjb2xvci5nICogMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgVGhpbkVuZ2luZS5fVGVtcENsZWFyQ29sb3JJbnQzMlsyXSA9IGNvbG9yLmIgKiAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICBUaGluRW5naW5lLl9UZW1wQ2xlYXJDb2xvckludDMyWzNdID0gY29sb3IuYSAqIDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLmNsZWFyQnVmZmVyaXYodGhpcy5fZ2wuQ09MT1IsIDAsIFRoaW5FbmdpbmUuX1RlbXBDbGVhckNvbG9ySW50MzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QmFja0J1ZmZlckNvbG9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0QmFja0J1ZmZlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuY2xlYXJDb2xvcihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hICE9PSB1bmRlZmluZWQgPyBjb2xvci5hIDogMS4wKTtcbiAgICAgICAgICAgICAgICBtb2RlIHw9IHRoaXMuX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcHRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VSZXZlcnNlRGVwdGhCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXB0aEN1bGxpbmdTdGF0ZS5kZXB0aEZ1bmMgPSB0aGlzLl9nbC5HRVFVQUw7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuY2xlYXJEZXB0aCgwLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuY2xlYXJEZXB0aCgxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZSB8PSB0aGlzLl9nbC5ERVBUSF9CVUZGRVJfQklUO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGVuY2lsKSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5jbGVhclN0ZW5jaWwoMCk7XG4gICAgICAgICAgICBtb2RlIHw9IHRoaXMuX2dsLlNURU5DSUxfQlVGRkVSX0JJVDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nbC5jbGVhcihtb2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3ZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHggIT09IHRoaXMuX3ZpZXdwb3J0Q2FjaGVkLnggfHwgeSAhPT0gdGhpcy5fdmlld3BvcnRDYWNoZWQueSB8fCB3aWR0aCAhPT0gdGhpcy5fdmlld3BvcnRDYWNoZWQueiB8fCBoZWlnaHQgIT09IHRoaXMuX3ZpZXdwb3J0Q2FjaGVkLncpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0Q2FjaGVkLnggPSB4O1xuICAgICAgICAgICAgdGhpcy5fdmlld3BvcnRDYWNoZWQueSA9IHk7XG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydENhY2hlZC56ID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydENhY2hlZC53ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fZ2wudmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5kIHRoZSBjdXJyZW50IGZyYW1lXG4gICAgICovXG4gICAgZW5kRnJhbWUoKSB7XG4gICAgICAgIHN1cGVyLmVuZEZyYW1lKCk7XG4gICAgICAgIC8vIEZvcmNlIGEgZmx1c2ggaW4gY2FzZSB3ZSBhcmUgdXNpbmcgYSBiYWQgT1MuXG4gICAgICAgIGlmICh0aGlzLl9iYWRPUykge1xuICAgICAgICAgICAgdGhpcy5mbHVzaEZyYW1lYnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGVyZm9ybWFuY2UgbW9uaXRvciBhdHRhY2hlZCB0byB0aGlzIGVuZ2luZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb2MuYmFieWxvbmpzLmNvbS9mZWF0dXJlcy9mZWF0dXJlc0RlZXBEaXZlL3NjZW5lL29wdGltaXplX3lvdXJfc2NlbmUjZW5naW5laW5zdHJ1bWVudGF0aW9uXG4gICAgICovXG4gICAgZ2V0IHBlcmZvcm1hbmNlTW9uaXRvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IFN1cHBvcnRlZCBieSBUaGluRW5naW5lXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgZnJhbWUgYnVmZmVyIHRvIHRoZSBzcGVjaWZpZWQgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0gcnRXcmFwcGVyIFRoZSByZW5kZXIgdGFyZ2V0IHdyYXBwZXIgdG8gcmVuZGVyIHRvXG4gICAgICogQHBhcmFtIGZhY2VJbmRleCBUaGUgZmFjZSBvZiB0aGUgdGV4dHVyZSB0byByZW5kZXIgdG8gaW4gY2FzZSBvZiBjdWJlIHRleHR1cmUgYW5kIGlmIHRoZSByZW5kZXIgdGFyZ2V0IHdyYXBwZXIgaXMgbm90IGEgbXVsdGkgcmVuZGVyIHRhcmdldFxuICAgICAqIEBwYXJhbSByZXF1aXJlZFdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgdGFyZ2V0IHRvIHJlbmRlciB0b1xuICAgICAqIEBwYXJhbSByZXF1aXJlZEhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgdG8gcmVuZGVyIHRvXG4gICAgICogQHBhcmFtIGZvcmNlRnVsbHNjcmVlblZpZXdwb3J0IEZvcmNlcyB0aGUgdmlld3BvcnQgdG8gYmUgdGhlIGVudGlyZSB0ZXh0dXJlL3NjcmVlbiBpZiB0cnVlXG4gICAgICogQHBhcmFtIGxvZExldmVsIERlZmluZXMgdGhlIGxvZCBsZXZlbCB0byBiaW5kIHRvIHRoZSBmcmFtZSBidWZmZXJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgRGVmaW5lcyB0aGUgMmQgYXJyYXkgaW5kZXggdG8gYmluZCB0byB0aGUgZnJhbWUgYnVmZmVyIGlmIHRoZSByZW5kZXIgdGFyZ2V0IHdyYXBwZXIgaXMgbm90IGEgbXVsdGkgcmVuZGVyIHRhcmdldFxuICAgICAqL1xuICAgIGJpbmRGcmFtZWJ1ZmZlcihydFdyYXBwZXIsIGZhY2VJbmRleCA9IDAsIHJlcXVpcmVkV2lkdGgsIHJlcXVpcmVkSGVpZ2h0LCBmb3JjZUZ1bGxzY3JlZW5WaWV3cG9ydCwgbG9kTGV2ZWwgPSAwLCBsYXllciA9IDApIHtcbiAgICAgICAgY29uc3Qgd2ViZ2xSdFdyYXBwZXIgPSBydFdyYXBwZXI7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50UmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnVuQmluZEZyYW1lYnVmZmVyKHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQgPSBydFdyYXBwZXI7XG4gICAgICAgIHRoaXMuX2JpbmRVbmJvdW5kRnJhbWVidWZmZXIod2ViZ2xSdFdyYXBwZXIuX2ZyYW1lYnVmZmVyKTtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgaWYgKCFydFdyYXBwZXIuaXNNdWx0aSkge1xuICAgICAgICAgICAgaWYgKHJ0V3JhcHBlci5pczJEQXJyYXkgfHwgcnRXcmFwcGVyLmlzM0QpIHtcbiAgICAgICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmVMYXllcihnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHJ0V3JhcHBlci50ZXh0dXJlLl9oYXJkd2FyZVRleHR1cmU/LnVuZGVybHlpbmdSZXNvdXJjZSwgbG9kTGV2ZWwsIGxheWVyKTtcbiAgICAgICAgICAgICAgICB3ZWJnbFJ0V3JhcHBlci5fY3VycmVudExPRCA9IGxvZExldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnRXcmFwcGVyLmlzQ3ViZSkge1xuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgZmFjZUluZGV4LCBydFdyYXBwZXIudGV4dHVyZS5faGFyZHdhcmVUZXh0dXJlPy51bmRlcmx5aW5nUmVzb3VyY2UsIGxvZExldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdlYmdsUnRXcmFwcGVyLl9jdXJyZW50TE9EICE9PSBsb2RMZXZlbCkge1xuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgcnRXcmFwcGVyLnRleHR1cmUuX2hhcmR3YXJlVGV4dHVyZT8udW5kZXJseWluZ1Jlc291cmNlLCBsb2RMZXZlbCk7XG4gICAgICAgICAgICAgICAgd2ViZ2xSdFdyYXBwZXIuX2N1cnJlbnRMT0QgPSBsb2RMZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXB0aFN0ZW5jaWxUZXh0dXJlID0gcnRXcmFwcGVyLl9kZXB0aFN0ZW5jaWxUZXh0dXJlO1xuICAgICAgICBpZiAoZGVwdGhTdGVuY2lsVGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHJ0V3JhcHBlci5pczNEKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ0V3JhcHBlci50ZXh0dXJlLndpZHRoICE9PSBkZXB0aFN0ZW5jaWxUZXh0dXJlLndpZHRoIHx8XG4gICAgICAgICAgICAgICAgICAgIHJ0V3JhcHBlci50ZXh0dXJlLmhlaWdodCAhPT0gZGVwdGhTdGVuY2lsVGV4dHVyZS5oZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgcnRXcmFwcGVyLnRleHR1cmUuZGVwdGggIT09IGRlcHRoU3RlbmNpbFRleHR1cmUuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLldhcm4oXCJEZXB0aC9TdGVuY2lsIGF0dGFjaG1lbnQgZm9yIDNEIHRhcmdldCBtdXN0IGhhdmUgc2FtZSBkaW1lbnNpb25zIGFzIGNvbG9yIGF0dGFjaG1lbnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXR0YWNobWVudCA9IHJ0V3JhcHBlci5fZGVwdGhTdGVuY2lsVGV4dHVyZVdpdGhTdGVuY2lsID8gZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIDogZ2wuREVQVEhfQVRUQUNITUVOVDtcbiAgICAgICAgICAgIGlmIChydFdyYXBwZXIuaXMyREFycmF5IHx8IHJ0V3JhcHBlci5pczNEKSB7XG4gICAgICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnQsIGRlcHRoU3RlbmNpbFRleHR1cmUuX2hhcmR3YXJlVGV4dHVyZT8udW5kZXJseWluZ1Jlc291cmNlLCBsb2RMZXZlbCwgbGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnRXcmFwcGVyLmlzQ3ViZSkge1xuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBmYWNlSW5kZXgsIGRlcHRoU3RlbmNpbFRleHR1cmUuX2hhcmR3YXJlVGV4dHVyZT8udW5kZXJseWluZ1Jlc291cmNlLCBsb2RMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgZ2wuVEVYVFVSRV8yRCwgZGVwdGhTdGVuY2lsVGV4dHVyZS5faGFyZHdhcmVUZXh0dXJlPy51bmRlcmx5aW5nUmVzb3VyY2UsIGxvZExldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2ViZ2xSdFdyYXBwZXIuX01TQUFGcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcih3ZWJnbFJ0V3JhcHBlci5fTVNBQUZyYW1lYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2FjaGVkVmlld3BvcnQgJiYgIWZvcmNlRnVsbHNjcmVlblZpZXdwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0KHRoaXMuX2NhY2hlZFZpZXdwb3J0LCByZXF1aXJlZFdpZHRoLCByZXF1aXJlZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXJlcXVpcmVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZFdpZHRoID0gcnRXcmFwcGVyLndpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChsb2RMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFdpZHRoID0gcmVxdWlyZWRXaWR0aCAvIE1hdGgucG93KDIsIGxvZExldmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlcXVpcmVkSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWRIZWlnaHQgPSBydFdyYXBwZXIuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChsb2RMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZEhlaWdodCA9IHJlcXVpcmVkSGVpZ2h0IC8gTWF0aC5wb3coMiwgbG9kTGV2ZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0KDAsIDAsIHJlcXVpcmVkV2lkdGgsIHJlcXVpcmVkSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpcGVDYWNoZXMoKTtcbiAgICB9XG4gICAgc2V0U3RhdGVDdWxsRmFjZVR5cGUoY3VsbEJhY2tGYWNlcywgZm9yY2UpIHtcbiAgICAgICAgY29uc3QgY3VsbEZhY2UgPSAodGhpcy5jdWxsQmFja0ZhY2VzID8/IGN1bGxCYWNrRmFjZXMgPz8gdHJ1ZSkgPyB0aGlzLl9nbC5CQUNLIDogdGhpcy5fZ2wuRlJPTlQ7XG4gICAgICAgIGlmICh0aGlzLl9kZXB0aEN1bGxpbmdTdGF0ZS5jdWxsRmFjZSAhPT0gY3VsbEZhY2UgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoQ3VsbGluZ1N0YXRlLmN1bGxGYWNlID0gY3VsbEZhY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHZhcmlvdXMgc3RhdGVzIHRvIHRoZSB3ZWJHTCBjb250ZXh0XG4gICAgICogQHBhcmFtIGN1bGxpbmcgZGVmaW5lcyBjdWxsaW5nIHN0YXRlOiB0cnVlIHRvIGVuYWJsZSBjdWxsaW5nLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHpPZmZzZXQgZGVmaW5lcyB0aGUgdmFsdWUgdG8gYXBwbHkgdG8gek9mZnNldCAoMCBieSBkZWZhdWx0KVxuICAgICAqIEBwYXJhbSBmb3JjZSBkZWZpbmVzIGlmIHN0YXRlcyBtdXN0IGJlIGFwcGxpZWQgZXZlbiBpZiBjYWNoZSBpcyB1cCB0byBkYXRlXG4gICAgICogQHBhcmFtIHJldmVyc2VTaWRlIGRlZmluZXMgaWYgY3VsbGluZyBtdXN0IGJlIHJldmVyc2VkIChDQ1cgaWYgZmFsc2UsIENXIGlmIHRydWUpXG4gICAgICogQHBhcmFtIGN1bGxCYWNrRmFjZXMgdHJ1ZSB0byBjdWxsIGJhY2sgZmFjZXMsIGZhbHNlIHRvIGN1bGwgZnJvbnQgZmFjZXMgKGlmIGN1bGxpbmcgaXMgZW5hYmxlZClcbiAgICAgKiBAcGFyYW0gc3RlbmNpbCBzdGVuY2lsIHN0YXRlcyB0byBzZXRcbiAgICAgKiBAcGFyYW0gek9mZnNldFVuaXRzIGRlZmluZXMgdGhlIHZhbHVlIHRvIGFwcGx5IHRvIHpPZmZzZXRVbml0cyAoMCBieSBkZWZhdWx0KVxuICAgICAqL1xuICAgIHNldFN0YXRlKGN1bGxpbmcsIHpPZmZzZXQgPSAwLCBmb3JjZSwgcmV2ZXJzZVNpZGUgPSBmYWxzZSwgY3VsbEJhY2tGYWNlcywgc3RlbmNpbCwgek9mZnNldFVuaXRzID0gMCkge1xuICAgICAgICAvLyBDdWxsaW5nXG4gICAgICAgIGlmICh0aGlzLl9kZXB0aEN1bGxpbmdTdGF0ZS5jdWxsICE9PSBjdWxsaW5nIHx8IGZvcmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXB0aEN1bGxpbmdTdGF0ZS5jdWxsID0gY3VsbGluZztcbiAgICAgICAgfVxuICAgICAgICAvLyBDdWxsIGZhY2VcbiAgICAgICAgdGhpcy5zZXRTdGF0ZUN1bGxGYWNlVHlwZShjdWxsQmFja0ZhY2VzLCBmb3JjZSk7XG4gICAgICAgIC8vIFogb2Zmc2V0XG4gICAgICAgIHRoaXMuc2V0Wk9mZnNldCh6T2Zmc2V0KTtcbiAgICAgICAgdGhpcy5zZXRaT2Zmc2V0VW5pdHMoek9mZnNldFVuaXRzKTtcbiAgICAgICAgLy8gRnJvbnQgZmFjZVxuICAgICAgICBjb25zdCBmcm9udEZhY2UgPSByZXZlcnNlU2lkZSA/IHRoaXMuX2dsLkNXIDogdGhpcy5fZ2wuQ0NXO1xuICAgICAgICBpZiAodGhpcy5fZGVwdGhDdWxsaW5nU3RhdGUuZnJvbnRGYWNlICE9PSBmcm9udEZhY2UgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoQ3VsbGluZ1N0YXRlLmZyb250RmFjZSA9IGZyb250RmFjZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGVuY2lsU3RhdGVDb21wb3Nlci5zdGVuY2lsTWF0ZXJpYWwgPSBzdGVuY2lsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfYmluZFVuYm91bmRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEZyYW1lYnVmZmVyICE9PSBmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2N1cnJlbnRGcmFtZUJ1ZmZlcklzRGVmYXVsdEZyYW1lQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudEZyYW1lYnVmZmVyID09PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIG1pcG1hcHMgZm9yIGEgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIHRleHR1cmUgdG8gZ2VuZXJhdGUgdGhlIG1pcG1hcHMgZm9yXG4gICAgICovXG4gICAgZ2VuZXJhdGVNaXBtYXBzKHRleHR1cmUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fZ2V0VGV4dHVyZVRhcmdldCh0ZXh0dXJlKTtcbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0YXJnZXQsIHRleHR1cmUsIHRydWUpO1xuICAgICAgICB0aGlzLl9nbC5nZW5lcmF0ZU1pcG1hcCh0YXJnZXQpO1xuICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KHRhcmdldCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuYmluZCB0aGUgY3VycmVudCByZW5kZXIgdGFyZ2V0IHRleHR1cmUgZnJvbSB0aGUgd2ViR0wgY29udGV4dFxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIGRlZmluZXMgdGhlIHJlbmRlciB0YXJnZXQgd3JhcHBlciB0byB1bmJpbmRcbiAgICAgKiBAcGFyYW0gZGlzYWJsZUdlbmVyYXRlTWlwTWFwcyBkZWZpbmVzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgbWlwbWFwcyBtdXN0IG5vdCBiZSBnZW5lcmF0ZWRcbiAgICAgKiBAcGFyYW0gb25CZWZvcmVVbmJpbmQgZGVmaW5lcyBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSB0aGUgZWZmZWN0aXZlIHVuYmluZFxuICAgICAqL1xuICAgIHVuQmluZEZyYW1lYnVmZmVyKHRleHR1cmUsIGRpc2FibGVHZW5lcmF0ZU1pcE1hcHMgPSBmYWxzZSwgb25CZWZvcmVVbmJpbmQpIHtcbiAgICAgICAgY29uc3Qgd2ViZ2xSdFdyYXBwZXIgPSB0ZXh0dXJlO1xuICAgICAgICB0aGlzLl9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCF3ZWJnbFJ0V3JhcHBlci5kaXNhYmxlQXV0b21hdGljTVNBQVJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLmlzTXVsdGkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVNdWx0aUZyYW1lYnVmZmVyKHRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlRnJhbWVidWZmZXIodGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkaXNhYmxlR2VuZXJhdGVNaXBNYXBzKSB7XG4gICAgICAgICAgICBpZiAodGV4dHVyZS5pc011bHRpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZU1pcE1hcHNNdWx0aUZyYW1lYnVmZmVyKHRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZU1pcE1hcHNGcmFtZWJ1ZmZlcih0ZXh0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob25CZWZvcmVVbmJpbmQpIHtcbiAgICAgICAgICAgIGlmICh3ZWJnbFJ0V3JhcHBlci5fTVNBQUZyYW1lYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQmluZCB0aGUgY29ycmVjdCBmcmFtZWJ1ZmZlclxuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRVbmJvdW5kRnJhbWVidWZmZXIod2ViZ2xSdFdyYXBwZXIuX2ZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uQmVmb3JlVW5iaW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmluZFVuYm91bmRGcmFtZWJ1ZmZlcihudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIG1pcG1hcHMgZm9yIHRoZSB0ZXh0dXJlIG9mIHRoZSAoc2luZ2xlKSByZW5kZXIgdGFyZ2V0XG4gICAgICogQHBhcmFtIHRleHR1cmUgVGhlIHJlbmRlciB0YXJnZXQgY29udGFpbmluZyB0aGUgdGV4dHVyZSB0byBnZW5lcmF0ZSB0aGUgbWlwbWFwcyBmb3JcbiAgICAgKi9cbiAgICBnZW5lcmF0ZU1pcE1hcHNGcmFtZWJ1ZmZlcih0ZXh0dXJlKSB7XG4gICAgICAgIGlmICghdGV4dHVyZS5pc011bHRpICYmIHRleHR1cmUudGV4dHVyZT8uZ2VuZXJhdGVNaXBNYXBzICYmICF0ZXh0dXJlLmlzQ3ViZSkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHModGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgTVNBQSB0ZXh0dXJlIG9mIHRoZSAoc2luZ2xlKSByZW5kZXIgdGFyZ2V0IGludG8gaXRzIG5vbi1NU0FBIHZlcnNpb24uXG4gICAgICogTm90ZSB0aGF0IGlmIFwidGV4dHVyZVwiIGlzIG5vdCBhIE1TQUEgcmVuZGVyIHRhcmdldCwgbm8gcmVzb2x2ZSBpcyBwZXJmb3JtZWQuXG4gICAgICogQHBhcmFtIHRleHR1cmUgIFRoZSByZW5kZXIgdGFyZ2V0IHRleHR1cmUgY29udGFpbmluZyB0aGUgTVNBQSB0ZXh0dXJlcyB0byByZXNvbHZlXG4gICAgICovXG4gICAgcmVzb2x2ZUZyYW1lYnVmZmVyKHRleHR1cmUpIHtcbiAgICAgICAgY29uc3QgcnRXcmFwcGVyID0gdGV4dHVyZTtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgaWYgKCFydFdyYXBwZXIuX01TQUFGcmFtZWJ1ZmZlciB8fCBydFdyYXBwZXIuaXNNdWx0aSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBidWZmZXJCaXRzID0gcnRXcmFwcGVyLnJlc29sdmVNU0FBQ29sb3JzID8gZ2wuQ09MT1JfQlVGRkVSX0JJVCA6IDA7XG4gICAgICAgIGJ1ZmZlckJpdHMgfD0gcnRXcmFwcGVyLl9nZW5lcmF0ZURlcHRoQnVmZmVyICYmIHJ0V3JhcHBlci5yZXNvbHZlTVNBQURlcHRoID8gZ2wuREVQVEhfQlVGRkVSX0JJVCA6IDA7XG4gICAgICAgIGJ1ZmZlckJpdHMgfD0gcnRXcmFwcGVyLl9nZW5lcmF0ZVN0ZW5jaWxCdWZmZXIgJiYgcnRXcmFwcGVyLnJlc29sdmVNU0FBU3RlbmNpbCA/IGdsLlNURU5DSUxfQlVGRkVSX0JJVCA6IDA7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5SRUFEX0ZSQU1FQlVGRkVSLCBydFdyYXBwZXIuX01TQUFGcmFtZWJ1ZmZlcik7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5EUkFXX0ZSQU1FQlVGRkVSLCBydFdyYXBwZXIuX2ZyYW1lYnVmZmVyKTtcbiAgICAgICAgZ2wuYmxpdEZyYW1lYnVmZmVyKDAsIDAsIHRleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0LCAwLCAwLCB0ZXh0dXJlLndpZHRoLCB0ZXh0dXJlLmhlaWdodCwgYnVmZmVyQml0cywgZ2wuTkVBUkVTVCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNlIGEgd2ViR0wgZmx1c2ggKGllLiBhIGZsdXNoIG9mIGFsbCB3YWl0aW5nIHdlYkdMIGNvbW1hbmRzKVxuICAgICAqL1xuICAgIGZsdXNoRnJhbWVidWZmZXIoKSB7XG4gICAgICAgIHRoaXMuX2dsLmZsdXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuYmluZCB0aGUgY3VycmVudCByZW5kZXIgdGFyZ2V0IGFuZCBiaW5kIHRoZSBkZWZhdWx0IGZyYW1lYnVmZmVyXG4gICAgICovXG4gICAgcmVzdG9yZURlZmF1bHRGcmFtZWJ1ZmZlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMudW5CaW5kRnJhbWVidWZmZXIodGhpcy5fY3VycmVudFJlbmRlclRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9iaW5kVW5ib3VuZEZyYW1lYnVmZmVyKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWRWaWV3cG9ydCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCh0aGlzLl9jYWNoZWRWaWV3cG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aXBlQ2FjaGVzKCk7XG4gICAgfVxuICAgIC8vIFZCT3NcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlc2V0VmVydGV4QnVmZmVyQmluZGluZygpIHtcbiAgICAgICAgdGhpcy5iaW5kQXJyYXlCdWZmZXIobnVsbCk7XG4gICAgICAgIHRoaXMuX2NhY2hlZFZlcnRleEJ1ZmZlcnMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdmVydGV4IGJ1ZmZlclxuICAgICAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIG9yIHNpemUgZm9yIHRoZSB2ZXJ0ZXggYnVmZmVyXG4gICAgICogQHBhcmFtIF91cGRhdGFibGUgd2hldGhlciB0aGUgYnVmZmVyIHNob3VsZCBiZSBjcmVhdGVkIGFzIHVwZGF0YWJsZVxuICAgICAqIEBwYXJhbSBfbGFiZWwgZGVmaW5lcyB0aGUgbGFiZWwgb2YgdGhlIGJ1ZmZlciAoZm9yIGRlYnVnIHB1cnBvc2UpXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBXZWJHTCBzdGF0aWMgYnVmZmVyXG4gICAgICovXG4gICAgY3JlYXRlVmVydGV4QnVmZmVyKGRhdGEsIF91cGRhdGFibGUsIF9sYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlVmVydGV4QnVmZmVyKGRhdGEsIHRoaXMuX2dsLlNUQVRJQ19EUkFXKTtcbiAgICB9XG4gICAgX2NyZWF0ZVZlcnRleEJ1ZmZlcihkYXRhLCB1c2FnZSkge1xuICAgICAgICBjb25zdCB2Ym8gPSB0aGlzLl9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgaWYgKCF2Ym8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgdmVydGV4IGJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhQnVmZmVyID0gbmV3IFdlYkdMRGF0YUJ1ZmZlcih2Ym8pO1xuICAgICAgICB0aGlzLmJpbmRBcnJheUJ1ZmZlcihkYXRhQnVmZmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuYnVmZmVyRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoZGF0YSksIHVzYWdlKTtcbiAgICAgICAgICAgICAgICBkYXRhQnVmZmVyLmNhcGFjaXR5ID0gZGF0YS5sZW5ndGggKiA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuYnVmZmVyRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIGRhdGEsIHVzYWdlKTtcbiAgICAgICAgICAgICAgICBkYXRhQnVmZmVyLmNhcGFjaXR5ID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2wuYnVmZmVyRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIG5ldyBVaW50OEFycmF5KGRhdGEpLCB1c2FnZSk7XG4gICAgICAgICAgICBkYXRhQnVmZmVyLmNhcGFjaXR5ID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNldFZlcnRleEJ1ZmZlckJpbmRpbmcoKTtcbiAgICAgICAgZGF0YUJ1ZmZlci5yZWZlcmVuY2VzID0gMTtcbiAgICAgICAgcmV0dXJuIGRhdGFCdWZmZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkeW5hbWljIHZlcnRleCBidWZmZXJcbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGR5bmFtaWMgdmVydGV4IGJ1ZmZlclxuICAgICAqIEBwYXJhbSBfbGFiZWwgZGVmaW5lcyB0aGUgbGFiZWwgb2YgdGhlIGJ1ZmZlciAoZm9yIGRlYnVnIHB1cnBvc2UpXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBXZWJHTCBkeW5hbWljIGJ1ZmZlclxuICAgICAqL1xuICAgIGNyZWF0ZUR5bmFtaWNWZXJ0ZXhCdWZmZXIoZGF0YSwgX2xhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVWZXJ0ZXhCdWZmZXIoZGF0YSwgdGhpcy5fZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICB9XG4gICAgX3Jlc2V0SW5kZXhCdWZmZXJCaW5kaW5nKCkge1xuICAgICAgICB0aGlzLmJpbmRJbmRleEJ1ZmZlcihudWxsKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkSW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluZGV4IGJ1ZmZlclxuICAgICAqIEBwYXJhbSBpbmRpY2VzIGRlZmluZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGluZGV4IGJ1ZmZlclxuICAgICAqIEBwYXJhbSB1cGRhdGFibGUgZGVmaW5lcyBpZiB0aGUgaW5kZXggYnVmZmVyIG11c3QgYmUgdXBkYXRhYmxlXG4gICAgICogQHBhcmFtIF9sYWJlbCBkZWZpbmVzIHRoZSBsYWJlbCBvZiB0aGUgYnVmZmVyIChmb3IgZGVidWcgcHVycG9zZSlcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB3ZWJHTCBidWZmZXJcbiAgICAgKi9cbiAgICBjcmVhdGVJbmRleEJ1ZmZlcihpbmRpY2VzLCB1cGRhdGFibGUsIF9sYWJlbCkge1xuICAgICAgICBjb25zdCB2Ym8gPSB0aGlzLl9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgZGF0YUJ1ZmZlciA9IG5ldyBXZWJHTERhdGFCdWZmZXIodmJvKTtcbiAgICAgICAgaWYgKCF2Ym8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgaW5kZXggYnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZEluZGV4QnVmZmVyKGRhdGFCdWZmZXIpO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fbm9ybWFsaXplSW5kZXhEYXRhKGluZGljZXMpO1xuICAgICAgICB0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBkYXRhLCB1cGRhdGFibGUgPyB0aGlzLl9nbC5EWU5BTUlDX0RSQVcgOiB0aGlzLl9nbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgIHRoaXMuX3Jlc2V0SW5kZXhCdWZmZXJCaW5kaW5nKCk7XG4gICAgICAgIGRhdGFCdWZmZXIucmVmZXJlbmNlcyA9IDE7XG4gICAgICAgIGRhdGFCdWZmZXIuaXMzMkJpdHMgPSBkYXRhLkJZVEVTX1BFUl9FTEVNRU5UID09PSA0O1xuICAgICAgICByZXR1cm4gZGF0YUJ1ZmZlcjtcbiAgICB9XG4gICAgX25vcm1hbGl6ZUluZGV4RGF0YShpbmRpY2VzKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzUGVyRWxlbWVudCA9IGluZGljZXMuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgIGlmIChieXRlc1BlckVsZW1lbnQgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIDMyIGJpdCBzdXBwb3J0XG4gICAgICAgIGlmICh0aGlzLl9jYXBzLnVpbnRJbmRpY2VzKSB7XG4gICAgICAgICAgICBpZiAoaW5kaWNlcyBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBudW1iZXJbXSBvciBJbnQzMkFycmF5LCBjaGVjayBpZiAzMiBiaXQgaXMgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGluZGljZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRpY2VzW2luZGV4XSA+PSA2NTUzNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShpbmRpY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIDMyIGJpdCBzdXBwb3J0LCBmb3JjZSBjb252ZXJzaW9uIHRvIDE2IGJpdCAodmFsdWVzIGdyZWF0ZXIgMTYgYml0IGFyZSBsb3N0KVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGluZGljZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGEgd2ViR0wgYnVmZmVyIHRvIHRoZSB3ZWJHTCBjb250ZXh0XG4gICAgICogQHBhcmFtIGJ1ZmZlciBkZWZpbmVzIHRoZSBidWZmZXIgdG8gYmluZFxuICAgICAqL1xuICAgIGJpbmRBcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92YW9SZWNvcmRJblByb2dyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl91bmJpbmRWZXJ0ZXhBcnJheU9iamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JpbmRCdWZmZXIoYnVmZmVyLCB0aGlzLl9nbC5BUlJBWV9CVUZGRVIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGEgc3BlY2lmaWMgYmxvY2sgYXQgYSBnaXZlbiBpbmRleCBpbiBhIHNwZWNpZmljIHNoYWRlciBwcm9ncmFtXG4gICAgICogQHBhcmFtIHBpcGVsaW5lQ29udGV4dCBkZWZpbmVzIHRoZSBwaXBlbGluZSBjb250ZXh0IHRvIHVzZVxuICAgICAqIEBwYXJhbSBibG9ja05hbWUgZGVmaW5lcyB0aGUgYmxvY2sgbmFtZVxuICAgICAqIEBwYXJhbSBpbmRleCBkZWZpbmVzIHRoZSBpbmRleCB3aGVyZSB0byBiaW5kIHRoZSBibG9ja1xuICAgICAqL1xuICAgIGJpbmRVbmlmb3JtQmxvY2socGlwZWxpbmVDb250ZXh0LCBibG9ja05hbWUsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBwaXBlbGluZUNvbnRleHQucHJvZ3JhbTtcbiAgICAgICAgY29uc3QgdW5pZm9ybUxvY2F0aW9uID0gdGhpcy5fZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgocHJvZ3JhbSwgYmxvY2tOYW1lKTtcbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybUJsb2NrQmluZGluZyhwcm9ncmFtLCB1bmlmb3JtTG9jYXRpb24sIGluZGV4KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIGJpbmRJbmRleEJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92YW9SZWNvcmRJblByb2dyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl91bmJpbmRWZXJ0ZXhBcnJheU9iamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JpbmRCdWZmZXIoYnVmZmVyLCB0aGlzLl9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUik7XG4gICAgfVxuICAgIF9iaW5kQnVmZmVyKGJ1ZmZlciwgdGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl92YW9SZWNvcmRJblByb2dyZXNzIHx8IHRoaXMuX2N1cnJlbnRCb3VuZEJ1ZmZlclt0YXJnZXRdICE9PSBidWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLmJpbmRCdWZmZXIodGFyZ2V0LCBidWZmZXIgPyBidWZmZXIudW5kZXJseWluZ1Jlc291cmNlIDogbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Qm91bmRCdWZmZXJbdGFyZ2V0XSA9IGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGJvdW5kIGJ1ZmZlciB3aXRoIHRoZSBnaXZlbiBkYXRhXG4gICAgICogQHBhcmFtIGRhdGEgZGVmaW5lcyB0aGUgZGF0YSB0byB1cGRhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVBcnJheUJ1ZmZlcihkYXRhKSB7XG4gICAgICAgIHRoaXMuX2dsLmJ1ZmZlclN1YkRhdGEodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCAwLCBkYXRhKTtcbiAgICB9XG4gICAgX3ZlcnRleEF0dHJpYlBvaW50ZXIoYnVmZmVyLCBpbmR4LCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBwb2ludGVyID0gdGhpcy5fY3VycmVudEJ1ZmZlclBvaW50ZXJzW2luZHhdO1xuICAgICAgICBpZiAoIXBvaW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXBvaW50ZXIuYWN0aXZlKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBvaW50ZXIuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHBvaW50ZXIuaW5kZXggPSBpbmR4O1xuICAgICAgICAgICAgcG9pbnRlci5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHBvaW50ZXIudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBwb2ludGVyLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgcG9pbnRlci5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgICAgICBwb2ludGVyLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHBvaW50ZXIuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBvaW50ZXIuYnVmZmVyICE9PSBidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2ludGVyLnNpemUgIT09IHNpemUpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvaW50ZXIudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXIudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9pbnRlci5ub3JtYWxpemVkICE9PSBub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlci5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2ludGVyLnN0cmlkZSAhPT0gc3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlci5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9pbnRlci5vZmZzZXQgIT09IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXIub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VkIHx8IHRoaXMuX3Zhb1JlY29yZEluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZEFycmF5QnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdGhpcy5fZ2wuVU5TSUdORURfSU5UIHx8IHR5cGUgPT09IHRoaXMuX2dsLklOVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLnZlcnRleEF0dHJpYklQb2ludGVyKGluZHgsIHNpemUsIHR5cGUsIHN0cmlkZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoaW5keCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9iaW5kSW5kZXhCdWZmZXJXaXRoQ2FjaGUoaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgaWYgKGluZGV4QnVmZmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2FjaGVkSW5kZXhCdWZmZXIgIT09IGluZGV4QnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRJbmRleEJ1ZmZlciA9IGluZGV4QnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5iaW5kSW5kZXhCdWZmZXIoaW5kZXhCdWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fdWludEluZGljZXNDdXJyZW50bHlTZXQgPSBpbmRleEJ1ZmZlci5pczMyQml0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYmluZFZlcnRleEJ1ZmZlcnNBdHRyaWJ1dGVzKHZlcnRleEJ1ZmZlcnMsIGVmZmVjdCwgb3ZlcnJpZGVWZXJ0ZXhCdWZmZXJzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBlZmZlY3QuZ2V0QXR0cmlidXRlc05hbWVzKCk7XG4gICAgICAgIGlmICghdGhpcy5fdmFvUmVjb3JkSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgdGhpcy5fdW5iaW5kVmVydGV4QXJyYXlPYmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuYmluZEFsbEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBvcmRlciA9IGVmZmVjdC5nZXRBdHRyaWJ1dGVMb2NhdGlvbihpbmRleCk7XG4gICAgICAgICAgICBpZiAob3JkZXIgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFpID0gYXR0cmlidXRlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IHZlcnRleEJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlVmVydGV4QnVmZmVycykge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXIgPSBvdmVycmlkZVZlcnRleEJ1ZmZlcnNbYWldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXZlcnRleEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXIgPSB2ZXJ0ZXhCdWZmZXJzW2FpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF2ZXJ0ZXhCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG9yZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Zhb1JlY29yZEluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliQXJyYXlzRW5hYmxlZFtvcmRlcl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSB2ZXJ0ZXhCdWZmZXIuZ2V0QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWJQb2ludGVyKGJ1ZmZlciwgb3JkZXIsIHZlcnRleEJ1ZmZlci5nZXRTaXplKCksIHZlcnRleEJ1ZmZlci50eXBlLCB2ZXJ0ZXhCdWZmZXIubm9ybWFsaXplZCwgdmVydGV4QnVmZmVyLmJ5dGVTdHJpZGUsIHZlcnRleEJ1ZmZlci5ieXRlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleEJ1ZmZlci5nZXRJc0luc3RhbmNlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKG9yZGVyLCB2ZXJ0ZXhCdWZmZXIuZ2V0SW5zdGFuY2VEaXZpc29yKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl92YW9SZWNvcmRJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEluc3RhbmNlTG9jYXRpb25zLnB1c2gob3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0YW5jZUJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29yZHMgYSB2ZXJ0ZXggYXJyYXkgb2JqZWN0XG4gICAgICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL3NldHVwL3N1cHBvcnQvd2ViR0wyI3ZlcnRleC1hcnJheS1vYmplY3RzXG4gICAgICogQHBhcmFtIHZlcnRleEJ1ZmZlcnMgZGVmaW5lcyB0aGUgbGlzdCBvZiB2ZXJ0ZXggYnVmZmVycyB0byBzdG9yZVxuICAgICAqIEBwYXJhbSBpbmRleEJ1ZmZlciBkZWZpbmVzIHRoZSBpbmRleCBidWZmZXIgdG8gc3RvcmVcbiAgICAgKiBAcGFyYW0gZWZmZWN0IGRlZmluZXMgdGhlIGVmZmVjdCB0byBzdG9yZVxuICAgICAqIEBwYXJhbSBvdmVycmlkZVZlcnRleEJ1ZmZlcnMgZGVmaW5lcyBvcHRpb25hbCBsaXN0IG9mIGF2ZXJ0ZXggYnVmZmVycyB0aGF0IG92ZXJyaWRlcyB0aGUgZW50cmllcyBpbiB2ZXJ0ZXhCdWZmZXJzXG4gICAgICogQHJldHVybnMgdGhlIG5ldyB2ZXJ0ZXggYXJyYXkgb2JqZWN0XG4gICAgICovXG4gICAgcmVjb3JkVmVydGV4QXJyYXlPYmplY3QodmVydGV4QnVmZmVycywgaW5kZXhCdWZmZXIsIGVmZmVjdCwgb3ZlcnJpZGVWZXJ0ZXhCdWZmZXJzKSB7XG4gICAgICAgIGNvbnN0IHZhbyA9IHRoaXMuX2dsLmNyZWF0ZVZlcnRleEFycmF5KCk7XG4gICAgICAgIGlmICghdmFvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIFZBT1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YW9SZWNvcmRJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG4gICAgICAgIHRoaXMuX211c3RXaXBlVmVydGV4QXR0cmlidXRlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2JpbmRWZXJ0ZXhCdWZmZXJzQXR0cmlidXRlcyh2ZXJ0ZXhCdWZmZXJzLCBlZmZlY3QsIG92ZXJyaWRlVmVydGV4QnVmZmVycyk7XG4gICAgICAgIHRoaXMuYmluZEluZGV4QnVmZmVyKGluZGV4QnVmZmVyKTtcbiAgICAgICAgdGhpcy5fdmFvUmVjb3JkSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9nbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICAgIHJldHVybiB2YW87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgYSBzcGVjaWZpYyB2ZXJ0ZXggYXJyYXkgb2JqZWN0XG4gICAgICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL3NldHVwL3N1cHBvcnQvd2ViR0wyI3ZlcnRleC1hcnJheS1vYmplY3RzXG4gICAgICogQHBhcmFtIHZlcnRleEFycmF5T2JqZWN0IGRlZmluZXMgdGhlIHZlcnRleCBhcnJheSBvYmplY3QgdG8gYmluZFxuICAgICAqIEBwYXJhbSBpbmRleEJ1ZmZlciBkZWZpbmVzIHRoZSBpbmRleCBidWZmZXIgdG8gYmluZFxuICAgICAqL1xuICAgIGJpbmRWZXJ0ZXhBcnJheU9iamVjdCh2ZXJ0ZXhBcnJheU9iamVjdCwgaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZFZlcnRleEFycmF5T2JqZWN0ICE9PSB2ZXJ0ZXhBcnJheU9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkVmVydGV4QXJyYXlPYmplY3QgPSB2ZXJ0ZXhBcnJheU9iamVjdDtcbiAgICAgICAgICAgIHRoaXMuX2dsLmJpbmRWZXJ0ZXhBcnJheSh2ZXJ0ZXhBcnJheU9iamVjdCk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRWZXJ0ZXhCdWZmZXJzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZEluZGV4QnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3VpbnRJbmRpY2VzQ3VycmVudGx5U2V0ID0gaW5kZXhCdWZmZXIgIT0gbnVsbCAmJiBpbmRleEJ1ZmZlci5pczMyQml0cztcbiAgICAgICAgICAgIHRoaXMuX211c3RXaXBlVmVydGV4QXR0cmlidXRlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCB3ZWJHbCBidWZmZXJzIGRpcmVjdGx5IHRvIHRoZSB3ZWJHTCBjb250ZXh0XG4gICAgICogQHBhcmFtIHZlcnRleEJ1ZmZlciBkZWZpbmVzIHRoZSB2ZXJ0ZXggYnVmZmVyIHRvIGJpbmRcbiAgICAgKiBAcGFyYW0gaW5kZXhCdWZmZXIgZGVmaW5lcyB0aGUgaW5kZXggYnVmZmVyIHRvIGJpbmRcbiAgICAgKiBAcGFyYW0gdmVydGV4RGVjbGFyYXRpb24gZGVmaW5lcyB0aGUgdmVydGV4IGRlY2xhcmF0aW9uIHRvIHVzZSB3aXRoIHRoZSB2ZXJ0ZXggYnVmZmVyXG4gICAgICogQHBhcmFtIHZlcnRleFN0cmlkZVNpemUgZGVmaW5lcyB0aGUgdmVydGV4IHN0cmlkZSBvZiB0aGUgdmVydGV4IGJ1ZmZlclxuICAgICAqIEBwYXJhbSBlZmZlY3QgZGVmaW5lcyB0aGUgZWZmZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGV4IGJ1ZmZlclxuICAgICAqL1xuICAgIGJpbmRCdWZmZXJzRGlyZWN0bHkodmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlciwgdmVydGV4RGVjbGFyYXRpb24sIHZlcnRleFN0cmlkZVNpemUsIGVmZmVjdCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkVmVydGV4QnVmZmVycyAhPT0gdmVydGV4QnVmZmVyIHx8IHRoaXMuX2NhY2hlZEVmZmVjdEZvclZlcnRleEJ1ZmZlcnMgIT09IGVmZmVjdCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkVmVydGV4QnVmZmVycyA9IHZlcnRleEJ1ZmZlcjtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZEVmZmVjdEZvclZlcnRleEJ1ZmZlcnMgPSBlZmZlY3Q7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzQ291bnQgPSBlZmZlY3QuZ2V0QXR0cmlidXRlc0NvdW50KCk7XG4gICAgICAgICAgICB0aGlzLl91bmJpbmRWZXJ0ZXhBcnJheU9iamVjdCgpO1xuICAgICAgICAgICAgdGhpcy51bmJpbmRBbGxBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhdHRyaWJ1dGVzQ291bnQ7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB2ZXJ0ZXhEZWNsYXJhdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSBlZmZlY3QuZ2V0QXR0cmlidXRlTG9jYXRpb24oaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXIgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkob3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliQXJyYXlzRW5hYmxlZFtvcmRlcl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhCdWZmZXIsIG9yZGVyLCB2ZXJ0ZXhEZWNsYXJhdGlvbltpbmRleF0sIHRoaXMuX2dsLkZMT0FULCBmYWxzZSwgdmVydGV4U3RyaWRlU2l6ZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdmVydGV4RGVjbGFyYXRpb25baW5kZXhdICogNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmluZEluZGV4QnVmZmVyV2l0aENhY2hlKGluZGV4QnVmZmVyKTtcbiAgICB9XG4gICAgX3VuYmluZFZlcnRleEFycmF5T2JqZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlZFZlcnRleEFycmF5T2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FjaGVkVmVydGV4QXJyYXlPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9nbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgYSBsaXN0IG9mIHZlcnRleCBidWZmZXJzIHRvIHRoZSB3ZWJHTCBjb250ZXh0XG4gICAgICogQHBhcmFtIHZlcnRleEJ1ZmZlcnMgZGVmaW5lcyB0aGUgbGlzdCBvZiB2ZXJ0ZXggYnVmZmVycyB0byBiaW5kXG4gICAgICogQHBhcmFtIGluZGV4QnVmZmVyIGRlZmluZXMgdGhlIGluZGV4IGJ1ZmZlciB0byBiaW5kXG4gICAgICogQHBhcmFtIGVmZmVjdCBkZWZpbmVzIHRoZSBlZmZlY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSB2ZXJ0ZXggYnVmZmVyc1xuICAgICAqIEBwYXJhbSBvdmVycmlkZVZlcnRleEJ1ZmZlcnMgZGVmaW5lcyBvcHRpb25hbCBsaXN0IG9mIGF2ZXJ0ZXggYnVmZmVycyB0aGF0IG92ZXJyaWRlcyB0aGUgZW50cmllcyBpbiB2ZXJ0ZXhCdWZmZXJzXG4gICAgICovXG4gICAgYmluZEJ1ZmZlcnModmVydGV4QnVmZmVycywgaW5kZXhCdWZmZXIsIGVmZmVjdCwgb3ZlcnJpZGVWZXJ0ZXhCdWZmZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWRWZXJ0ZXhCdWZmZXJzICE9PSB2ZXJ0ZXhCdWZmZXJzIHx8IHRoaXMuX2NhY2hlZEVmZmVjdEZvclZlcnRleEJ1ZmZlcnMgIT09IGVmZmVjdCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkVmVydGV4QnVmZmVycyA9IHZlcnRleEJ1ZmZlcnM7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRFZmZlY3RGb3JWZXJ0ZXhCdWZmZXJzID0gZWZmZWN0O1xuICAgICAgICAgICAgdGhpcy5fYmluZFZlcnRleEJ1ZmZlcnNBdHRyaWJ1dGVzKHZlcnRleEJ1ZmZlcnMsIGVmZmVjdCwgb3ZlcnJpZGVWZXJ0ZXhCdWZmZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iaW5kSW5kZXhCdWZmZXJXaXRoQ2FjaGUoaW5kZXhCdWZmZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgYWxsIGluc3RhbmNlIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICB1bmJpbmRJbnN0YW5jZUF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGxldCBib3VuZEJ1ZmZlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHVsID0gdGhpcy5fY3VycmVudEluc3RhbmNlTG9jYXRpb25zLmxlbmd0aDsgaSA8IHVsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlc0J1ZmZlciA9IHRoaXMuX2N1cnJlbnRJbnN0YW5jZUJ1ZmZlcnNbaV07XG4gICAgICAgICAgICBpZiAoYm91bmRCdWZmZXIgIT0gaW5zdGFuY2VzQnVmZmVyICYmIGluc3RhbmNlc0J1ZmZlci5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgYm91bmRCdWZmZXIgPSBpbnN0YW5jZXNCdWZmZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kQXJyYXlCdWZmZXIoaW5zdGFuY2VzQnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldExvY2F0aW9uID0gdGhpcy5fY3VycmVudEluc3RhbmNlTG9jYXRpb25zW2ldO1xuICAgICAgICAgICAgdGhpcy5fZ2wudmVydGV4QXR0cmliRGl2aXNvcihvZmZzZXRMb2NhdGlvbiwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudEluc3RhbmNlQnVmZmVycy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9jdXJyZW50SW5zdGFuY2VMb2NhdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsZWFzZSBhbmQgZnJlZSB0aGUgbWVtb3J5IG9mIGEgdmVydGV4IGFycmF5IG9iamVjdFxuICAgICAqIEBwYXJhbSB2YW8gZGVmaW5lcyB0aGUgdmVydGV4IGFycmF5IG9iamVjdCB0byBkZWxldGVcbiAgICAgKi9cbiAgICByZWxlYXNlVmVydGV4QXJyYXlPYmplY3QodmFvKSB7XG4gICAgICAgIHRoaXMuX2dsLmRlbGV0ZVZlcnRleEFycmF5KHZhbyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9yZWxlYXNlQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICBidWZmZXIucmVmZXJlbmNlcy0tO1xuICAgICAgICBpZiAoYnVmZmVyLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGV0ZUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfZGVsZXRlQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLl9nbC5kZWxldGVCdWZmZXIoYnVmZmVyLnVuZGVybHlpbmdSZXNvdXJjZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgY29udGVudCBvZiBhIHdlYkdMIGJ1ZmZlciB1c2VkIHdpdGggaW5zdGFudGlhdGlvbiBhbmQgYmluZCBpdCB0byB0aGUgd2ViR0wgY29udGV4dFxuICAgICAqIEBwYXJhbSBpbnN0YW5jZXNCdWZmZXIgZGVmaW5lcyB0aGUgd2ViR0wgYnVmZmVyIHRvIHVwZGF0ZSBhbmQgYmluZFxuICAgICAqIEBwYXJhbSBkYXRhIGRlZmluZXMgdGhlIGRhdGEgdG8gc3RvcmUgaW4gdGhlIGJ1ZmZlclxuICAgICAqIEBwYXJhbSBvZmZzZXRMb2NhdGlvbnMgZGVmaW5lcyB0aGUgb2Zmc2V0cyBvciBhdHRyaWJ1dGVzIGluZm9ybWF0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXJlIGRhdGEgbXVzdCBiZSBzdG9yZWQgaW4gdGhlIGJ1ZmZlclxuICAgICAqL1xuICAgIHVwZGF0ZUFuZEJpbmRJbnN0YW5jZXNCdWZmZXIoaW5zdGFuY2VzQnVmZmVyLCBkYXRhLCBvZmZzZXRMb2NhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5iaW5kQXJyYXlCdWZmZXIoaW5zdGFuY2VzQnVmZmVyKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLmJ1ZmZlclN1YkRhdGEodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCAwLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0TG9jYXRpb25zWzBdLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZEluc3RhbmNlc0J1ZmZlcihpbnN0YW5jZXNCdWZmZXIsIG9mZnNldExvY2F0aW9ucywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgNDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldExvY2F0aW9uID0gb2Zmc2V0TG9jYXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3ZlcnRleEF0dHJpYkFycmF5c0VuYWJsZWRbb2Zmc2V0TG9jYXRpb25dKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG9mZnNldExvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliQXJyYXlzRW5hYmxlZFtvZmZzZXRMb2NhdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWJQb2ludGVyKGluc3RhbmNlc0J1ZmZlciwgb2Zmc2V0TG9jYXRpb24sIDQsIHRoaXMuX2dsLkZMT0FULCBmYWxzZSwgNjQsIGluZGV4ICogMTYpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLnZlcnRleEF0dHJpYkRpdmlzb3Iob2Zmc2V0TG9jYXRpb24sIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0YW5jZUxvY2F0aW9ucy5wdXNoKG9mZnNldExvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5zdGFuY2VCdWZmZXJzLnB1c2goaW5zdGFuY2VzQnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIHRoZSBjb250ZW50IG9mIGEgd2ViR0wgYnVmZmVyIHVzZWQgd2l0aCBpbnN0YW50aWF0aW9uXG4gICAgICogQHBhcmFtIGluc3RhbmNlc0J1ZmZlciBkZWZpbmVzIHRoZSB3ZWJHTCBidWZmZXIgdG8gYmluZFxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzSW5mbyBkZWZpbmVzIHRoZSBvZmZzZXRzIG9yIGF0dHJpYnV0ZXMgaW5mb3JtYXRpb24gdXNlZCB0byBkZXRlcm1pbmUgd2hlcmUgZGF0YSBtdXN0IGJlIHN0b3JlZCBpbiB0aGUgYnVmZmVyXG4gICAgICogQHBhcmFtIGNvbXB1dGVTdHJpZGUgZGVmaW5lcyBXaGV0aGVyIHRvIGNvbXB1dGUgdGhlIHN0cmlkZXMgZnJvbSB0aGUgaW5mbyBvciB1c2UgdGhlIGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGJpbmRJbnN0YW5jZXNCdWZmZXIoaW5zdGFuY2VzQnVmZmVyLCBhdHRyaWJ1dGVzSW5mbywgY29tcHV0ZVN0cmlkZSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5iaW5kQXJyYXlCdWZmZXIoaW5zdGFuY2VzQnVmZmVyKTtcbiAgICAgICAgbGV0IHN0cmlkZSA9IDA7XG4gICAgICAgIGlmIChjb21wdXRlU3RyaWRlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXNJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWkgPSBhdHRyaWJ1dGVzSW5mb1tpXTtcbiAgICAgICAgICAgICAgICBzdHJpZGUgKz0gYWkuYXR0cmlidXRlU2l6ZSAqIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWkgPSBhdHRyaWJ1dGVzSW5mb1tpXTtcbiAgICAgICAgICAgIGlmIChhaS5pbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWkuaW5kZXggPSB0aGlzLl9jdXJyZW50RWZmZWN0LmdldEF0dHJpYnV0ZUxvY2F0aW9uQnlOYW1lKGFpLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFpLmluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl92ZXJ0ZXhBdHRyaWJBcnJheXNFbmFibGVkW2FpLmluZGV4XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFpLmluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWJBcnJheXNFbmFibGVkW2FpLmluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWJQb2ludGVyKGluc3RhbmNlc0J1ZmZlciwgYWkuaW5kZXgsIGFpLmF0dHJpYnV0ZVNpemUsIGFpLmF0dHJpYnV0ZVR5cGUgfHwgdGhpcy5fZ2wuRkxPQVQsIGFpLm5vcm1hbGl6ZWQgfHwgZmFsc2UsIHN0cmlkZSwgYWkub2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuX2dsLnZlcnRleEF0dHJpYkRpdmlzb3IoYWkuaW5kZXgsIGFpLmRpdmlzb3IgPT09IHVuZGVmaW5lZCA/IDEgOiBhaS5kaXZpc29yKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0YW5jZUxvY2F0aW9ucy5wdXNoKGFpLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0YW5jZUJ1ZmZlcnMucHVzaChpbnN0YW5jZXNCdWZmZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIGluc3RhbmNlIGF0dHJpYnV0ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBuYW1lIGluIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSBuYW1lIGRlZmluZXMgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBkaXNhYmxlXG4gICAgICovXG4gICAgZGlzYWJsZUluc3RhbmNlQXR0cmlidXRlQnlOYW1lKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50RWZmZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cmlidXRlTG9jYXRpb24gPSB0aGlzLl9jdXJyZW50RWZmZWN0LmdldEF0dHJpYnV0ZUxvY2F0aW9uQnlOYW1lKG5hbWUpO1xuICAgICAgICB0aGlzLmRpc2FibGVJbnN0YW5jZUF0dHJpYnV0ZShhdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIGluc3RhbmNlIGF0dHJpYnV0ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBsb2NhdGlvbiBpbiBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlTG9jYXRpb24gZGVmaW5lcyB0aGUgYXR0cmlidXRlIGxvY2F0aW9uIG9mIHRoZSBhdHRyaWJ1dGUgdG8gZGlzYWJsZVxuICAgICAqL1xuICAgIGRpc2FibGVJbnN0YW5jZUF0dHJpYnV0ZShhdHRyaWJ1dGVMb2NhdGlvbikge1xuICAgICAgICBsZXQgc2hvdWxkQ2xlYW4gPSBmYWxzZTtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICB3aGlsZSAoKGluZGV4ID0gdGhpcy5fY3VycmVudEluc3RhbmNlTG9jYXRpb25zLmluZGV4T2YoYXR0cmlidXRlTG9jYXRpb24pKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbnN0YW5jZUxvY2F0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEluc3RhbmNlQnVmZmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgc2hvdWxkQ2xlYW4gPSB0cnVlO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9jdXJyZW50SW5zdGFuY2VMb2NhdGlvbnMuaW5kZXhPZihhdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENsZWFuKSB7XG4gICAgICAgICAgICB0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJpYnV0ZUxvY2F0aW9uLCAwKTtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUF0dHJpYnV0ZUJ5SW5kZXgoYXR0cmlidXRlTG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIGF0dHJpYnV0ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBsb2NhdGlvbiBpbiBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlTG9jYXRpb24gZGVmaW5lcyB0aGUgYXR0cmlidXRlIGxvY2F0aW9uIG9mIHRoZSBhdHRyaWJ1dGUgdG8gZGlzYWJsZVxuICAgICAqL1xuICAgIGRpc2FibGVBdHRyaWJ1dGVCeUluZGV4KGF0dHJpYnV0ZUxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuX2dsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYkFycmF5c0VuYWJsZWRbYXR0cmlidXRlTG9jYXRpb25dID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCdWZmZXJQb2ludGVyc1thdHRyaWJ1dGVMb2NhdGlvbl0uYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBkcmF3IG9yZGVyXG4gICAgICogQHBhcmFtIHVzZVRyaWFuZ2xlcyBkZWZpbmVzIGlmIHRyaWFuZ2xlcyBtdXN0IGJlIHVzZWQgdG8gZHJhdyAoZWxzZSB3aXJlZnJhbWUgd2lsbCBiZSB1c2VkKVxuICAgICAqIEBwYXJhbSBpbmRleFN0YXJ0IGRlZmluZXMgdGhlIHN0YXJ0aW5nIGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4Q291bnQgZGVmaW5lcyB0aGUgbnVtYmVyIG9mIGluZGV4IHRvIGRyYXdcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2VzQ291bnQgZGVmaW5lcyB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyB0byBkcmF3IChpZiBpbnN0YW50aWF0aW9uIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgZHJhdyh1c2VUcmlhbmdsZXMsIGluZGV4U3RhcnQsIGluZGV4Q291bnQsIGluc3RhbmNlc0NvdW50KSB7XG4gICAgICAgIHRoaXMuZHJhd0VsZW1lbnRzVHlwZSh1c2VUcmlhbmdsZXMgPyAwIDogMSwgaW5kZXhTdGFydCwgaW5kZXhDb3VudCwgaW5zdGFuY2VzQ291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgbGlzdCBvZiBwb2ludHNcbiAgICAgKiBAcGFyYW0gdmVydGljZXNTdGFydCBkZWZpbmVzIHRoZSBpbmRleCBvZiBmaXJzdCB2ZXJ0ZXggdG8gZHJhd1xuICAgICAqIEBwYXJhbSB2ZXJ0aWNlc0NvdW50IGRlZmluZXMgdGhlIGNvdW50IG9mIHZlcnRpY2VzIHRvIGRyYXdcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2VzQ291bnQgZGVmaW5lcyB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyB0byBkcmF3IChpZiBpbnN0YW50aWF0aW9uIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgZHJhd1BvaW50Q2xvdWRzKHZlcnRpY2VzU3RhcnQsIHZlcnRpY2VzQ291bnQsIGluc3RhbmNlc0NvdW50KSB7XG4gICAgICAgIHRoaXMuZHJhd0FycmF5c1R5cGUoMiwgdmVydGljZXNTdGFydCwgdmVydGljZXNDb3VudCwgaW5zdGFuY2VzQ291bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgbGlzdCBvZiB1bmluZGV4ZWQgcHJpbWl0aXZlc1xuICAgICAqIEBwYXJhbSB1c2VUcmlhbmdsZXMgZGVmaW5lcyBpZiB0cmlhbmdsZXMgbXVzdCBiZSB1c2VkIHRvIGRyYXcgKGVsc2Ugd2lyZWZyYW1lIHdpbGwgYmUgdXNlZClcbiAgICAgKiBAcGFyYW0gdmVydGljZXNTdGFydCBkZWZpbmVzIHRoZSBpbmRleCBvZiBmaXJzdCB2ZXJ0ZXggdG8gZHJhd1xuICAgICAqIEBwYXJhbSB2ZXJ0aWNlc0NvdW50IGRlZmluZXMgdGhlIGNvdW50IG9mIHZlcnRpY2VzIHRvIGRyYXdcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2VzQ291bnQgZGVmaW5lcyB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyB0byBkcmF3IChpZiBpbnN0YW50aWF0aW9uIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgZHJhd1VuSW5kZXhlZCh1c2VUcmlhbmdsZXMsIHZlcnRpY2VzU3RhcnQsIHZlcnRpY2VzQ291bnQsIGluc3RhbmNlc0NvdW50KSB7XG4gICAgICAgIHRoaXMuZHJhd0FycmF5c1R5cGUodXNlVHJpYW5nbGVzID8gMCA6IDEsIHZlcnRpY2VzU3RhcnQsIHZlcnRpY2VzQ291bnQsIGluc3RhbmNlc0NvdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhdyBhIGxpc3Qgb2YgaW5kZXhlZCBwcmltaXRpdmVzXG4gICAgICogQHBhcmFtIGZpbGxNb2RlIGRlZmluZXMgdGhlIHByaW1pdGl2ZSB0byB1c2VcbiAgICAgKiBAcGFyYW0gaW5kZXhTdGFydCBkZWZpbmVzIHRoZSBzdGFydGluZyBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleENvdW50IGRlZmluZXMgdGhlIG51bWJlciBvZiBpbmRleCB0byBkcmF3XG4gICAgICogQHBhcmFtIGluc3RhbmNlc0NvdW50IGRlZmluZXMgdGhlIG51bWJlciBvZiBpbnN0YW5jZXMgdG8gZHJhdyAoaWYgaW5zdGFudGlhdGlvbiBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGRyYXdFbGVtZW50c1R5cGUoZmlsbE1vZGUsIGluZGV4U3RhcnQsIGluZGV4Q291bnQsIGluc3RhbmNlc0NvdW50KSB7XG4gICAgICAgIC8vIEFwcGx5IHN0YXRlc1xuICAgICAgICB0aGlzLmFwcGx5U3RhdGVzKCk7XG4gICAgICAgIHRoaXMuX3JlcG9ydERyYXdDYWxsKCk7XG4gICAgICAgIC8vIFJlbmRlclxuICAgICAgICBjb25zdCBkcmF3TW9kZSA9IHRoaXMuX2RyYXdNb2RlKGZpbGxNb2RlKTtcbiAgICAgICAgY29uc3QgaW5kZXhGb3JtYXQgPSB0aGlzLl91aW50SW5kaWNlc0N1cnJlbnRseVNldCA/IHRoaXMuX2dsLlVOU0lHTkVEX0lOVCA6IHRoaXMuX2dsLlVOU0lHTkVEX1NIT1JUO1xuICAgICAgICBjb25zdCBtdWx0ID0gdGhpcy5fdWludEluZGljZXNDdXJyZW50bHlTZXQgPyA0IDogMjtcbiAgICAgICAgaWYgKGluc3RhbmNlc0NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQoZHJhd01vZGUsIGluZGV4Q291bnQsIGluZGV4Rm9ybWF0LCBpbmRleFN0YXJ0ICogbXVsdCwgaW5zdGFuY2VzQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2wuZHJhd0VsZW1lbnRzKGRyYXdNb2RlLCBpbmRleENvdW50LCBpbmRleEZvcm1hdCwgaW5kZXhTdGFydCAqIG11bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYXcgYSBsaXN0IG9mIHVuaW5kZXhlZCBwcmltaXRpdmVzXG4gICAgICogQHBhcmFtIGZpbGxNb2RlIGRlZmluZXMgdGhlIHByaW1pdGl2ZSB0byB1c2VcbiAgICAgKiBAcGFyYW0gdmVydGljZXNTdGFydCBkZWZpbmVzIHRoZSBpbmRleCBvZiBmaXJzdCB2ZXJ0ZXggdG8gZHJhd1xuICAgICAqIEBwYXJhbSB2ZXJ0aWNlc0NvdW50IGRlZmluZXMgdGhlIGNvdW50IG9mIHZlcnRpY2VzIHRvIGRyYXdcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2VzQ291bnQgZGVmaW5lcyB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyB0byBkcmF3IChpZiBpbnN0YW50aWF0aW9uIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgZHJhd0FycmF5c1R5cGUoZmlsbE1vZGUsIHZlcnRpY2VzU3RhcnQsIHZlcnRpY2VzQ291bnQsIGluc3RhbmNlc0NvdW50KSB7XG4gICAgICAgIC8vIEFwcGx5IHN0YXRlc1xuICAgICAgICB0aGlzLmFwcGx5U3RhdGVzKCk7XG4gICAgICAgIHRoaXMuX3JlcG9ydERyYXdDYWxsKCk7XG4gICAgICAgIGNvbnN0IGRyYXdNb2RlID0gdGhpcy5fZHJhd01vZGUoZmlsbE1vZGUpO1xuICAgICAgICBpZiAoaW5zdGFuY2VzQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLmRyYXdBcnJheXNJbnN0YW5jZWQoZHJhd01vZGUsIHZlcnRpY2VzU3RhcnQsIHZlcnRpY2VzQ291bnQsIGluc3RhbmNlc0NvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLmRyYXdBcnJheXMoZHJhd01vZGUsIHZlcnRpY2VzU3RhcnQsIHZlcnRpY2VzQ291bnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9kcmF3TW9kZShmaWxsTW9kZSkge1xuICAgICAgICBzd2l0Y2ggKGZpbGxNb2RlKSB7XG4gICAgICAgICAgICAvLyBUcmlhbmdsZSB2aWV3c1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5UUklBTkdMRVM7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlBPSU5UUztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuTElORVM7XG4gICAgICAgICAgICAvLyBEcmF3IG1vZGVzXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlBPSU5UUztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuTElORVM7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLkxJTkVfTE9PUDtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuTElORV9TVFJJUDtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuVFJJQU5HTEVfU1RSSVA7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlRSSUFOR0xFX0ZBTjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlRSSUFOR0xFUztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTaGFkZXJzXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3JlbGVhc2VFZmZlY3QoZWZmZWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21waWxlZEVmZmVjdHNbZWZmZWN0Ll9rZXldKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY29tcGlsZWRFZmZlY3RzW2VmZmVjdC5fa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaXBlbGluZUNvbnRleHQgPSBlZmZlY3QuZ2V0UGlwZWxpbmVDb250ZXh0KCk7XG4gICAgICAgIGlmIChwaXBlbGluZUNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGV0ZVBpcGVsaW5lQ29udGV4dChwaXBlbGluZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9kZWxldGVQaXBlbGluZUNvbnRleHQocGlwZWxpbmVDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHdlYkdMUGlwZWxpbmVDb250ZXh0ID0gcGlwZWxpbmVDb250ZXh0O1xuICAgICAgICBpZiAod2ViR0xQaXBlbGluZUNvbnRleHQgJiYgd2ViR0xQaXBlbGluZUNvbnRleHQucHJvZ3JhbSkge1xuICAgICAgICAgICAgd2ViR0xQaXBlbGluZUNvbnRleHQucHJvZ3JhbS5fX1NQRUNUT1JfcmVidWlsZFByb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgcmVzZXRDYWNoZWRQaXBlbGluZSh3ZWJHTFBpcGVsaW5lQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2wpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFByb2dyYW0gPT09IHdlYkdMUGlwZWxpbmVDb250ZXh0LnByb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvZ3JhbShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuZGVsZXRlUHJvZ3JhbSh3ZWJHTFBpcGVsaW5lQ29udGV4dC5wcm9ncmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfZ2V0R2xvYmFsRGVmaW5lcyhkZWZpbmVzKSB7XG4gICAgICAgIHJldHVybiBfR2V0R2xvYmFsRGVmaW5lcyhkZWZpbmVzLCB0aGlzLmlzTkRDSGFsZlpSYW5nZSwgdGhpcy51c2VSZXZlcnNlRGVwdGhCdWZmZXIsIHRoaXMudXNlRXhhY3RTcmdiQ29udmVyc2lvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZWZmZWN0ICh1c2VkIHRvIHN0b3JlIHZlcnRleC9mcmFnbWVudCBzaGFkZXJzKVxuICAgICAqIEBwYXJhbSBiYXNlTmFtZSBkZWZpbmVzIHRoZSBiYXNlIG5hbWUgb2YgdGhlIGVmZmVjdCAoVGhlIG5hbWUgb2YgZmlsZSB3aXRob3V0IC5mcmFnbWVudC5meCBvciAudmVydGV4LmZ4KVxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzTmFtZXNPck9wdGlvbnMgZGVmaW5lcyBlaXRoZXIgYSBsaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyBvciBhbiBJRWZmZWN0Q3JlYXRpb25PcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB1bmlmb3Jtc05hbWVzT3JFbmdpbmUgZGVmaW5lcyBlaXRoZXIgYSBsaXN0IG9mIHVuaWZvcm0gbmFtZXMgb3IgdGhlIGVuZ2luZSB0byB1c2VcbiAgICAgKiBAcGFyYW0gc2FtcGxlcnMgZGVmaW5lcyBhbiBhcnJheSBvZiBzdHJpbmcgdXNlZCB0byByZXByZXNlbnQgdGV4dHVyZXNcbiAgICAgKiBAcGFyYW0gZGVmaW5lcyBkZWZpbmVzIHRoZSBzdHJpbmcgY29udGFpbmluZyB0aGUgZGVmaW5lcyB0byB1c2UgdG8gY29tcGlsZSB0aGUgc2hhZGVyc1xuICAgICAqIEBwYXJhbSBmYWxsYmFja3MgZGVmaW5lcyB0aGUgbGlzdCBvZiBwb3RlbnRpYWwgZmFsbGJhY2tzIHRvIHVzZSBpZiBzaGFkZXIgY29tcGlsYXRpb24gZmFpbHNcbiAgICAgKiBAcGFyYW0gb25Db21waWxlZCBkZWZpbmVzIGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBlZmZlY3QgY3JlYXRpb24gaXMgc3VjY2Vzc2Z1bFxuICAgICAqIEBwYXJhbSBvbkVycm9yIGRlZmluZXMgYSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGVmZmVjdCBjcmVhdGlvbiBoYXMgZmFpbGVkXG4gICAgICogQHBhcmFtIGluZGV4UGFyYW1ldGVycyBkZWZpbmVzIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBpbmRleCB2YWx1ZXMgdG8gdXNlIHRvIGNvbXBpbGUgc2hhZGVycyAobGlrZSB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzIGxpZ2h0cylcbiAgICAgKiBAcGFyYW0gc2hhZGVyTGFuZ3VhZ2UgdGhlIGxhbmd1YWdlIHRoZSBzaGFkZXIgaXMgd3JpdHRlbiBpbiAoZGVmYXVsdDogR0xTTClcbiAgICAgKiBAcGFyYW0gZXh0cmFJbml0aWFsaXphdGlvbnNBc3luYyBhZGRpdGlvbmFsIGFzeW5jIGNvZGUgdG8gcnVuIGJlZm9yZSBwcmVwYXJpbmcgdGhlIGVmZmVjdFxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgRWZmZWN0XG4gICAgICovXG4gICAgY3JlYXRlRWZmZWN0KGJhc2VOYW1lLCBhdHRyaWJ1dGVzTmFtZXNPck9wdGlvbnMsIHVuaWZvcm1zTmFtZXNPckVuZ2luZSwgc2FtcGxlcnMsIGRlZmluZXMsIGZhbGxiYWNrcywgb25Db21waWxlZCwgb25FcnJvciwgaW5kZXhQYXJhbWV0ZXJzLCBzaGFkZXJMYW5ndWFnZSA9IDAgLyogU2hhZGVyTGFuZ3VhZ2UuR0xTTCAqLywgZXh0cmFJbml0aWFsaXphdGlvbnNBc3luYykge1xuICAgICAgICBjb25zdCB2ZXJ0ZXggPSB0eXBlb2YgYmFzZU5hbWUgPT09IFwic3RyaW5nXCIgPyBiYXNlTmFtZSA6IGJhc2VOYW1lLnZlcnRleFRva2VuIHx8IGJhc2VOYW1lLnZlcnRleFNvdXJjZSB8fCBiYXNlTmFtZS52ZXJ0ZXhFbGVtZW50IHx8IGJhc2VOYW1lLnZlcnRleDtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0eXBlb2YgYmFzZU5hbWUgPT09IFwic3RyaW5nXCIgPyBiYXNlTmFtZSA6IGJhc2VOYW1lLmZyYWdtZW50VG9rZW4gfHwgYmFzZU5hbWUuZnJhZ21lbnRTb3VyY2UgfHwgYmFzZU5hbWUuZnJhZ21lbnRFbGVtZW50IHx8IGJhc2VOYW1lLmZyYWdtZW50O1xuICAgICAgICBjb25zdCBnbG9iYWxEZWZpbmVzID0gdGhpcy5fZ2V0R2xvYmFsRGVmaW5lcygpO1xuICAgICAgICBjb25zdCBpc09wdGlvbnMgPSBhdHRyaWJ1dGVzTmFtZXNPck9wdGlvbnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZnVsbERlZmluZXMgPSBkZWZpbmVzID8/IGF0dHJpYnV0ZXNOYW1lc09yT3B0aW9ucy5kZWZpbmVzID8/IFwiXCI7XG4gICAgICAgIGlmIChnbG9iYWxEZWZpbmVzKSB7XG4gICAgICAgICAgICBmdWxsRGVmaW5lcyArPSBnbG9iYWxEZWZpbmVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB2ZXJ0ZXggKyBcIitcIiArIGZyYWdtZW50ICsgXCJAXCIgKyBmdWxsRGVmaW5lcztcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBpbGVkRWZmZWN0c1tuYW1lXSkge1xuICAgICAgICAgICAgY29uc3QgY29tcGlsZWRFZmZlY3QgPSB0aGlzLl9jb21waWxlZEVmZmVjdHNbbmFtZV07XG4gICAgICAgICAgICBpZiAob25Db21waWxlZCAmJiBjb21waWxlZEVmZmVjdC5pc1JlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICBvbkNvbXBpbGVkKGNvbXBpbGVkRWZmZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBpbGVkRWZmZWN0Ll9yZWZDb3VudCsrO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVkRWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9nbCkge1xuICAgICAgICAgICAgZ2V0U3RhdGVPYmplY3QodGhpcy5fZ2wpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IG5ldyBFZmZlY3QoYmFzZU5hbWUsIGF0dHJpYnV0ZXNOYW1lc09yT3B0aW9ucywgaXNPcHRpb25zID8gdGhpcyA6IHVuaWZvcm1zTmFtZXNPckVuZ2luZSwgc2FtcGxlcnMsIHRoaXMsIGRlZmluZXMsIGZhbGxiYWNrcywgb25Db21waWxlZCwgb25FcnJvciwgaW5kZXhQYXJhbWV0ZXJzLCBuYW1lLCBhdHRyaWJ1dGVzTmFtZXNPck9wdGlvbnMuc2hhZGVyTGFuZ3VhZ2UgPz8gc2hhZGVyTGFuZ3VhZ2UsIGF0dHJpYnV0ZXNOYW1lc09yT3B0aW9ucy5leHRyYUluaXRpYWxpemF0aW9uc0FzeW5jID8/IGV4dHJhSW5pdGlhbGl6YXRpb25zQXN5bmMpO1xuICAgICAgICB0aGlzLl9jb21waWxlZEVmZmVjdHNbbmFtZV0gPSBlZmZlY3Q7XG4gICAgICAgIHJldHVybiBlZmZlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9nZXRTaGFkZXJTb3VyY2Uoc2hhZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nbC5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlyZWN0bHkgY3JlYXRlcyBhIHdlYkdMIHByb2dyYW1cbiAgICAgKiBAcGFyYW0gcGlwZWxpbmVDb250ZXh0ICBkZWZpbmVzIHRoZSBwaXBlbGluZSBjb250ZXh0IHRvIGF0dGFjaCB0b1xuICAgICAqIEBwYXJhbSB2ZXJ0ZXhDb2RlIGRlZmluZXMgdGhlIHZlcnRleCBzaGFkZXIgY29kZSB0byB1c2VcbiAgICAgKiBAcGFyYW0gZnJhZ21lbnRDb2RlIGRlZmluZXMgdGhlIGZyYWdtZW50IHNoYWRlciBjb2RlIHRvIHVzZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IGRlZmluZXMgdGhlIHdlYkdMIGNvbnRleHQgdG8gdXNlIChpZiBub3Qgc2V0LCB0aGUgY3VycmVudCBvbmUgd2lsbCBiZSB1c2VkKVxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzIGRlZmluZXMgdGhlIGxpc3Qgb2YgdHJhbnNmb3JtIGZlZWRiYWNrIHZhcnlpbmdzIHRvIHVzZVxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgd2ViR0wgcHJvZ3JhbVxuICAgICAqL1xuICAgIGNyZWF0ZVJhd1NoYWRlclByb2dyYW0ocGlwZWxpbmVDb250ZXh0LCB2ZXJ0ZXhDb2RlLCBmcmFnbWVudENvZGUsIGNvbnRleHQsIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlT2JqZWN0ID0gZ2V0U3RhdGVPYmplY3QodGhpcy5fZ2wpO1xuICAgICAgICBzdGF0ZU9iamVjdC5fY29udGV4dFdhc0xvc3QgPSB0aGlzLl9jb250ZXh0V2FzTG9zdDtcbiAgICAgICAgc3RhdGVPYmplY3QudmFsaWRhdGVTaGFkZXJQcm9ncmFtcyA9IHRoaXMudmFsaWRhdGVTaGFkZXJQcm9ncmFtcztcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJhd1NoYWRlclByb2dyYW0ocGlwZWxpbmVDb250ZXh0LCB2ZXJ0ZXhDb2RlLCBmcmFnbWVudENvZGUsIGNvbnRleHQgfHwgdGhpcy5fZ2wsIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgd2ViR0wgcHJvZ3JhbVxuICAgICAqIEBwYXJhbSBwaXBlbGluZUNvbnRleHQgIGRlZmluZXMgdGhlIHBpcGVsaW5lIGNvbnRleHQgdG8gYXR0YWNoIHRvXG4gICAgICogQHBhcmFtIHZlcnRleENvZGUgIGRlZmluZXMgdGhlIHZlcnRleCBzaGFkZXIgY29kZSB0byB1c2VcbiAgICAgKiBAcGFyYW0gZnJhZ21lbnRDb2RlIGRlZmluZXMgdGhlIGZyYWdtZW50IHNoYWRlciBjb2RlIHRvIHVzZVxuICAgICAqIEBwYXJhbSBkZWZpbmVzIGRlZmluZXMgdGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBkZWZpbmVzIHRvIHVzZSB0byBjb21waWxlIHRoZSBzaGFkZXJzXG4gICAgICogQHBhcmFtIGNvbnRleHQgZGVmaW5lcyB0aGUgd2ViR0wgY29udGV4dCB0byB1c2UgKGlmIG5vdCBzZXQsIHRoZSBjdXJyZW50IG9uZSB3aWxsIGJlIHVzZWQpXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgZGVmaW5lcyB0aGUgbGlzdCBvZiB0cmFuc2Zvcm0gZmVlZGJhY2sgdmFyeWluZ3MgdG8gdXNlXG4gICAgICogQHJldHVybnMgdGhlIG5ldyB3ZWJHTCBwcm9ncmFtXG4gICAgICovXG4gICAgY3JlYXRlU2hhZGVyUHJvZ3JhbShwaXBlbGluZUNvbnRleHQsIHZlcnRleENvZGUsIGZyYWdtZW50Q29kZSwgZGVmaW5lcywgY29udGV4dCwgdHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyA9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVPYmplY3QgPSBnZXRTdGF0ZU9iamVjdCh0aGlzLl9nbCk7XG4gICAgICAgIC8vIGFzc3VyZSB0aGUgc3RhdGUgb2JqZWN0IGlzIGNvcnJlY3RcbiAgICAgICAgc3RhdGVPYmplY3QuX2NvbnRleHRXYXNMb3N0ID0gdGhpcy5fY29udGV4dFdhc0xvc3Q7XG4gICAgICAgIHN0YXRlT2JqZWN0LnZhbGlkYXRlU2hhZGVyUHJvZ3JhbXMgPSB0aGlzLnZhbGlkYXRlU2hhZGVyUHJvZ3JhbXM7XG4gICAgICAgIHJldHVybiBjcmVhdGVTaGFkZXJQcm9ncmFtKHBpcGVsaW5lQ29udGV4dCwgdmVydGV4Q29kZSwgZnJhZ21lbnRDb2RlLCBkZWZpbmVzLCBjb250ZXh0IHx8IHRoaXMuX2dsLCB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5saW5lIGZ1bmN0aW9ucyBpbiBzaGFkZXIgY29kZSB0aGF0IGFyZSBtYXJrZWQgdG8gYmUgaW5saW5lZFxuICAgICAqIEBwYXJhbSBjb2RlIGNvZGUgdG8gaW5saW5lXG4gICAgICogQHJldHVybnMgaW5saW5lZCBjb2RlXG4gICAgICovXG4gICAgaW5saW5lU2hhZGVyQ29kZShjb2RlKSB7XG4gICAgICAgIC8vIG5vIGlubGluaW5nIG5lZWRlZCBpbiB0aGUgV2ViR0wgZW5naW5lXG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHBpcGVsaW5lIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gc2hhZGVyUHJvY2Vzc2luZ0NvbnRleHQgZGVmaW5lcyB0aGUgc2hhZGVyIHByb2Nlc3NpbmcgY29udGV4dCB1c2VkIGR1cmluZyB0aGUgcHJvY2Vzc2luZyBpZiBhdmFpbGFibGVcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IHBpcGVsaW5lXG4gICAgICovXG4gICAgY3JlYXRlUGlwZWxpbmVDb250ZXh0KHNoYWRlclByb2Nlc3NpbmdDb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9nbCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVPYmplY3QgPSBnZXRTdGF0ZU9iamVjdCh0aGlzLl9nbCk7XG4gICAgICAgICAgICBzdGF0ZU9iamVjdC5wYXJhbGxlbFNoYWRlckNvbXBpbGUgPSB0aGlzLl9jYXBzLnBhcmFsbGVsU2hhZGVyQ29tcGlsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlUGlwZWxpbmVDb250ZXh0KHRoaXMuX2dsLCBzaGFkZXJQcm9jZXNzaW5nQ29udGV4dCk7XG4gICAgICAgIGNvbnRleHQuZW5naW5lID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbWF0ZXJpYWwgY29udGV4dFxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgY29udGV4dFxuICAgICAqL1xuICAgIGNyZWF0ZU1hdGVyaWFsQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkcmF3IGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IGNvbnRleHRcbiAgICAgKi9cbiAgICBjcmVhdGVEcmF3Q29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX2ZpbmFsaXplUGlwZWxpbmVDb250ZXh0KHBpcGVsaW5lQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gX2ZpbmFsaXplUGlwZWxpbmVDb250ZXh0KHBpcGVsaW5lQ29udGV4dCwgdGhpcy5fZ2wsIHRoaXMudmFsaWRhdGVTaGFkZXJQcm9ncmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIC8vIG5hbWVkIGFzeW5jIGJ1dCBub3QgYWN0dWFsbHkgYW4gYXN5bmMgZnVuY3Rpb25cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICBfcHJlcGFyZVBpcGVsaW5lQ29udGV4dEFzeW5jKHBpcGVsaW5lQ29udGV4dCwgdmVydGV4U291cmNlQ29kZSwgZnJhZ21lbnRTb3VyY2VDb2RlLCBjcmVhdGVBc1JhdywgcmF3VmVydGV4U291cmNlQ29kZSwgcmF3RnJhZ21lbnRTb3VyY2VDb2RlLCByZWJ1aWxkUmViaW5kLCBkZWZpbmVzLCB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzLCBrZXksIG9uUmVhZHkpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVPYmplY3QgPSBnZXRTdGF0ZU9iamVjdCh0aGlzLl9nbCk7XG4gICAgICAgIHN0YXRlT2JqZWN0Ll9jb250ZXh0V2FzTG9zdCA9IHRoaXMuX2NvbnRleHRXYXNMb3N0O1xuICAgICAgICBzdGF0ZU9iamVjdC52YWxpZGF0ZVNoYWRlclByb2dyYW1zID0gdGhpcy52YWxpZGF0ZVNoYWRlclByb2dyYW1zO1xuICAgICAgICBzdGF0ZU9iamVjdC5fY3JlYXRlU2hhZGVyUHJvZ3JhbUluamVjdGlvbiA9IHRoaXMuX2NyZWF0ZVNoYWRlclByb2dyYW0uYmluZCh0aGlzKTtcbiAgICAgICAgc3RhdGVPYmplY3QuY3JlYXRlUmF3U2hhZGVyUHJvZ3JhbUluamVjdGlvbiA9IHRoaXMuY3JlYXRlUmF3U2hhZGVyUHJvZ3JhbS5iaW5kKHRoaXMpO1xuICAgICAgICBzdGF0ZU9iamVjdC5jcmVhdGVTaGFkZXJQcm9ncmFtSW5qZWN0aW9uID0gdGhpcy5jcmVhdGVTaGFkZXJQcm9ncmFtLmJpbmQodGhpcyk7XG4gICAgICAgIHN0YXRlT2JqZWN0LmxvYWRGaWxlSW5qZWN0aW9uID0gdGhpcy5fbG9hZEZpbGUuYmluZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIF9wcmVwYXJlUGlwZWxpbmVDb250ZXh0KHBpcGVsaW5lQ29udGV4dCwgdmVydGV4U291cmNlQ29kZSwgZnJhZ21lbnRTb3VyY2VDb2RlLCBjcmVhdGVBc1JhdywgcmF3VmVydGV4U291cmNlQ29kZSwgcmF3RnJhZ21lbnRTb3VyY2VDb2RlLCByZWJ1aWxkUmViaW5kLCBkZWZpbmVzLCB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzLCBrZXksIG9uUmVhZHkpO1xuICAgIH1cbiAgICBfY3JlYXRlU2hhZGVyUHJvZ3JhbShwaXBlbGluZUNvbnRleHQsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIGNvbnRleHQsIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBfY3JlYXRlU2hhZGVyUHJvZ3JhbShwaXBlbGluZUNvbnRleHQsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIGNvbnRleHQsIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaXNSZW5kZXJpbmdTdGF0ZUNvbXBpbGVkKHBpcGVsaW5lQ29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfaXNSZW5kZXJpbmdTdGF0ZUNvbXBpbGVkKHBpcGVsaW5lQ29udGV4dCwgdGhpcy5fZ2wsIHRoaXMudmFsaWRhdGVTaGFkZXJQcm9ncmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9leGVjdXRlV2hlblJlbmRlcmluZ1N0YXRlSXNDb21waWxlZChwaXBlbGluZUNvbnRleHQsIGFjdGlvbikge1xuICAgICAgICBfZXhlY3V0ZVdoZW5SZW5kZXJpbmdTdGF0ZUlzQ29tcGlsZWQocGlwZWxpbmVDb250ZXh0LCBhY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IG9mIHdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGFzc29jaWF0ZWQgd2l0aCBhIHNwZWNpZmljIHByb2dyYW0gYmFzZWQgb24gYSBsaXN0IG9mIHVuaWZvcm0gbmFtZXNcbiAgICAgKiBAcGFyYW0gcGlwZWxpbmVDb250ZXh0IGRlZmluZXMgdGhlIHBpcGVsaW5lIGNvbnRleHQgdG8gdXNlXG4gICAgICogQHBhcmFtIHVuaWZvcm1zTmFtZXMgZGVmaW5lcyB0aGUgbGlzdCBvZiB1bmlmb3JtIG5hbWVzXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2Ygd2ViR0wgdW5pZm9ybSBsb2NhdGlvbnNcbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtcyhwaXBlbGluZUNvbnRleHQsIHVuaWZvcm1zTmFtZXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBjb25zdCB3ZWJHTFBpcGVsaW5lQ29udGV4dCA9IHBpcGVsaW5lQ29udGV4dDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHVuaWZvcm1zTmFtZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5fZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUGlwZWxpbmVDb250ZXh0LnByb2dyYW0sIHVuaWZvcm1zTmFtZXNbaW5kZXhdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3Qgb2YgYWN0aXZlIGF0dHJpYnV0ZXMgZm9yIGEgZ2l2ZW4gd2ViR0wgcHJvZ3JhbVxuICAgICAqIEBwYXJhbSBwaXBlbGluZUNvbnRleHQgZGVmaW5lcyB0aGUgcGlwZWxpbmUgY29udGV4dCB0byB1c2VcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlc05hbWVzIGRlZmluZXMgdGhlIGxpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGdldFxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIGluZGljZXMgaW5kaWNhdGluZyB0aGUgb2Zmc2V0IG9mIGVhY2ggYXR0cmlidXRlXG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlcyhwaXBlbGluZUNvbnRleHQsIGF0dHJpYnV0ZXNOYW1lcykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IHdlYkdMUGlwZWxpbmVDb250ZXh0ID0gcGlwZWxpbmVDb250ZXh0O1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXR0cmlidXRlc05hbWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5fZ2wuZ2V0QXR0cmliTG9jYXRpb24od2ViR0xQaXBlbGluZUNvbnRleHQucHJvZ3JhbSwgYXR0cmlidXRlc05hbWVzW2luZGV4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgYW4gZWZmZWN0LCBtYWtpbmcgaXQgdGhlIGN1cnJlbnQgb25lIChpZS4gdGhlIG9uZSB1c2VkIGZvciByZW5kZXJpbmcpXG4gICAgICogQHBhcmFtIGVmZmVjdCBkZWZpbmVzIHRoZSBlZmZlY3QgdG8gYWN0aXZhdGVcbiAgICAgKi9cbiAgICBlbmFibGVFZmZlY3QoZWZmZWN0KSB7XG4gICAgICAgIGVmZmVjdCA9IGVmZmVjdCAhPT0gbnVsbCAmJiBJc1dyYXBwZXIoZWZmZWN0KSA/IGVmZmVjdC5lZmZlY3QgOiBlZmZlY3Q7IC8vIGdldCBvbmx5IHRoZSBlZmZlY3QsIHdlIGRvbid0IG5lZWQgYSBXcmFwcGVyIGluIHRoZSBXZWJHTCBlbmdpbmVcbiAgICAgICAgaWYgKCFlZmZlY3QgfHwgZWZmZWN0ID09PSB0aGlzLl9jdXJyZW50RWZmZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RlbmNpbFN0YXRlQ29tcG9zZXIuc3RlbmNpbE1hdGVyaWFsID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBVc2UgcHJvZ3JhbVxuICAgICAgICB0aGlzLmJpbmRTYW1wbGVycyhlZmZlY3QpO1xuICAgICAgICB0aGlzLl9jdXJyZW50RWZmZWN0ID0gZWZmZWN0O1xuICAgICAgICBpZiAoZWZmZWN0Lm9uQmluZCkge1xuICAgICAgICAgICAgZWZmZWN0Lm9uQmluZChlZmZlY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3QuX29uQmluZE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIGVmZmVjdC5fb25CaW5kT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoZWZmZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIGFuIHVuaWZvcm0gdG8gYSBudW1iZXIgKGludClcbiAgICAgKiBAcGFyYW0gdW5pZm9ybSBkZWZpbmVzIHRoZSB3ZWJHTCB1bmlmb3JtIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBkZWZpbmVzIHRoZSBpbnQgbnVtYmVyIHRvIHN0b3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldEludCh1bmlmb3JtLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXVuaWZvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nbC51bmlmb3JtMWkodW5pZm9ybSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGEgaW50MlxuICAgICAqIEBwYXJhbSB1bmlmb3JtIGRlZmluZXMgdGhlIHdlYkdMIHVuaWZvcm0gbG9jYXRpb24gd2hlcmUgdG8gc3RvcmUgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIHggZGVmaW5lcyB0aGUgMXN0IGNvbXBvbmVudCBvZiB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0geSBkZWZpbmVzIHRoZSAybmQgY29tcG9uZW50IG9mIHRoZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHdhcyBzZXRcbiAgICAgKi9cbiAgICBzZXRJbnQyKHVuaWZvcm0sIHgsIHkpIHtcbiAgICAgICAgaWYgKCF1bmlmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTJpKHVuaWZvcm0sIHgsIHkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGEgaW50M1xuICAgICAqIEBwYXJhbSB1bmlmb3JtIGRlZmluZXMgdGhlIHdlYkdMIHVuaWZvcm0gbG9jYXRpb24gd2hlcmUgdG8gc3RvcmUgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIHggZGVmaW5lcyB0aGUgMXN0IGNvbXBvbmVudCBvZiB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0geSBkZWZpbmVzIHRoZSAybmQgY29tcG9uZW50IG9mIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB6IGRlZmluZXMgdGhlIDNyZCBjb21wb25lbnQgb2YgdGhlIHZhbHVlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldEludDModW5pZm9ybSwgeCwgeSwgeikge1xuICAgICAgICBpZiAoIXVuaWZvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nbC51bmlmb3JtM2kodW5pZm9ybSwgeCwgeSwgeik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIGFuIHVuaWZvcm0gdG8gYSBpbnQ0XG4gICAgICogQHBhcmFtIHVuaWZvcm0gZGVmaW5lcyB0aGUgd2ViR0wgdW5pZm9ybSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0geCBkZWZpbmVzIHRoZSAxc3QgY29tcG9uZW50IG9mIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB5IGRlZmluZXMgdGhlIDJuZCBjb21wb25lbnQgb2YgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIHogZGVmaW5lcyB0aGUgM3JkIGNvbXBvbmVudCBvZiB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gdyBkZWZpbmVzIHRoZSA0dGggY29tcG9uZW50IG9mIHRoZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHdhcyBzZXRcbiAgICAgKi9cbiAgICBzZXRJbnQ0KHVuaWZvcm0sIHgsIHksIHosIHcpIHtcbiAgICAgICAgaWYgKCF1bmlmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTRpKHVuaWZvcm0sIHgsIHksIHosIHcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGFuIGFycmF5IG9mIGludDMyXG4gICAgICogQHBhcmFtIHVuaWZvcm0gZGVmaW5lcyB0aGUgd2ViR0wgdW5pZm9ybSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gYXJyYXkgZGVmaW5lcyB0aGUgYXJyYXkgb2YgaW50MzIgdG8gc3RvcmVcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSB3YXMgc2V0XG4gICAgICovXG4gICAgc2V0SW50QXJyYXkodW5pZm9ybSwgYXJyYXkpIHtcbiAgICAgICAgaWYgKCF1bmlmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTFpdih1bmlmb3JtLCBhcnJheSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIGFuIHVuaWZvcm0gdG8gYW4gYXJyYXkgb2YgaW50MzIgKHN0b3JlZCBhcyB2ZWMyKVxuICAgICAqIEBwYXJhbSB1bmlmb3JtIGRlZmluZXMgdGhlIHdlYkdMIHVuaWZvcm0gbG9jYXRpb24gd2hlcmUgdG8gc3RvcmUgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIGFycmF5IGRlZmluZXMgdGhlIGFycmF5IG9mIGludDMyIHRvIHN0b3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldEludEFycmF5Mih1bmlmb3JtLCBhcnJheSkge1xuICAgICAgICBpZiAoIXVuaWZvcm0gfHwgYXJyYXkubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm0yaXYodW5pZm9ybSwgYXJyYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGFuIGFycmF5IG9mIGludDMyIChzdG9yZWQgYXMgdmVjMylcbiAgICAgKiBAcGFyYW0gdW5pZm9ybSBkZWZpbmVzIHRoZSB3ZWJHTCB1bmlmb3JtIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBhcnJheSBkZWZpbmVzIHRoZSBhcnJheSBvZiBpbnQzMiB0byBzdG9yZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHdhcyBzZXRcbiAgICAgKi9cbiAgICBzZXRJbnRBcnJheTModW5pZm9ybSwgYXJyYXkpIHtcbiAgICAgICAgaWYgKCF1bmlmb3JtIHx8IGFycmF5Lmxlbmd0aCAlIDMgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nbC51bmlmb3JtM2l2KHVuaWZvcm0sIGFycmF5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYW4gdW5pZm9ybSB0byBhbiBhcnJheSBvZiBpbnQzMiAoc3RvcmVkIGFzIHZlYzQpXG4gICAgICogQHBhcmFtIHVuaWZvcm0gZGVmaW5lcyB0aGUgd2ViR0wgdW5pZm9ybSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gYXJyYXkgZGVmaW5lcyB0aGUgYXJyYXkgb2YgaW50MzIgdG8gc3RvcmVcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSB3YXMgc2V0XG4gICAgICovXG4gICAgc2V0SW50QXJyYXk0KHVuaWZvcm0sIGFycmF5KSB7XG4gICAgICAgIGlmICghdW5pZm9ybSB8fCBhcnJheS5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTRpdih1bmlmb3JtLCBhcnJheSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIGFuIHVuaWZvcm0gdG8gYSBudW1iZXIgKHVuc2lnbmVkIGludClcbiAgICAgKiBAcGFyYW0gdW5pZm9ybSBkZWZpbmVzIHRoZSB3ZWJHTCB1bmlmb3JtIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBkZWZpbmVzIHRoZSB1bnNpZ25lZCBpbnQgbnVtYmVyIHRvIHN0b3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldFVJbnQodW5pZm9ybSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF1bmlmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTF1aSh1bmlmb3JtLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIGFuIHVuaWZvcm0gdG8gYSB1bnNpZ25lZCBpbnQyXG4gICAgICogQHBhcmFtIHVuaWZvcm0gZGVmaW5lcyB0aGUgd2ViR0wgdW5pZm9ybSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0geCBkZWZpbmVzIHRoZSAxc3QgY29tcG9uZW50IG9mIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB5IGRlZmluZXMgdGhlIDJuZCBjb21wb25lbnQgb2YgdGhlIHZhbHVlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldFVJbnQyKHVuaWZvcm0sIHgsIHkpIHtcbiAgICAgICAgaWYgKCF1bmlmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTJ1aSh1bmlmb3JtLCB4LCB5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYW4gdW5pZm9ybSB0byBhIHVuc2lnbmVkIGludDNcbiAgICAgKiBAcGFyYW0gdW5pZm9ybSBkZWZpbmVzIHRoZSB3ZWJHTCB1bmlmb3JtIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB4IGRlZmluZXMgdGhlIDFzdCBjb21wb25lbnQgb2YgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIHkgZGVmaW5lcyB0aGUgMm5kIGNvbXBvbmVudCBvZiB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0geiBkZWZpbmVzIHRoZSAzcmQgY29tcG9uZW50IG9mIHRoZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHdhcyBzZXRcbiAgICAgKi9cbiAgICBzZXRVSW50Myh1bmlmb3JtLCB4LCB5LCB6KSB7XG4gICAgICAgIGlmICghdW5pZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm0zdWkodW5pZm9ybSwgeCwgeSwgeik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIGFuIHVuaWZvcm0gdG8gYSB1bnNpZ25lZCBpbnQ0XG4gICAgICogQHBhcmFtIHVuaWZvcm0gZGVmaW5lcyB0aGUgd2ViR0wgdW5pZm9ybSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0geCBkZWZpbmVzIHRoZSAxc3QgY29tcG9uZW50IG9mIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB5IGRlZmluZXMgdGhlIDJuZCBjb21wb25lbnQgb2YgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIHogZGVmaW5lcyB0aGUgM3JkIGNvbXBvbmVudCBvZiB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gdyBkZWZpbmVzIHRoZSA0dGggY29tcG9uZW50IG9mIHRoZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHdhcyBzZXRcbiAgICAgKi9cbiAgICBzZXRVSW50NCh1bmlmb3JtLCB4LCB5LCB6LCB3KSB7XG4gICAgICAgIGlmICghdW5pZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm00dWkodW5pZm9ybSwgeCwgeSwgeiwgdyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIGFuIHVuaWZvcm0gdG8gYW4gYXJyYXkgb2YgdW5zaWduZWQgaW50MzJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybSBkZWZpbmVzIHRoZSB3ZWJHTCB1bmlmb3JtIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBhcnJheSBkZWZpbmVzIHRoZSBhcnJheSBvZiB1bnNpZ25lZCBpbnQzMiB0byBzdG9yZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHdhcyBzZXRcbiAgICAgKi9cbiAgICBzZXRVSW50QXJyYXkodW5pZm9ybSwgYXJyYXkpIHtcbiAgICAgICAgaWYgKCF1bmlmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTF1aXYodW5pZm9ybSwgYXJyYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGFuIGFycmF5IG9mIHVuc2lnbmVkIGludDMyIChzdG9yZWQgYXMgdmVjMilcbiAgICAgKiBAcGFyYW0gdW5pZm9ybSBkZWZpbmVzIHRoZSB3ZWJHTCB1bmlmb3JtIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBhcnJheSBkZWZpbmVzIHRoZSBhcnJheSBvZiB1bnNpZ25lZCBpbnQzMiB0byBzdG9yZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHdhcyBzZXRcbiAgICAgKi9cbiAgICBzZXRVSW50QXJyYXkyKHVuaWZvcm0sIGFycmF5KSB7XG4gICAgICAgIGlmICghdW5pZm9ybSB8fCBhcnJheS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTJ1aXYodW5pZm9ybSwgYXJyYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGFuIGFycmF5IG9mIHVuc2lnbmVkIGludDMyIChzdG9yZWQgYXMgdmVjMylcbiAgICAgKiBAcGFyYW0gdW5pZm9ybSBkZWZpbmVzIHRoZSB3ZWJHTCB1bmlmb3JtIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBhcnJheSBkZWZpbmVzIHRoZSBhcnJheSBvZiB1bnNpZ25lZCBpbnQzMiB0byBzdG9yZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHdhcyBzZXRcbiAgICAgKi9cbiAgICBzZXRVSW50QXJyYXkzKHVuaWZvcm0sIGFycmF5KSB7XG4gICAgICAgIGlmICghdW5pZm9ybSB8fCBhcnJheS5sZW5ndGggJSAzICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTN1aXYodW5pZm9ybSwgYXJyYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGFuIGFycmF5IG9mIHVuc2lnbmVkIGludDMyIChzdG9yZWQgYXMgdmVjNClcbiAgICAgKiBAcGFyYW0gdW5pZm9ybSBkZWZpbmVzIHRoZSB3ZWJHTCB1bmlmb3JtIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBhcnJheSBkZWZpbmVzIHRoZSBhcnJheSBvZiB1bnNpZ25lZCBpbnQzMiB0byBzdG9yZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHdhcyBzZXRcbiAgICAgKi9cbiAgICBzZXRVSW50QXJyYXk0KHVuaWZvcm0sIGFycmF5KSB7XG4gICAgICAgIGlmICghdW5pZm9ybSB8fCBhcnJheS5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTR1aXYodW5pZm9ybSwgYXJyYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGFuIGFycmF5IG9mIG51bWJlclxuICAgICAqIEBwYXJhbSB1bmlmb3JtIGRlZmluZXMgdGhlIHdlYkdMIHVuaWZvcm0gbG9jYXRpb24gd2hlcmUgdG8gc3RvcmUgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIGFycmF5IGRlZmluZXMgdGhlIGFycmF5IG9mIG51bWJlciB0byBzdG9yZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHdhcyBzZXRcbiAgICAgKi9cbiAgICBzZXRBcnJheSh1bmlmb3JtLCBhcnJheSkge1xuICAgICAgICBpZiAoIXVuaWZvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm0xZnYodW5pZm9ybSwgYXJyYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGFuIGFycmF5IG9mIG51bWJlciAoc3RvcmVkIGFzIHZlYzIpXG4gICAgICogQHBhcmFtIHVuaWZvcm0gZGVmaW5lcyB0aGUgd2ViR0wgdW5pZm9ybSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gYXJyYXkgZGVmaW5lcyB0aGUgYXJyYXkgb2YgbnVtYmVyIHRvIHN0b3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldEFycmF5Mih1bmlmb3JtLCBhcnJheSkge1xuICAgICAgICBpZiAoIXVuaWZvcm0gfHwgYXJyYXkubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm0yZnYodW5pZm9ybSwgYXJyYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGFuIGFycmF5IG9mIG51bWJlciAoc3RvcmVkIGFzIHZlYzMpXG4gICAgICogQHBhcmFtIHVuaWZvcm0gZGVmaW5lcyB0aGUgd2ViR0wgdW5pZm9ybSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gYXJyYXkgZGVmaW5lcyB0aGUgYXJyYXkgb2YgbnVtYmVyIHRvIHN0b3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldEFycmF5Myh1bmlmb3JtLCBhcnJheSkge1xuICAgICAgICBpZiAoIXVuaWZvcm0gfHwgYXJyYXkubGVuZ3RoICUgMyAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm0zZnYodW5pZm9ybSwgYXJyYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGFuIGFycmF5IG9mIG51bWJlciAoc3RvcmVkIGFzIHZlYzQpXG4gICAgICogQHBhcmFtIHVuaWZvcm0gZGVmaW5lcyB0aGUgd2ViR0wgdW5pZm9ybSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gYXJyYXkgZGVmaW5lcyB0aGUgYXJyYXkgb2YgbnVtYmVyIHRvIHN0b3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldEFycmF5NCh1bmlmb3JtLCBhcnJheSkge1xuICAgICAgICBpZiAoIXVuaWZvcm0gfHwgYXJyYXkubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm00ZnYodW5pZm9ybSwgYXJyYXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGFuIGFycmF5IG9mIGZsb2F0MzIgKHN0b3JlZCBhcyBtYXRyaWNlcylcbiAgICAgKiBAcGFyYW0gdW5pZm9ybSBkZWZpbmVzIHRoZSB3ZWJHTCB1bmlmb3JtIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBtYXRyaWNlcyBkZWZpbmVzIHRoZSBhcnJheSBvZiBmbG9hdDMyIHRvIHN0b3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldE1hdHJpY2VzKHVuaWZvcm0sIG1hdHJpY2VzKSB7XG4gICAgICAgIGlmICghdW5pZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm1NYXRyaXg0ZnYodW5pZm9ybSwgZmFsc2UsIG1hdHJpY2VzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYW4gdW5pZm9ybSB0byBhIG1hdHJpeCAoM3gzKVxuICAgICAqIEBwYXJhbSB1bmlmb3JtIGRlZmluZXMgdGhlIHdlYkdMIHVuaWZvcm0gbG9jYXRpb24gd2hlcmUgdG8gc3RvcmUgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIG1hdHJpeCBkZWZpbmVzIHRoZSBGbG9hdDMyQXJyYXkgcmVwcmVzZW50aW5nIHRoZSAzeDMgbWF0cml4IHRvIHN0b3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldE1hdHJpeDN4Myh1bmlmb3JtLCBtYXRyaXgpIHtcbiAgICAgICAgaWYgKCF1bmlmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybU1hdHJpeDNmdih1bmlmb3JtLCBmYWxzZSwgbWF0cml4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYW4gdW5pZm9ybSB0byBhIG1hdHJpeCAoMngyKVxuICAgICAqIEBwYXJhbSB1bmlmb3JtIGRlZmluZXMgdGhlIHdlYkdMIHVuaWZvcm0gbG9jYXRpb24gd2hlcmUgdG8gc3RvcmUgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIG1hdHJpeCBkZWZpbmVzIHRoZSBGbG9hdDMyQXJyYXkgcmVwcmVzZW50aW5nIHRoZSAyeDIgbWF0cml4IHRvIHN0b3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldE1hdHJpeDJ4Mih1bmlmb3JtLCBtYXRyaXgpIHtcbiAgICAgICAgaWYgKCF1bmlmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybU1hdHJpeDJmdih1bmlmb3JtLCBmYWxzZSwgbWF0cml4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYW4gdW5pZm9ybSB0byBhIG51bWJlciAoZmxvYXQpXG4gICAgICogQHBhcmFtIHVuaWZvcm0gZGVmaW5lcyB0aGUgd2ViR0wgdW5pZm9ybSBsb2NhdGlvbiB3aGVyZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgZGVmaW5lcyB0aGUgZmxvYXQgbnVtYmVyIHRvIHN0b3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHRyYW5zZmVycmVkXG4gICAgICovXG4gICAgc2V0RmxvYXQodW5pZm9ybSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF1bmlmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTFmKHVuaWZvcm0sIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYW4gdW5pZm9ybSB0byBhIHZlYzJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybSBkZWZpbmVzIHRoZSB3ZWJHTCB1bmlmb3JtIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB4IGRlZmluZXMgdGhlIDFzdCBjb21wb25lbnQgb2YgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIHkgZGVmaW5lcyB0aGUgMm5kIGNvbXBvbmVudCBvZiB0aGUgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSB3YXMgc2V0XG4gICAgICovXG4gICAgc2V0RmxvYXQyKHVuaWZvcm0sIHgsIHkpIHtcbiAgICAgICAgaWYgKCF1bmlmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTJmKHVuaWZvcm0sIHgsIHkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhbiB1bmlmb3JtIHRvIGEgdmVjM1xuICAgICAqIEBwYXJhbSB1bmlmb3JtIGRlZmluZXMgdGhlIHdlYkdMIHVuaWZvcm0gbG9jYXRpb24gd2hlcmUgdG8gc3RvcmUgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIHggZGVmaW5lcyB0aGUgMXN0IGNvbXBvbmVudCBvZiB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0geSBkZWZpbmVzIHRoZSAybmQgY29tcG9uZW50IG9mIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB6IGRlZmluZXMgdGhlIDNyZCBjb21wb25lbnQgb2YgdGhlIHZhbHVlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldEZsb2F0Myh1bmlmb3JtLCB4LCB5LCB6KSB7XG4gICAgICAgIGlmICghdW5pZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm0zZih1bmlmb3JtLCB4LCB5LCB6KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYW4gdW5pZm9ybSB0byBhIHZlYzRcbiAgICAgKiBAcGFyYW0gdW5pZm9ybSBkZWZpbmVzIHRoZSB3ZWJHTCB1bmlmb3JtIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB4IGRlZmluZXMgdGhlIDFzdCBjb21wb25lbnQgb2YgdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIHkgZGVmaW5lcyB0aGUgMm5kIGNvbXBvbmVudCBvZiB0aGUgdmFsdWVcbiAgICAgKiBAcGFyYW0geiBkZWZpbmVzIHRoZSAzcmQgY29tcG9uZW50IG9mIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB3IGRlZmluZXMgdGhlIDR0aCBjb21wb25lbnQgb2YgdGhlIHZhbHVlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIHNldFxuICAgICAqL1xuICAgIHNldEZsb2F0NCh1bmlmb3JtLCB4LCB5LCB6LCB3KSB7XG4gICAgICAgIGlmICghdW5pZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm00Zih1bmlmb3JtLCB4LCB5LCB6LCB3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFN0YXRlc1xuICAgIC8qKlxuICAgICAqIEFwcGx5IGFsbCBjYWNoZWQgc3RhdGVzIChkZXB0aCwgY3VsbGluZywgc3RlbmNpbCBhbmQgYWxwaGEpXG4gICAgICovXG4gICAgYXBwbHlTdGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuX2RlcHRoQ3VsbGluZ1N0YXRlLmFwcGx5KHRoaXMuX2dsKTtcbiAgICAgICAgdGhpcy5fc3RlbmNpbFN0YXRlQ29tcG9zZXIuYXBwbHkodGhpcy5fZ2wpO1xuICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLmFwcGx5KHRoaXMuX2dsKTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yV3JpdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xvcldyaXRlQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgZW5hYmxlID0gdGhpcy5fY29sb3JXcml0ZTtcbiAgICAgICAgICAgIHRoaXMuX2dsLmNvbG9yTWFzayhlbmFibGUsIGVuYWJsZSwgZW5hYmxlLCBlbmFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRleHR1cmVzXG4gICAgLyoqXG4gICAgICogRm9yY2UgdGhlIGVudGlyZSBjYWNoZSB0byBiZSBjbGVhcmVkXG4gICAgICogWW91IHNob3VsZCBub3QgaGF2ZSB0byB1c2UgdGhpcyBmdW5jdGlvbiB1bmxlc3MgeW91ciBlbmdpbmUgbmVlZHMgdG8gc2hhcmUgdGhlIHdlYkdMIGNvbnRleHQgd2l0aCBhbm90aGVyIGVuZ2luZVxuICAgICAqIEBwYXJhbSBicnV0ZUZvcmNlIGRlZmluZXMgYSBib29sZWFuIHRvIGZvcmNlIGNsZWFyaW5nIEFMTCBjYWNoZXMgKGluY2x1ZGluZyBzdGVuY2lsLCBkZXRvaCBhbmQgYWxwaGEgc3RhdGVzKVxuICAgICAqL1xuICAgIHdpcGVDYWNoZXMoYnJ1dGVGb3JjZSkge1xuICAgICAgICBpZiAodGhpcy5wcmV2ZW50Q2FjaGVXaXBlQmV0d2VlbkZyYW1lcyAmJiAhYnJ1dGVGb3JjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRFZmZlY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl92aWV3cG9ydENhY2hlZC54ID0gMDtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRDYWNoZWQueSA9IDA7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0Q2FjaGVkLnogPSAwO1xuICAgICAgICB0aGlzLl92aWV3cG9ydENhY2hlZC53ID0gMDtcbiAgICAgICAgLy8gRG9uZSBiZWZvcmUgaW4gY2FzZSB3ZSBjbGVhbiB0aGUgYXR0cmlidXRlc1xuICAgICAgICB0aGlzLl91bmJpbmRWZXJ0ZXhBcnJheU9iamVjdCgpO1xuICAgICAgICBpZiAoYnJ1dGVGb3JjZSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFByb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNldFRleHR1cmVDYWNoZSgpO1xuICAgICAgICAgICAgdGhpcy5fc3RlbmNpbFN0YXRlQ29tcG9zZXIucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoQ3VsbGluZ1N0YXRlLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9kZXB0aEN1bGxpbmdTdGF0ZS5kZXB0aEZ1bmMgPSB0aGlzLl9nbC5MRVFVQUw7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYVN0YXRlLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYU1vZGUgPSAxO1xuICAgICAgICAgICAgdGhpcy5fYWxwaGFFcXVhdGlvbiA9IDA7XG4gICAgICAgICAgICB0aGlzLl9jb2xvcldyaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yV3JpdGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3VucGFja0ZsaXBZQ2FjaGVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2dsLnBpeGVsU3RvcmVpKHRoaXMuX2dsLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsIHRoaXMuX2dsLk5PTkUpO1xuICAgICAgICAgICAgdGhpcy5fZ2wucGl4ZWxTdG9yZWkodGhpcy5fZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCAwKTtcbiAgICAgICAgICAgIHRoaXMuX211c3RXaXBlVmVydGV4QXR0cmlidXRlcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnVuYmluZEFsbEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNldFZlcnRleEJ1ZmZlckJpbmRpbmcoKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkSW5kZXhCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWNoZWRFZmZlY3RGb3JWZXJ0ZXhCdWZmZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5iaW5kSW5kZXhCdWZmZXIobnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9nZXRTYW1wbGluZ1BhcmFtZXRlcnMoc2FtcGxpbmdNb2RlLCBnZW5lcmF0ZU1pcE1hcHMpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgbGV0IG1hZ0ZpbHRlciA9IGdsLk5FQVJFU1Q7XG4gICAgICAgIGxldCBtaW5GaWx0ZXIgPSBnbC5ORUFSRVNUO1xuICAgICAgICBsZXQgaGFzTWlwTWFwcyA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKHNhbXBsaW5nTW9kZSkge1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBtYWdGaWx0ZXIgPSBnbC5MSU5FQVI7XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlTWlwTWFwcykge1xuICAgICAgICAgICAgICAgICAgICBtaW5GaWx0ZXIgPSBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW5GaWx0ZXIgPSBnbC5MSU5FQVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIG1hZ0ZpbHRlciA9IGdsLkxJTkVBUjtcbiAgICAgICAgICAgICAgICBoYXNNaXBNYXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVNaXBNYXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkZpbHRlciA9IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRmlsdGVyID0gZ2wuTElORUFSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBoYXNNaXBNYXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtYWdGaWx0ZXIgPSBnbC5ORUFSRVNUO1xuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZU1pcE1hcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRmlsdGVyID0gZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRmlsdGVyID0gZ2wuTkVBUkVTVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgbWFnRmlsdGVyID0gZ2wuTkVBUkVTVDtcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVNaXBNYXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkZpbHRlciA9IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW5GaWx0ZXIgPSBnbC5ORUFSRVNUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBtYWdGaWx0ZXIgPSBnbC5ORUFSRVNUO1xuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZU1pcE1hcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRmlsdGVyID0gZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRmlsdGVyID0gZ2wuTElORUFSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBoYXNNaXBNYXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtYWdGaWx0ZXIgPSBnbC5ORUFSRVNUO1xuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZU1pcE1hcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRmlsdGVyID0gZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW5GaWx0ZXIgPSBnbC5MSU5FQVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIG1hZ0ZpbHRlciA9IGdsLk5FQVJFU1Q7XG4gICAgICAgICAgICAgICAgbWluRmlsdGVyID0gZ2wuTElORUFSO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1hZ0ZpbHRlciA9IGdsLk5FQVJFU1Q7XG4gICAgICAgICAgICAgICAgbWluRmlsdGVyID0gZ2wuTkVBUkVTVDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBtYWdGaWx0ZXIgPSBnbC5MSU5FQVI7XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlTWlwTWFwcykge1xuICAgICAgICAgICAgICAgICAgICBtaW5GaWx0ZXIgPSBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRmlsdGVyID0gZ2wuTkVBUkVTVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIGhhc01pcE1hcHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hZ0ZpbHRlciA9IGdsLkxJTkVBUjtcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVNaXBNYXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkZpbHRlciA9IGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkZpbHRlciA9IGdsLk5FQVJFU1Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG1hZ0ZpbHRlciA9IGdsLkxJTkVBUjtcbiAgICAgICAgICAgICAgICBtaW5GaWx0ZXIgPSBnbC5MSU5FQVI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIG1hZ0ZpbHRlciA9IGdsLkxJTkVBUjtcbiAgICAgICAgICAgICAgICBtaW5GaWx0ZXIgPSBnbC5ORUFSRVNUO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IG1pbkZpbHRlcixcbiAgICAgICAgICAgIG1hZzogbWFnRmlsdGVyLFxuICAgICAgICAgICAgaGFzTWlwTWFwczogaGFzTWlwTWFwcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jcmVhdGVUZXh0dXJlKCkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgdGV4dHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jcmVhdGVIYXJkd2FyZVRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2ViR0xIYXJkd2FyZVRleHR1cmUodGhpcy5fY3JlYXRlVGV4dHVyZSgpLCB0aGlzLl9nbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW50ZXJuYWwgdGV4dHVyZSB3aXRob3V0IGJpbmRpbmcgaXQgdG8gYSBmcmFtZWJ1ZmZlclxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSBzaXplIGRlZmluZXMgdGhlIHNpemUgb2YgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBkZWZpbmVzIHRoZSBvcHRpb25zIHVzZWQgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGRlbGF5R1BVVGV4dHVyZUNyZWF0aW9uIHRydWUgdG8gZGVsYXkgdGhlIHRleHR1cmUgY3JlYXRpb24gdGhlIGZpcnN0IHRpbWUgaXQgaXMgcmVhbGx5IG5lZWRlZC4gZmFsc2UgdG8gY3JlYXRlIGl0IHJpZ2h0IGF3YXlcbiAgICAgKiBAcGFyYW0gc291cmNlIHNvdXJjZSB0eXBlIG9mIHRoZSB0ZXh0dXJlXG4gICAgICogQHJldHVybnMgYSBuZXcgaW50ZXJuYWwgdGV4dHVyZVxuICAgICAqL1xuICAgIF9jcmVhdGVJbnRlcm5hbFRleHR1cmUoc2l6ZSwgb3B0aW9ucywgZGVsYXlHUFVUZXh0dXJlQ3JlYXRpb24gPSB0cnVlLCBzb3VyY2UgPSAwIC8qIEludGVybmFsVGV4dHVyZVNvdXJjZS5Vbmtub3duICovKSB7XG4gICAgICAgIGxldCBnZW5lcmF0ZU1pcE1hcHMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNyZWF0ZU1pcE1hcHMgPSBmYWxzZTtcbiAgICAgICAgbGV0IHR5cGUgPSAwO1xuICAgICAgICBsZXQgc2FtcGxpbmdNb2RlID0gMztcbiAgICAgICAgbGV0IGZvcm1hdCA9IDU7XG4gICAgICAgIGxldCB1c2VTUkdCQnVmZmVyID0gZmFsc2U7XG4gICAgICAgIGxldCBzYW1wbGVzID0gMTtcbiAgICAgICAgbGV0IGxhYmVsO1xuICAgICAgICBsZXQgY3JlYXRlTVNBQVRleHR1cmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvbXBhcmlzb25GdW5jdGlvbiA9IDA7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGdlbmVyYXRlTWlwTWFwcyA9ICEhb3B0aW9ucy5nZW5lcmF0ZU1pcE1hcHM7XG4gICAgICAgICAgICBjcmVhdGVNaXBNYXBzID0gISFvcHRpb25zLmNyZWF0ZU1pcE1hcHM7XG4gICAgICAgICAgICB0eXBlID0gb3B0aW9ucy50eXBlID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy50eXBlO1xuICAgICAgICAgICAgc2FtcGxpbmdNb2RlID0gb3B0aW9ucy5zYW1wbGluZ01vZGUgPT09IHVuZGVmaW5lZCA/IDMgOiBvcHRpb25zLnNhbXBsaW5nTW9kZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0ID09PSB1bmRlZmluZWQgPyA1IDogb3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgICAgICB1c2VTUkdCQnVmZmVyID0gb3B0aW9ucy51c2VTUkdCQnVmZmVyID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMudXNlU1JHQkJ1ZmZlcjtcbiAgICAgICAgICAgIHNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXMgPz8gMTtcbiAgICAgICAgICAgIGxhYmVsID0gb3B0aW9ucy5sYWJlbDtcbiAgICAgICAgICAgIGNyZWF0ZU1TQUFUZXh0dXJlID0gISFvcHRpb25zLmNyZWF0ZU1TQUFUZXh0dXJlO1xuICAgICAgICAgICAgY29tcGFyaXNvbkZ1bmN0aW9uID0gb3B0aW9ucy5jb21wYXJpc29uRnVuY3Rpb24gfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbmVyYXRlTWlwTWFwcyA9ICEhb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICB1c2VTUkdCQnVmZmVyICYmICh1c2VTUkdCQnVmZmVyID0gdGhpcy5fY2Fwcy5zdXBwb3J0U1JHQkJ1ZmZlcnMgJiYgKHRoaXMud2ViR0xWZXJzaW9uID4gMSB8fCB0aGlzLmlzV2ViR1BVKSk7XG4gICAgICAgIGlmICh0eXBlID09PSAxICYmICF0aGlzLl9jYXBzLnRleHR1cmVGbG9hdExpbmVhckZpbHRlcmluZykge1xuICAgICAgICAgICAgLy8gaWYgZmxvYXRpbmcgcG9pbnQgbGluZWFyIChnbC5GTE9BVCkgdGhlbiBmb3JjZSB0byBORUFSRVNUX1NBTVBMSU5HTU9ERVxuICAgICAgICAgICAgc2FtcGxpbmdNb2RlID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAyICYmICF0aGlzLl9jYXBzLnRleHR1cmVIYWxmRmxvYXRMaW5lYXJGaWx0ZXJpbmcpIHtcbiAgICAgICAgICAgIC8vIGlmIGZsb2F0aW5nIHBvaW50IGxpbmVhciAoSEFMRl9GTE9BVCkgdGhlbiBmb3JjZSB0byBORUFSRVNUX1NBTVBMSU5HTU9ERVxuICAgICAgICAgICAgc2FtcGxpbmdNb2RlID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gMSAmJiAhdGhpcy5fY2Fwcy50ZXh0dXJlRmxvYXQpIHtcbiAgICAgICAgICAgIHR5cGUgPSAwO1xuICAgICAgICAgICAgTG9nZ2VyLldhcm4oXCJGbG9hdCB0ZXh0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC4gVHlwZSBmb3JjZWQgdG8gVEVYVFVSRVRZUEVfVU5TSUdORURfQllURVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0RlcHRoVGV4dHVyZSA9IElzRGVwdGhUZXh0dXJlKGZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGhhc1N0ZW5jaWwgPSBIYXNTdGVuY2lsQXNwZWN0KGZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgSW50ZXJuYWxUZXh0dXJlKHRoaXMsIHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gc2l6ZS53aWR0aCB8fCBzaXplO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBzaXplLmhlaWdodCB8fCBzaXplO1xuICAgICAgICBjb25zdCBkZXB0aCA9IHNpemUuZGVwdGggfHwgMDtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gc2l6ZS5sYXllcnMgfHwgMDtcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IHRoaXMuX2dldFNhbXBsaW5nUGFyYW1ldGVycyhzYW1wbGluZ01vZGUsIChnZW5lcmF0ZU1pcE1hcHMgfHwgY3JlYXRlTWlwTWFwcykgJiYgIWlzRGVwdGhUZXh0dXJlKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbGF5ZXJzICE9PSAwID8gZ2wuVEVYVFVSRV8yRF9BUlJBWSA6IGRlcHRoICE9PSAwID8gZ2wuVEVYVFVSRV8zRCA6IGdsLlRFWFRVUkVfMkQ7XG4gICAgICAgIGNvbnN0IHNpemVkRm9ybWF0ID0gaXNEZXB0aFRleHR1cmVcbiAgICAgICAgICAgID8gdGhpcy5fZ2V0SW50ZXJuYWxGb3JtYXRGcm9tRGVwdGhUZXh0dXJlRm9ybWF0KGZvcm1hdCwgdHJ1ZSwgaGFzU3RlbmNpbClcbiAgICAgICAgICAgIDogdGhpcy5fZ2V0UkdCQUJ1ZmZlckludGVybmFsU2l6ZWRGb3JtYXQodHlwZSwgZm9ybWF0LCB1c2VTUkdCQnVmZmVyKTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSBpc0RlcHRoVGV4dHVyZSA/IChoYXNTdGVuY2lsID8gZ2wuREVQVEhfU1RFTkNJTCA6IGdsLkRFUFRIX0NPTVBPTkVOVCkgOiB0aGlzLl9nZXRJbnRlcm5hbEZvcm1hdChmb3JtYXQpO1xuICAgICAgICBjb25zdCB0ZXh0dXJlVHlwZSA9IGlzRGVwdGhUZXh0dXJlID8gdGhpcy5fZ2V0V2ViR0xUZXh0dXJlVHlwZUZyb21EZXB0aFRleHR1cmVGb3JtYXQoZm9ybWF0KSA6IHRoaXMuX2dldFdlYkdMVGV4dHVyZVR5cGUodHlwZSk7XG4gICAgICAgIC8vIEJpbmRcbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0YXJnZXQsIHRleHR1cmUpO1xuICAgICAgICBpZiAobGF5ZXJzICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLmlzMkRBcnJheSA9IHRydWU7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTNEKHRhcmdldCwgMCwgc2l6ZWRGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGxheWVycywgMCwgaW50ZXJuYWxGb3JtYXQsIHRleHR1cmVUeXBlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZXB0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dHVyZS5pczNEID0gdHJ1ZTtcbiAgICAgICAgICAgIGdsLnRleEltYWdlM0QodGFyZ2V0LCAwLCBzaXplZEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIDAsIGludGVybmFsRm9ybWF0LCB0ZXh0dXJlVHlwZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgMCwgc2l6ZWRGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGludGVybmFsRm9ybWF0LCB0ZXh0dXJlVHlwZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVycy5tYWcpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJzLm1pbik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGlmIChpc0RlcHRoVGV4dHVyZSAmJiB0aGlzLndlYkdMVmVyc2lvbiA+IDEpIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJpc29uRnVuY3Rpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgZ2wuVEVYVFVSRV9DT01QQVJFX0ZVTkMsIDUxNSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIGdsLlRFWFRVUkVfQ09NUEFSRV9NT0RFLCBnbC5OT05FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBnbC5URVhUVVJFX0NPTVBBUkVfRlVOQywgY29tcGFyaXNvbkZ1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgZ2wuVEVYVFVSRV9DT01QQVJFX01PREUsIGdsLkNPTVBBUkVfUkVGX1RPX1RFWFRVUkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1pcE1hcHNcbiAgICAgICAgaWYgKGdlbmVyYXRlTWlwTWFwcyB8fCBjcmVhdGVNaXBNYXBzKSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5nZW5lcmF0ZU1pcG1hcCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGFyZ2V0LCBudWxsKTtcbiAgICAgICAgdGV4dHVyZS5fdXNlU1JHQkJ1ZmZlciA9IHVzZVNSR0JCdWZmZXI7XG4gICAgICAgIHRleHR1cmUuYmFzZVdpZHRoID0gd2lkdGg7XG4gICAgICAgIHRleHR1cmUuYmFzZUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGV4dHVyZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0ZXh0dXJlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGV4dHVyZS5kZXB0aCA9IGxheWVycyB8fCBkZXB0aDtcbiAgICAgICAgdGV4dHVyZS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGV4dHVyZS5zYW1wbGVzID0gc2FtcGxlcztcbiAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMgPSBnZW5lcmF0ZU1pcE1hcHM7XG4gICAgICAgIHRleHR1cmUuc2FtcGxpbmdNb2RlID0gc2FtcGxpbmdNb2RlO1xuICAgICAgICB0ZXh0dXJlLnR5cGUgPSB0eXBlO1xuICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgdGV4dHVyZS5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0ZXh0dXJlLmNvbXBhcmlzb25GdW5jdGlvbiA9IGNvbXBhcmlzb25GdW5jdGlvbjtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxUZXh0dXJlc0NhY2hlLnB1c2godGV4dHVyZSk7XG4gICAgICAgIGlmIChjcmVhdGVNU0FBVGV4dHVyZSkge1xuICAgICAgICAgICAgbGV0IHJlbmRlckJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoSXNEZXB0aFRleHR1cmUodGV4dHVyZS5mb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyQnVmZmVyID0gdGhpcy5fc2V0dXBGcmFtZWJ1ZmZlckRlcHRoQXR0YWNobWVudHMoSGFzU3RlbmNpbEFzcGVjdCh0ZXh0dXJlLmZvcm1hdCksIHRleHR1cmUuZm9ybWF0ICE9PSAxOSwgdGV4dHVyZS53aWR0aCwgdGV4dHVyZS5oZWlnaHQsIHNhbXBsZXMsIHRleHR1cmUuZm9ybWF0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmRlckJ1ZmZlciA9IHRoaXMuX2NyZWF0ZVJlbmRlckJ1ZmZlcih0ZXh0dXJlLndpZHRoLCB0ZXh0dXJlLmhlaWdodCwgc2FtcGxlcywgLTEgLyogbm90IHVzZWQgKi8sIHRoaXMuX2dldFJHQkFCdWZmZXJJbnRlcm5hbFNpemVkRm9ybWF0KHRleHR1cmUudHlwZSwgdGV4dHVyZS5mb3JtYXQsIHRleHR1cmUuX3VzZVNSR0JCdWZmZXIpLCAtMSAvKiBhdHRhY2htZW50ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVuZGVyQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSByZW5kZXIgYnVmZmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dHVyZS5fYXV0b01TQUFNYW5hZ2VtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBoYXJkd2FyZVRleHR1cmUgPSB0ZXh0dXJlLl9oYXJkd2FyZVRleHR1cmU7XG4gICAgICAgICAgICBpZiAoIWhhcmR3YXJlVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGhhcmR3YXJlVGV4dHVyZSA9IHRleHR1cmUuX2hhcmR3YXJlVGV4dHVyZSA9IHRoaXMuX2NyZWF0ZUhhcmR3YXJlVGV4dHVyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFyZHdhcmVUZXh0dXJlLmFkZE1TQUFSZW5kZXJCdWZmZXIocmVuZGVyQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2dldFVzZVNSR0JCdWZmZXIodXNlU1JHQkJ1ZmZlciwgbm9NaXBtYXApIHtcbiAgICAgICAgLy8gR2VuZXJhdGluZyBtaXBtYXBzIGZvciBzUkdCIHRleHR1cmVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gV2ViR0wxIHNvIHdlIG11c3QgZGlzYWJsZSB0aGUgc3VwcG9ydCBpZiBtaXBtYXBzIGlzIGVuYWJsZWRcbiAgICAgICAgcmV0dXJuIHVzZVNSR0JCdWZmZXIgJiYgdGhpcy5fY2Fwcy5zdXBwb3J0U1JHQkJ1ZmZlcnMgJiYgKHRoaXMud2ViR0xWZXJzaW9uID4gMSB8fCBub01pcG1hcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzdWFsbHkgY2FsbGVkIGZyb20gVGV4dHVyZS50cy5cbiAgICAgKiBQYXNzZWQgaW5mb3JtYXRpb24gdG8gY3JlYXRlIGEgV2ViR0xUZXh0dXJlXG4gICAgICogQHBhcmFtIHVybCBkZWZpbmVzIGEgdmFsdWUgd2hpY2ggY29udGFpbnMgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgICogKiBBIGNvbnZlbnRpb25hbCBodHRwIFVSTCwgZS5nLiAnaHR0cDovLy4uLicgb3IgJ2ZpbGU6Ly8uLi4nXG4gICAgICogKiBBIGJhc2U2NCBzdHJpbmcgb2YgaW4tbGluZSB0ZXh0dXJlIGRhdGEsIGUuZy4gJ2RhdGE6aW1hZ2UvanBnO2Jhc2U2NCwvLi4uJ1xuICAgICAqICogQW4gaW5kaWNhdG9yIHRoYXQgZGF0YSBiZWluZyBwYXNzZWQgdXNpbmcgdGhlIGJ1ZmZlciBwYXJhbWV0ZXIsIGUuZy4gJ2RhdGE6bXl0ZXh0dXJlLmpwZydcbiAgICAgKiBAcGFyYW0gbm9NaXBtYXAgZGVmaW5lcyBhIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IG5vIG1pcG1hcHMgc2hhbGwgYmUgZ2VuZXJhdGVkLiAgSWdub3JlZCBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcy4gIFRoZXkgbXVzdCBiZSBpbiB0aGUgZmlsZVxuICAgICAqIEBwYXJhbSBpbnZlcnRZIHdoZW4gdHJ1ZSwgaW1hZ2UgaXMgZmxpcHBlZCB3aGVuIGxvYWRlZC4gIFlvdSBwcm9iYWJseSB3YW50IHRydWUuIENlcnRhaW4gY29tcHJlc3NlZCB0ZXh0dXJlcyBtYXkgaW52ZXJ0IHRoaXMgaWYgdGhlaXIgZGVmYXVsdCBpcyBpbnZlcnRlZCAoZWcuIGt0eClcbiAgICAgKiBAcGFyYW0gc2NlbmUgbmVlZGVkIGZvciBsb2FkaW5nIHRvIHRoZSBjb3JyZWN0IHNjZW5lXG4gICAgICogQHBhcmFtIHNhbXBsaW5nTW9kZSBtb2RlIHdpdGggc2hvdWxkIGJlIHVzZWQgc2FtcGxlIC8gYWNjZXNzIHRoZSB0ZXh0dXJlIChEZWZhdWx0OiBUZXh0dXJlLlRSSUxJTkVBUl9TQU1QTElOR01PREUpXG4gICAgICogQHBhcmFtIG9uTG9hZCBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBjYWxsZWQgdXBvbiBzdWNjZXNzZnVsIGNvbXBsZXRpb25cbiAgICAgKiBAcGFyYW0gb25FcnJvciBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBjYWxsZWQgdXBvbiBmYWlsdXJlXG4gICAgICogQHBhcmFtIGJ1ZmZlciBhIHNvdXJjZSBvZiBhIGZpbGUgcHJldmlvdXNseSBmZXRjaGVkIGFzIGVpdGhlciBhIGJhc2U2NCBzdHJpbmcsIGFuIEFycmF5QnVmZmVyIChjb21wcmVzc2VkIG9yIGltYWdlIGZvcm1hdCksIEhUTUxJbWFnZUVsZW1lbnQgKGltYWdlIGZvcm1hdCksIG9yIGEgQmxvYlxuICAgICAqIEBwYXJhbSBmYWxsYmFjayBhbiBpbnRlcm5hbCBhcmd1bWVudCBpbiBjYXNlIHRoZSBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBhZ2FpbiwgZHVlIHRvIGV0YzEgbm90IGhhdmluZyBhbHBoYSBjYXBhYmlsaXRpZXNcbiAgICAgKiBAcGFyYW0gZm9ybWF0IGludGVybmFsIGZvcm1hdC4gIERlZmF1bHQ6IFJHQiB3aGVuIGV4dGVuc2lvbiBpcyAnLmpwZycgZWxzZSBSR0JBLiAgSWdub3JlZCBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xuICAgICAqIEBwYXJhbSBmb3JjZWRFeHRlbnNpb24gZGVmaW5lcyB0aGUgZXh0ZW5zaW9uIHRvIHVzZSB0byBwaWNrIHRoZSByaWdodCBsb2FkZXJcbiAgICAgKiBAcGFyYW0gbWltZVR5cGUgZGVmaW5lcyBhbiBvcHRpb25hbCBtaW1lIHR5cGVcbiAgICAgKiBAcGFyYW0gbG9hZGVyT3B0aW9ucyBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGUgbG9hZGVyXG4gICAgICogQHBhcmFtIGNyZWF0aW9uRmxhZ3Mgc3BlY2lmaWMgZmxhZ3MgdG8gdXNlIHdoZW4gY3JlYXRpbmcgdGhlIHRleHR1cmUgKDEgZm9yIHN0b3JhZ2UgdGV4dHVyZXMsIGZvciBlZylcbiAgICAgKiBAcGFyYW0gdXNlU1JHQkJ1ZmZlciBkZWZpbmVzIGlmIHRoZSB0ZXh0dXJlIG11c3QgYmUgbG9hZGVkIGluIGEgc1JHQiBHUFUgYnVmZmVyIChpZiBzdXBwb3J0ZWQgYnkgdGhlIEdQVSkuXG4gICAgICogQHJldHVybnMgYSBJbnRlcm5hbFRleHR1cmUgZm9yIGFzc2lnbm1lbnQgYmFjayBpbnRvIEJBQllMT04uVGV4dHVyZVxuICAgICAqL1xuICAgIGNyZWF0ZVRleHR1cmUodXJsLCBub01pcG1hcCwgaW52ZXJ0WSwgc2NlbmUsIHNhbXBsaW5nTW9kZSA9IDMsIG9uTG9hZCA9IG51bGwsIG9uRXJyb3IgPSBudWxsLCBidWZmZXIgPSBudWxsLCBmYWxsYmFjayA9IG51bGwsIGZvcm1hdCA9IG51bGwsIGZvcmNlZEV4dGVuc2lvbiA9IG51bGwsIG1pbWVUeXBlLCBsb2FkZXJPcHRpb25zLCBjcmVhdGlvbkZsYWdzLCB1c2VTUkdCQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVUZXh0dXJlQmFzZSh1cmwsIG5vTWlwbWFwLCBpbnZlcnRZLCBzY2VuZSwgc2FtcGxpbmdNb2RlLCBvbkxvYWQsIG9uRXJyb3IsICguLi5hcmdzKSA9PiB0aGlzLl9wcmVwYXJlV2ViR0xUZXh0dXJlKC4uLmFyZ3MsIGZvcm1hdCksIChwb3RXaWR0aCwgcG90SGVpZ2h0LCBpbWcsIGV4dGVuc2lvbiwgdGV4dHVyZSwgY29udGludWF0aW9uQ2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgICAgICAgICBjb25zdCBpc1BvdCA9IGltZy53aWR0aCA9PT0gcG90V2lkdGggJiYgaW1nLmhlaWdodCA9PT0gcG90SGVpZ2h0O1xuICAgICAgICAgICAgdGV4dHVyZS5fY3JlYXRpb25GbGFncyA9IGNyZWF0aW9uRmxhZ3MgPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRleEltYWdlUGFyYW1ldGVyc0ZvckNyZWF0ZVRleHR1cmUodGV4dHVyZS5mb3JtYXQsIHRleHR1cmUuX3VzZVNSR0JCdWZmZXIpO1xuICAgICAgICAgICAgaWYgKGlzUG90KSB7XG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aXAuaW50ZXJuYWxGb3JtYXQsIHRpcC5mb3JtYXQsIHRpcC50eXBlLCBpbWcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1heFRleHR1cmVTaXplID0gdGhpcy5fY2Fwcy5tYXhUZXh0dXJlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpbWcud2lkdGggPiBtYXhUZXh0dXJlU2l6ZSB8fCBpbWcuaGVpZ2h0ID4gbWF4VGV4dHVyZVNpemUgfHwgIXRoaXMuX3N1cHBvcnRzSGFyZHdhcmVUZXh0dXJlUmVzY2FsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZVdvcmtpbmdDYW52YXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dvcmtpbmdDYW52YXMgfHwgIXRoaXMuX3dvcmtpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2luZ0NhbnZhcy53aWR0aCA9IHBvdFdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtpbmdDYW52YXMuaGVpZ2h0ID0gcG90SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtpbmdDb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZy53aWR0aCwgaW1nLmhlaWdodCwgMCwgMCwgcG90V2lkdGgsIHBvdEhlaWdodCk7XG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aXAuaW50ZXJuYWxGb3JtYXQsIHRpcC5mb3JtYXQsIHRpcC50eXBlLCB0aGlzLl93b3JraW5nQ2FudmFzKTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLndpZHRoID0gcG90V2lkdGg7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5oZWlnaHQgPSBwb3RIZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgc2hhZGVycyB3aGVuIHBvc3NpYmxlIHRvIHJlc2NhbGUgYmVjYXVzZSBjYW52YXMuZHJhd0ltYWdlIGlzIGxvc3N5XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IEludGVybmFsVGV4dHVyZSh0aGlzLCAyIC8qIEludGVybmFsVGV4dHVyZVNvdXJjZS5UZW1wICovKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KGdsLlRFWFRVUkVfMkQsIHNvdXJjZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aXAuaW50ZXJuYWxGb3JtYXQsIHRpcC5mb3JtYXQsIHRpcC50eXBlLCBpbWcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2NhbGVUZXh0dXJlKHNvdXJjZSwgdGV4dHVyZSwgc2NlbmUsIHRpcC5mb3JtYXQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVsZWFzZVRleHR1cmUoc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWF0aW9uQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LCBidWZmZXIsIGZhbGxiYWNrLCBmb3JtYXQsIGZvcmNlZEV4dGVuc2lvbiwgbWltZVR5cGUsIGxvYWRlck9wdGlvbnMsIHVzZVNSR0JCdWZmZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyB0byB0aGUgR0wgdGV4SW1hZ2UyRCBhbmQgdGV4SW1hZ2UzRCBmdW5jdGlvbnMgcmVxdWlyZSB0aHJlZSBhcmd1bWVudHMgZGVzY3JpYmluZyB0aGUgcGl4ZWwgZm9ybWF0IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqIGNyZWF0ZVRleHR1cmUgZGVyaXZlcyB0aGVzZSBmcm9tIHRoZSBiYWJ5bG9uRm9ybWF0IGFuZCB1c2VTUkdCQnVmZmVyIGFyZ3VtZW50cyBhbmQgYWxzbyB0aGUgZmlsZSBleHRlbnNpb24gb2YgdGhlIFVSTCBpdCdzIHdvcmtpbmcgd2l0aC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGVuY2Fwc3VsYXRlcyB0aGF0IGRlcml2YXRpb24gZm9yIGVhc3kgdW5pdCB0ZXN0aW5nLlxuICAgICAqIEBwYXJhbSBiYWJ5bG9uRm9ybWF0IEJhYnlsb24ncyBmb3JtYXQgZW51bSwgYXMgc3BlY2lmaWVkIGluIElUZXh0dXJlQ3JlYXRpb25PcHRpb25zLlxuICAgICAqIEBwYXJhbSBmaWxlRXh0ZW5zaW9uIFRoZSBmaWxlIGV4dGVuc2lvbiBpbmNsdWRpbmcgdGhlIGRvdCwgZS5nLiAuanBnLlxuICAgICAqIEBwYXJhbSB1c2VTUkdCQnVmZmVyIFVzZSBTUkdCIG5vdCBsaW5lYXIuXG4gICAgICogQHJldHVybnMgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0ZXhJbWFnZTJEIG9yIHRleEltYWdlM0QgY2FsbHMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2dldFRleEltYWdlUGFyYW1ldGVyc0ZvckNyZWF0ZVRleHR1cmUoYmFieWxvbkZvcm1hdCwgdXNlU1JHQkJ1ZmZlcikge1xuICAgICAgICBsZXQgZm9ybWF0LCBpbnRlcm5hbEZvcm1hdDtcbiAgICAgICAgaWYgKHRoaXMud2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICAvLyBJbiBXZWJHTCAxLCBmb3JtYXQgYW5kIGludGVybmFsRm9ybWF0IG11c3QgYmUgdGhlIHNhbWUgYW5kIHRha2VuIGZyb20gYSBsaW1pdGVkIHNldCBvZiB2YWx1ZXMsIHNlZSBodHRwczovL2RvY3MuZ2wvZXMyL2dsVGV4SW1hZ2UyRC5cbiAgICAgICAgICAgIC8vIFRoZSBTUkdCIGV4dGVuc2lvbiAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VYVF9zUkdCKSBhZGRzIHNvbWUgZXh0cmEgdmFsdWVzLCBoZW5jZSBwYXNzaW5nIHVzZVNSR0JCdWZmZXJcbiAgICAgICAgICAgIC8vIHRvIGdldEludGVybmFsRm9ybWF0LlxuICAgICAgICAgICAgZm9ybWF0ID0gdGhpcy5fZ2V0SW50ZXJuYWxGb3JtYXQoYmFieWxvbkZvcm1hdCwgdXNlU1JHQkJ1ZmZlcik7XG4gICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIFdlYkdMIDIsIGZvcm1hdCBoYXMgYSB3aWRlciByYW5nZSBvZiB2YWx1ZXMgYW5kIGludGVybmFsIGZvcm1hdCBjYW4gYmUgb25lIG9mIHRoZSBzaXplZCBmb3JtYXRzLCBzZWVcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvT3BlbkdMLVJlZnBhZ2VzL2VzMy4wL2h0bWwvZ2xUZXhJbWFnZTJELnhodG1sLlxuICAgICAgICAgICAgLy8gU1JHQiBpcyBpbmNsdWRlZCBpbiB0aGUgc2l6ZWQgZm9ybWF0IGFuZCBzaG91bGQgbm90IGJlIHBhc3NlZCBpbiBcImZvcm1hdFwiLCBoZW5jZSBhbHdheXMgcGFzc2luZyB1c2VTUkdCQnVmZmVyIGFzIGZhbHNlLlxuICAgICAgICAgICAgZm9ybWF0ID0gdGhpcy5fZ2V0SW50ZXJuYWxGb3JtYXQoYmFieWxvbkZvcm1hdCwgZmFsc2UpO1xuICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLl9nZXRSR0JBQnVmZmVySW50ZXJuYWxTaXplZEZvcm1hdCgwLCBiYWJ5bG9uRm9ybWF0LCB1c2VTUkdCQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9nbC5VTlNJR05FRF9CWVRFLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfcmVzY2FsZVRleHR1cmUoc291cmNlLCBkZXN0aW5hdGlvbiwgc2NlbmUsIGludGVybmFsRm9ybWF0LCBvbkNvbXBsZXRlKSB7IH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfdW5wYWNrRmxpcFkodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VucGFja0ZsaXBZQ2FjaGVkICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZ2wucGl4ZWxTdG9yZWkodGhpcy5fZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdmFsdWUgPyAxIDogMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVVbnBhY2tGbGlwWUNhY2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VucGFja0ZsaXBZQ2FjaGVkID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRVbnBhY2tBbGlnbmVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLlVOUEFDS19BTElHTk1FTlQpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFRleHR1cmVUYXJnZXQodGV4dHVyZSkge1xuICAgICAgICBpZiAodGV4dHVyZS5pc0N1YmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5URVhUVVJFX0NVQkVfTUFQO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHR1cmUuaXMzRCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlRFWFRVUkVfM0Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dHVyZS5pczJEQXJyYXkgfHwgdGV4dHVyZS5pc011bHRpdmlldykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlRFWFRVUkVfMkRfQVJSQVk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlRFWFRVUkVfMkQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2FtcGxpbmcgbW9kZSBvZiBhIGdpdmVuIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gc2FtcGxpbmdNb2RlIGRlZmluZXMgdGhlIHJlcXVpcmVkIHNhbXBsaW5nIG1vZGVcbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSB0ZXh0dXJlIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSBnZW5lcmF0ZU1pcE1hcHMgZGVmaW5lcyB3aGV0aGVyIHRvIGdlbmVyYXRlIG1pcG1hcHMgZm9yIHRoZSB0ZXh0dXJlXG4gICAgICovXG4gICAgdXBkYXRlVGV4dHVyZVNhbXBsaW5nTW9kZShzYW1wbGluZ01vZGUsIHRleHR1cmUsIGdlbmVyYXRlTWlwTWFwcyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2dldFRleHR1cmVUYXJnZXQodGV4dHVyZSk7XG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLl9nZXRTYW1wbGluZ1BhcmFtZXRlcnMoc2FtcGxpbmdNb2RlLCB0ZXh0dXJlLnVzZU1pcE1hcHMgfHwgZ2VuZXJhdGVNaXBNYXBzKTtcbiAgICAgICAgdGhpcy5fc2V0VGV4dHVyZVBhcmFtZXRlckludGVnZXIodGFyZ2V0LCB0aGlzLl9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlcnMubWFnLCB0ZXh0dXJlKTtcbiAgICAgICAgdGhpcy5fc2V0VGV4dHVyZVBhcmFtZXRlckludGVnZXIodGFyZ2V0LCB0aGlzLl9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlcnMubWluKTtcbiAgICAgICAgaWYgKGdlbmVyYXRlTWlwTWFwcyAmJiBmaWx0ZXJzLmhhc01pcE1hcHMpIHtcbiAgICAgICAgICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBNYXBzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2dsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0YXJnZXQsIG51bGwpO1xuICAgICAgICB0ZXh0dXJlLnNhbXBsaW5nTW9kZSA9IHNhbXBsaW5nTW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBkaW1lbnNpb25zIG9mIGEgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIHRleHR1cmUgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIHdpZHRoIG5ldyB3aWR0aCBvZiB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgbmV3IGhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBkZXB0aCBuZXcgZGVwdGggb2YgdGhlIHRleHR1cmVcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0dXJlRGltZW5zaW9ucyh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCA9IDEpIHsgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2FtcGxpbmcgbW9kZSBvZiBhIGdpdmVuIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSB0ZXh0dXJlIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB3cmFwVSBkZWZpbmVzIHRoZSB0ZXh0dXJlIHdyYXAgbW9kZSBvZiB0aGUgdSBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB3cmFwViBkZWZpbmVzIHRoZSB0ZXh0dXJlIHdyYXAgbW9kZSBvZiB0aGUgdiBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB3cmFwUiBkZWZpbmVzIHRoZSB0ZXh0dXJlIHdyYXAgbW9kZSBvZiB0aGUgciBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIHVwZGF0ZVRleHR1cmVXcmFwcGluZ01vZGUodGV4dHVyZSwgd3JhcFUsIHdyYXBWID0gbnVsbCwgd3JhcFIgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2dldFRleHR1cmVUYXJnZXQodGV4dHVyZSk7XG4gICAgICAgIGlmICh3cmFwVSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VGV4dHVyZVBhcmFtZXRlckludGVnZXIodGFyZ2V0LCB0aGlzLl9nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fZ2V0VGV4dHVyZVdyYXBNb2RlKHdyYXBVKSwgdGV4dHVyZSk7XG4gICAgICAgICAgICB0ZXh0dXJlLl9jYWNoZWRXcmFwVSA9IHdyYXBVO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwViAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VGV4dHVyZVBhcmFtZXRlckludGVnZXIodGFyZ2V0LCB0aGlzLl9nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fZ2V0VGV4dHVyZVdyYXBNb2RlKHdyYXBWKSwgdGV4dHVyZSk7XG4gICAgICAgICAgICB0ZXh0dXJlLl9jYWNoZWRXcmFwViA9IHdyYXBWO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGV4dHVyZS5pczJEQXJyYXkgfHwgdGV4dHVyZS5pczNEKSAmJiB3cmFwUiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VGV4dHVyZVBhcmFtZXRlckludGVnZXIodGFyZ2V0LCB0aGlzLl9nbC5URVhUVVJFX1dSQVBfUiwgdGhpcy5fZ2V0VGV4dHVyZVdyYXBNb2RlKHdyYXBSKSwgdGV4dHVyZSk7XG4gICAgICAgICAgICB0ZXh0dXJlLl9jYWNoZWRXcmFwUiA9IHdyYXBSO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGFyZ2V0LCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3VwbG9hZENvbXByZXNzZWREYXRhVG9UZXh0dXJlRGlyZWN0bHkodGV4dHVyZSwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGRhdGEsIGZhY2VJbmRleCA9IDAsIGxvZCA9IDApIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgbGV0IHRhcmdldCA9IGdsLlRFWFRVUkVfMkQ7XG4gICAgICAgIGlmICh0ZXh0dXJlLmlzQ3ViZSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgZmFjZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0dXJlLl91c2VTUkdCQnVmZmVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGludGVybmFsRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzNzQ5MjpcbiAgICAgICAgICAgICAgICBjYXNlIDM2MTk2OlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlLCBpZiB1c2luZyBFVEMxIGFuZCBzUkdCIGlzIHJlcXVlc3RlZCwgdGhpcyB3aWxsIHVzZSBFVEMyIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhcHMuZXRjMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSBnbC5DT01QUkVTU0VEX1NSR0I4X0VUQzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLl91c2VTUkdCQnVmZmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzNzQ5NjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhcHMuZXRjMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSBnbC5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuX3VzZVNSR0JCdWZmZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM2NDkyOlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IGdsLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9CUFRDX1VOT1JNX0VYVDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzNzgwODpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSBnbC5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzR4NF9LSFI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzM3NzY6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXBzLnMzdGNfc3JnYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSBnbC5DT01QUkVTU0VEX1NSR0JfUzNUQ19EWFQxX0VYVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFMzVEMgc1JHQiBleHRlbnNpb24gbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5fdXNlU1JHQkJ1ZmZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzM3Nzc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXBzLnMzdGNfc3JnYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSBnbC5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFMzVEMgc1JHQiBleHRlbnNpb24gbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5fdXNlU1JHQkJ1ZmZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzM3Nzk6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXBzLnMzdGNfc3JnYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSBnbC5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFMzVEMgc1JHQiBleHRlbnNpb24gbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5fdXNlU1JHQkJ1ZmZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgYSBzUkdCIGZvcm1hdCBjb3JyZXNwb25kaW5nIHRvIGludGVybmFsRm9ybWF0LCBzbyByZXZlcnQgdG8gbm9uIHNSR0IgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUuX3VzZVNSR0JCdWZmZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wuY29tcHJlc3NlZFRleEltYWdlMkQodGFyZ2V0LCBsb2QsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3VwbG9hZERhdGFUb1RleHR1cmVEaXJlY3RseSh0ZXh0dXJlLCBpbWFnZURhdGEsIGZhY2VJbmRleCA9IDAsIGxvZCA9IDAsIGJhYnlsb25JbnRlcm5hbEZvcm1hdCwgdXNlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgY29uc3QgdGV4dHVyZVR5cGUgPSB0aGlzLl9nZXRXZWJHTFRleHR1cmVUeXBlKHRleHR1cmUudHlwZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuX2dldEludGVybmFsRm9ybWF0KHRleHR1cmUuZm9ybWF0KTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSBiYWJ5bG9uSW50ZXJuYWxGb3JtYXQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0aGlzLl9nZXRSR0JBQnVmZmVySW50ZXJuYWxTaXplZEZvcm1hdCh0ZXh0dXJlLnR5cGUsIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLl91c2VTUkdCQnVmZmVyKVxuICAgICAgICAgICAgOiB0aGlzLl9nZXRJbnRlcm5hbEZvcm1hdChiYWJ5bG9uSW50ZXJuYWxGb3JtYXQsIHRleHR1cmUuX3VzZVNSR0JCdWZmZXIpO1xuICAgICAgICB0aGlzLl91bnBhY2tGbGlwWSh0ZXh0dXJlLmludmVydFkpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gZ2wuVEVYVFVSRV8yRDtcbiAgICAgICAgaWYgKHRleHR1cmUuaXNDdWJlKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBmYWNlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9kTWF4V2lkdGggPSBNYXRoLnJvdW5kKE1hdGgubG9nKHRleHR1cmUud2lkdGgpICogTWF0aC5MT0cyRSk7XG4gICAgICAgIGNvbnN0IGxvZE1heEhlaWdodCA9IE1hdGgucm91bmQoTWF0aC5sb2codGV4dHVyZS5oZWlnaHQpICogTWF0aC5MT0cyRSk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdXNlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0ID8gdGV4dHVyZS53aWR0aCA6IE1hdGgucG93KDIsIE1hdGgubWF4KGxvZE1heFdpZHRoIC0gbG9kLCAwKSk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHVzZVRleHR1cmVXaWR0aEFuZEhlaWdodCA/IHRleHR1cmUuaGVpZ2h0IDogTWF0aC5wb3coMiwgTWF0aC5tYXgobG9kTWF4SGVpZ2h0IC0gbG9kLCAwKSk7XG4gICAgICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBsb2QsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHRleHR1cmVUeXBlLCBpbWFnZURhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBwb3J0aW9uIG9mIGFuIGludGVybmFsIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSB0ZXh0dXJlIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSBpbWFnZURhdGEgZGVmaW5lcyB0aGUgZGF0YSB0byBzdG9yZSBpbnRvIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHhPZmZzZXQgZGVmaW5lcyB0aGUgeCBjb29yZGluYXRlcyBvZiB0aGUgdXBkYXRlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB5T2Zmc2V0IGRlZmluZXMgdGhlIHkgY29vcmRpbmF0ZXMgb2YgdGhlIHVwZGF0ZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gd2lkdGggZGVmaW5lcyB0aGUgd2lkdGggb2YgdGhlIHVwZGF0ZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IGRlZmluZXMgdGhlIGhlaWdodCBvZiB0aGUgdXBkYXRlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBmYWNlSW5kZXggZGVmaW5lcyB0aGUgZmFjZSBpbmRleCBpZiB0ZXh0dXJlIGlzIGEgY3ViZSAoMCBieSBkZWZhdWx0KVxuICAgICAqIEBwYXJhbSBsb2QgZGVmaW5lcyB0aGUgbG9kIGxldmVsIHRvIHVwZGF0ZSAoMCBieSBkZWZhdWx0KVxuICAgICAqIEBwYXJhbSBnZW5lcmF0ZU1pcE1hcHMgZGVmaW5lcyB3aGV0aGVyIHRvIGdlbmVyYXRlIG1pcG1hcHMgb3Igbm90XG4gICAgICovXG4gICAgdXBkYXRlVGV4dHVyZURhdGEodGV4dHVyZSwgaW1hZ2VEYXRhLCB4T2Zmc2V0LCB5T2Zmc2V0LCB3aWR0aCwgaGVpZ2h0LCBmYWNlSW5kZXggPSAwLCBsb2QgPSAwLCBnZW5lcmF0ZU1pcE1hcHMgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICBjb25zdCB0ZXh0dXJlVHlwZSA9IHRoaXMuX2dldFdlYkdMVGV4dHVyZVR5cGUodGV4dHVyZS50eXBlKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5fZ2V0SW50ZXJuYWxGb3JtYXQodGV4dHVyZS5mb3JtYXQpO1xuICAgICAgICB0aGlzLl91bnBhY2tGbGlwWSh0ZXh0dXJlLmludmVydFkpO1xuICAgICAgICBsZXQgdGFyZ2V0Rm9yQmluZGluZyA9IGdsLlRFWFRVUkVfMkQ7XG4gICAgICAgIGxldCB0YXJnZXQgPSBnbC5URVhUVVJFXzJEO1xuICAgICAgICBpZiAodGV4dHVyZS5pc0N1YmUpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGZhY2VJbmRleDtcbiAgICAgICAgICAgIHRhcmdldEZvckJpbmRpbmcgPSBnbC5URVhUVVJFX0NVQkVfTUFQO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGFyZ2V0Rm9yQmluZGluZywgdGV4dHVyZSwgdHJ1ZSk7XG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQodGFyZ2V0LCBsb2QsIHhPZmZzZXQsIHlPZmZzZXQsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdGV4dHVyZVR5cGUsIGltYWdlRGF0YSk7XG4gICAgICAgIGlmIChnZW5lcmF0ZU1pcE1hcHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLmdlbmVyYXRlTWlwbWFwKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0YXJnZXRGb3JCaW5kaW5nLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3VwbG9hZEFycmF5QnVmZmVyVmlld1RvVGV4dHVyZSh0ZXh0dXJlLCBpbWFnZURhdGEsIGZhY2VJbmRleCA9IDAsIGxvZCA9IDApIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgY29uc3QgYmluZFRhcmdldCA9IHRleHR1cmUuaXNDdWJlID8gZ2wuVEVYVFVSRV9DVUJFX01BUCA6IGdsLlRFWFRVUkVfMkQ7XG4gICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkoYmluZFRhcmdldCwgdGV4dHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3VwbG9hZERhdGFUb1RleHR1cmVEaXJlY3RseSh0ZXh0dXJlLCBpbWFnZURhdGEsIGZhY2VJbmRleCwgbG9kKTtcbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseShiaW5kVGFyZ2V0LCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgX3ByZXBhcmVXZWJHTFRleHR1cmVDb250aW51YXRpb24odGV4dHVyZSwgc2NlbmUsIG5vTWlwbWFwLCBpc0NvbXByZXNzZWQsIHNhbXBsaW5nTW9kZSkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICBpZiAoIWdsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVycyA9IHRoaXMuX2dldFNhbXBsaW5nUGFyYW1ldGVycyhzYW1wbGluZ01vZGUsICFub01pcG1hcCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJzLm1hZyk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJzLm1pbik7XG4gICAgICAgIGlmICghbm9NaXBtYXAgJiYgIWlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgLy8gdGhpcy5yZXNldFRleHR1cmVDYWNoZSgpO1xuICAgICAgICBpZiAoc2NlbmUpIHtcbiAgICAgICAgICAgIHNjZW5lLnJlbW92ZVBlbmRpbmdEYXRhKHRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHRleHR1cmUub25Mb2FkZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyh0ZXh0dXJlKTtcbiAgICAgICAgdGV4dHVyZS5vbkxvYWRlZE9ic2VydmFibGUuY2xlYXIoKTtcbiAgICB9XG4gICAgX3ByZXBhcmVXZWJHTFRleHR1cmUodGV4dHVyZSwgZXh0ZW5zaW9uLCBzY2VuZSwgaW1nLCBpbnZlcnRZLCBub01pcG1hcCwgaXNDb21wcmVzc2VkLCBwcm9jZXNzRnVuY3Rpb24sIHNhbXBsaW5nTW9kZSwgZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IG1heFRleHR1cmVTaXplID0gdGhpcy5nZXRDYXBzKCkubWF4VGV4dHVyZVNpemU7XG4gICAgICAgIGNvbnN0IHBvdFdpZHRoID0gTWF0aC5taW4obWF4VGV4dHVyZVNpemUsIHRoaXMubmVlZFBPVFRleHR1cmVzID8gR2V0RXhwb25lbnRPZlR3byhpbWcud2lkdGgsIG1heFRleHR1cmVTaXplKSA6IGltZy53aWR0aCk7XG4gICAgICAgIGNvbnN0IHBvdEhlaWdodCA9IE1hdGgubWluKG1heFRleHR1cmVTaXplLCB0aGlzLm5lZWRQT1RUZXh0dXJlcyA/IEdldEV4cG9uZW50T2ZUd28oaW1nLmhlaWdodCwgbWF4VGV4dHVyZVNpemUpIDogaW1nLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRleHR1cmUuX2hhcmR3YXJlVGV4dHVyZSkge1xuICAgICAgICAgICAgLy8gIHRoaXMucmVzZXRUZXh0dXJlQ2FjaGUoKTtcbiAgICAgICAgICAgIGlmIChzY2VuZSkge1xuICAgICAgICAgICAgICAgIHNjZW5lLnJlbW92ZVBlbmRpbmdEYXRhKHRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3VucGFja0ZsaXBZKGludmVydFkgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpbnZlcnRZID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgICAgdGV4dHVyZS5iYXNlV2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgIHRleHR1cmUuYmFzZUhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgICAgIHRleHR1cmUud2lkdGggPSBwb3RXaWR0aDtcbiAgICAgICAgdGV4dHVyZS5oZWlnaHQgPSBwb3RIZWlnaHQ7XG4gICAgICAgIHRleHR1cmUuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHRleHR1cmUudHlwZSA9IHRleHR1cmUudHlwZSAhPT0gLTEgPyB0ZXh0dXJlLnR5cGUgOiAwO1xuICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9XG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCAhPT0gLTEgPyB0ZXh0dXJlLmZvcm1hdCA6IChmb3JtYXQgPz8gKGV4dGVuc2lvbiA9PT0gXCIuanBnXCIgJiYgIXRleHR1cmUuX3VzZVNSR0JCdWZmZXIgPyA0IDogNSkpO1xuICAgICAgICBpZiAocHJvY2Vzc0Z1bmN0aW9uKHBvdFdpZHRoLCBwb3RIZWlnaHQsIGltZywgZXh0ZW5zaW9uLCB0ZXh0dXJlLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcmVwYXJlV2ViR0xUZXh0dXJlQ29udGludWF0aW9uKHRleHR1cmUsIHNjZW5lLCBub01pcG1hcCwgaXNDb21wcmVzc2VkLCBzYW1wbGluZ01vZGUpO1xuICAgICAgICB9KSkge1xuICAgICAgICAgICAgLy8gUmV0dXJuaW5nIGFzIHRleHR1cmUgbmVlZHMgZXh0cmEgYXN5bmMgc3RlcHNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmVwYXJlV2ViR0xUZXh0dXJlQ29udGludWF0aW9uKHRleHR1cmUsIHNjZW5lLCBub01pcG1hcCwgaXNDb21wcmVzc2VkLCBzYW1wbGluZ01vZGUpO1xuICAgIH1cbiAgICBfZ2V0SW50ZXJuYWxGb3JtYXRGcm9tRGVwdGhUZXh0dXJlRm9ybWF0KHRleHR1cmVGb3JtYXQsIGhhc0RlcHRoLCBoYXNTdGVuY2lsKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgICAgIGlmICghaGFzRGVwdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBnbC5TVEVOQ0lMX0lOREVYODtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXQgPSBoYXNTdGVuY2lsID8gZ2wuREVQVEhfU1RFTkNJTCA6IGdsLkRFUFRIX0NPTVBPTkVOVDtcbiAgICAgICAgbGV0IGludGVybmFsRm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICBpZiAodGhpcy53ZWJHTFZlcnNpb24gPiAxKSB7XG4gICAgICAgICAgICBpZiAodGV4dHVyZUZvcm1hdCA9PT0gMTUpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IGdsLkRFUFRIX0NPTVBPTkVOVDE2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dHVyZUZvcm1hdCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IGdsLkRFUFRIX0NPTVBPTkVOVDI0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dHVyZUZvcm1hdCA9PT0gMTcgfHwgdGV4dHVyZUZvcm1hdCA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IGhhc1N0ZW5jaWwgPyBnbC5ERVBUSDI0X1NURU5DSUw4IDogZ2wuREVQVEhfQ09NUE9ORU5UMjQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0dXJlRm9ybWF0ID09PSAxNCkge1xuICAgICAgICAgICAgICAgIGludGVybmFsRm9ybWF0ID0gZ2wuREVQVEhfQ09NUE9ORU5UMzJGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dHVyZUZvcm1hdCA9PT0gMTgpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IGhhc1N0ZW5jaWwgPyBnbC5ERVBUSDMyRl9TVEVOQ0lMOCA6IGdsLkRFUFRIX0NPTVBPTkVOVDMyRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGludGVybmFsRm9ybWF0ID0gZ2wuREVQVEhfQ09NUE9ORU5UMTY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVybmFsRm9ybWF0O1xuICAgIH1cbiAgICBfZ2V0V2ViR0xUZXh0dXJlVHlwZUZyb21EZXB0aFRleHR1cmVGb3JtYXQodGV4dHVyZUZvcm1hdCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICBsZXQgdHlwZSA9IGdsLlVOU0lHTkVEX0lOVDtcbiAgICAgICAgaWYgKHRleHR1cmVGb3JtYXQgPT09IDE1KSB7XG4gICAgICAgICAgICB0eXBlID0gZ2wuVU5TSUdORURfU0hPUlQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dHVyZUZvcm1hdCA9PT0gMTcgfHwgdGV4dHVyZUZvcm1hdCA9PT0gMTMpIHtcbiAgICAgICAgICAgIHR5cGUgPSBnbC5VTlNJR05FRF9JTlRfMjRfODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0dXJlRm9ybWF0ID09PSAxNCkge1xuICAgICAgICAgICAgdHlwZSA9IGdsLkZMT0FUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHR1cmVGb3JtYXQgPT09IDE4KSB7XG4gICAgICAgICAgICB0eXBlID0gZ2wuRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHR1cmVGb3JtYXQgPT09IDE5KSB7XG4gICAgICAgICAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldHVwRnJhbWVidWZmZXJEZXB0aEF0dGFjaG1lbnRzKGdlbmVyYXRlU3RlbmNpbEJ1ZmZlciwgZ2VuZXJhdGVEZXB0aEJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgc2FtcGxlcyA9IDEsIGRlcHRoVGV4dHVyZUZvcm1hdCwgZG9udEJpbmRSZW5kZXJCdWZmZXJUb0ZyYW1lQnVmZmVyID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgZGVwdGhUZXh0dXJlRm9ybWF0ID0gZGVwdGhUZXh0dXJlRm9ybWF0ID8/IChnZW5lcmF0ZVN0ZW5jaWxCdWZmZXIgPyAxMyA6IDE0KTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLl9nZXRJbnRlcm5hbEZvcm1hdEZyb21EZXB0aFRleHR1cmVGb3JtYXQoZGVwdGhUZXh0dXJlRm9ybWF0LCBnZW5lcmF0ZURlcHRoQnVmZmVyLCBnZW5lcmF0ZVN0ZW5jaWxCdWZmZXIpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGRlcHRoL3N0ZW5jaWwgYnVmZmVyXG4gICAgICAgIGlmIChnZW5lcmF0ZVN0ZW5jaWxCdWZmZXIgJiYgZ2VuZXJhdGVEZXB0aEJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVJlbmRlckJ1ZmZlcih3aWR0aCwgaGVpZ2h0LCBzYW1wbGVzLCBnbC5ERVBUSF9TVEVOQ0lMLCBpbnRlcm5hbEZvcm1hdCwgZG9udEJpbmRSZW5kZXJCdWZmZXJUb0ZyYW1lQnVmZmVyID8gLTEgOiBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5lcmF0ZURlcHRoQnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlUmVuZGVyQnVmZmVyKHdpZHRoLCBoZWlnaHQsIHNhbXBsZXMsIGludGVybmFsRm9ybWF0LCBpbnRlcm5hbEZvcm1hdCwgZG9udEJpbmRSZW5kZXJCdWZmZXJUb0ZyYW1lQnVmZmVyID8gLTEgOiBnbC5ERVBUSF9BVFRBQ0hNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2VuZXJhdGVTdGVuY2lsQnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlUmVuZGVyQnVmZmVyKHdpZHRoLCBoZWlnaHQsIHNhbXBsZXMsIGludGVybmFsRm9ybWF0LCBpbnRlcm5hbEZvcm1hdCwgZG9udEJpbmRSZW5kZXJCdWZmZXJUb0ZyYW1lQnVmZmVyID8gLTEgOiBnbC5TVEVOQ0lMX0FUVEFDSE1FTlQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfY3JlYXRlUmVuZGVyQnVmZmVyKHdpZHRoLCBoZWlnaHQsIHNhbXBsZXMsIGludGVybmFsRm9ybWF0LCBtc0ludGVybmFsRm9ybWF0LCBhdHRhY2htZW50LCB1bmJpbmRCdWZmZXIgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgICAgIGNvbnN0IHJlbmRlckJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlUmVuZGVyQnVmZmVyKHJlbmRlckJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgc2FtcGxlcywgaW50ZXJuYWxGb3JtYXQsIG1zSW50ZXJuYWxGb3JtYXQsIGF0dGFjaG1lbnQsIHVuYmluZEJ1ZmZlcik7XG4gICAgfVxuICAgIF91cGRhdGVSZW5kZXJCdWZmZXIocmVuZGVyQnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBzYW1wbGVzLCBpbnRlcm5hbEZvcm1hdCwgbXNJbnRlcm5hbEZvcm1hdCwgYXR0YWNobWVudCwgdW5iaW5kQnVmZmVyID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyQnVmZmVyKTtcbiAgICAgICAgaWYgKHNhbXBsZXMgPiAxICYmIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSkge1xuICAgICAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgbXNJbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRhY2htZW50ICE9PSAtMSkge1xuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnQsIGdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5iaW5kQnVmZmVyKSB7XG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlckJ1ZmZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3JlbGVhc2VUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fZGVsZXRlVGV4dHVyZSh0ZXh0dXJlLl9oYXJkd2FyZVRleHR1cmUpO1xuICAgICAgICAvLyBVbmJpbmQgY2hhbm5lbHNcbiAgICAgICAgdGhpcy51bmJpbmRBbGxUZXh0dXJlcygpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2ludGVybmFsVGV4dHVyZXNDYWNoZS5pbmRleE9mKHRleHR1cmUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbFRleHR1cmVzQ2FjaGUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnRlZ3JhdGVkIGZpeGVkIGxvZCBzYW1wbGVycy5cbiAgICAgICAgaWYgKHRleHR1cmUuX2xvZFRleHR1cmVIaWdoKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLl9sb2RUZXh0dXJlSGlnaC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHR1cmUuX2xvZFRleHR1cmVNaWQpIHtcbiAgICAgICAgICAgIHRleHR1cmUuX2xvZFRleHR1cmVNaWQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0dXJlLl9sb2RUZXh0dXJlTG93KSB7XG4gICAgICAgICAgICB0ZXh0dXJlLl9sb2RUZXh0dXJlTG93LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnRlZ3JhdGVkIGlycmFkaWFuY2UgbWFwLlxuICAgICAgICBpZiAodGV4dHVyZS5faXJyYWRpYW5jZVRleHR1cmUpIHtcbiAgICAgICAgICAgIHRleHR1cmUuX2lycmFkaWFuY2VUZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgICAgIHRleHR1cmU/LnJlbGVhc2UoKTtcbiAgICB9XG4gICAgX3NldFByb2dyYW0ocHJvZ3JhbSkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudFByb2dyYW0gIT09IHByb2dyYW0pIHtcbiAgICAgICAgICAgIF9zZXRQcm9ncmFtKHByb2dyYW0sIHRoaXMuX2dsKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kcyBhbiBlZmZlY3QgdG8gdGhlIHdlYkdMIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZWZmZWN0IGRlZmluZXMgdGhlIGVmZmVjdCB0byBiaW5kXG4gICAgICovXG4gICAgYmluZFNhbXBsZXJzKGVmZmVjdCkge1xuICAgICAgICBjb25zdCB3ZWJHTFBpcGVsaW5lQ29udGV4dCA9IGVmZmVjdC5nZXRQaXBlbGluZUNvbnRleHQoKTtcbiAgICAgICAgdGhpcy5fc2V0UHJvZ3JhbSh3ZWJHTFBpcGVsaW5lQ29udGV4dC5wcm9ncmFtKTtcbiAgICAgICAgY29uc3Qgc2FtcGxlcnMgPSBlZmZlY3QuZ2V0U2FtcGxlcnMoKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHNhbXBsZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgdW5pZm9ybSA9IGVmZmVjdC5nZXRVbmlmb3JtKHNhbXBsZXJzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAodW5pZm9ybSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kVW5pZm9ybXNbaW5kZXhdID0gdW5pZm9ybTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50RWZmZWN0ID0gbnVsbDtcbiAgICB9XG4gICAgX2FjdGl2YXRlQ3VycmVudFRleHR1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGV4dHVyZUNoYW5uZWwgIT09IHRoaXMuX2FjdGl2ZUNoYW5uZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLmFjdGl2ZVRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRTAgKyB0aGlzLl9hY3RpdmVDaGFubmVsKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUZXh0dXJlQ2hhbm5lbCA9IHRoaXMuX2FjdGl2ZUNoYW5uZWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2JpbmRUZXh0dXJlRGlyZWN0bHkodGFyZ2V0LCB0ZXh0dXJlLCBmb3JUZXh0dXJlRGF0YVVwZGF0ZSA9IGZhbHNlLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB3YXNQcmV2aW91c2x5Qm91bmQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgaXNUZXh0dXJlRm9yUmVuZGVyaW5nID0gdGV4dHVyZSAmJiB0ZXh0dXJlLl9hc3NvY2lhdGVkQ2hhbm5lbCA+IC0xO1xuICAgICAgICBpZiAoZm9yVGV4dHVyZURhdGFVcGRhdGUgJiYgaXNUZXh0dXJlRm9yUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVDaGFubmVsID0gdGV4dHVyZS5fYXNzb2NpYXRlZENoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFRleHR1cmVCb3VuZCA9IHRoaXMuX2JvdW5kVGV4dHVyZXNDYWNoZVt0aGlzLl9hY3RpdmVDaGFubmVsXTtcbiAgICAgICAgaWYgKGN1cnJlbnRUZXh0dXJlQm91bmQgIT09IHRleHR1cmUgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlQ3VycmVudFRleHR1cmUoKTtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlICYmIHRleHR1cmUuaXNNdWx0aXZpZXcpIHtcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2dsLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4dHVyZSA/IHRleHR1cmUuX2NvbG9yVGV4dHVyZUFycmF5IDogbnVsbCk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFtcIl9iaW5kVGV4dHVyZURpcmVjdGx5IGNhbGxlZCB3aXRoIGEgbXVsdGl2aWV3IHRleHR1cmUhXCIsIHRhcmdldCwgdGV4dHVyZV0pO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJfYmluZFRleHR1cmVEaXJlY3RseSBjYWxsZWQgd2l0aCBhIG11bHRpdmlldyB0ZXh0dXJlIVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXh0dXJlPy5faGFyZHdhcmVUZXh0dXJlPy51bmRlcmx5aW5nUmVzb3VyY2UgPz8gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ib3VuZFRleHR1cmVzQ2FjaGVbdGhpcy5fYWN0aXZlQ2hhbm5lbF0gPSB0ZXh0dXJlO1xuICAgICAgICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLl9hc3NvY2lhdGVkQ2hhbm5lbCA9IHRoaXMuX2FjdGl2ZUNoYW5uZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9yVGV4dHVyZURhdGFVcGRhdGUpIHtcbiAgICAgICAgICAgIHdhc1ByZXZpb3VzbHlCb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZUN1cnJlbnRUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dHVyZUZvclJlbmRlcmluZyAmJiAhZm9yVGV4dHVyZURhdGFVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRTYW1wbGVyVW5pZm9ybVRvQ2hhbm5lbCh0ZXh0dXJlLl9hc3NvY2lhdGVkQ2hhbm5lbCwgdGhpcy5fYWN0aXZlQ2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhc1ByZXZpb3VzbHlCb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2JpbmRUZXh0dXJlKGNoYW5uZWwsIHRleHR1cmUsIG5hbWUpIHtcbiAgICAgICAgaWYgKGNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLl9hc3NvY2lhdGVkQ2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWN0aXZlQ2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRleHR1cmUgPyB0aGlzLl9nZXRUZXh0dXJlVGFyZ2V0KHRleHR1cmUpIDogdGhpcy5fZ2wuVEVYVFVSRV8yRDtcbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0YXJnZXQsIHRleHR1cmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgYWxsIHRleHR1cmVzIGZyb20gdGhlIHdlYkdMIGNvbnRleHRcbiAgICAgKi9cbiAgICB1bmJpbmRBbGxUZXh0dXJlcygpIHtcbiAgICAgICAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCB0aGlzLl9tYXhTaW11bHRhbmVvdXNUZXh0dXJlczsgY2hhbm5lbCsrKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVDaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KHRoaXMuX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuICAgICAgICAgICAgaWYgKHRoaXMud2ViR0xWZXJzaW9uID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGhpcy5fZ2wuVEVYVFVSRV8zRCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0aGlzLl9nbC5URVhUVVJFXzJEX0FSUkFZLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdGV4dHVyZSB0byB0aGUgYWNjb3JkaW5nIHVuaWZvcm0uXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIHRleHR1cmUgY2hhbm5lbFxuICAgICAqIEBwYXJhbSB1bmlmb3JtIFRoZSB1bmlmb3JtIHRvIHNldFxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIFRoZSB0ZXh0dXJlIHRvIGFwcGx5XG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHVuaWZvcm0gaW4gdGhlIGVmZmVjdFxuICAgICAqL1xuICAgIHNldFRleHR1cmUoY2hhbm5lbCwgdW5pZm9ybSwgdGV4dHVyZSwgbmFtZSkge1xuICAgICAgICBpZiAoY2hhbm5lbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaWZvcm0pIHtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kVW5pZm9ybXNbY2hhbm5lbF0gPSB1bmlmb3JtO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFRleHR1cmUoY2hhbm5lbCwgdGV4dHVyZSk7XG4gICAgfVxuICAgIF9iaW5kU2FtcGxlclVuaWZvcm1Ub0NoYW5uZWwoc291cmNlU2xvdCwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgY29uc3QgdW5pZm9ybSA9IHRoaXMuX2JvdW5kVW5pZm9ybXNbc291cmNlU2xvdF07XG4gICAgICAgIGlmICghdW5pZm9ybSB8fCB1bmlmb3JtLl9jdXJyZW50U3RhdGUgPT09IGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTFpKHVuaWZvcm0sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdW5pZm9ybS5fY3VycmVudFN0YXRlID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIF9nZXRUZXh0dXJlV3JhcE1vZGUobW9kZSkge1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkVQRUFUO1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5DTEFNUF9UT19FREdFO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5NSVJST1JFRF9SRVBFQVQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJFUEVBVDtcbiAgICB9XG4gICAgX3NldFRleHR1cmUoY2hhbm5lbCwgdGV4dHVyZSwgaXNQYXJ0T2ZUZXh0dXJlQXJyYXkgPSBmYWxzZSwgZGVwdGhTdGVuY2lsVGV4dHVyZSA9IGZhbHNlLCBuYW1lID0gXCJcIikge1xuICAgICAgICAvLyBOb3QgcmVhZHk/XG4gICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2JvdW5kVGV4dHVyZXNDYWNoZVtjaGFubmVsXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlQ2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0aGlzLl9nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZURpcmVjdGx5KHRoaXMuX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLndlYkdMVmVyc2lvbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0aGlzLl9nbC5URVhUVVJFXzNELCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0aGlzLl9nbC5URVhUVVJFXzJEX0FSUkFZLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmlkZW9cbiAgICAgICAgaWYgKHRleHR1cmUudmlkZW8pIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZUNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICAgICAgY29uc3QgdmlkZW9JbnRlcm5hbFRleHR1cmUgPSB0ZXh0dXJlLmdldEludGVybmFsVGV4dHVyZSgpO1xuICAgICAgICAgICAgaWYgKHZpZGVvSW50ZXJuYWxUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9JbnRlcm5hbFRleHR1cmUuX2Fzc29jaWF0ZWRDaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHR1cmUudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dHVyZS5kZWxheUxvYWRTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgLy8gRGVsYXkgbG9hZGluZ1xuICAgICAgICAgICAgdGV4dHVyZS5kZWxheUxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW50ZXJuYWxUZXh0dXJlO1xuICAgICAgICBpZiAoZGVwdGhTdGVuY2lsVGV4dHVyZSkge1xuICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlID0gdGV4dHVyZS5kZXB0aFN0ZW5jaWxUZXh0dXJlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHR1cmUuaXNSZWFkeSgpKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUgPSB0ZXh0dXJlLmdldEludGVybmFsVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHR1cmUuaXNDdWJlKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUgPSB0aGlzLmVtcHR5Q3ViZVRleHR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dHVyZS5pczNEKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUgPSB0aGlzLmVtcHR5VGV4dHVyZTNEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHR1cmUuaXMyREFycmF5KSB7XG4gICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUgPSB0aGlzLmVtcHR5VGV4dHVyZTJEQXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUgPSB0aGlzLmVtcHR5VGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUGFydE9mVGV4dHVyZUFycmF5ICYmIGludGVybmFsVGV4dHVyZSkge1xuICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlLl9hc3NvY2lhdGVkQ2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5lZWRUb0JpbmQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fYm91bmRUZXh0dXJlc0NhY2hlW2NoYW5uZWxdID09PSBpbnRlcm5hbFRleHR1cmUpIHtcbiAgICAgICAgICAgIGlmICghaXNQYXJ0T2ZUZXh0dXJlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kU2FtcGxlclVuaWZvcm1Ub0NoYW5uZWwoaW50ZXJuYWxUZXh0dXJlLl9hc3NvY2lhdGVkQ2hhbm5lbCwgY2hhbm5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZWVkVG9CaW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWN0aXZlQ2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2dldFRleHR1cmVUYXJnZXQoaW50ZXJuYWxUZXh0dXJlKTtcbiAgICAgICAgaWYgKG5lZWRUb0JpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGFyZ2V0LCBpbnRlcm5hbFRleHR1cmUsIGlzUGFydE9mVGV4dHVyZUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJuYWxUZXh0dXJlICYmICFpbnRlcm5hbFRleHR1cmUuaXNNdWx0aXZpZXcpIHtcbiAgICAgICAgICAgIC8vIENVQklDX01PREUgYW5kIFNLWUJPWF9NT0RFIGJvdGggcmVxdWlyZSBDTEFNUF9UT19FREdFLiAgQWxsIG90aGVyIG1vZGVzIHVzZSBSRVBFQVQuXG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxUZXh0dXJlLmlzQ3ViZSAmJiBpbnRlcm5hbFRleHR1cmUuX2NhY2hlZENvb3JkaW5hdGVzTW9kZSAhPT0gdGV4dHVyZS5jb29yZGluYXRlc01vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUuX2NhY2hlZENvb3JkaW5hdGVzTW9kZSA9IHRleHR1cmUuY29vcmRpbmF0ZXNNb2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVXcmFwTW9kZSA9IHRleHR1cmUuY29vcmRpbmF0ZXNNb2RlICE9PSAzICYmIHRleHR1cmUuY29vcmRpbmF0ZXNNb2RlICE9PSA1XG4gICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS53cmFwVSA9IHRleHR1cmVXcmFwTW9kZTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLndyYXBWID0gdGV4dHVyZVdyYXBNb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGludGVybmFsVGV4dHVyZS5fY2FjaGVkV3JhcFUgIT09IHRleHR1cmUud3JhcFUpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUuX2NhY2hlZFdyYXBVID0gdGV4dHVyZS53cmFwVTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRUZXh0dXJlUGFyYW1ldGVySW50ZWdlcih0YXJnZXQsIHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl9nZXRUZXh0dXJlV3JhcE1vZGUodGV4dHVyZS53cmFwVSksIGludGVybmFsVGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxUZXh0dXJlLl9jYWNoZWRXcmFwViAhPT0gdGV4dHVyZS53cmFwVikge1xuICAgICAgICAgICAgICAgIGludGVybmFsVGV4dHVyZS5fY2FjaGVkV3JhcFYgPSB0ZXh0dXJlLndyYXBWO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFRleHR1cmVQYXJhbWV0ZXJJbnRlZ2VyKHRhcmdldCwgdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX2dldFRleHR1cmVXcmFwTW9kZSh0ZXh0dXJlLndyYXBWKSwgaW50ZXJuYWxUZXh0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnRlcm5hbFRleHR1cmUuaXMzRCAmJiBpbnRlcm5hbFRleHR1cmUuX2NhY2hlZFdyYXBSICE9PSB0ZXh0dXJlLndyYXBSKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlLl9jYWNoZWRXcmFwUiA9IHRleHR1cmUud3JhcFI7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VGV4dHVyZVBhcmFtZXRlckludGVnZXIodGFyZ2V0LCB0aGlzLl9nbC5URVhUVVJFX1dSQVBfUiwgdGhpcy5fZ2V0VGV4dHVyZVdyYXBNb2RlKHRleHR1cmUud3JhcFIpLCBpbnRlcm5hbFRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0QW5pc290cm9waWNMZXZlbCh0YXJnZXQsIGludGVybmFsVGV4dHVyZSwgdGV4dHVyZS5hbmlzb3Ryb3BpY0ZpbHRlcmluZ0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBhcnJheSBvZiB0ZXh0dXJlIHRvIHRoZSB3ZWJHTCBjb250ZXh0XG4gICAgICogQHBhcmFtIGNoYW5uZWwgZGVmaW5lcyB0aGUgY2hhbm5lbCB3aGVyZSB0aGUgdGV4dHVyZSBhcnJheSBtdXN0IGJlIHNldFxuICAgICAqIEBwYXJhbSB1bmlmb3JtIGRlZmluZXMgdGhlIGFzc29jaWF0ZWQgdW5pZm9ybSBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB0ZXh0dXJlcyBkZWZpbmVzIHRoZSBhcnJheSBvZiB0ZXh0dXJlcyB0byBiaW5kXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHNldFRleHR1cmVBcnJheShjaGFubmVsLCB1bmlmb3JtLCB0ZXh0dXJlcywgbmFtZSkge1xuICAgICAgICBpZiAoY2hhbm5lbCA9PT0gdW5kZWZpbmVkIHx8ICF1bmlmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlVW5pdHMgfHwgdGhpcy5fdGV4dHVyZVVuaXRzLmxlbmd0aCAhPT0gdGV4dHVyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlVW5pdHMgPSBuZXcgSW50MzJBcnJheSh0ZXh0dXJlcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSB0ZXh0dXJlc1tpXS5nZXRJbnRlcm5hbFRleHR1cmUoKTtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZVVuaXRzW2ldID0gY2hhbm5lbCArIGk7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5fYXNzb2NpYXRlZENoYW5uZWwgPSBjaGFubmVsICsgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmVVbml0c1tpXSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm0xaXYodW5pZm9ybSwgdGhpcy5fdGV4dHVyZVVuaXRzKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRleHR1cmVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdGhpcy5fc2V0VGV4dHVyZSh0aGlzLl90ZXh0dXJlVW5pdHNbaW5kZXhdLCB0ZXh0dXJlc1tpbmRleF0sIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9zZXRBbmlzb3Ryb3BpY0xldmVsKHRhcmdldCwgaW50ZXJuYWxUZXh0dXJlLCBhbmlzb3Ryb3BpY0ZpbHRlcmluZ0xldmVsKSB7XG4gICAgICAgIGNvbnN0IGFuaXNvdHJvcGljRmlsdGVyRXh0ZW5zaW9uID0gdGhpcy5fY2Fwcy50ZXh0dXJlQW5pc290cm9waWNGaWx0ZXJFeHRlbnNpb247XG4gICAgICAgIGlmIChpbnRlcm5hbFRleHR1cmUuc2FtcGxpbmdNb2RlICE9PSAxMSAmJlxuICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlLnNhbXBsaW5nTW9kZSAhPT0gMyAmJlxuICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlLnNhbXBsaW5nTW9kZSAhPT0gMikge1xuICAgICAgICAgICAgYW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCA9IDE7IC8vIEZvcmNpbmcgdGhlIGFuaXNvdHJvcGljIHRvIDEgYmVjYXVzZSBlbHNlIHdlYmdsIHdpbGwgZm9yY2UgZmlsdGVycyB0byBsaW5lYXJcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pc290cm9waWNGaWx0ZXJFeHRlbnNpb24gJiYgaW50ZXJuYWxUZXh0dXJlLl9jYWNoZWRBbmlzb3Ryb3BpY0ZpbHRlcmluZ0xldmVsICE9PSBhbmlzb3Ryb3BpY0ZpbHRlcmluZ0xldmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRUZXh0dXJlUGFyYW1ldGVyRmxvYXQodGFyZ2V0LCBhbmlzb3Ryb3BpY0ZpbHRlckV4dGVuc2lvbi5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4oYW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCwgdGhpcy5fY2Fwcy5tYXhBbmlzb3Ryb3B5KSwgaW50ZXJuYWxUZXh0dXJlKTtcbiAgICAgICAgICAgIGludGVybmFsVGV4dHVyZS5fY2FjaGVkQW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCA9IGFuaXNvdHJvcGljRmlsdGVyaW5nTGV2ZWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NldFRleHR1cmVQYXJhbWV0ZXJGbG9hdCh0YXJnZXQsIHBhcmFtZXRlciwgdmFsdWUsIHRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fYmluZFRleHR1cmVEaXJlY3RseSh0YXJnZXQsIHRleHR1cmUsIHRydWUsIHRydWUpO1xuICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJmKHRhcmdldCwgcGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIF9zZXRUZXh0dXJlUGFyYW1ldGVySW50ZWdlcih0YXJnZXQsIHBhcmFtZXRlciwgdmFsdWUsIHRleHR1cmUpIHtcbiAgICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGFyZ2V0LCB0ZXh0dXJlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgcGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuYmluZCBhbGwgdmVydGV4IGF0dHJpYnV0ZXMgZnJvbSB0aGUgd2ViR0wgY29udGV4dFxuICAgICAqL1xuICAgIHVuYmluZEFsbEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tdXN0V2lwZVZlcnRleEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX211c3RXaXBlVmVydGV4QXR0cmlidXRlcyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jYXBzLm1heFZlcnRleEF0dHJpYnM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZUF0dHJpYnV0ZUJ5SW5kZXgoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHVsID0gdGhpcy5fdmVydGV4QXR0cmliQXJyYXlzRW5hYmxlZC5sZW5ndGg7IGkgPCB1bDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSB0aGlzLl9jYXBzLm1heFZlcnRleEF0dHJpYnMgfHwgIXRoaXMuX3ZlcnRleEF0dHJpYkFycmF5c0VuYWJsZWRbaV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUF0dHJpYnV0ZUJ5SW5kZXgoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yY2UgdGhlIGVuZ2luZSB0byByZWxlYXNlIGFsbCBjYWNoZWQgZWZmZWN0cy4gVGhpcyBtZWFucyB0aGF0IG5leHQgZWZmZWN0IGNvbXBpbGF0aW9uIHdpbGwgaGF2ZSB0byBiZSBkb25lIGNvbXBsZXRlbHkgZXZlbiBpZiBhIHNpbWlsYXIgZWZmZWN0IHdhcyBhbHJlYWR5IGNvbXBpbGVkXG4gICAgICovXG4gICAgcmVsZWFzZUVmZmVjdHMoKSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkRWZmZWN0cyA9IHt9O1xuICAgICAgICB0aGlzLm9uUmVsZWFzZUVmZmVjdHNPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBhbmQgcmVsZWFzZSBhbGwgYXNzb2NpYXRlZCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICAvLyBFdmVudHNcbiAgICAgICAgaWYgKElzV2luZG93T2JqZWN0RXhpc3QoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmluZ0NhbnZhcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmluZ0NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLCB0aGlzLl9vbkNvbnRleHRMb3N0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25Db250ZXh0UmVzdG9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyaW5nQ2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCB0aGlzLl9vbkNvbnRleHRSZXN0b3JlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNob3VsZCBub3QgYmUgbW92ZWQgdXAgb2YgcmVuZGVyaW5nQ2FudmFzIHdpbGwgYmUgbnVsbC5cbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5fZHVtbXlGcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5fZHVtbXlGcmFtZWJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5iaW5kXG4gICAgICAgIHRoaXMudW5iaW5kQWxsQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLl9ib3VuZFVuaWZvcm1zID0ge307XG4gICAgICAgIHRoaXMuX3dvcmtpbmdDYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLl93b3JraW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCdWZmZXJQb2ludGVycy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9jdXJyZW50UHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9jcmVhdGlvbk9wdGlvbnMubG9zZUNvbnRleHRPbkRpc3Bvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKT8ubG9zZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbGVhciB0aGUgc3RhdGUgb2JqZWN0XG4gICAgICAgIGRlbGV0ZVN0YXRlT2JqZWN0KHRoaXMuX2dsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgbmV3IGNhbGxiYWNrIHJhaXNlZCB3aGVuIGNvbnRleHQgbG9zdCBldmVudCBpcyBmaXJlZFxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBkZWZpbmVzIHRoZSBjYWxsYmFjayB0byBjYWxsXG4gICAgICovXG4gICAgYXR0YWNoQ29udGV4dExvc3RFdmVudChjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyaW5nQ2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJpbmdDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSBuZXcgY2FsbGJhY2sgcmFpc2VkIHdoZW4gY29udGV4dCByZXN0b3JlZCBldmVudCBpcyBmaXJlZFxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBkZWZpbmVzIHRoZSBjYWxsYmFjayB0byBjYWxsXG4gICAgICovXG4gICAgYXR0YWNoQ29udGV4dFJlc3RvcmVkRXZlbnQoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmluZ0NhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyaW5nQ2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBlcnJvciBjb2RlIG9mIHRoZSB3ZWJHTCBjb250ZXh0XG4gICAgICogQHJldHVybnMgdGhlIGVycm9yIGNvZGVcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJHTFJlbmRlcmluZ0NvbnRleHQvZ2V0RXJyb3JcbiAgICAgKi9cbiAgICBnZXRFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsLmdldEVycm9yKCk7XG4gICAgfVxuICAgIF9jYW5SZW5kZXJUb0Zsb2F0RnJhbWVidWZmZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWJHTFZlcnNpb24gPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2Fwcy5jb2xvckJ1ZmZlckZsb2F0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5SZW5kZXJUb0ZyYW1lYnVmZmVyKDEpO1xuICAgIH1cbiAgICBfY2FuUmVuZGVyVG9IYWxmRmxvYXRGcmFtZWJ1ZmZlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlYkdMVmVyc2lvbiA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXBzLmNvbG9yQnVmZmVyRmxvYXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhblJlbmRlclRvRnJhbWVidWZmZXIoMik7XG4gICAgfVxuICAgIC8vIFRoYW5rIHlvdSA6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjg4Mjc1MTEvd2ViZ2wtaW9zLXJlbmRlci10by1mbG9hdGluZy1wb2ludC10ZXh0dXJlXG4gICAgX2NhblJlbmRlclRvRnJhbWVidWZmZXIodHlwZSkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgICAgICAvL2NsZWFyIGV4aXN0aW5nIGVycm9yc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgd2hpbGUgKGdsLmdldEVycm9yKCkgIT09IGdsLk5PX0VSUk9SKSB7IH1cbiAgICAgICAgbGV0IHN1Y2Nlc3NmdWwgPSB0cnVlO1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLl9nZXRSR0JBQnVmZmVySW50ZXJuYWxTaXplZEZvcm1hdCh0eXBlKSwgMSwgMSwgMCwgZ2wuUkdCQSwgdGhpcy5fZ2V0V2ViR0xUZXh0dXJlVHlwZSh0eXBlKSwgbnVsbCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICBjb25zdCBmYiA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmIpO1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcbiAgICAgICAgc3VjY2Vzc2Z1bCA9IHN1Y2Nlc3NmdWwgJiYgc3RhdHVzID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURTtcbiAgICAgICAgc3VjY2Vzc2Z1bCA9IHN1Y2Nlc3NmdWwgJiYgZ2wuZ2V0RXJyb3IoKSA9PT0gZ2wuTk9fRVJST1I7XG4gICAgICAgIC8vdHJ5IHJlbmRlciBieSBjbGVhcmluZyBmcmFtZSBidWZmZXIncyBjb2xvciBidWZmZXJcbiAgICAgICAgaWYgKHN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgc3VjY2Vzc2Z1bCA9IHN1Y2Nlc3NmdWwgJiYgZ2wuZ2V0RXJyb3IoKSA9PT0gZ2wuTk9fRVJST1I7XG4gICAgICAgIH1cbiAgICAgICAgLy90cnkgcmVhZGluZyBmcm9tIGZyYW1lIHRvIGVuc3VyZSByZW5kZXIgb2NjdXJzIChqdXN0IGNyZWF0aW5nIHRoZSBGQk8gaXMgbm90IHN1ZmZpY2llbnQgdG8gZGV0ZXJtaW5lIGlmIHJlbmRlcmluZyBpcyBzdXBwb3J0ZWQpXG4gICAgICAgIGlmIChzdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICAvL2luIHByYWN0aWNlIGl0J3Mgc3VmZmljaWVudCB0byBqdXN0IHJlYWQgZnJvbSB0aGUgYmFja2J1ZmZlciByYXRoZXIgdGhhbiBoYW5kbGUgcG90ZW50aWFsbHkgaXNzdWVzIHJlYWRpbmcgZnJvbSB0aGUgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRGb3JtYXQgPSBnbC5SR0JBO1xuICAgICAgICAgICAgY29uc3QgcmVhZFR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIDEsIDEsIHJlYWRGb3JtYXQsIHJlYWRUeXBlLCBidWZmZXIpO1xuICAgICAgICAgICAgc3VjY2Vzc2Z1bCA9IHN1Y2Nlc3NmdWwgJiYgZ2wuZ2V0RXJyb3IoKSA9PT0gZ2wuTk9fRVJST1I7XG4gICAgICAgIH1cbiAgICAgICAgLy9jbGVhbiB1cFxuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmYik7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIC8vY2xlYXIgYWNjdW11bGF0ZWQgZXJyb3JzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICB3aGlsZSAoIXN1Y2Nlc3NmdWwgJiYgZ2wuZ2V0RXJyb3IoKSAhPT0gZ2wuTk9fRVJST1IpIHsgfVxuICAgICAgICByZXR1cm4gc3VjY2Vzc2Z1bDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2dldFdlYkdMVGV4dHVyZVR5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fd2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5GTE9BVDtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5IQUxGX0ZMT0FUX09FUztcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5VTlNJR05FRF9CWVRFO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuVU5TSUdORURfQllURTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuQllURTtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuVU5TSUdORURfQllURTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuU0hPUlQ7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlVOU0lHTkVEX1NIT1JUO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5JTlQ7XG4gICAgICAgICAgICBjYXNlIDc6IC8vIFJlZmVycyB0byBVTlNJR05FRF9JTlRcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuVU5TSUdORURfSU5UO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5GTE9BVDtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuSEFMRl9GTE9BVDtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlVOU0lHTkVEX1NIT1JUXzVfNl81O1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuVU5TSUdORURfSU5UXzI0Xzg7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5VTlNJR05FRF9JTlRfMTBGXzExRl8xMUZfUkVWO1xuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuVU5TSUdORURfSU5UXzVfOV85XzlfUkVWO1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nbC5VTlNJR05FRF9CWVRFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfZ2V0SW50ZXJuYWxGb3JtYXQoZm9ybWF0LCB1c2VTUkdCQnVmZmVyID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGludGVybmFsRm9ybWF0ID0gdXNlU1JHQkJ1ZmZlciA/IHRoaXMuX2dsU1JHQkV4dGVuc2lvblZhbHVlcy5TUkdCOF9BTFBIQTggOiB0aGlzLl9nbC5SR0JBO1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5fZ2wuQUxQSEE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLl9nbC5MVU1JTkFOQ0U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLl9nbC5MVU1JTkFOQ0VfQUxQSEE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIDMzMzIyOlxuICAgICAgICAgICAgY2FzZSAzNjc2MDpcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuX2dsLlJFRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgMzMzMjQ6XG4gICAgICAgICAgICBjYXNlIDM2NzYxOlxuICAgICAgICAgICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5fZ2wuUkc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBjYXNlIDMyODUyOlxuICAgICAgICAgICAgY2FzZSAzNjc2MjpcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IHVzZVNSR0JCdWZmZXIgPyB0aGlzLl9nbFNSR0JFeHRlbnNpb25WYWx1ZXMuU1JHQiA6IHRoaXMuX2dsLlJHQjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGNhc2UgMzI4NTk6XG4gICAgICAgICAgICBjYXNlIDM2NzYzOlxuICAgICAgICAgICAgICAgIGludGVybmFsRm9ybWF0ID0gdXNlU1JHQkJ1ZmZlciA/IHRoaXMuX2dsU1JHQkV4dGVuc2lvblZhbHVlcy5TUkdCOF9BTFBIQTggOiB0aGlzLl9nbC5SR0JBO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl93ZWJHTFZlcnNpb24gPiAxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLl9nbC5SRURfSU5URUdFUjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuX2dsLlJHX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5fZ2wuUkdCX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5fZ2wuUkdCQV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJuYWxGb3JtYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9nZXRSR0JBQnVmZmVySW50ZXJuYWxTaXplZEZvcm1hdCh0eXBlLCBmb3JtYXQsIHVzZVNSR0JCdWZmZXIgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fd2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5MVU1JTkFOQ0U7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5MVU1JTkFOQ0VfQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VTUkdCQnVmZmVyID8gdGhpcy5fZ2xTUkdCRXh0ZW5zaW9uVmFsdWVzLlNSR0IgOiB0aGlzLl9nbC5SR0I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQkE7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlI4X1NOT1JNO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkc4X1NOT1JNO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCOF9TTk9STTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlI4STtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHOEk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCOEk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCQThJO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQkE4X1NOT1JNO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUjg7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SRzg7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VTUkdCQnVmZmVyID8gdGhpcy5fZ2xTUkdCRXh0ZW5zaW9uVmFsdWVzLlNSR0I4IDogdGhpcy5fZ2wuUkdCODsgLy8gQnkgZGVmYXVsdC4gT3RoZXIgcG9zc2liaWxpdGllcyBhcmUgUkdCNTY1LCBTUkdCOC5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZVNSR0JCdWZmZXIgPyB0aGlzLl9nbFNSR0JFeHRlbnNpb25WYWx1ZXMuU1JHQjhfQUxQSEE4IDogdGhpcy5fZ2wuUkdCQTg7IC8vIEJ5IGRlZmF1bHQuIE90aGVyIHBvc3NpYmlsaXRpZXMgYXJlIFJHQjVfQTEsIFJHQkE0LCBTUkdCOF9BTFBIQTguXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SOFVJO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkc4VUk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCOFVJO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQkE4VUk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLkxVTUlOQU5DRTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLkxVTUlOQU5DRV9BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0JBODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlIxNkk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzY3NjA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUjE2X1NOT1JNX0VYVDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNjc2MTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SRzE2X1NOT1JNX0VYVDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNjc2MjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0IxNl9TTk9STV9FWFQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzY3NjM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCQTE2X1NOT1JNX0VYVDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHMTZJO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQjE2STtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0JBMTZJO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQkExNkk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SMTZVSTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzMzMyMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SMTZfRVhUO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDMzMzI0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHMTZfRVhUO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDMyODUyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQjE2X0VYVDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzMjg1OTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0JBMTZfRVhUO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkcxNlVJO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQjE2VUk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCQTE2VUk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCQTE2VUk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SMzJJO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkczMkk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCMzJJO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQkEzMkk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCQTMySTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDc6IC8vIFJlZmVycyB0byBVTlNJR05FRF9JTlRcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUjMyVUk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SRzMyVUk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCMzJVSTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0JBMzJVSTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0JBMzJVSTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlIzMkY7IC8vIEJ5IGRlZmF1bHQuIE90aGVyIHBvc3NpYmlsaXR5IGlzIFIxNkYuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SRzMyRjsgLy8gQnkgZGVmYXVsdC4gT3RoZXIgcG9zc2liaWxpdHkgaXMgUkcxNkYuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0IzMkY7IC8vIEJ5IGRlZmF1bHQuIE90aGVyIHBvc3NpYmlsaXRpZXMgYXJlIFJHQjE2RiwgUjExRl9HMTFGX0IxMEYsIFJHQjlfRTUuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0JBMzJGOyAvLyBCeSBkZWZhdWx0LiBPdGhlciBwb3NzaWJpbGl0eSBpcyBSR0JBMTZGLlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQkEzMkY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SMTZGO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkcxNkY7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0IxNkY7IC8vIEJ5IGRlZmF1bHQuIE90aGVyIHBvc3NpYmlsaXRpZXMgYXJlIFIxMUZfRzExRl9CMTBGLCBSR0I5X0U1LlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCQTE2RjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0JBMTZGO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQjU2NTtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlIxMUZfRzExRl9CMTBGO1xuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCOV9FNTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2wuUkdCQTQ7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQjVfQTE7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0IxMF9BMjsgLy8gQnkgZGVmYXVsdC4gT3RoZXIgcG9zc2liaWxpdHkgaXMgUkdCNV9BMS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nbC5SR0IxMF9BMlVJO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dsLlJHQjEwX0EyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXNlU1JHQkJ1ZmZlciA/IHRoaXMuX2dsU1JHQkV4dGVuc2lvblZhbHVlcy5TUkdCOF9BTFBIQTggOiB0aGlzLl9nbC5SR0JBODtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgcGl4ZWxzIGZyb20gdGhlIGN1cnJlbnQgZnJhbWUgYnVmZmVyLiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIGJlIHNsb3dcbiAgICAgKiBAcGFyYW0geCBkZWZpbmVzIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJlY3RhbmdsZSB3aGVyZSBwaXhlbHMgbXVzdCBiZSByZWFkXG4gICAgICogQHBhcmFtIHkgZGVmaW5lcyB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSByZWN0YW5nbGUgd2hlcmUgcGl4ZWxzIG11c3QgYmUgcmVhZFxuICAgICAqIEBwYXJhbSB3aWR0aCBkZWZpbmVzIHRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIHdoZXJlIHBpeGVscyBtdXN0IGJlIHJlYWRcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IGRlZmluZXMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHdoZXJlIHBpeGVscyBtdXN0IGJlIHJlYWRcbiAgICAgKiBAcGFyYW0gaGFzQWxwaGEgZGVmaW5lcyB3aGV0aGVyIHRoZSBvdXRwdXQgc2hvdWxkIGhhdmUgYWxwaGEgb3Igbm90IChkZWZhdWx0cyB0byB0cnVlKVxuICAgICAqIEBwYXJhbSBmbHVzaFJlbmRlcmVyIHRydWUgdG8gZmx1c2ggdGhlIHJlbmRlcmVyIGZyb20gdGhlIHBlbmRpbmcgY29tbWFuZHMgYmVmb3JlIHJlYWRpbmcgdGhlIHBpeGVsc1xuICAgICAqIEBwYXJhbSBkYXRhIGRlZmluZXMgdGhlIGRhdGEgdG8gZmlsbCB3aXRoIHRoZSByZWFkIHBpeGVscyAoaWYgbm90IHByb3ZpZGVkLCBhIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkKVxuICAgICAqIEByZXR1cm5zIGEgQXJyYXlCdWZmZXJWaWV3IHByb21pc2UgKFVpbnQ4QXJyYXkpIGNvbnRhaW5pbmcgUkdCQSBjb2xvcnNcbiAgICAgKi9cbiAgICAvLyBBc3luYyBmdW5jdGlvbiwgbm90IG5hbWVkIEFzeW5jIGFuZCBub3QgbWFya2VkIGFzIGFzeW5jIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmNcbiAgICByZWFkUGl4ZWxzKHgsIHksIHdpZHRoLCBoZWlnaHQsIGhhc0FscGhhID0gdHJ1ZSwgZmx1c2hSZW5kZXJlciA9IHRydWUsIGRhdGEgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG51bUNoYW5uZWxzID0gaGFzQWxwaGEgPyA0IDogMztcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gaGFzQWxwaGEgPyB0aGlzLl9nbC5SR0JBIDogdGhpcy5fZ2wuUkdCO1xuICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gd2lkdGggKiBoZWlnaHQgKiBudW1DaGFubmVscztcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPCBkYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoYERhdGEgYnVmZmVyIGlzIHRvbyBzbWFsbCB0byBzdG9yZSB0aGUgcmVhZCBwaXhlbHMgKCR7ZGF0YS5sZW5ndGh9IHNob3VsZCBiZSBtb3JlIHRoYW4gJHtkYXRhTGVuZ3RofSlgKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsdXNoUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hGcmFtZWJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0aGlzLl9nbC5VTlNJR05FRF9CWVRFLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIFByb21pc2U8Ym9vbGVhbj4gaW5kaWNhdGluZyBpZiB0aGUgZW5naW5lIGNhbiBiZSBpbnN0YW50aWF0ZWQgKGllLiBpZiBhIHdlYkdMIGNvbnRleHQgY2FuIGJlIGZvdW5kKVxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIHN0YXRpYyBnZXQgSXNTdXBwb3J0ZWRBc3luYygpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmlzU3VwcG9ydGVkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBlbmdpbmUgY2FuIGJlIGluc3RhbnRpYXRlZCAoaWUuIGlmIGEgd2ViR0wgY29udGV4dCBjYW4gYmUgZm91bmQpXG4gICAgICovXG4gICAgc3RhdGljIGdldCBJc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQoKTsgLy8gQmFja3dhcmQgY29tcGF0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGVuZ2luZSBjYW4gYmUgaW5zdGFudGlhdGVkIChpZS4gaWYgYSB3ZWJHTCBjb250ZXh0IGNhbiBiZSBmb3VuZClcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBlbmdpbmUgY2FuIGJlIGNyZWF0ZWRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fSGFzTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9IYXNNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OyAvLyBXZSBrbm93IGl0IGlzIHBlcmZvcm1hbnQgc28gV2ViR0wgaXMgc3VwcG9ydGVkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX0lzU3VwcG9ydGVkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBjYW52YXMgPSBBYnN0cmFjdEVuZ2luZS5fQ3JlYXRlQ2FudmFzKDEsIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdsID0gdGVtcGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIikgfHwgdGVtcGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX0lzU3VwcG9ydGVkID0gZ2wgIT0gbnVsbCAmJiAhIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX0lzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX0lzU3VwcG9ydGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBlbmdpbmUgY2FuIGJlIGluc3RhbnRpYXRlZCBvbiBhIHBlcmZvcm1hbnQgZGV2aWNlIChpZS4gaWYgYSB3ZWJHTCBjb250ZXh0IGNhbiBiZSBmb3VuZCBhbmQgaXQgZG9lcyBub3QgdXNlIGEgc2xvdyBpbXBsZW1lbnRhdGlvbilcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEhhc01ham9yUGVyZm9ybWFuY2VDYXZlYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9IYXNNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBjYW52YXMgPSBBYnN0cmFjdEVuZ2luZS5fQ3JlYXRlQ2FudmFzKDEsIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdsID0gdGVtcGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgeyBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiB0cnVlIH0pIHx8XG4gICAgICAgICAgICAgICAgICAgIHRlbXBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCB7IGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fSGFzTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA9ICFnbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fSGFzTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9IYXNNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0O1xuICAgIH1cbn1cblRoaW5FbmdpbmUuX1RlbXBDbGVhckNvbG9yVWludDMyID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuVGhpbkVuZ2luZS5fVGVtcENsZWFyQ29sb3JJbnQzMiA9IG5ldyBJbnQzMkFycmF5KDQpO1xuLyoqIFVzZSB0aGlzIGFycmF5IHRvIHR1cm4gb2ZmIHNvbWUgV2ViR0wyIGZlYXR1cmVzIG9uIGtub3duIGJ1Z2d5IGJyb3dzZXJzIHZlcnNpb24gKi9cblRoaW5FbmdpbmUuRXhjZXB0aW9uTGlzdCA9IFtcbiAgICB7IGtleTogXCJDaHJvbWUvNjMuMFwiLCBjYXB0dXJlOiBcIjYzXFxcXC4wXFxcXC4zMjM5XFxcXC4oXFxcXGQrKVwiLCBjYXB0dXJlQ29uc3RyYWludDogMTA4LCB0YXJnZXRzOiBbXCJ1bmlmb3JtQnVmZmVyXCJdIH0sXG4gICAgeyBrZXk6IFwiRmlyZWZveC81OFwiLCBjYXB0dXJlOiBudWxsLCBjYXB0dXJlQ29uc3RyYWludDogbnVsbCwgdGFyZ2V0czogW1widW5pZm9ybUJ1ZmZlclwiXSB9LFxuICAgIHsga2V5OiBcIkZpcmVmb3gvNTlcIiwgY2FwdHVyZTogbnVsbCwgY2FwdHVyZUNvbnN0cmFpbnQ6IG51bGwsIHRhcmdldHM6IFtcInVuaWZvcm1CdWZmZXJcIl0gfSxcbiAgICB7IGtleTogXCJDaHJvbWUvNzIuKz9Nb2JpbGVcIiwgY2FwdHVyZTogbnVsbCwgY2FwdHVyZUNvbnN0cmFpbnQ6IG51bGwsIHRhcmdldHM6IFtcInZhb1wiXSB9LFxuICAgIHsga2V5OiBcIkNocm9tZS83My4rP01vYmlsZVwiLCBjYXB0dXJlOiBudWxsLCBjYXB0dXJlQ29uc3RyYWludDogbnVsbCwgdGFyZ2V0czogW1widmFvXCJdIH0sXG4gICAgeyBrZXk6IFwiQ2hyb21lLzc0Lis/TW9iaWxlXCIsIGNhcHR1cmU6IG51bGwsIGNhcHR1cmVDb25zdHJhaW50OiBudWxsLCB0YXJnZXRzOiBbXCJ2YW9cIl0gfSxcbiAgICB7IGtleTogXCJNYWMgT1MuK0Nocm9tZS83MVwiLCBjYXB0dXJlOiBudWxsLCBjYXB0dXJlQ29uc3RyYWludDogbnVsbCwgdGFyZ2V0czogW1widmFvXCJdIH0sXG4gICAgeyBrZXk6IFwiTWFjIE9TLitDaHJvbWUvNzJcIiwgY2FwdHVyZTogbnVsbCwgY2FwdHVyZUNvbnN0cmFpbnQ6IG51bGwsIHRhcmdldHM6IFtcInZhb1wiXSB9LFxuICAgIHsga2V5OiBcIk1hYyBPUy4rQ2hyb21lXCIsIGNhcHR1cmU6IG51bGwsIGNhcHR1cmVDb25zdHJhaW50OiBudWxsLCB0YXJnZXRzOiBbXCJ1bmlmb3JtQnVmZmVyXCJdIH0sXG4gICAgeyBrZXk6IFwiQ2hyb21lLzEyXFxcXGRcXFxcLi4rP01vYmlsZVwiLCBjYXB0dXJlOiBudWxsLCBjYXB0dXJlQ29uc3RyYWludDogbnVsbCwgdGFyZ2V0czogW1widW5pZm9ybUJ1ZmZlclwiXSB9LFxuICAgIC8vIGRlc2t0b3Agb3N4IHNhZmFyaSAxNS40XG4gICAgeyBrZXk6IFwiLipBcHBsZVdlYktpdC4qKDE1LjQpLipTYWZhcmlcIiwgY2FwdHVyZTogbnVsbCwgY2FwdHVyZUNvbnN0cmFpbnQ6IG51bGwsIHRhcmdldHM6IFtcImFudGlhbGlhc1wiLCBcIm1heE1TQUFTYW1wbGVzXCJdIH0sXG4gICAgLy8gbW9iaWxlIGJyb3dzZXJzIHVzaW5nIHNhZmFyaSAxNS40IG9uIGlvc1xuICAgIHsga2V5OiBcIi4qKDE1LjQpLipBcHBsZVdlYktpdC4qU2FmYXJpXCIsIGNhcHR1cmU6IG51bGwsIGNhcHR1cmVDb25zdHJhaW50OiBudWxsLCB0YXJnZXRzOiBbXCJhbnRpYWxpYXNcIiwgXCJtYXhNU0FBU2FtcGxlc1wiXSB9LFxuXTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cblRoaW5FbmdpbmUuX0NvbmNhdGVuYXRlU2hhZGVyID0gX0NvbmNhdGVuYXRlU2hhZGVyO1xuLy8gU3RhdGljc1xuVGhpbkVuZ2luZS5fSXNTdXBwb3J0ZWQgPSBudWxsO1xuVGhpbkVuZ2luZS5fSGFzTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA9IG51bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGluRW5naW5lLmpzLm1hcCIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwiLi4vLi4vTWlzYy9vYnNlcnZhYmxlLmpzXCI7XG5pbXBvcnQgeyBNYXRyaXgsIFZlY3RvcjMgfSBmcm9tIFwiLi4vLi4vTWF0aHMvbWF0aC52ZWN0b3IuanNcIjtcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tIFwiLi4vLi4vTWF0ZXJpYWxzL1RleHR1cmVzL3RleHR1cmUuanNcIjtcbmltcG9ydCB7IFBvc3RQcm9jZXNzTWFuYWdlciB9IGZyb20gXCIuLi8uLi9Qb3N0UHJvY2Vzc2VzL3Bvc3RQcm9jZXNzTWFuYWdlci5qc1wiO1xuXG5pbXBvcnQgeyBGbG9vclBPVCwgTmVhcmVzdFBPVCB9IGZyb20gXCIuLi8uLi9NaXNjL3Rvb2xzLmZ1bmN0aW9ucy5qc1wiO1xuaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSBcIi4uL2VmZmVjdC5qc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uLy4uL01pc2MvbG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyBPYmplY3RSZW5kZXJlciB9IGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvb2JqZWN0UmVuZGVyZXIuanNcIjtcbi8qKlxuICogU2V0cyBhIGRlcHRoIHN0ZW5jaWwgdGV4dHVyZSBmcm9tIGEgcmVuZGVyIHRhcmdldCBvbiB0aGUgZW5naW5lIHRvIGJlIHVzZWQgaW4gdGhlIHNoYWRlci5cbiAqIEBwYXJhbSBjaGFubmVsIE5hbWUgb2YgdGhlIHNhbXBsZXIgdmFyaWFibGUuXG4gKiBAcGFyYW0gdGV4dHVyZSBUZXh0dXJlIHRvIHNldC5cbiAqL1xuRWZmZWN0LnByb3RvdHlwZS5zZXREZXB0aFN0ZW5jaWxUZXh0dXJlID0gZnVuY3Rpb24gKGNoYW5uZWwsIHRleHR1cmUpIHtcbiAgICB0aGlzLl9lbmdpbmUuc2V0RGVwdGhTdGVuY2lsVGV4dHVyZSh0aGlzLl9zYW1wbGVyc1tjaGFubmVsXSwgdGhpcy5fdW5pZm9ybXNbY2hhbm5lbF0sIHRleHR1cmUsIGNoYW5uZWwpO1xufTtcbi8qKlxuICogVGhpcyBIZWxwcyBjcmVhdGluZyBhIHRleHR1cmUgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgZnJvbSBhIGNhbWVyYSBpbiB5b3VyIHNjZW5lLlxuICogSXQgaXMgYmFzaWNhbGx5IGEgZHluYW1pYyB0ZXh0dXJlIHRoYXQgY291bGQgYmUgdXNlZCB0byBjcmVhdGUgc3BlY2lhbCBlZmZlY3RzIGZvciBpbnN0YW5jZS5cbiAqIEFjdHVhbGx5LCBJdCBpcyB0aGUgYmFzZSBvZiBsb3Qgb2YgZWZmZWN0cyBpbiB0aGUgZnJhbWV3b3JrIGxpa2UgcG9zdCBwcm9jZXNzLCBzaGFkb3dzLCBlZmZlY3QgbGF5ZXJzIGFuZCByZW5kZXJpbmcgcGlwZWxpbmVzLi4uXG4gKi9cbmV4cG9ydCBjbGFzcyBSZW5kZXJUYXJnZXRUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcHJlZGljYXRlIHRvIGR5bmFtaWNhbGx5IGRlZmluZSB0aGUgbGlzdCBvZiBtZXNoIHlvdSB3YW50IHRvIHJlbmRlci5cbiAgICAgKiBJZiBzZXQsIHRoZSByZW5kZXJMaXN0IHByb3BlcnR5IHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICovXG4gICAgZ2V0IHJlbmRlckxpc3RQcmVkaWNhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmplY3RSZW5kZXJlci5yZW5kZXJMaXN0UHJlZGljYXRlO1xuICAgIH1cbiAgICBzZXQgcmVuZGVyTGlzdFByZWRpY2F0ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5yZW5kZXJMaXN0UHJlZGljYXRlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGxpc3QgdG8gZGVmaW5lIHRoZSBsaXN0IG9mIG1lc2ggeW91IHdhbnQgdG8gcmVuZGVyLlxuICAgICAqL1xuICAgIGdldCByZW5kZXJMaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0UmVuZGVyZXIucmVuZGVyTGlzdDtcbiAgICB9XG4gICAgc2V0IHJlbmRlckxpc3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0UmVuZGVyZXIucmVuZGVyTGlzdCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhlIGxpc3Qgb2YgcGFydGljbGUgc3lzdGVtcyB0byByZW5kZXIgaW4gdGhlIHRleHR1cmUuIElmIG5vdCBwcm92aWRlZCwgd2lsbCByZW5kZXIgYWxsIHRoZSBwYXJ0aWNsZSBzeXN0ZW1zIG9mIHRoZSBzY2VuZS5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIHBhcnRpY2xlIHN5c3RlbXMgYXJlIHJlbmRlcmVkIG9ubHkgaWYgcmVuZGVyUGFydGljbGVzIGlzIHNldCB0byB0cnVlLlxuICAgICAqL1xuICAgIGdldCBwYXJ0aWNsZVN5c3RlbUxpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmplY3RSZW5kZXJlci5wYXJ0aWNsZVN5c3RlbUxpc3Q7XG4gICAgfVxuICAgIHNldCBwYXJ0aWNsZVN5c3RlbUxpc3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0UmVuZGVyZXIucGFydGljbGVTeXN0ZW1MaXN0ID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIG92ZXJsb2FkIHRoZSByZW5kZXJMaXN0IGFycmF5IGF0IHJlbmRlcmluZyB0aW1lLlxuICAgICAqIFJldHVybiBudWxsIHRvIHJlbmRlciB3aXRoIHRoZSBjdXJyZW50IHJlbmRlckxpc3QsIGVsc2UgcmV0dXJuIHRoZSBsaXN0IG9mIG1lc2hlcyB0byB1c2UgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBGb3IgMkRBcnJheSBSVFQsIGxheWVyT3JGYWNlIGlzIHRoZSBpbmRleCBvZiB0aGUgbGF5ZXIgdGhhdCBpcyBnb2luZyB0byBiZSByZW5kZXJlZCwgZWxzZSBpdCBpcyB0aGUgZmFjZUluZGV4IG9mXG4gICAgICogdGhlIGN1YmUgKGlmIHRoZSBSVFQgaXMgYSBjdWJlLCBlbHNlIGxheWVyT3JGYWNlPTApLlxuICAgICAqIFRoZSByZW5kZXJMaXN0IHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gaXMgdGhlIGN1cnJlbnQgcmVuZGVyIGxpc3QgKHRoZSBvbmUgdGhhdCB3aWxsIGJlIHVzZWQgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgbnVsbCkuXG4gICAgICogVGhlIGxlbmd0aCBvZiB0aGlzIGxpc3QgaXMgcGFzc2VkIHRocm91Z2ggcmVuZGVyTGlzdExlbmd0aDogZG9uJ3QgdXNlIHJlbmRlckxpc3QubGVuZ3RoIGRpcmVjdGx5IGJlY2F1c2UgdGhlIGFycmF5IGNhblxuICAgICAqIGhvbGQgZHVtbXkgZWxlbWVudHMhXG4gICAgICovXG4gICAgZ2V0IGdldEN1c3RvbVJlbmRlckxpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmplY3RSZW5kZXJlci5nZXRDdXN0b21SZW5kZXJMaXN0O1xuICAgIH1cbiAgICBzZXQgZ2V0Q3VzdG9tUmVuZGVyTGlzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5nZXRDdXN0b21SZW5kZXJMaXN0ID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSBpZiBwYXJ0aWNsZXMgc2hvdWxkIGJlIHJlbmRlcmVkIGluIHlvdXIgdGV4dHVyZSAoZGVmYXVsdDogdHJ1ZSkuXG4gICAgICovXG4gICAgZ2V0IHJlbmRlclBhcnRpY2xlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFJlbmRlcmVyLnJlbmRlclBhcnRpY2xlcztcbiAgICB9XG4gICAgc2V0IHJlbmRlclBhcnRpY2xlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5yZW5kZXJQYXJ0aWNsZXMgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lIGlmIHNwcml0ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIGluIHlvdXIgdGV4dHVyZSAoZGVmYXVsdDogZmFsc2UpLlxuICAgICAqL1xuICAgIGdldCByZW5kZXJTcHJpdGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0UmVuZGVyZXIucmVuZGVyU3ByaXRlcztcbiAgICB9XG4gICAgc2V0IHJlbmRlclNwcml0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0UmVuZGVyZXIucmVuZGVyU3ByaXRlcyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JjZSBjaGVja2luZyB0aGUgbGF5ZXJNYXNrIHByb3BlcnR5IGV2ZW4gaWYgYSBjdXN0b20gbGlzdCBvZiBtZXNoZXMgaXMgcHJvdmlkZWQgKGllLiBpZiByZW5kZXJMaXN0IGlzIG5vdCB1bmRlZmluZWQpIChkZWZhdWx0OiBmYWxzZSkuXG4gICAgICovXG4gICAgZ2V0IGZvcmNlTGF5ZXJNYXNrQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmplY3RSZW5kZXJlci5mb3JjZUxheWVyTWFza0NoZWNrO1xuICAgIH1cbiAgICBzZXQgZm9yY2VMYXllck1hc2tDaGVjayh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5mb3JjZUxheWVyTWFza0NoZWNrID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSB0aGUgY2FtZXJhIHVzZWQgdG8gcmVuZGVyIHRoZSB0ZXh0dXJlLlxuICAgICAqL1xuICAgIGdldCBhY3RpdmVDYW1lcmEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmplY3RSZW5kZXJlci5hY3RpdmVDYW1lcmE7XG4gICAgfVxuICAgIHNldCBhY3RpdmVDYW1lcmEodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0UmVuZGVyZXIuYWN0aXZlQ2FtZXJhID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSB0aGUgY2FtZXJhIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBMT0Qgb2YgdGhlIG9iamVjdHMuXG4gICAgICogSWYgbm90IGRlZmluZWQsIGFjdGl2ZUNhbWVyYSB3aWxsIGJlIHVzZWQuIElmIG5vdCBkZWZpbmVkIG5vciBhY3RpdmVDYW1lcmEsIHNjZW5lJ3MgYWN0aXZlIGNhbWVyYSB3aWxsIGJlIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IGNhbWVyYUZvckxPRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFJlbmRlcmVyLmNhbWVyYUZvckxPRDtcbiAgICB9XG4gICAgc2V0IGNhbWVyYUZvckxPRCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5jYW1lcmFGb3JMT0QgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIHJlbmRlcmVyIHdpbGwgcmVuZGVyIGFsbCBvYmplY3RzIHdpdGhvdXQgYW55IGltYWdlIHByb2Nlc3NpbmcgYXBwbGllZC5cbiAgICAgKiBJZiBmYWxzZSAoZGVmYXVsdCB2YWx1ZSksIHRoZSByZW5kZXJlciB3aWxsIHVzZSB0aGUgY3VycmVudCBzZXR0aW5nIG9mIHRoZSBzY2VuZSdzIGltYWdlIHByb2Nlc3NpbmcgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZUltYWdlUHJvY2Vzc2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFJlbmRlcmVyLmRpc2FibGVJbWFnZVByb2Nlc3Npbmc7XG4gICAgfVxuICAgIHNldCBkaXNhYmxlSW1hZ2VQcm9jZXNzaW5nKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29iamVjdFJlbmRlcmVyLmRpc2FibGVJbWFnZVByb2Nlc3NpbmcgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIG1lc2ggaXNSZWFkeSBmdW5jdGlvbiB3aXRoIHlvdXIgb3duIG9uZS5cbiAgICAgKi9cbiAgICBnZXQgY3VzdG9tSXNSZWFkeUZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0UmVuZGVyZXIuY3VzdG9tSXNSZWFkeUZ1bmN0aW9uO1xuICAgIH1cbiAgICBzZXQgY3VzdG9tSXNSZWFkeUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29iamVjdFJlbmRlcmVyLmN1c3RvbUlzUmVhZHlGdW5jdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9mIHRoZSB0ZXh0dXJlIHdpdGggeW91ciBvd24gb25lLlxuICAgICAqL1xuICAgIGdldCBjdXN0b21SZW5kZXJGdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFJlbmRlcmVyLmN1c3RvbVJlbmRlckZ1bmN0aW9uO1xuICAgIH1cbiAgICBzZXQgY3VzdG9tUmVuZGVyRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0UmVuZGVyZXIuY3VzdG9tUmVuZGVyRnVuY3Rpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9zdC1wcm9jZXNzZXMgZm9yIHRoaXMgcmVuZGVyIHRhcmdldFxuICAgICAqL1xuICAgIGdldCBwb3N0UHJvY2Vzc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zdFByb2Nlc3NlcztcbiAgICB9XG4gICAgZ2V0IF9wcmVQYXNzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fcHJlUGFzc1JlbmRlclRhcmdldCAmJiB0aGlzLl9wcmVQYXNzUmVuZGVyVGFyZ2V0LmVuYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIGFmdGVyIHVuYmluZCBjYWxsYmFjayBpbiB0aGUgdGV4dHVyZS5cbiAgICAgKiBUaGlzIGhhcyBiZWVuIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYW5kIHVzZSBvZiBvbkFmdGVyVW5iaW5kT2JzZXJ2YWJsZSBpcyByZWNvbW1lbmRlZC5cbiAgICAgKi9cbiAgICBzZXQgb25BZnRlclVuYmluZChjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5fb25BZnRlclVuYmluZE9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9uQWZ0ZXJVbmJpbmRPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9vbkFmdGVyVW5iaW5kT2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uQWZ0ZXJVbmJpbmRPYnNlcnZlciA9IHRoaXMub25BZnRlclVuYmluZE9ic2VydmFibGUuYWRkKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgdHJpZ2dlcmVkIGJlZm9yZSByZW5kZXJpbmcgdGhlIHRleHR1cmVcbiAgICAgKi9cbiAgICBnZXQgb25CZWZvcmVSZW5kZXJPYnNlcnZhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0UmVuZGVyZXIub25CZWZvcmVSZW5kZXJPYnNlcnZhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBiZWZvcmUgcmVuZGVyIGNhbGxiYWNrIGluIHRoZSB0ZXh0dXJlLlxuICAgICAqIFRoaXMgaGFzIGJlZW4ga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhbmQgdXNlIG9mIG9uQmVmb3JlUmVuZGVyT2JzZXJ2YWJsZSBpcyByZWNvbW1lbmRlZC5cbiAgICAgKi9cbiAgICBzZXQgb25CZWZvcmVSZW5kZXIoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX29uQmVmb3JlUmVuZGVyT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub25CZWZvcmVSZW5kZXJPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9vbkJlZm9yZVJlbmRlck9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbkJlZm9yZVJlbmRlck9ic2VydmVyID0gdGhpcy5vbkJlZm9yZVJlbmRlck9ic2VydmFibGUuYWRkKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgdHJpZ2dlcmVkIGFmdGVyIHJlbmRlcmluZyB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIGdldCBvbkFmdGVyUmVuZGVyT2JzZXJ2YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFJlbmRlcmVyLm9uQWZ0ZXJSZW5kZXJPYnNlcnZhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBhZnRlciByZW5kZXIgY2FsbGJhY2sgaW4gdGhlIHRleHR1cmUuXG4gICAgICogVGhpcyBoYXMgYmVlbiBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFuZCB1c2Ugb2Ygb25BZnRlclJlbmRlck9ic2VydmFibGUgaXMgcmVjb21tZW5kZWQuXG4gICAgICovXG4gICAgc2V0IG9uQWZ0ZXJSZW5kZXIoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX29uQWZ0ZXJSZW5kZXJPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5vbkFmdGVyUmVuZGVyT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25BZnRlclJlbmRlck9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbkFmdGVyUmVuZGVyT2JzZXJ2ZXIgPSB0aGlzLm9uQWZ0ZXJSZW5kZXJPYnNlcnZhYmxlLmFkZChjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIGNsZWFyIGNhbGxiYWNrIGluIHRoZSB0ZXh0dXJlLlxuICAgICAqIFRoaXMgaGFzIGJlZW4ga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhbmQgdXNlIG9mIG9uQ2xlYXJPYnNlcnZhYmxlIGlzIHJlY29tbWVuZGVkLlxuICAgICAqL1xuICAgIHNldCBvbkNsZWFyKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbkNsZWFyT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub25DbGVhck9ic2VydmFibGUucmVtb3ZlKHRoaXMuX29uQ2xlYXJPYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25DbGVhck9ic2VydmVyID0gdGhpcy5vbkNsZWFyT2JzZXJ2YWJsZS5hZGQoY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZ2V0IF93YWl0aW5nUmVuZGVyTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFJlbmRlcmVyLl93YWl0aW5nUmVuZGVyTGlzdDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHNldCBfd2FpdGluZ1JlbmRlckxpc3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0UmVuZGVyZXIuX3dhaXRpbmdSZW5kZXJMaXN0ID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgcmVuZGVyIHBhc3MgaWQgb2YgdGhlIHJlbmRlciB0YXJnZXQgdGV4dHVyZS4gTm90ZSBpdCBjYW4gY2hhbmdlIG92ZXIgdGhlIHJlbmRlcmluZyBhcyB0aGVyZSdzIGEgc2VwYXJhdGUgaWQgZm9yIGVhY2ggZmFjZSBvZiBhIGN1YmUgLyBlYWNoIGxheWVyIG9mIGFuIGFycmF5IGxheWVyIVxuICAgICAqL1xuICAgIGdldCByZW5kZXJQYXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmplY3RSZW5kZXJlci5yZW5kZXJQYXNzSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlbmRlciBwYXNzIGlkcyB1c2VkIGJ5IHRoZSByZW5kZXIgdGFyZ2V0IHRleHR1cmUuIEZvciBhIHNpbmdsZSByZW5kZXIgdGFyZ2V0IHRoZSBhcnJheSBsZW5ndGggd2lsbCBiZSAxLCBmb3IgYSBjdWJlIHRleHR1cmUgaXQgd2lsbCBiZSA2IGFuZCBmb3JcbiAgICAgKiBhIDJEIHRleHR1cmUgYXJyYXkgaXQgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgaWRzIHRoZSBzaXplIG9mIHRoZSAyRCB0ZXh0dXJlIGFycmF5XG4gICAgICovXG4gICAgZ2V0IHJlbmRlclBhc3NJZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmplY3RSZW5kZXJlci5yZW5kZXJQYXNzSWRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSByZWZyZXNoSWQgY291bnRlclxuICAgICAqL1xuICAgIGdldCBjdXJyZW50UmVmcmVzaElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0UmVuZGVyZXIuY3VycmVudFJlZnJlc2hJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHNwZWNpZmljIG1hdGVyaWFsIHRvIGJlIHVzZWQgdG8gcmVuZGVyIGEgbWVzaC9hIGxpc3Qgb2YgbWVzaGVzIGluIHRoaXMgcmVuZGVyIHRhcmdldCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIG1lc2ggbWVzaCBvciBhcnJheSBvZiBtZXNoZXNcbiAgICAgKiBAcGFyYW0gbWF0ZXJpYWwgbWF0ZXJpYWwgb3IgYXJyYXkgb2YgbWF0ZXJpYWxzIHRvIHVzZSBmb3IgdGhpcyByZW5kZXIgcGFzcy4gSWYgdW5kZWZpbmVkIGlzIHBhc3NlZCwgbm8gc3BlY2lmaWMgbWF0ZXJpYWwgd2lsbCBiZSB1c2VkIGJ1dCB0aGUgcmVndWxhciBtYXRlcmlhbCBpbnN0ZWFkIChtZXNoLm1hdGVyaWFsKS4gSXQncyBwb3NzaWJsZSB0byBwcm92aWRlIGFuIGFycmF5IG9mIG1hdGVyaWFscyB0byB1c2UgYSBkaWZmZXJlbnQgbWF0ZXJpYWwgZm9yIGVhY2ggcmVuZGVyaW5nIGluIHRoZSBjYXNlIG9mIGEgY3ViZSB0ZXh0dXJlICg2IHJlbmRlcmluZykgYW5kIGEgMkQgdGV4dHVyZSBhcnJheSAoYXMgbWFueSByZW5kZXJpbmcgYXMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkpXG4gICAgICovXG4gICAgc2V0TWF0ZXJpYWxGb3JSZW5kZXJpbmcobWVzaCwgbWF0ZXJpYWwpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0UmVuZGVyZXIuc2V0TWF0ZXJpYWxGb3JSZW5kZXJpbmcobWVzaCwgbWF0ZXJpYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgaWYgdGhlIHRleHR1cmUgaGFzIG11bHRpcGxlIGRyYXcgYnVmZmVycyBvciBpZiBmYWxzZSBhIHNpbmdsZSBkcmF3IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBnZXQgaXNNdWx0aSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclRhcmdldD8uaXNNdWx0aSA/PyBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyByZW5kZXIgdGFyZ2V0IGNyZWF0aW9uIG9wdGlvbnMgdGhhdCB3ZXJlIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IHJlbmRlclRhcmdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZW5kZXIgdGFyZ2V0IHdyYXBwZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVuZGVyIHRhcmdldFxuICAgICAqL1xuICAgIGdldCByZW5kZXJUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJUYXJnZXQ7XG4gICAgfVxuICAgIF9vblJhdGlvUmVzY2FsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NpemVSYXRpbykge1xuICAgICAgICAgICAgdGhpcy5yZXNpemUodGhpcy5faW5pdGlhbFNpemVQYXJhbWV0ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc2l6ZSBvZiB0aGUgYm91bmRpbmcgYm94IGFzc29jaWF0ZWQgd2l0aCB0aGUgdGV4dHVyZSAod2hlbiBpbiBjdWJlIG1vZGUpXG4gICAgICogV2hlbiBkZWZpbmVkLCB0aGUgY3ViZW1hcCB3aWxsIHN3aXRjaCB0byBsb2NhbCBtb2RlXG4gICAgICogQHNlZSBodHRwczovL2NvbW11bml0eS5hcm0uY29tL2dyYXBoaWNzL2IvYmxvZy9wb3N0cy9yZWZsZWN0aW9ucy1iYXNlZC1vbi1sb2NhbC1jdWJlbWFwcy1pbi11bml0eVxuICAgICAqIEBleGFtcGxlIGh0dHBzOi8vd3d3LmJhYnlsb25qcy1wbGF5Z3JvdW5kLmNvbS8jUk5BU01MXG4gICAgICovXG4gICAgc2V0IGJvdW5kaW5nQm94U2l6ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fYm91bmRpbmdCb3hTaXplICYmIHRoaXMuX2JvdW5kaW5nQm94U2l6ZS5lcXVhbHModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm91bmRpbmdCb3hTaXplID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5nZXRTY2VuZSgpO1xuICAgICAgICBpZiAoc2NlbmUpIHtcbiAgICAgICAgICAgIHNjZW5lLm1hcmtBbGxNYXRlcmlhbHNBc0RpcnR5KDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBib3VuZGluZ0JveFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZGluZ0JveFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluIGNhc2UgdGhlIFJUVCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYSBkZXB0aCB0ZXh0dXJlLCBnZXQgdGhlIGFzc29jaWF0ZWRcbiAgICAgKiBkZXB0aCB0ZXh0dXJlLlxuICAgICAqIE90aGVyd2lzZSwgcmV0dXJuIG51bGwuXG4gICAgICovXG4gICAgZ2V0IGRlcHRoU3RlbmNpbFRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJUYXJnZXQ/Ll9kZXB0aFN0ZW5jaWxUZXh0dXJlID8/IG51bGw7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzaXplLCBzY2VuZSwgZ2VuZXJhdGVNaXBNYXBzID0gZmFsc2UsIGRvTm90Q2hhbmdlQXNwZWN0UmF0aW8gPSB0cnVlLCB0eXBlID0gMCwgaXNDdWJlID0gZmFsc2UsIHNhbXBsaW5nTW9kZSA9IFRleHR1cmUuVFJJTElORUFSX1NBTVBMSU5HTU9ERSwgZ2VuZXJhdGVEZXB0aEJ1ZmZlciA9IHRydWUsIGdlbmVyYXRlU3RlbmNpbEJ1ZmZlciA9IGZhbHNlLCBpc011bHRpID0gZmFsc2UsIGZvcm1hdCA9IDUsIGRlbGF5QWxsb2NhdGlvbiA9IGZhbHNlLCBzYW1wbGVzLCBjcmVhdGlvbkZsYWdzLCBub0NvbG9yQXR0YWNobWVudCA9IGZhbHNlLCB1c2VTUkdCQnVmZmVyID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGNvbG9yQXR0YWNobWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGdhbW1hU3BhY2UgPSB0cnVlO1xuICAgICAgICBsZXQgZXhpc3RpbmdPYmplY3RSZW5kZXJlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiBnZW5lcmF0ZU1pcE1hcHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBnZW5lcmF0ZU1pcE1hcHM7XG4gICAgICAgICAgICBnZW5lcmF0ZU1pcE1hcHMgPSAhIW9wdGlvbnMuZ2VuZXJhdGVNaXBNYXBzO1xuICAgICAgICAgICAgZG9Ob3RDaGFuZ2VBc3BlY3RSYXRpbyA9IG9wdGlvbnMuZG9Ob3RDaGFuZ2VBc3BlY3RSYXRpbyA/PyB0cnVlO1xuICAgICAgICAgICAgdHlwZSA9IG9wdGlvbnMudHlwZSA/PyAwO1xuICAgICAgICAgICAgaXNDdWJlID0gISFvcHRpb25zLmlzQ3ViZTtcbiAgICAgICAgICAgIHNhbXBsaW5nTW9kZSA9IG9wdGlvbnMuc2FtcGxpbmdNb2RlID8/IFRleHR1cmUuVFJJTElORUFSX1NBTVBMSU5HTU9ERTtcbiAgICAgICAgICAgIGdlbmVyYXRlRGVwdGhCdWZmZXIgPSBvcHRpb25zLmdlbmVyYXRlRGVwdGhCdWZmZXIgPz8gdHJ1ZTtcbiAgICAgICAgICAgIGdlbmVyYXRlU3RlbmNpbEJ1ZmZlciA9ICEhb3B0aW9ucy5nZW5lcmF0ZVN0ZW5jaWxCdWZmZXI7XG4gICAgICAgICAgICBpc011bHRpID0gISFvcHRpb25zLmlzTXVsdGk7XG4gICAgICAgICAgICBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCA/PyA1O1xuICAgICAgICAgICAgZGVsYXlBbGxvY2F0aW9uID0gISFvcHRpb25zLmRlbGF5QWxsb2NhdGlvbjtcbiAgICAgICAgICAgIHNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXM7XG4gICAgICAgICAgICBjcmVhdGlvbkZsYWdzID0gb3B0aW9ucy5jcmVhdGlvbkZsYWdzO1xuICAgICAgICAgICAgbm9Db2xvckF0dGFjaG1lbnQgPSAhIW9wdGlvbnMubm9Db2xvckF0dGFjaG1lbnQ7XG4gICAgICAgICAgICB1c2VTUkdCQnVmZmVyID0gISFvcHRpb25zLnVzZVNSR0JCdWZmZXI7XG4gICAgICAgICAgICBjb2xvckF0dGFjaG1lbnQgPSBvcHRpb25zLmNvbG9yQXR0YWNobWVudDtcbiAgICAgICAgICAgIGdhbW1hU3BhY2UgPSBvcHRpb25zLmdhbW1hU3BhY2UgPz8gZ2FtbWFTcGFjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nT2JqZWN0UmVuZGVyZXIgPSBvcHRpb25zLmV4aXN0aW5nT2JqZWN0UmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobnVsbCwgc2NlbmUsICFnZW5lcmF0ZU1pcE1hcHMsIHVuZGVmaW5lZCwgc2FtcGxpbmdNb2RlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZvcm1hdCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgaWYgdGhlIGNhbWVyYSB2aWV3cG9ydCBzaG91bGQgYmUgcmVzcGVjdGVkIHdoaWxlIHJlbmRlcmluZyB0aGUgdGV4dHVyZSBvciBpZiB0aGUgcmVuZGVyIHNob3VsZCBiZSBkb25lIHRvIHRoZSBlbnRpcmUgdGV4dHVyZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWdub3JlQ2FtZXJhVmlld3BvcnQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSB0ZXh0dXJlIGlzIHVuYmluZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CZWZvcmVCaW5kT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgdGV4dHVyZSBpcyB1bmJpbmQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQWZ0ZXJVbmJpbmRPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRyaWdnZXJlZCBhZnRlciB0aGUgdGV4dHVyZSBjbGVhclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNsZWFyT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgdGV4dHVyZSBpcyByZXNpemVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblJlc2l6ZU9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2NsZWFyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNraXAgdGhlIGluaXRpYWwgY2xlYXIgb2YgdGhlIHJ0dCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmcmFtZSByZW5kZXIgbG9vcFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5za2lwSW5pdGlhbENsZWFyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NhbXBsZXMgPSAxO1xuICAgICAgICB0aGlzLl9jYW5SZXNjYWxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZG9udERpc3Bvc2VPYmplY3RSZW5kZXJlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIGJveCBhc3NvY2lhdGVkIHdpdGggdGhlIHRleHR1cmUgKHdoZW4gaW4gY3ViZSBtb2RlKVxuICAgICAgICAgKiBJdCBtdXN0IGRlZmluZSB3aGVyZSB0aGUgY2FtZXJhIHVzZWQgdG8gcmVuZGVyIHRoZSB0ZXh0dXJlIGlzIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveFBvc2l0aW9uID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZUVuZ2luZVN0YWdlcyA9IGZhbHNlOyAvLyBUT0RPOiByZW1vdmUgdGhpcyB3aGVuIHRoZSBzaGFkb3cgZ2VuZXJhdG9yIHRhc2sgKGZyYW1lIGdyYXBoKSBpcyByZXdvcmtlZCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9CYWJ5bG9uSlMvQmFieWxvbi5qcy9wdWxsLzE1OTYyI2Rpc2N1c3Npb25fcjE4NzQ0MTc2MDcpXG4gICAgICAgIHRoaXMuX2R1bXBUb29sc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgc2NlbmUgPSB0aGlzLmdldFNjZW5lKCk7XG4gICAgICAgIGlmICghc2NlbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLmdldFNjZW5lKCkuZ2V0RW5naW5lKCk7XG4gICAgICAgIHRoaXMuX2dhbW1hU3BhY2UgPSBnYW1tYVNwYWNlO1xuICAgICAgICB0aGlzLl9jb29yZGluYXRlc01vZGUgPSBUZXh0dXJlLlBST0pFQ1RJT05fTU9ERTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pc1JlbmRlclRhcmdldCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2luaXRpYWxTaXplUGFyYW1ldGVyID0gc2l6ZTtcbiAgICAgICAgdGhpcy5fZG9udERpc3Bvc2VPYmplY3RSZW5kZXJlciA9ICEhZXhpc3RpbmdPYmplY3RSZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1NpemVQYXJhbWV0ZXIoc2l6ZSk7XG4gICAgICAgIHRoaXMuX29iamVjdFJlbmRlcmVyID1cbiAgICAgICAgICAgIGV4aXN0aW5nT2JqZWN0UmVuZGVyZXIgPz9cbiAgICAgICAgICAgICAgICBuZXcgT2JqZWN0UmVuZGVyZXIobmFtZSwgc2NlbmUsIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUGFzc2VzOiBpc0N1YmUgPyA2IDogdGhpcy5nZXRSZW5kZXJMYXllcnMoKSB8fCAxLFxuICAgICAgICAgICAgICAgICAgICBkb05vdENoYW5nZUFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vbkJlZm9yZVJlbmRlcmluZ01hbmFnZXJSZW5kZXJPYnNlcnZlciA9IHRoaXMuX29iamVjdFJlbmRlcmVyLm9uQmVmb3JlUmVuZGVyaW5nTWFuYWdlclJlbmRlck9ic2VydmFibGUuYWRkKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEJlZm9yZSBjbGVhclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXNhYmxlRW5naW5lU3RhZ2VzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIHRoaXMuX3NjZW5lLl9iZWZvcmVSZW5kZXJUYXJnZXRDbGVhclN0YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXAuYWN0aW9uKHRoaXMsIHRoaXMuX2N1cnJlbnRGYWNlSW5kZXgsIHRoaXMuX2N1cnJlbnRMYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYXJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQ2xlYXJPYnNlcnZhYmxlLmhhc09ic2VydmVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsZWFyT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoZW5naW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnNraXBJbml0aWFsQ2xlYXIpIHtcbiAgICAgICAgICAgICAgICBlbmdpbmUuY2xlYXIodGhpcy5jbGVhckNvbG9yIHx8IHRoaXMuX3NjZW5lLmNsZWFyQ29sb3IsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb05vdENoYW5nZUFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NlbmUudXBkYXRlVHJhbnNmb3JtTWF0cml4KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmVmb3JlIENhbWVyYSBEcmF3XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Rpc2FibGVFbmdpbmVTdGFnZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0ZXAgb2YgdGhpcy5fc2NlbmUuX2JlZm9yZVJlbmRlclRhcmdldERyYXdTdGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGVwLmFjdGlvbih0aGlzLCB0aGlzLl9jdXJyZW50RmFjZUluZGV4LCB0aGlzLl9jdXJyZW50TGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uQWZ0ZXJSZW5kZXJpbmdNYW5hZ2VyUmVuZGVyT2JzZXJ2ZXIgPSB0aGlzLl9vYmplY3RSZW5kZXJlci5vbkFmdGVyUmVuZGVyaW5nTWFuYWdlclJlbmRlck9ic2VydmFibGUuYWRkKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEFmdGVyIENhbWVyYSBEcmF3XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Rpc2FibGVFbmdpbmVTdGFnZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0ZXAgb2YgdGhpcy5fc2NlbmUuX2FmdGVyUmVuZGVyVGFyZ2V0RHJhd1N0YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXAuYWN0aW9uKHRoaXMsIHRoaXMuX2N1cnJlbnRGYWNlSW5kZXgsIHRoaXMuX2N1cnJlbnRMYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2F2ZUdlbmVyYXRlTWlwTWFwcyA9IHRoaXMuX3RleHR1cmU/LmdlbmVyYXRlTWlwTWFwcyA/PyBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMgPSBmYWxzZTsgLy8gaWYgbGVmdCB0cnVlLCB0aGUgbWlwbWFwcyB3aWxsIGJlIGdlbmVyYXRlZCAoaWYgdGhpcy5fdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMgPSB0cnVlKSB3aGVuIHRoZSBmaXJzdCBwb3N0IHByb2Nlc3MgYmluZHMgaXRzIG93biBSVFQ6IGJ5IGRvaW5nIHNvIGl0IHdpbGwgdW5iaW5kIHRoZSBjdXJyZW50IFJUVCxcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3aWxsIHRyaWdnZXIgYSBtaXBtYXAgZ2VuZXJhdGlvbi4gV2UgZG9uJ3Qgd2FudCB0aGlzIGJlY2F1c2UgaXQncyBhIHdhc3RlZCB3b3JrLCB3ZSB3aWxsIGRvIGFuIHVuYmluZCBvZiB0aGUgY3VycmVudCBSVFQgYXQgdGhlIGVuZCBvZiB0aGUgcHJvY2VzcyAoc2VlIHVuYmluZEZyYW1lQnVmZmVyKSB3aGljaCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciB0aGUgZ2VuZXJhdGlvbiBvZiB0aGUgZmluYWwgbWlwbWFwc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Bvc3RQcm9jZXNzTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc3RQcm9jZXNzTWFuYWdlci5fZmluYWxpemVGcmFtZShmYWxzZSwgdGhpcy5fcmVuZGVyVGFyZ2V0ID8/IHVuZGVmaW5lZCwgdGhpcy5fY3VycmVudEZhY2VJbmRleCwgdGhpcy5fcG9zdFByb2Nlc3NlcywgdGhpcy5pZ25vcmVDYW1lcmFWaWV3cG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jdXJyZW50VXNlQ2FtZXJhUG9zdFByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2VuZS5wb3N0UHJvY2Vzc01hbmFnZXIuX2ZpbmFsaXplRnJhbWUoZmFsc2UsIHRoaXMuX3JlbmRlclRhcmdldCA/PyB1bmRlZmluZWQsIHRoaXMuX2N1cnJlbnRGYWNlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXNhYmxlRW5naW5lU3RhZ2VzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIHRoaXMuX3NjZW5lLl9hZnRlclJlbmRlclRhcmdldFBvc3RQcm9jZXNzU3RhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcC5hY3Rpb24odGhpcywgdGhpcy5fY3VycmVudEZhY2VJbmRleCwgdGhpcy5fY3VycmVudExheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmUuZ2VuZXJhdGVNaXBNYXBzID0gc2F2ZUdlbmVyYXRlTWlwTWFwcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fZG9Ob3RDaGFuZ2VBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjZW5lLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIER1bXAgP1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnREdW1wRm9yRGVidWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2R1bXBUb29scykge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuRXJyb3IoXCJkdW1wVG9vbHMgbW9kdWxlIGlzIHN0aWxsIGJlaW5nIGxvYWRlZC4gVG8gc3BlZWQgdXAgdGhlIHByb2Nlc3MgaW1wb3J0IGR1bXAgdG9vbHMgZGlyZWN0bHkgaW4geW91ciBwcm9qZWN0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHVtcFRvb2xzLkR1bXBGcmFtZWJ1ZmZlcih0aGlzLmdldFJlbmRlcldpZHRoKCksIHRoaXMuZ2V0UmVuZGVySGVpZ2h0KCksIGVuZ2luZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb25GYXN0UGF0aFJlbmRlck9ic2VydmVyID0gdGhpcy5fb2JqZWN0UmVuZGVyZXIub25GYXN0UGF0aFJlbmRlck9ic2VydmFibGUuYWRkKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQ2xlYXJPYnNlcnZhYmxlLmhhc09ic2VydmVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsZWFyT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoZW5naW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5za2lwSW5pdGlhbENsZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZ2luZS5jbGVhcih0aGlzLmNsZWFyQ29sb3IgfHwgdGhpcy5fc2NlbmUuY2xlYXJDb2xvciwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBlbmdpbmUub25SZXNpemVPYnNlcnZhYmxlLmFkZCgoKSA9PiB7IH0pO1xuICAgICAgICB0aGlzLl9nZW5lcmF0ZU1pcE1hcHMgPSBnZW5lcmF0ZU1pcE1hcHMgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHRoaXMuX2RvTm90Q2hhbmdlQXNwZWN0UmF0aW8gPSBkb05vdENoYW5nZUFzcGVjdFJhdGlvO1xuICAgICAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBnZW5lcmF0ZU1pcE1hcHM6IGdlbmVyYXRlTWlwTWFwcyxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2Zvcm1hdCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBzYW1wbGluZ01vZGU6IHRoaXMuc2FtcGxpbmdNb2RlLFxuICAgICAgICAgICAgZ2VuZXJhdGVEZXB0aEJ1ZmZlcjogZ2VuZXJhdGVEZXB0aEJ1ZmZlcixcbiAgICAgICAgICAgIGdlbmVyYXRlU3RlbmNpbEJ1ZmZlcjogZ2VuZXJhdGVTdGVuY2lsQnVmZmVyLFxuICAgICAgICAgICAgc2FtcGxlcyxcbiAgICAgICAgICAgIGNyZWF0aW9uRmxhZ3MsXG4gICAgICAgICAgICBub0NvbG9yQXR0YWNobWVudDogbm9Db2xvckF0dGFjaG1lbnQsXG4gICAgICAgICAgICB1c2VTUkdCQnVmZmVyLFxuICAgICAgICAgICAgY29sb3JBdHRhY2htZW50OiBjb2xvckF0dGFjaG1lbnQsXG4gICAgICAgICAgICBsYWJlbDogdGhpcy5uYW1lLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zYW1wbGluZ01vZGUgPT09IFRleHR1cmUuTkVBUkVTVF9TQU1QTElOR01PREUpIHtcbiAgICAgICAgICAgIHRoaXMud3JhcFUgPSBUZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFO1xuICAgICAgICAgICAgdGhpcy53cmFwViA9IFRleHR1cmUuQ0xBTVBfQUREUkVTU01PREU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheUFsbG9jYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChpc0N1YmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQgPSBzY2VuZS5nZXRFbmdpbmUoKS5jcmVhdGVSZW5kZXJUYXJnZXRDdWJlVGV4dHVyZSh0aGlzLmdldFJlbmRlclNpemUoKSwgdGhpcy5fcmVuZGVyVGFyZ2V0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZGluYXRlc01vZGUgPSBUZXh0dXJlLklOVkNVQklDX01PREU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZU1hdHJpeCA9IE1hdHJpeC5JZGVudGl0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gc2NlbmUuZ2V0RW5naW5lKCkuY3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZSh0aGlzLl9zaXplLCB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl9yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICAgICAgICAgIGlmIChzYW1wbGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZXMgPSBzYW1wbGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZXB0aCBzdGVuY2lsIHRleHR1cmUuXG4gICAgICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBXZWJHTCAyIG9yIHdpdGggdGhlIGRlcHRoIHRleHR1cmUgZXh0ZW5zaW9uIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0gY29tcGFyaXNvbkZ1bmN0aW9uIFNwZWNpZmllcyB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBzZXQgb24gdGhlIHRleHR1cmUuIElmIDAgb3IgdW5kZWZpbmVkLCB0aGUgdGV4dHVyZSBpcyBub3QgaW4gY29tcGFyaXNvbiBtb2RlIChkZWZhdWx0OiAwKVxuICAgICAqIEBwYXJhbSBiaWxpbmVhckZpbHRlcmluZyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgYmlsaW5lYXIgZmlsdGVyaW5nIGlzIGVuYWJsZSBvbiB0aGUgdGV4dHVyZSAoZGVmYXVsdDogdHJ1ZSlcbiAgICAgKiBAcGFyYW0gZ2VuZXJhdGVTdGVuY2lsIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCBhIHN0ZW5jaWwgc2hvdWxkIGJlIGFsbG9jYXRlZCBpbiB0aGUgdGV4dHVyZSAoZGVmYXVsdDogZmFsc2UpXG4gICAgICogQHBhcmFtIHNhbXBsZXMgc2FtcGxlIGNvdW50IG9mIHRoZSBkZXB0aC9zdGVuY2lsIHRleHR1cmUgKGRlZmF1bHQ6IDEpXG4gICAgICogQHBhcmFtIGZvcm1hdCBmb3JtYXQgb2YgdGhlIGRlcHRoIHRleHR1cmUgKGRlZmF1bHQ6IDE0KVxuICAgICAqIEBwYXJhbSBsYWJlbCBkZWZpbmVzIHRoZSBsYWJlbCBvZiB0aGUgdGV4dHVyZSAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlKVxuICAgICAqL1xuICAgIGNyZWF0ZURlcHRoU3RlbmNpbFRleHR1cmUoY29tcGFyaXNvbkZ1bmN0aW9uID0gMCwgYmlsaW5lYXJGaWx0ZXJpbmcgPSB0cnVlLCBnZW5lcmF0ZVN0ZW5jaWwgPSBmYWxzZSwgc2FtcGxlcyA9IDEsIGZvcm1hdCA9IDE0LCBsYWJlbCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQ/LmNyZWF0ZURlcHRoU3RlbmNpbFRleHR1cmUoY29tcGFyaXNvbkZ1bmN0aW9uLCBiaWxpbmVhckZpbHRlcmluZywgZ2VuZXJhdGVTdGVuY2lsLCBzYW1wbGVzLCBmb3JtYXQsIGxhYmVsKTtcbiAgICB9XG4gICAgX3Byb2Nlc3NTaXplUGFyYW1ldGVyKHNpemUpIHtcbiAgICAgICAgaWYgKHNpemUucmF0aW8pIHtcbiAgICAgICAgICAgIHRoaXMuX3NpemVSYXRpbyA9IHNpemUucmF0aW87XG4gICAgICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9nZXRFbmdpbmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuX2Jlc3RSZWZsZWN0aW9uUmVuZGVyVGFyZ2V0RGltZW5zaW9uKGVuZ2luZS5nZXRSZW5kZXJXaWR0aCgpLCB0aGlzLl9zaXplUmF0aW8pLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5fYmVzdFJlZmxlY3Rpb25SZW5kZXJUYXJnZXREaW1lbnNpb24oZW5naW5lLmdldFJlbmRlckhlaWdodCgpLCB0aGlzLl9zaXplUmF0aW8pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgdG8gdXNlIGluIGNhc2Ugb2YgTVNBQS5cbiAgICAgKiBJdCBkZWZhdWx0cyB0byBvbmUgbWVhbmluZyBubyBNU0FBIGhhcyBiZWVuIGVuYWJsZWQuXG4gICAgICovXG4gICAgZ2V0IHNhbXBsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJUYXJnZXQ/LnNhbXBsZXMgPz8gdGhpcy5fc2FtcGxlcztcbiAgICB9XG4gICAgc2V0IHNhbXBsZXModmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fc2FtcGxlcyA9IHRoaXMuX3JlbmRlclRhcmdldC5zZXRTYW1wbGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcG9zdCBwcm9jZXNzIHRvIHRoZSByZW5kZXIgdGFyZ2V0IHJlbmRlcmluZyBwYXNzZXMuXG4gICAgICogQHBhcmFtIHBvc3RQcm9jZXNzIGRlZmluZSB0aGUgcG9zdCBwcm9jZXNzIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZFBvc3RQcm9jZXNzKHBvc3RQcm9jZXNzKSB7XG4gICAgICAgIGlmICghdGhpcy5fcG9zdFByb2Nlc3NNYW5hZ2VyKSB7XG4gICAgICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoKTtcbiAgICAgICAgICAgIGlmICghc2NlbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wb3N0UHJvY2Vzc01hbmFnZXIgPSBuZXcgUG9zdFByb2Nlc3NNYW5hZ2VyKHNjZW5lKTtcbiAgICAgICAgICAgIHRoaXMuX3Bvc3RQcm9jZXNzZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb3N0UHJvY2Vzc2VzLnB1c2gocG9zdFByb2Nlc3MpO1xuICAgICAgICB0aGlzLl9wb3N0UHJvY2Vzc2VzWzBdLmF1dG9DbGVhciA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgdGhlIHBvc3QgcHJvY2Vzc2VzIGF0dGFjaGVkIHRvIHRoZSByZW5kZXIgdGFyZ2V0XG4gICAgICogQHBhcmFtIGRpc3Bvc2UgZGVmaW5lIGlmIHRoZSBjbGVhcmVkIHBvc3QgcHJvY2Vzc2VzIHNob3VsZCBhbHNvIGJlIGRpc3Bvc2VkIChmYWxzZSBieSBkZWZhdWx0KVxuICAgICAqL1xuICAgIGNsZWFyUG9zdFByb2Nlc3NlcyhkaXNwb3NlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wb3N0UHJvY2Vzc2VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3Bvc2UpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcG9zdFByb2Nlc3Mgb2YgdGhpcy5fcG9zdFByb2Nlc3Nlcykge1xuICAgICAgICAgICAgICAgIHBvc3RQcm9jZXNzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb3N0UHJvY2Vzc2VzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBvbmUgb2YgdGhlIHBvc3QgcHJvY2VzcyBmcm9tIHRoZSBsaXN0IG9mIGF0dGFjaGVkIHBvc3QgcHJvY2Vzc2VzIHRvIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHBvc3RQcm9jZXNzIGRlZmluZSB0aGUgcG9zdCBwcm9jZXNzIHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0XG4gICAgICovXG4gICAgcmVtb3ZlUG9zdFByb2Nlc3MocG9zdFByb2Nlc3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wb3N0UHJvY2Vzc2VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wb3N0UHJvY2Vzc2VzLmluZGV4T2YocG9zdFByb2Nlc3MpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9zdFByb2Nlc3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAodGhpcy5fcG9zdFByb2Nlc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3N0UHJvY2Vzc2VzWzBdLmF1dG9DbGVhciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgcmVmcmVzaCBjb3VudGVyIG9mIHRoZSB0ZXh0dXJlIGFuZCBzdGFydCBiYWsgZnJvbSBzY3JhdGNoLlxuICAgICAqIENvdWxkIGJlIHVzZWZ1bCB0byByZWdlbmVyYXRlIHRoZSB0ZXh0dXJlIGlmIGl0IGlzIHNldHVwIHRvIHJlbmRlciBvbmx5IG9uY2UuXG4gICAgICovXG4gICAgcmVzZXRSZWZyZXNoQ291bnRlcigpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0UmVuZGVyZXIucmVzZXRSZWZyZXNoQ291bnRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhlIHJlZnJlc2ggcmF0ZSBvZiB0aGUgdGV4dHVyZSBvciB0aGUgcmVuZGVyaW5nIGZyZXF1ZW5jeS5cbiAgICAgKiBVc2UgMCB0byByZW5kZXIganVzdCBvbmNlLCAxIHRvIHJlbmRlciBvbiBldmVyeSBmcmFtZSwgMiB0byByZW5kZXIgZXZlcnkgdHdvIGZyYW1lcyBhbmQgc28gb24uLi5cbiAgICAgKi9cbiAgICBnZXQgcmVmcmVzaFJhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmplY3RSZW5kZXJlci5yZWZyZXNoUmF0ZTtcbiAgICB9XG4gICAgc2V0IHJlZnJlc2hSYXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29iamVjdFJlbmRlcmVyLnJlZnJlc2hSYXRlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc2hvdWxkUmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0UmVuZGVyZXIuc2hvdWxkUmVuZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFjdHVhbCByZW5kZXIgc2l6ZSBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHJlbmRlciBzaXplXG4gICAgICovXG4gICAgZ2V0UmVuZGVyU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyV2lkdGgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYWN0dWFsIHJlbmRlciB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHJlbmRlciBzaXplXG4gICAgICovXG4gICAgZ2V0UmVuZGVyV2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaXplLndpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYWN0dWFsIHJlbmRlciBoZWlnaHQgb2YgdGhlIHRleHR1cmUuXG4gICAgICogQHJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyIHNpemVcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJIZWlnaHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaXplLndpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFjdHVhbCBudW1iZXIgb2YgbGF5ZXJzIG9mIHRoZSB0ZXh0dXJlIG9yLCBpbiB0aGUgY2FzZSBvZiBhIDNEIHRleHR1cmUsIHJldHVybiB0aGUgZGVwdGguXG4gICAgICogQHJldHVybnMgdGhlIG51bWJlciBvZiBsYXllcnNcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJMYXllcnMoKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX3NpemUubGF5ZXJzO1xuICAgICAgICBpZiAobGF5ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlcHRoID0gdGhpcy5fc2l6ZS5kZXB0aDtcbiAgICAgICAgaWYgKGRlcHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvbid0IGFsbG93IHRoaXMgcmVuZGVyIHRhcmdldCB0ZXh0dXJlIHRvIHJlc2NhbGUuIE1haW5seSB1c2VkIHRvIHByZXZlbnQgcmVzY2FsaW5nIGJ5IHRoZSBzY2VuZSBvcHRpbWl6ZXIuXG4gICAgICovXG4gICAgZGlzYWJsZVJlc2NhbGluZygpIHtcbiAgICAgICAgdGhpcy5fY2FuUmVzY2FsZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgaWYgdGhlIHRleHR1cmUgY2FuIGJlIHJlc2NhbGVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBnZXQgY2FuUmVzY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhblJlc2NhbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSB0aGUgdGV4dHVyZSB1c2luZyBhIHJhdGlvLlxuICAgICAqIEBwYXJhbSByYXRpbyB0aGUgcmF0aW8gdG8gYXBwbHkgdG8gdGhlIHRleHR1cmUgc2l6ZSBpbiBvcmRlciB0byBjb21wdXRlIHRoZSBuZXcgdGFyZ2V0IHNpemVcbiAgICAgKi9cbiAgICBzY2FsZShyYXRpbykge1xuICAgICAgICBjb25zdCBuZXdTaXplID0gTWF0aC5tYXgoMSwgdGhpcy5nZXRSZW5kZXJTaXplKCkgKiByYXRpbyk7XG4gICAgICAgIHRoaXMucmVzaXplKG5ld1NpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRleHR1cmUgcmVmbGVjdGlvbiBtYXRyaXggdXNlZCB0byByb3RhdGUvdHJhbnNmb3JtIHRoZSByZWZsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHRoZSByZWZsZWN0aW9uIG1hdHJpeFxuICAgICAqL1xuICAgIGdldFJlZmxlY3Rpb25UZXh0dXJlTWF0cml4KCkge1xuICAgICAgICBpZiAodGhpcy5pc0N1YmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlTWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRSZWZsZWN0aW9uVGV4dHVyZU1hdHJpeCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdGhlIHRleHR1cmUgdG8gYSBuZXcgZGVzaXJlZCBzaXplLlxuICAgICAqIEJlIGNhcmVmdWwgYXMgaXQgd2lsbCByZWNyZWF0ZSBhbGwgdGhlIGRhdGEgaW4gdGhlIG5ldyB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSBzaXplIERlZmluZSB0aGUgbmV3IHNpemUuIEl0IGNhbiBiZTpcbiAgICAgKiAgIC0gYSBudW1iZXIgZm9yIHNxdWFyZWQgdGV4dHVyZSxcbiAgICAgKiAgIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgeyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9XG4gICAgICogICAtIG9yIGFuIG9iamVjdCBjb250YWluaW5nIGEgcmF0aW8geyByYXRpbzogbnVtYmVyIH1cbiAgICAgKi9cbiAgICByZXNpemUoc2l6ZSkge1xuICAgICAgICBjb25zdCB3YXNDdWJlID0gdGhpcy5pc0N1YmU7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldD8uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQgPSBudWxsO1xuICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoKTtcbiAgICAgICAgaWYgKCFzY2VuZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NTaXplUGFyYW1ldGVyKHNpemUpO1xuICAgICAgICBpZiAod2FzQ3ViZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gc2NlbmUuZ2V0RW5naW5lKCkuY3JlYXRlUmVuZGVyVGFyZ2V0Q3ViZVRleHR1cmUodGhpcy5nZXRSZW5kZXJTaXplKCksIHRoaXMuX3JlbmRlclRhcmdldE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gc2NlbmUuZ2V0RW5naW5lKCkuY3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZSh0aGlzLl9zaXplLCB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdGhpcy5fcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zLnNhbXBsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zYW1wbGVzID0gdGhpcy5fcmVuZGVyVGFyZ2V0T3B0aW9ucy5zYW1wbGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uUmVzaXplT2JzZXJ2YWJsZS5oYXNPYnNlcnZlcnMoKSkge1xuICAgICAgICAgICAgdGhpcy5vblJlc2l6ZU9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYWxsIHRoZSBvYmplY3RzIGZyb20gdGhlIHJlbmRlciBsaXN0IGludG8gdGhlIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHVzZUNhbWVyYVBvc3RQcm9jZXNzIERlZmluZSBpZiBjYW1lcmEgcG9zdCBwcm9jZXNzZXMgc2hvdWxkIGJlIHVzZWQgZHVyaW5nIHRoZSByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0gZHVtcEZvckRlYnVnIERlZmluZSBpZiB0aGUgcmVuZGVyaW5nIHJlc3VsdCBzaG91bGQgYmUgZHVtcGVkIChjb3BpZWQpIGZvciBkZWJ1Z2dpbmcgcHVycG9zZVxuICAgICAqL1xuICAgIHJlbmRlcih1c2VDYW1lcmFQb3N0UHJvY2VzcyA9IGZhbHNlLCBkdW1wRm9yRGVidWcgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXIodXNlQ2FtZXJhUG9zdFByb2Nlc3MsIGR1bXBGb3JEZWJ1Zyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjaGVjayBpZiB0aGUgcmVuZGVyIHRhcmdldCB0ZXh0dXJlIGNhbiBiZSByZW5kZXJlZCAodGV4dHVyZXMgYXJlIGxvYWRlZCwgc2hhZGVycyBhcmUgY29tcGlsZWQpXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBhbGwgcmVxdWlyZWQgcmVzb3VyY2VzIGFyZSByZWFkeVxuICAgICAqL1xuICAgIGlzUmVhZHlGb3JSZW5kZXJpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZHVtcFRvb2xzTG9hZGluZykge1xuICAgICAgICAgICAgdGhpcy5fZHVtcFRvb2xzTG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAvLyBhdm9pZCBhIHN0YXRpYyBpbXBvcnQgdG8gYWxsb3cgaWdub3JpbmcgdGhlIGltcG9ydCBpbiBzb21lIGNhc2VzXG4gICAgICAgICAgICBpbXBvcnQoXCIuLi8uLi9NaXNjL2R1bXBUb29scy5qc1wiKS50aGVuKChtb2R1bGUpID0+ICh0aGlzLl9kdW1wVG9vbHMgPSBtb2R1bGUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5wcmVwYXJlUmVuZGVyTGlzdCgpO1xuICAgICAgICB0aGlzLm9uQmVmb3JlQmluZE9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5pbml0UmVuZGVyKHRoaXMuZ2V0UmVuZGVyV2lkdGgoKSwgdGhpcy5nZXRSZW5kZXJIZWlnaHQoKSk7XG4gICAgICAgIGNvbnN0IGlzUmVhZHkgPSB0aGlzLl9vYmplY3RSZW5kZXJlci5fY2hlY2tSZWFkaW5lc3MoKTtcbiAgICAgICAgdGhpcy5vbkFmdGVyVW5iaW5kT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnModGhpcyk7XG4gICAgICAgIHRoaXMuX29iamVjdFJlbmRlcmVyLmZpbmlzaFJlbmRlcigpO1xuICAgICAgICByZXR1cm4gaXNSZWFkeTtcbiAgICB9XG4gICAgX3JlbmRlcih1c2VDYW1lcmFQb3N0UHJvY2VzcyA9IGZhbHNlLCBkdW1wRm9yRGVidWcgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoKTtcbiAgICAgICAgaWYgKCFzY2VuZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVzZUNhbWVyYVBvc3RQcm9jZXNzZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXNlQ2FtZXJhUG9zdFByb2Nlc3MgPSB0aGlzLnVzZUNhbWVyYVBvc3RQcm9jZXNzZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2JqZWN0UmVuZGVyZXIucHJlcGFyZVJlbmRlckxpc3QoKTtcbiAgICAgICAgdGhpcy5vbkJlZm9yZUJpbmRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyh0aGlzKTtcbiAgICAgICAgdGhpcy5fb2JqZWN0UmVuZGVyZXIuaW5pdFJlbmRlcih0aGlzLmdldFJlbmRlcldpZHRoKCksIHRoaXMuZ2V0UmVuZGVySGVpZ2h0KCkpO1xuICAgICAgICBpZiAoKHRoaXMuaXMyREFycmF5IHx8IHRoaXMuaXMzRCkgJiYgIXRoaXMuaXNNdWx0aSkge1xuICAgICAgICAgICAgZm9yIChsZXQgbGF5ZXIgPSAwOyBsYXllciA8IHRoaXMuZ2V0UmVuZGVyTGF5ZXJzKCk7IGxheWVyKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUb1RhcmdldCgwLCB1c2VDYW1lcmFQb3N0UHJvY2VzcywgZHVtcEZvckRlYnVnLCBsYXllcik7XG4gICAgICAgICAgICAgICAgc2NlbmUuaW5jcmVtZW50UmVuZGVySWQoKTtcbiAgICAgICAgICAgICAgICBzY2VuZS5yZXNldENhY2hlZE1hdGVyaWFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0N1YmUgJiYgIXRoaXMuaXNNdWx0aSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCA2OyBmYWNlKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUb1RhcmdldChmYWNlLCB1c2VDYW1lcmFQb3N0UHJvY2VzcywgZHVtcEZvckRlYnVnKTtcbiAgICAgICAgICAgICAgICBzY2VuZS5pbmNyZW1lbnRSZW5kZXJJZCgpO1xuICAgICAgICAgICAgICAgIHNjZW5lLnJlc2V0Q2FjaGVkTWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRvVGFyZ2V0KDAsIHVzZUNhbWVyYVBvc3RQcm9jZXNzLCBkdW1wRm9yRGVidWcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25BZnRlclVuYmluZE9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5maW5pc2hSZW5kZXIoKTtcbiAgICB9XG4gICAgX2Jlc3RSZWZsZWN0aW9uUmVuZGVyVGFyZ2V0RGltZW5zaW9uKHJlbmRlckRpbWVuc2lvbiwgc2NhbGUpIHtcbiAgICAgICAgY29uc3QgbWluaW11bSA9IDEyODtcbiAgICAgICAgY29uc3QgeCA9IHJlbmRlckRpbWVuc2lvbiAqIHNjYWxlO1xuICAgICAgICBjb25zdCBjdXJ2ZWQgPSBOZWFyZXN0UE9UKHggKyAobWluaW11bSAqIG1pbmltdW0pIC8gKG1pbmltdW0gKyB4KSk7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBleGNlZWQgdGhlIHJlbmRlciBkaW1lbnNpb24gKHdoaWxlIHN0YXlpbmcgUE9UKVxuICAgICAgICByZXR1cm4gTWF0aC5taW4oRmxvb3JQT1QocmVuZGVyRGltZW5zaW9uKSwgY3VydmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIGZhY2VJbmRleCBmYWNlIGluZGV4IHRvIGJpbmQgdG8gaWYgdGhpcyBpcyBhIGN1YmV0ZXh0dXJlXG4gICAgICogQHBhcmFtIGxheWVyIGRlZmluZXMgdGhlIGluZGV4IG9mIHRoZSB0ZXh0dXJlIHRvIGJpbmQgaW4gdGhlIGFycmF5XG4gICAgICovXG4gICAgX2JpbmRGcmFtZUJ1ZmZlcihmYWNlSW5kZXggPSAwLCBsYXllciA9IDApIHtcbiAgICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzLmdldFNjZW5lKCk7XG4gICAgICAgIGlmICghc2NlbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmdpbmUgPSBzY2VuZS5nZXRFbmdpbmUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgZW5naW5lLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9yZW5kZXJUYXJnZXQsIHRoaXMuaXNDdWJlID8gZmFjZUluZGV4IDogdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcy5pZ25vcmVDYW1lcmFWaWV3cG9ydCwgMCwgbGF5ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91bmJpbmRGcmFtZUJ1ZmZlcihlbmdpbmUsIGZhY2VJbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVuZ2luZS51bkJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9yZW5kZXJUYXJnZXQsIHRoaXMuaXNDdWJlLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQWZ0ZXJSZW5kZXJPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhmYWNlSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3ByZXBhcmVGcmFtZShzY2VuZSwgZmFjZUluZGV4LCBsYXllciwgdXNlQ2FtZXJhUG9zdFByb2Nlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Bvc3RQcm9jZXNzTWFuYWdlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcmVQYXNzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc3RQcm9jZXNzTWFuYWdlci5fcHJlcGFyZUZyYW1lKHRoaXMuX3RleHR1cmUsIHRoaXMuX3Bvc3RQcm9jZXNzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF1c2VDYW1lcmFQb3N0UHJvY2VzcyB8fCAhc2NlbmUucG9zdFByb2Nlc3NNYW5hZ2VyLl9wcmVwYXJlRnJhbWUodGhpcy5fdGV4dHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRGcmFtZUJ1ZmZlcihmYWNlSW5kZXgsIGxheWVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVuZGVyVG9UYXJnZXQoZmFjZUluZGV4LCB1c2VDYW1lcmFQb3N0UHJvY2VzcywgZHVtcEZvckRlYnVnLCBsYXllciA9IDApIHtcbiAgICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzLmdldFNjZW5lKCk7XG4gICAgICAgIGlmICghc2NlbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmdpbmUgPSBzY2VuZS5nZXRFbmdpbmUoKTtcbiAgICAgICAgdGhpcy5fY3VycmVudEZhY2VJbmRleCA9IGZhY2VJbmRleDtcbiAgICAgICAgdGhpcy5fY3VycmVudExheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRVc2VDYW1lcmFQb3N0UHJvY2VzcyA9IHVzZUNhbWVyYVBvc3RQcm9jZXNzO1xuICAgICAgICB0aGlzLl9jdXJyZW50RHVtcEZvckRlYnVnID0gZHVtcEZvckRlYnVnO1xuICAgICAgICB0aGlzLl9wcmVwYXJlRnJhbWUoc2NlbmUsIGZhY2VJbmRleCwgbGF5ZXIsIHVzZUNhbWVyYVBvc3RQcm9jZXNzKTtcbiAgICAgICAgZW5naW5lLl9kZWJ1Z1B1c2hHcm91cD8uKGByZW5kZXIgdG8gZmFjZSAjJHtmYWNlSW5kZXh9IGxheWVyICMke2xheWVyfWAsIDIpO1xuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5yZW5kZXIoZmFjZUluZGV4ICsgbGF5ZXIsIHRydWUpOyAvLyBvbmx5IGZhY2VJbmRleCBvciBsYXllciAoaWYgYW55KSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDAgKHdlIGRvbid0IHN1cHBvcnQgYXJyYXkgb2YgY3ViZXMpLCBzbyBpdCdzIHNhZmUgdG8gYWRkIHRoZW0gdG8gZ2V0IHRoZSBwYXNzIGluZGV4XG4gICAgICAgIGVuZ2luZS5fZGVidWdQb3BHcm91cD8uKDIpO1xuICAgICAgICB0aGlzLl91bmJpbmRGcmFtZUJ1ZmZlcihlbmdpbmUsIGZhY2VJbmRleCk7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlICYmIHRoaXMuaXNDdWJlICYmIGZhY2VJbmRleCA9PT0gNSkge1xuICAgICAgICAgICAgZW5naW5lLmdlbmVyYXRlTWlwTWFwc0ZvckN1YmVtYXAodGhpcy5fdGV4dHVyZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IHNvcnQgZnVuY3Rpb24gYXBwbGllZCBpbiB0aGUgcmVuZGVyaW5nIGdyb3VwIHRvIHByZXBhcmUgdGhlIG1lc2hlcy5cbiAgICAgKiBUaGlzIGFsbG93ZWQgY29udHJvbCBmb3IgZnJvbnQgdG8gYmFjayByZW5kZXJpbmcgb3IgcmV2ZXJzZWx5IGRlcGVuZGluZyBvZiB0aGUgc3BlY2lhbCBuZWVkcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZW5kZXJpbmdHcm91cElkIFRoZSByZW5kZXJpbmcgZ3JvdXAgaWQgY29ycmVzcG9uZGluZyB0byBpdHMgaW5kZXhcbiAgICAgKiBAcGFyYW0gb3BhcXVlU29ydENvbXBhcmVGbiBUaGUgb3BhcXVlIHF1ZXVlIGNvbXBhcmlzb24gZnVuY3Rpb24gdXNlIHRvIHNvcnQuXG4gICAgICogQHBhcmFtIGFscGhhVGVzdFNvcnRDb21wYXJlRm4gVGhlIGFscGhhIHRlc3QgcXVldWUgY29tcGFyaXNvbiBmdW5jdGlvbiB1c2UgdG8gc29ydC5cbiAgICAgKiBAcGFyYW0gdHJhbnNwYXJlbnRTb3J0Q29tcGFyZUZuIFRoZSB0cmFuc3BhcmVudCBxdWV1ZSBjb21wYXJpc29uIGZ1bmN0aW9uIHVzZSB0byBzb3J0LlxuICAgICAqL1xuICAgIHNldFJlbmRlcmluZ09yZGVyKHJlbmRlcmluZ0dyb3VwSWQsIG9wYXF1ZVNvcnRDb21wYXJlRm4gPSBudWxsLCBhbHBoYVRlc3RTb3J0Q29tcGFyZUZuID0gbnVsbCwgdHJhbnNwYXJlbnRTb3J0Q29tcGFyZUZuID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5zZXRSZW5kZXJpbmdPcmRlcihyZW5kZXJpbmdHcm91cElkLCBvcGFxdWVTb3J0Q29tcGFyZUZuLCBhbHBoYVRlc3RTb3J0Q29tcGFyZUZuLCB0cmFuc3BhcmVudFNvcnRDb21wYXJlRm4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhlIHN0ZW5jaWwgYW5kIGRlcHRoIGJ1ZmZlciBhcmUgY2xlYXJlZCBiZXR3ZWVuIHR3byByZW5kZXJpbmcgZ3JvdXBzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbmRlcmluZ0dyb3VwSWQgVGhlIHJlbmRlcmluZyBncm91cCBpZCBjb3JyZXNwb25kaW5nIHRvIGl0cyBpbmRleFxuICAgICAqIEBwYXJhbSBhdXRvQ2xlYXJEZXB0aFN0ZW5jaWwgQXV0b21hdGljYWxseSBjbGVhcnMgZGVwdGggYW5kIHN0ZW5jaWwgYmV0d2VlbiBncm91cHMgaWYgdHJ1ZS5cbiAgICAgKi9cbiAgICBzZXRSZW5kZXJpbmdBdXRvQ2xlYXJEZXB0aFN0ZW5jaWwocmVuZGVyaW5nR3JvdXBJZCwgYXV0b0NsZWFyRGVwdGhTdGVuY2lsKSB7XG4gICAgICAgIHRoaXMuX29iamVjdFJlbmRlcmVyLnNldFJlbmRlcmluZ0F1dG9DbGVhckRlcHRoU3RlbmNpbChyZW5kZXJpbmdHcm91cElkLCBhdXRvQ2xlYXJEZXB0aFN0ZW5jaWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgdGhlIHRleHR1cmUuXG4gICAgICogQHJldHVybnMgdGhlIGNsb25lZCB0ZXh0dXJlXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmVTaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICAgIGNvbnN0IG5ld1RleHR1cmUgPSBuZXcgUmVuZGVyVGFyZ2V0VGV4dHVyZSh0aGlzLm5hbWUsIHRleHR1cmVTaXplLCB0aGlzLmdldFNjZW5lKCksIHRoaXMuX3JlbmRlclRhcmdldE9wdGlvbnMuZ2VuZXJhdGVNaXBNYXBzLCB0aGlzLl9kb05vdENoYW5nZUFzcGVjdFJhdGlvLCB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zLnR5cGUsIHRoaXMuaXNDdWJlLCB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zLnNhbXBsaW5nTW9kZSwgdGhpcy5fcmVuZGVyVGFyZ2V0T3B0aW9ucy5nZW5lcmF0ZURlcHRoQnVmZmVyLCB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zLmdlbmVyYXRlU3RlbmNpbEJ1ZmZlciwgdW5kZWZpbmVkLCB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zLmZvcm1hdCwgdW5kZWZpbmVkLCB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zLnNhbXBsZXMpO1xuICAgICAgICAvLyBCYXNlIHRleHR1cmVcbiAgICAgICAgbmV3VGV4dHVyZS5oYXNBbHBoYSA9IHRoaXMuaGFzQWxwaGE7XG4gICAgICAgIG5ld1RleHR1cmUubGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgICAvLyBSZW5kZXJUYXJnZXQgVGV4dHVyZVxuICAgICAgICBuZXdUZXh0dXJlLmNvb3JkaW5hdGVzTW9kZSA9IHRoaXMuY29vcmRpbmF0ZXNNb2RlO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJMaXN0KSB7XG4gICAgICAgICAgICBuZXdUZXh0dXJlLnJlbmRlckxpc3QgPSB0aGlzLnJlbmRlckxpc3Quc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1RleHR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgdGV4dHVyZSB0byBhIEpTT04gcmVwcmVzZW50YXRpb24gd2UgY2FuIGVhc2lseSB1c2UgaW4gdGhlIHJlc3BlY3RpdmUgUGFyc2UgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMgVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRleHR1cmVcbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGlmICghdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpYWxpemF0aW9uT2JqZWN0ID0gc3VwZXIuc2VyaWFsaXplKCk7XG4gICAgICAgIHNlcmlhbGl6YXRpb25PYmplY3QucmVuZGVyVGFyZ2V0U2l6ZSA9IHRoaXMuZ2V0UmVuZGVyU2l6ZSgpO1xuICAgICAgICBzZXJpYWxpemF0aW9uT2JqZWN0LnJlbmRlckxpc3QgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyTGlzdCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucmVuZGVyTGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uT2JqZWN0LnJlbmRlckxpc3QucHVzaCh0aGlzLnJlbmRlckxpc3RbaW5kZXhdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXphdGlvbk9iamVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgd2lsbCByZW1vdmUgdGhlIGF0dGFjaGVkIGZyYW1lYnVmZmVyIG9iamVjdHMuIFRoZSB0ZXh0dXJlIHdpbGwgbm90IGJlIGFibGUgdG8gYmUgdXNlZCBhcyByZW5kZXIgdGFyZ2V0IGFueW1vcmVcbiAgICAgKi9cbiAgICBkaXNwb3NlRnJhbWVidWZmZXJPYmplY3RzKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQ/LmRpc3Bvc2UodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgYW5kIGRlc3Ryb3kgdGhlIHVuZGVybHlpbmcgbG93ZXIgbGV2ZWwgdGV4dHVyZSBha2EgaW50ZXJuYWxUZXh0dXJlLlxuICAgICAqL1xuICAgIHJlbGVhc2VJbnRlcm5hbFRleHR1cmUoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldD8ucmVsZWFzZVRleHR1cmVzKCk7XG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHRoZSB0ZXh0dXJlIGFuZCByZWxlYXNlIGl0cyBhc3NvY2lhdGVkIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLm9uUmVzaXplT2JzZXJ2YWJsZS5jbGVhcigpO1xuICAgICAgICB0aGlzLm9uQ2xlYXJPYnNlcnZhYmxlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMub25BZnRlclVuYmluZE9ic2VydmFibGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5vbkJlZm9yZUJpbmRPYnNlcnZhYmxlLmNsZWFyKCk7XG4gICAgICAgIGlmICh0aGlzLl9wb3N0UHJvY2Vzc01hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc3RQcm9jZXNzTWFuYWdlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9wb3N0UHJvY2Vzc01hbmFnZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcmVQYXNzUmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9wcmVQYXNzUmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5vbkJlZm9yZVJlbmRlcmluZ01hbmFnZXJSZW5kZXJPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9vbkJlZm9yZVJlbmRlcmluZ01hbmFnZXJSZW5kZXJPYnNlcnZlcik7XG4gICAgICAgIHRoaXMuX29iamVjdFJlbmRlcmVyLm9uQWZ0ZXJSZW5kZXJpbmdNYW5hZ2VyUmVuZGVyT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25BZnRlclJlbmRlcmluZ01hbmFnZXJSZW5kZXJPYnNlcnZlcik7XG4gICAgICAgIHRoaXMuX29iamVjdFJlbmRlcmVyLm9uRmFzdFBhdGhSZW5kZXJPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9vbkZhc3RQYXRoUmVuZGVyT2JzZXJ2ZXIpO1xuICAgICAgICBpZiAoIXRoaXMuX2RvbnREaXNwb3NlT2JqZWN0UmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdFJlbmRlcmVyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyUG9zdFByb2Nlc3Nlcyh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmdldFNjZW5lKCkuZ2V0RW5naW5lKCkub25SZXNpemVPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9yZXNpemVPYnNlcnZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gY3VzdG9tIHJlbmRlciB0YXJnZXRzXG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5nZXRTY2VuZSgpO1xuICAgICAgICBpZiAoIXNjZW5lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4ID0gc2NlbmUuY3VzdG9tUmVuZGVyVGFyZ2V0cy5pbmRleE9mKHRoaXMpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgc2NlbmUuY3VzdG9tUmVuZGVyVGFyZ2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2FtZXJhIG9mIHNjZW5lLmNhbWVyYXMpIHtcbiAgICAgICAgICAgIGluZGV4ID0gY2FtZXJhLmN1c3RvbVJlbmRlclRhcmdldHMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY2FtZXJhLmN1c3RvbVJlbmRlclRhcmdldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQ/LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9yZWJ1aWxkKCkge1xuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5fcmVidWlsZCgpO1xuICAgICAgICBpZiAodGhpcy5fcG9zdFByb2Nlc3NNYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3N0UHJvY2Vzc01hbmFnZXIuX3JlYnVpbGQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgaW5mbyByZWxhdGVkIHRvIHJlbmRlcmluZyBncm91cHMgcHJldmVudGluZyByZXRlbnRpb24gcG9pbnQgaW4gbWF0ZXJpYWwgZGlzcG9zZS5cbiAgICAgKi9cbiAgICBmcmVlUmVuZGVyaW5nR3JvdXBzKCkge1xuICAgICAgICB0aGlzLl9vYmplY3RSZW5kZXJlci5mcmVlUmVuZGVyaW5nR3JvdXBzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiB2aWV3cyB0aGUgY29ycmVzcG9uZGluZyB0byB0aGUgdGV4dHVyZSAoZWcuIGEgTXVsdGl2aWV3UmVuZGVyVGFyZ2V0IHdpbGwgaGF2ZSA+IDEpXG4gICAgICogQHJldHVybnMgdGhlIHZpZXcgY291bnRcbiAgICAgKi9cbiAgICBnZXRWaWV3Q291bnQoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHRleHR1cmUgd2lsbCBvbmx5IGJlIHJlbmRlcmVkIG9uY2Ugd2hpY2ggY2FuIGJlIHVzZWZ1bCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIGlmIGV2ZXJ5dGhpbmcgaW4geW91ciByZW5kZXIgaXMgc3RhdGljIGZvciBpbnN0YW5jZS5cbiAqL1xuUmVuZGVyVGFyZ2V0VGV4dHVyZS5SRUZSRVNIUkFURV9SRU5ERVJfT05DRSA9IE9iamVjdFJlbmRlcmVyLlJFRlJFU0hSQVRFX1JFTkRFUl9PTkNFO1xuLyoqXG4gKiBUaGUgdGV4dHVyZSB3aWxsIGJlIHJlbmRlcmVkIGV2ZXJ5IGZyYW1lIGFuZCBpcyByZWNvbW1lbmRlZCBmb3IgZHluYW1pYyBjb250ZW50cy5cbiAqL1xuUmVuZGVyVGFyZ2V0VGV4dHVyZS5SRUZSRVNIUkFURV9SRU5ERVJfT05FVkVSWUZSQU1FID0gT2JqZWN0UmVuZGVyZXIuUkVGUkVTSFJBVEVfUkVOREVSX09ORVZFUllGUkFNRTtcbi8qKlxuICogVGhlIHRleHR1cmUgd2lsbCBiZSByZW5kZXJlZCBldmVyeSAyIGZyYW1lcyB3aGljaCBjb3VsZCBiZSBlbm91Z2ggaWYgeW91ciBkeW5hbWljIG9iamVjdHMgYXJlIG5vdFxuICogdGhlIGNlbnRyYWwgcG9pbnQgb2YgeW91ciBlZmZlY3QgYW5kIGNhbiBzYXZlIGEgbG90IG9mIHBlcmZvcm1hbmNlcy5cbiAqL1xuUmVuZGVyVGFyZ2V0VGV4dHVyZS5SRUZSRVNIUkFURV9SRU5ERVJfT05FVkVSWVRXT0ZSQU1FUyA9IE9iamVjdFJlbmRlcmVyLlJFRlJFU0hSQVRFX1JFTkRFUl9PTkVWRVJZVFdPRlJBTUVTO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuVGV4dHVyZS5fQ3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IChuYW1lLCByZW5kZXJUYXJnZXRTaXplLCBzY2VuZSwgZ2VuZXJhdGVNaXBNYXBzLCBjcmVhdGlvbkZsYWdzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBSZW5kZXJUYXJnZXRUZXh0dXJlKG5hbWUsIHJlbmRlclRhcmdldFNpemUsIHNjZW5lLCBnZW5lcmF0ZU1pcE1hcHMpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlclRhcmdldFRleHR1cmUuanMubWFwIiwiXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGZvcm1hdCBpcyBhIGRlcHRoIHRleHR1cmUgZm9ybWF0XG4gKiBAcGFyYW0gZm9ybWF0IEZvcm1hdCB0byBjaGVja1xuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZm9ybWF0IGlzIGEgZGVwdGggdGV4dHVyZSBmb3JtYXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIElzRGVwdGhUZXh0dXJlKGZvcm1hdCkge1xuICAgIHJldHVybiAoZm9ybWF0ID09PSAxMyB8fFxuICAgICAgICBmb3JtYXQgPT09IDE0IHx8XG4gICAgICAgIGZvcm1hdCA9PT0gMTUgfHxcbiAgICAgICAgZm9ybWF0ID09PSAxNiB8fFxuICAgICAgICBmb3JtYXQgPT09IDE3IHx8XG4gICAgICAgIGZvcm1hdCA9PT0gMTggfHxcbiAgICAgICAgZm9ybWF0ID09PSAxOSk7XG59XG4vKipcbiAqIEdldHMgdGhlIHR5cGUgb2YgYSBkZXB0aCB0ZXh0dXJlIGZvciBhIGdpdmVuIGZvcm1hdFxuICogQHBhcmFtIGZvcm1hdCBGb3JtYXQgb2YgdGhlIHRleHR1cmVcbiAqIEByZXR1cm5zIFRoZSB0eXBlIG9mIHRoZSBkZXB0aCB0ZXh0dXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRUeXBlRm9yRGVwdGhUZXh0dXJlKGZvcm1hdCkge1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBmb3JtYXQgaGFzIGEgc3RlbmNpbCBhc3BlY3RcbiAqIEBwYXJhbSBmb3JtYXQgRm9ybWF0IHRvIGNoZWNrXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBmb3JtYXQgaGFzIGEgc3RlbmNpbCBhc3BlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEhhc1N0ZW5jaWxBc3BlY3QoZm9ybWF0KSB7XG4gICAgcmV0dXJuIChmb3JtYXQgPT09IDEzIHx8XG4gICAgICAgIGZvcm1hdCA9PT0gMTcgfHxcbiAgICAgICAgZm9ybWF0ID09PSAxOCB8fFxuICAgICAgICBmb3JtYXQgPT09IDE5KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHR1cmVIZWxwZXIuZnVuY3Rpb25zLmpzLm1hcCIsIi8qKlxuICogRGV0ZWN0IGlmIHRoZSBlZmZlY3QgaXMgYSBEcmF3V3JhcHBlclxuICogQHBhcmFtIGVmZmVjdCBkZWZpbmVzIHRoZSBlbnRpdHkgdG8gdGVzdFxuICogQHJldHVybnMgaWYgdGhlIGVudGl0eSBpcyBhIERyYXdXcmFwcGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBJc1dyYXBwZXIoZWZmZWN0KSB7XG4gICAgcmV0dXJuIGVmZmVjdC5nZXRQaXBlbGluZUNvbnRleHQgPT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYXdXcmFwcGVyLmZ1bmN0aW9ucy5qcy5tYXAiLCJpbXBvcnQgeyBUaW1pbmdUb29scyB9IGZyb20gXCIuLi9NaXNjL3RpbWluZ1Rvb2xzLmpzXCI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgRHJhd1dyYXBwZXIge1xuICAgIHN0YXRpYyBHZXRFZmZlY3QoZWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBlZmZlY3QuZ2V0UGlwZWxpbmVDb250ZXh0ID09PSB1bmRlZmluZWQgPyBlZmZlY3QuZWZmZWN0IDogZWZmZWN0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIGNyZWF0ZU1hdGVyaWFsQ29udGV4dCA9IHRydWUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGVmZmVjdCB3YXMgcHJldmlvdXNseSByZWFkeVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fd2FzUHJldmlvdXNseVJlYWR5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogRm9yY2VzIHRoZSBjb2RlIGZyb20gYmluZEZvclN1Yk1lc2ggdG8gYmUgZnVsbHkgcnVuIHRoZSBuZXh0IHRpbWUgaXQgaXMgY2FsbGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9mb3JjZVJlYmluZE9uTmV4dENhbGwgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIFNwZWNpZmllcyBpZiB0aGUgZWZmZWN0IHdhcyBwcmV2aW91c2x5IHVzaW5nIGluc3RhbmNlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fd2FzUHJldmlvdXNseVVzaW5nSW5zdGFuY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5lZmZlY3QgPSBudWxsO1xuICAgICAgICB0aGlzLmRlZmluZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmRyYXdDb250ZXh0ID0gZW5naW5lLmNyZWF0ZURyYXdDb250ZXh0KCk7XG4gICAgICAgIGlmIChjcmVhdGVNYXRlcmlhbENvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxDb250ZXh0ID0gZW5naW5lLmNyZWF0ZU1hdGVyaWFsQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEVmZmVjdChlZmZlY3QsIGRlZmluZXMsIHJlc2V0Q29udGV4dCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5lZmZlY3QgPSBlZmZlY3Q7XG4gICAgICAgIGlmIChkZWZpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcyA9IGRlZmluZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2V0Q29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3Q29udGV4dD8ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHRoZSBlZmZlY3Qgd3JhcHBlciBhbmQgaXRzIHJlc291cmNlc1xuICAgICAqIEBwYXJhbSBpbW1lZGlhdGUgaWYgdGhlIGVmZmVjdCBzaG91bGQgYmUgZGlzcG9zZWQgaW1tZWRpYXRlbHkgb3Igb24gdGhlIG5leHQgZnJhbWUuXG4gICAgICogSWYgZGlzcG9zZSgpIGlzIG5vdCBjYWxsZWQgZHVyaW5nIGEgc2NlbmUgb3IgZW5naW5lIGRpc3Bvc2UsIHdlIHdhbnQgdG8gZGVsYXkgdGhlIGRpc3Bvc2Ugb2YgdGhlIHVuZGVybHlpbmcgZWZmZWN0LiBNb3N0bHkgdG8gZ2l2ZSBhIGNoYW5jZSB0byB1c2VyIGNvZGUgdG8gcmV1c2UgdGhlIGVmZmVjdCBpbiBzb21lIHdheS5cbiAgICAgKi9cbiAgICBkaXNwb3NlKGltbWVkaWF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmVmZmVjdCkge1xuICAgICAgICAgICAgY29uc3QgZWZmZWN0ID0gdGhpcy5lZmZlY3Q7XG4gICAgICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFRpbWluZ1Rvb2xzLlNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdC5nZXRFbmdpbmUoKS5vbkVuZEZyYW1lT2JzZXJ2YWJsZS5hZGRPbmNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lZmZlY3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhd0NvbnRleHQ/LmRpc3Bvc2UoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmF3V3JhcHBlci5qcy5tYXAiLCJpbXBvcnQgeyBWZXJ0ZXhCdWZmZXIgfSBmcm9tIFwiLi4vQnVmZmVycy9idWZmZXIuanNcIjtcbmltcG9ydCB7IFZpZXdwb3J0IH0gZnJvbSBcIi4uL01hdGhzL21hdGgudmlld3BvcnQuanNcIjtcblxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCIuLi9NaXNjL29ic2VydmFibGUuanNcIjtcbmltcG9ydCB7IEVmZmVjdCB9IGZyb20gXCIuL2VmZmVjdC5qc1wiO1xuaW1wb3J0IHsgRHJhd1dyYXBwZXIgfSBmcm9tIFwiLi9kcmF3V3JhcHBlci5qc1wiO1xuLy8gUHJldmVudHMgRVM2IGlzc3VlIGlmIG5vdCBpbXBvcnRlZC5cbmltcG9ydCBcIi4uL1NoYWRlcnMvcG9zdHByb2Nlc3MudmVydGV4LmpzXCI7XG4vLyBGdWxsc2NyZWVuIHF1YWQgYnVmZmVycyBieSBkZWZhdWx0LlxuY29uc3QgRGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcG9zaXRpb25zOiBbMSwgMSwgLTEsIDEsIC0xLCAtMSwgMSwgLTFdLFxuICAgIGluZGljZXM6IFswLCAxLCAyLCAwLCAyLCAzXSxcbn07XG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byByZW5kZXIgb25lIG9yIG1vcmUgZWZmZWN0cy5cbiAqIFlvdSBjYW4gYWNjZXNzIHRoZSBwcmV2aW91cyByZW5kZXJpbmcgaW4geW91ciBzaGFkZXIgYnkgZGVjbGFyaW5nIGEgc2FtcGxlciBuYW1lZCB0ZXh0dXJlU2FtcGxlclxuICovXG5leHBvcnQgY2xhc3MgRWZmZWN0UmVuZGVyZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZWZmZWN0IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIGVuZ2luZSB0aGUgZW5naW5lIHRvIHVzZSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIG9wdGlvbnMgZGVmaW5lcyB0aGUgb3B0aW9ucyBvZiB0aGUgZWZmZWN0IHJlbmRlcmVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW5naW5lLCBvcHRpb25zID0gRGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fZnVsbHNjcmVlblZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KDAsIDAsIDEsIDEpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBvcHRpb25zLnBvc2l0aW9ucyA/PyBEZWZhdWx0T3B0aW9ucy5wb3NpdGlvbnM7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBvcHRpb25zLmluZGljZXMgPz8gRGVmYXVsdE9wdGlvbnMuaW5kaWNlcztcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlcnMgPSB7XG4gICAgICAgICAgICBbVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZF06IG5ldyBWZXJ0ZXhCdWZmZXIoZW5naW5lLCBwb3NpdGlvbnMsIFZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsIGZhbHNlLCBmYWxzZSwgMiksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luZGV4QnVmZmVyID0gZW5naW5lLmNyZWF0ZUluZGV4QnVmZmVyKGluZGljZXMpO1xuICAgICAgICB0aGlzLl9vbkNvbnRleHRSZXN0b3JlZE9ic2VydmVyID0gZW5naW5lLm9uQ29udGV4dFJlc3RvcmVkT2JzZXJ2YWJsZS5hZGQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faW5kZXhCdWZmZXIgPSBlbmdpbmUuY3JlYXRlSW5kZXhCdWZmZXIoaW5kaWNlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl92ZXJ0ZXhCdWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5fdmVydGV4QnVmZmVyc1trZXldO1xuICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlci5fcmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCB2aWV3cG9ydCBpbiBub3JtYWxpemVkIGNvb3JkaW5hdGVzIDAtMVxuICAgICAqIEBwYXJhbSB2aWV3cG9ydCBEZWZpbmVzIHRoZSB2aWV3cG9ydCB0byBzZXQgKGRlZmF1bHRzIHRvIDAgMCAxIDEpXG4gICAgICovXG4gICAgc2V0Vmlld3BvcnQodmlld3BvcnQgPSB0aGlzLl9mdWxsc2NyZWVuVmlld3BvcnQpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUuc2V0Vmlld3BvcnQodmlld3BvcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgZW1iZWRkZWQgYXR0cmlidXRlcyBidWZmZXIgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0gZWZmZWN0IERlZmluZXMgdGhlIGVmZmVjdCB0byBiaW5kIHRoZSBhdHRyaWJ1dGVzIGZvclxuICAgICAqL1xuICAgIGJpbmRCdWZmZXJzKGVmZmVjdCkge1xuICAgICAgICB0aGlzLmVuZ2luZS5iaW5kQnVmZmVycyh0aGlzLl92ZXJ0ZXhCdWZmZXJzLCB0aGlzLl9pbmRleEJ1ZmZlciwgZWZmZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBlZmZlY3Qgd3JhcHBlciB0byB1c2UgZHVyaW5nIGRyYXcuXG4gICAgICogVGhlIGVmZmVjdCBuZWVkcyB0byBiZSByZWFkeSBiZWZvcmUgY2FsbGluZyB0aGlzIGFwaS5cbiAgICAgKiBUaGlzIGFsc28gc2V0cyB0aGUgZGVmYXVsdCBmdWxsIHNjcmVlbiBwb3NpdGlvbiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIGVmZmVjdFdyYXBwZXIgRGVmaW5lcyB0aGUgZWZmZWN0IHRvIGRyYXcgd2l0aFxuICAgICAqL1xuICAgIGFwcGx5RWZmZWN0V3JhcHBlcihlZmZlY3RXcmFwcGVyKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLnNldFN0YXRlKHRydWUpO1xuICAgICAgICB0aGlzLmVuZ2luZS5kZXB0aEN1bGxpbmdTdGF0ZS5kZXB0aFRlc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmdpbmUuc3RlbmNpbFN0YXRlLnN0ZW5jaWxUZXN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5naW5lLmVuYWJsZUVmZmVjdChlZmZlY3RXcmFwcGVyLmRyYXdXcmFwcGVyKTtcbiAgICAgICAgdGhpcy5iaW5kQnVmZmVycyhlZmZlY3RXcmFwcGVyLmVmZmVjdCk7XG4gICAgICAgIGVmZmVjdFdyYXBwZXIub25BcHBseU9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2F2ZXMgZW5naW5lIHN0YXRlc1xuICAgICAqL1xuICAgIHNhdmVTdGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuX3NhdmVkU3RhdGVEZXB0aFRlc3QgPSB0aGlzLmVuZ2luZS5kZXB0aEN1bGxpbmdTdGF0ZS5kZXB0aFRlc3Q7XG4gICAgICAgIHRoaXMuX3NhdmVkU3RhdGVTdGVuY2lsVGVzdCA9IHRoaXMuZW5naW5lLnN0ZW5jaWxTdGF0ZS5zdGVuY2lsVGVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgZW5naW5lIHN0YXRlc1xuICAgICAqL1xuICAgIHJlc3RvcmVTdGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLmRlcHRoQ3VsbGluZ1N0YXRlLmRlcHRoVGVzdCA9IHRoaXMuX3NhdmVkU3RhdGVEZXB0aFRlc3Q7XG4gICAgICAgIHRoaXMuZW5naW5lLnN0ZW5jaWxTdGF0ZS5zdGVuY2lsVGVzdCA9IHRoaXMuX3NhdmVkU3RhdGVTdGVuY2lsVGVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBmdWxsIHNjcmVlbiBxdWFkLlxuICAgICAqL1xuICAgIGRyYXcoKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLmRyYXdFbGVtZW50c1R5cGUoMCwgMCwgNik7XG4gICAgfVxuICAgIF9pc1JlbmRlclRhcmdldFRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICByZXR1cm4gdGV4dHVyZS5yZW5kZXJUYXJnZXQgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVuZGVycyBvbmUgb3IgbW9yZSBlZmZlY3RzIHRvIGEgc3BlY2lmaWVkIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gZWZmZWN0V3JhcHBlciB0aGUgZWZmZWN0IHRvIHJlbmRlcmVyXG4gICAgICogQHBhcmFtIG91dHB1dFRleHR1cmUgdGV4dHVyZSB0byBkcmF3IHRvLCBpZiBudWxsIGl0IHdpbGwgcmVuZGVyIHRvIHRoZSBjdXJyZW50bHkgYm91bmQgZnJhbWUgYnVmZmVyXG4gICAgICovXG4gICAgcmVuZGVyKGVmZmVjdFdyYXBwZXIsIG91dHB1dFRleHR1cmUgPSBudWxsKSB7XG4gICAgICAgIC8vIEVuc3VyZSBlZmZlY3QgaXMgcmVhZHlcbiAgICAgICAgaWYgKCFlZmZlY3RXcmFwcGVyLmVmZmVjdC5pc1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNhdmVTdGF0ZXMoKTtcbiAgICAgICAgLy8gUmVzZXQgc3RhdGVcbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCgpO1xuICAgICAgICBjb25zdCBvdXQgPSBvdXRwdXRUZXh0dXJlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX2lzUmVuZGVyVGFyZ2V0VGV4dHVyZShvdXRwdXRUZXh0dXJlKSA/IG91dHB1dFRleHR1cmUucmVuZGVyVGFyZ2V0IDogb3V0cHV0VGV4dHVyZTtcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuYmluZEZyYW1lYnVmZmVyKG91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBseUVmZmVjdFdyYXBwZXIoZWZmZWN0V3JhcHBlcik7XG4gICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS51bkJpbmRGcmFtZWJ1ZmZlcihvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdG9yZVN0YXRlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBvZiB0aGUgZWZmZWN0IHJlbmRlcmVyXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5fdmVydGV4QnVmZmVyc1tWZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kXTtcbiAgICAgICAgaWYgKHZlcnRleEJ1ZmZlcikge1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl92ZXJ0ZXhCdWZmZXJzW1ZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmRdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUuX3JlbGVhc2VCdWZmZXIodGhpcy5faW5kZXhCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vbkNvbnRleHRSZXN0b3JlZE9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5vbkNvbnRleHRSZXN0b3JlZE9ic2VydmFibGUucmVtb3ZlKHRoaXMuX29uQ29udGV4dFJlc3RvcmVkT2JzZXJ2ZXIpO1xuICAgICAgICAgICAgdGhpcy5fb25Db250ZXh0UmVzdG9yZWRPYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFdyYXBzIGFuIGVmZmVjdCB0byBiZSB1c2VkIGZvciByZW5kZXJpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIEVmZmVjdFdyYXBwZXIge1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHNoYWRlciBjb2RlIHByb2Nlc3Npbmcgd2l0aCBhbiBlZmZlY3Qgd3JhcHBlciBuYW1lLlxuICAgICAqIEBwYXJhbSBlZmZlY3RXcmFwcGVyTmFtZSBuYW1lIG9mIHRoZSBlZmZlY3Qgd3JhcHBlci4gVXNlIG51bGwgZm9yIHRoZSBmYWxsYmFjayBzaGFkZXIgY29kZSBwcm9jZXNzaW5nLiBUaGlzIGlzIHRoZSBzaGFkZXIgY29kZSBwcm9jZXNzaW5nIHRoYXQgd2lsbCBiZSB1c2VkIGluIGNhc2Ugbm8gc3BlY2lmaWMgc2hhZGVyIGNvZGUgcHJvY2Vzc2luZyBoYXMgYmVlbiBhc3NvY2lhdGVkIHRvIGFuIGVmZmVjdCB3cmFwcGVyIG5hbWVcbiAgICAgKiBAcGFyYW0gY3VzdG9tU2hhZGVyQ29kZVByb2Nlc3Npbmcgc2hhZGVyIGNvZGUgcHJvY2Vzc2luZyB0byBhc3NvY2lhdGUgdG8gdGhlIGVmZmVjdCB3cmFwcGVyIG5hbWVcbiAgICAgKi9cbiAgICBzdGF0aWMgUmVnaXN0ZXJTaGFkZXJDb2RlUHJvY2Vzc2luZyhlZmZlY3RXcmFwcGVyTmFtZSwgY3VzdG9tU2hhZGVyQ29kZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgaWYgKCFjdXN0b21TaGFkZXJDb2RlUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgZGVsZXRlIEVmZmVjdFdyYXBwZXIuX0N1c3RvbVNoYWRlckNvZGVQcm9jZXNzaW5nW2VmZmVjdFdyYXBwZXJOYW1lID8/IFwiXCJdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEVmZmVjdFdyYXBwZXIuX0N1c3RvbVNoYWRlckNvZGVQcm9jZXNzaW5nW2VmZmVjdFdyYXBwZXJOYW1lID8/IFwiXCJdID0gY3VzdG9tU2hhZGVyQ29kZVByb2Nlc3Npbmc7XG4gICAgfVxuICAgIHN0YXRpYyBfR2V0U2hhZGVyQ29kZVByb2Nlc3NpbmcoZWZmZWN0V3JhcHBlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIEVmZmVjdFdyYXBwZXIuX0N1c3RvbVNoYWRlckNvZGVQcm9jZXNzaW5nW2VmZmVjdFdyYXBwZXJOYW1lXSA/PyBFZmZlY3RXcmFwcGVyLl9DdXN0b21TaGFkZXJDb2RlUHJvY2Vzc2luZ1tcIlwiXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBuYW1lIG9mIHRoZSBlZmZlY3Qgd3JhcHBlclxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm5hbWU7XG4gICAgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlIGVmZmVjdCBpcyByZWFkeSB0byBiZSB1c2VkXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zdC1wcm9jZXNzIGlzIHJlYWR5IChzaGFkZXIgaXMgY29tcGlsZWQpXG4gICAgICovXG4gICAgaXNSZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYXdXcmFwcGVyLmVmZmVjdD8uaXNSZWFkeSgpID8/IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRyYXcgd3JhcHBlciBhc3NvY2lhdGVkIHdpdGggdGhlIGVmZmVjdCB3cmFwcGVyXG4gICAgICogQHJldHVybnMgdGhlIGRyYXcgd3JhcHBlciBhc3NvY2lhdGVkIHdpdGggdGhlIGVmZmVjdCB3cmFwcGVyXG4gICAgICovXG4gICAgZ2V0IGRyYXdXcmFwcGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJhd1dyYXBwZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB1bmRlcmx5aW5nIGVmZmVjdFxuICAgICAqL1xuICAgIGdldCBlZmZlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcmF3V3JhcHBlci5lZmZlY3Q7XG4gICAgfVxuICAgIHNldCBlZmZlY3QoZWZmZWN0KSB7XG4gICAgICAgIHRoaXMuX2RyYXdXcmFwcGVyLmVmZmVjdCA9IGVmZmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlZmZlY3QgdG8gYmUgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0gY3JlYXRpb25PcHRpb25zIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBlZmZlY3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjcmVhdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR5cGUgb2YgYWxwaGEgbW9kZSB0byB1c2Ugd2hlbiBhcHBseWluZyB0aGUgZWZmZWN0IChkZWZhdWx0OiBFbmdpbmUuQUxQSEFfRElTQUJMRSkuIFVzZWQgb25seSBpZiB1c2VBc1Bvc3RQcm9jZXNzIGlzIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFscGhhTW9kZSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGVjdXRlZCB3aGVuIHRoZSBlZmZlY3QgaXMgY3JlYXRlZFxuICAgICAgICAgKiBAcmV0dXJucyBlZmZlY3QgdGhhdCB3YXMgY3JlYXRlZCBmb3IgdGhpcyBlZmZlY3Qgd3JhcHBlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkVmZmVjdENyZWF0ZWRPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IHRoYXQgaXMgZmlyZWQgKG9ubHkgd2hlbiB0aGUgRWZmZWN0V3JhcHBlciBpcyB1c2VkIHdpdGggYW4gRWZmZWN0UmVuZGVyZXIpIHJpZ2h0IGJlZm9yZSB0aGUgZWZmZWN0IGlzIGRyYXduIChzaG91bGQgYmUgdXNlZCB0byB1cGRhdGUgdW5pZm9ybXMpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQXBwbHlPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5fc2hhZGVyc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3dlYkdQVVJlYWR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ltcG9ydFByb21pc2VzID0gW107XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLmNyZWF0aW9uT3B0aW9ucyxcbiAgICAgICAgICAgIG5hbWU6IGNyZWF0aW9uT3B0aW9ucy5uYW1lIHx8IFwiZWZmZWN0V3JhcHBlclwiLFxuICAgICAgICAgICAgZW5naW5lOiBjcmVhdGlvbk9wdGlvbnMuZW5naW5lLFxuICAgICAgICAgICAgdW5pZm9ybXM6IGNyZWF0aW9uT3B0aW9ucy51bmlmb3JtcyB8fCBjcmVhdGlvbk9wdGlvbnMudW5pZm9ybU5hbWVzIHx8IFtdLFxuICAgICAgICAgICAgdW5pZm9ybU5hbWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzYW1wbGVyczogY3JlYXRpb25PcHRpb25zLnNhbXBsZXJzIHx8IGNyZWF0aW9uT3B0aW9ucy5zYW1wbGVyTmFtZXMgfHwgW10sXG4gICAgICAgICAgICBzYW1wbGVyTmFtZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWVzOiBjcmVhdGlvbk9wdGlvbnMuYXR0cmlidXRlTmFtZXMgfHwgW1wicG9zaXRpb25cIl0sXG4gICAgICAgICAgICB1bmlmb3JtQnVmZmVyczogY3JlYXRpb25PcHRpb25zLnVuaWZvcm1CdWZmZXJzIHx8IFtdLFxuICAgICAgICAgICAgZGVmaW5lczogY3JlYXRpb25PcHRpb25zLmRlZmluZXMgfHwgXCJcIixcbiAgICAgICAgICAgIHVzZVNoYWRlclN0b3JlOiBjcmVhdGlvbk9wdGlvbnMudXNlU2hhZGVyU3RvcmUgfHwgZmFsc2UsXG4gICAgICAgICAgICB2ZXJ0ZXhVcmw6IGNyZWF0aW9uT3B0aW9ucy52ZXJ0ZXhVcmwgfHwgY3JlYXRpb25PcHRpb25zLnZlcnRleFNoYWRlciB8fCBcInBvc3Rwcm9jZXNzXCIsXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBjcmVhdGlvbk9wdGlvbnMuZnJhZ21lbnRTaGFkZXIgfHwgXCJwYXNzXCIsXG4gICAgICAgICAgICBpbmRleFBhcmFtZXRlcnM6IGNyZWF0aW9uT3B0aW9ucy5pbmRleFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBibG9ja0NvbXBpbGF0aW9uOiBjcmVhdGlvbk9wdGlvbnMuYmxvY2tDb21waWxhdGlvbiB8fCBmYWxzZSxcbiAgICAgICAgICAgIHNoYWRlckxhbmd1YWdlOiBjcmVhdGlvbk9wdGlvbnMuc2hhZGVyTGFuZ3VhZ2UgfHwgMCAvKiBTaGFkZXJMYW5ndWFnZS5HTFNMICovLFxuICAgICAgICAgICAgb25Db21waWxlZDogY3JlYXRpb25PcHRpb25zLm9uQ29tcGlsZWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXh0cmFJbml0aWFsaXphdGlvbnM6IGNyZWF0aW9uT3B0aW9ucy5leHRyYUluaXRpYWxpemF0aW9ucyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBleHRyYUluaXRpYWxpemF0aW9uc0FzeW5jOiBjcmVhdGlvbk9wdGlvbnMuZXh0cmFJbml0aWFsaXphdGlvbnNBc3luYyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICB1c2VBc1Bvc3RQcm9jZXNzOiBjcmVhdGlvbk9wdGlvbnMudXNlQXNQb3N0UHJvY2VzcyA/PyBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnVuaWZvcm1OYW1lcyA9IHRoaXMub3B0aW9ucy51bmlmb3JtcztcbiAgICAgICAgdGhpcy5vcHRpb25zLnNhbXBsZXJOYW1lcyA9IHRoaXMub3B0aW9ucy5zYW1wbGVycztcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcnRleFNoYWRlciA9IHRoaXMub3B0aW9ucy52ZXJ0ZXhVcmw7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlQXNQb3N0UHJvY2Vzcykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYW1wbGVycy5pbmRleE9mKFwidGV4dHVyZVNhbXBsZXJcIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNhbXBsZXJzLnB1c2goXCJ0ZXh0dXJlU2FtcGxlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudW5pZm9ybXMuaW5kZXhPZihcInNjYWxlXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy51bmlmb3Jtcy5wdXNoKFwic2NhbGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNyZWF0aW9uT3B0aW9ucy52ZXJ0ZXhVcmwgfHwgY3JlYXRpb25PcHRpb25zLnZlcnRleFNoYWRlcikge1xuICAgICAgICAgICAgdGhpcy5fc2hhZGVyUGF0aCA9IHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTb3VyY2U6IHRoaXMub3B0aW9ucy52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudXNlQXNQb3N0UHJvY2Vzcykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy51bmlmb3Jtcy5wdXNoKFwic2NhbGVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFwcGx5T2JzZXJ2YWJsZS5hZGQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdC5zZXRGbG9hdDIoXCJzY2FsZVwiLCAxLCAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NoYWRlclBhdGggPSB7XG4gICAgICAgICAgICAgICAgdmVydGV4OiB0aGlzLm9wdGlvbnMudmVydGV4U2hhZGVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaGFkZXJQYXRoLmZyYWdtZW50U291cmNlID0gdGhpcy5vcHRpb25zLmZyYWdtZW50U2hhZGVyO1xuICAgICAgICB0aGlzLl9zaGFkZXJQYXRoLnNwZWN0b3JOYW1lID0gdGhpcy5vcHRpb25zLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlU2hhZGVyU3RvcmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlclBhdGguZnJhZ21lbnQgPSB0aGlzLl9zaGFkZXJQYXRoLmZyYWdtZW50U291cmNlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zaGFkZXJQYXRoLnZlcnRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRlclBhdGgudmVydGV4ID0gdGhpcy5fc2hhZGVyUGF0aC52ZXJ0ZXhTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2hhZGVyUGF0aC5mcmFnbWVudFNvdXJjZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zaGFkZXJQYXRoLnZlcnRleFNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQXBwbHlPYnNlcnZhYmxlLmFkZCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnVzZVNoYWRlclN0b3JlKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbnRleHRSZXN0b3JlZE9ic2VydmVyID0gdGhpcy5vcHRpb25zLmVuZ2luZS5vbkNvbnRleHRSZXN0b3JlZE9ic2VydmFibGUuYWRkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdC5fcGlwZWxpbmVDb250ZXh0ID0gbnVsbDsgLy8gYmVjYXVzZSBfcHJlcGFyZUVmZmVjdCB3aWxsIHRyeSB0byBkaXNwb3NlIHRoaXMgcGlwZWxpbmUgYmVmb3JlIHJlY3JlYXRpbmcgaXQgYW5kIHRoYXQgd291bGQgbGVhZCB0byB3ZWJnbCBlcnJvcnNcbiAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdC5fcHJlcGFyZUVmZmVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZHJhd1dyYXBwZXIgPSBuZXcgRHJhd1dyYXBwZXIodGhpcy5vcHRpb25zLmVuZ2luZSk7XG4gICAgICAgIHRoaXMuX3dlYkdQVVJlYWR5ID0gdGhpcy5vcHRpb25zLnNoYWRlckxhbmd1YWdlID09PSAxIC8qIFNoYWRlckxhbmd1YWdlLldHU0wgKi87XG4gICAgICAgIGNvbnN0IGRlZmluZXMgPSBBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5kZWZpbmVzKSA/IHRoaXMub3B0aW9ucy5kZWZpbmVzLmpvaW4oXCJcXG5cIikgOiB0aGlzLm9wdGlvbnMuZGVmaW5lcztcbiAgICAgICAgdGhpcy5fcG9zdENvbnN0cnVjdG9yKHRoaXMub3B0aW9ucy5ibG9ja0NvbXBpbGF0aW9uLCBkZWZpbmVzLCB0aGlzLm9wdGlvbnMuZXh0cmFJbml0aWFsaXphdGlvbnMpO1xuICAgIH1cbiAgICBfZ2F0aGVySW1wb3J0cyh1c2VXZWJHUFUgPSBmYWxzZSwgbGlzdCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VBc1Bvc3RQcm9jZXNzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5fd2ViR1BVUmVhZHkgaXMgdXNlZCB0byBkZXRlY3Qgd2hlbiBhbiBlZmZlY3Qgd3JhcHBlciBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGggV2ViR1BVXG4gICAgICAgIGlmICh1c2VXZWJHUFUgJiYgdGhpcy5fd2ViR1BVUmVhZHkpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChQcm9taXNlLmFsbChbaW1wb3J0KFwiLi4vU2hhZGVyc1dHU0wvcG9zdHByb2Nlc3MudmVydGV4LmpzXCIpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5wdXNoKFByb21pc2UuYWxsKFtpbXBvcnQoXCIuLi9TaGFkZXJzL3Bvc3Rwcm9jZXNzLnZlcnRleC5qc1wiKV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Bvc3RDb25zdHJ1Y3RvcihibG9ja0NvbXBpbGF0aW9uLCBkZWZpbmVzID0gbnVsbCwgZXh0cmFJbml0aWFsaXphdGlvbnMsIGltcG9ydFByb21pc2VzKSB7XG4gICAgICAgIHRoaXMuX2ltcG9ydFByb21pc2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChpbXBvcnRQcm9taXNlcykge1xuICAgICAgICAgICAgdGhpcy5faW1wb3J0UHJvbWlzZXMucHVzaCguLi5pbXBvcnRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlV2ViR1BVID0gdGhpcy5vcHRpb25zLmVuZ2luZS5pc1dlYkdQVSAmJiAhRWZmZWN0V3JhcHBlci5Gb3JjZUdMU0w7XG4gICAgICAgIHRoaXMuX2dhdGhlckltcG9ydHModXNlV2ViR1BVLCB0aGlzLl9pbXBvcnRQcm9taXNlcyk7XG4gICAgICAgIGlmIChleHRyYUluaXRpYWxpemF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHRyYUluaXRpYWxpemF0aW9ucyh1c2VXZWJHUFUsIHRoaXMuX2ltcG9ydFByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlV2ViR1BVICYmIHRoaXMuX3dlYkdQVVJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hhZGVyTGFuZ3VhZ2UgPSAxIC8qIFNoYWRlckxhbmd1YWdlLldHU0wgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFibG9ja0NvbXBpbGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVmZmVjdChkZWZpbmVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBlZmZlY3Qgd2l0aCB0aGUgY3VycmVudCBlZmZlY3Qgd3JhcHBlciBjb21waWxlIHRpbWUgdmFsdWVzIGFuZCByZWNvbXBpbGVzIHRoZSBzaGFkZXIuXG4gICAgICogQHBhcmFtIGRlZmluZXMgRGVmaW5lIHN0YXRlbWVudHMgdGhhdCBzaG91bGQgYmUgYWRkZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2hhZGVyLiAoZGVmYXVsdDogbnVsbClcbiAgICAgKiBAcGFyYW0gdW5pZm9ybXMgU2V0IG9mIHVuaWZvcm0gdmFyaWFibGVzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHNoYWRlci4gKGRlZmF1bHQ6IG51bGwpXG4gICAgICogQHBhcmFtIHNhbXBsZXJzIFNldCBvZiBUZXh0dXJlMkQgdmFyaWFibGVzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHNoYWRlci4gKGRlZmF1bHQ6IG51bGwpXG4gICAgICogQHBhcmFtIGluZGV4UGFyYW1ldGVycyBUaGUgaW5kZXggcGFyYW1ldGVycyB0byBiZSB1c2VkIGZvciBiYWJ5bG9ucyBpbmNsdWRlIHN5bnRheCBcIiNpbmNsdWRlPGtlcm5lbEJsdXJWYXJ5aW5nRGVjbGFyYXRpb24+WzAuLnZhcnlpbmdDb3VudF1cIi4gKGRlZmF1bHQ6IHVuZGVmaW5lZCkgU2VlIHVzYWdlIGluIGJhYnlsb24uYmx1clBvc3RQcm9jZXNzLnRzIGFuZCBrZXJuZWxCbHVyLnZlcnRleC5meFxuICAgICAqIEBwYXJhbSBvbkNvbXBpbGVkIENhbGxlZCB3aGVuIHRoZSBzaGFkZXIgaGFzIGJlZW4gY29tcGlsZWQuXG4gICAgICogQHBhcmFtIG9uRXJyb3IgQ2FsbGVkIGlmIHRoZXJlIGlzIGFuIGVycm9yIHdoZW4gY29tcGlsaW5nIGEgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB2ZXJ0ZXhVcmwgVGhlIHVybCBvZiB0aGUgdmVydGV4IHNoYWRlciB0byBiZSB1c2VkIChkZWZhdWx0OiB0aGUgb25lIGdpdmVuIGF0IGNvbnN0cnVjdGlvbiB0aW1lKVxuICAgICAqIEBwYXJhbSBmcmFnbWVudFVybCBUaGUgdXJsIG9mIHRoZSBmcmFnbWVudCBzaGFkZXIgdG8gYmUgdXNlZCAoZGVmYXVsdDogdGhlIG9uZSBnaXZlbiBhdCBjb25zdHJ1Y3Rpb24gdGltZSlcbiAgICAgKi9cbiAgICB1cGRhdGVFZmZlY3QoZGVmaW5lcyA9IG51bGwsIHVuaWZvcm1zID0gbnVsbCwgc2FtcGxlcnMgPSBudWxsLCBpbmRleFBhcmFtZXRlcnMsIG9uQ29tcGlsZWQsIG9uRXJyb3IsIHZlcnRleFVybCwgZnJhZ21lbnRVcmwpIHtcbiAgICAgICAgY29uc3QgY3VzdG9tU2hhZGVyQ29kZVByb2Nlc3NpbmcgPSBFZmZlY3RXcmFwcGVyLl9HZXRTaGFkZXJDb2RlUHJvY2Vzc2luZyh0aGlzLm5hbWUpO1xuICAgICAgICBpZiAoY3VzdG9tU2hhZGVyQ29kZVByb2Nlc3Npbmc/LmRlZmluZUN1c3RvbUJpbmRpbmdzKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdVbmlmb3JtcyA9IHVuaWZvcm1zPy5zbGljZSgpID8/IFtdO1xuICAgICAgICAgICAgbmV3VW5pZm9ybXMucHVzaCguLi50aGlzLm9wdGlvbnMudW5pZm9ybXMpO1xuICAgICAgICAgICAgY29uc3QgbmV3U2FtcGxlcnMgPSBzYW1wbGVycz8uc2xpY2UoKSA/PyBbXTtcbiAgICAgICAgICAgIG5ld1NhbXBsZXJzLnB1c2goLi4udGhpcy5vcHRpb25zLnNhbXBsZXJzKTtcbiAgICAgICAgICAgIGRlZmluZXMgPSBjdXN0b21TaGFkZXJDb2RlUHJvY2Vzc2luZy5kZWZpbmVDdXN0b21CaW5kaW5ncyh0aGlzLm5hbWUsIGRlZmluZXMsIG5ld1VuaWZvcm1zLCBuZXdTYW1wbGVycyk7XG4gICAgICAgICAgICB1bmlmb3JtcyA9IG5ld1VuaWZvcm1zO1xuICAgICAgICAgICAgc2FtcGxlcnMgPSBuZXdTYW1wbGVycztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMuZGVmaW5lcyA9IGRlZmluZXMgfHwgXCJcIjtcbiAgICAgICAgY29uc3Qgd2FpdEltcG9ydHNMb2FkZWQgPSB0aGlzLl9zaGFkZXJzTG9hZGVkIHx8IHRoaXMuX2ltcG9ydFByb21pc2VzLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuX2ltcG9ydFByb21pc2VzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFkZXJzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGxldCBleHRyYUluaXRpYWxpemF0aW9uc0FzeW5jO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dHJhSW5pdGlhbGl6YXRpb25zQXN5bmMpIHtcbiAgICAgICAgICAgIGV4dHJhSW5pdGlhbGl6YXRpb25zQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2FpdEltcG9ydHNMb2FkZWQ/LigpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMub3B0aW9ucy5leHRyYUluaXRpYWxpemF0aW9uc0FzeW5jKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXh0cmFJbml0aWFsaXphdGlvbnNBc3luYyA9IHdhaXRJbXBvcnRzTG9hZGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlU2hhZGVyU3RvcmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdXcmFwcGVyLmVmZmVjdCA9IHRoaXMub3B0aW9ucy5lbmdpbmUuY3JlYXRlRWZmZWN0KHsgdmVydGV4OiB2ZXJ0ZXhVcmwgPz8gdGhpcy5fc2hhZGVyUGF0aC52ZXJ0ZXgsIGZyYWdtZW50OiBmcmFnbWVudFVybCA/PyB0aGlzLl9zaGFkZXJQYXRoLmZyYWdtZW50IH0sIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZXMsXG4gICAgICAgICAgICAgICAgdW5pZm9ybXNOYW1lczogdW5pZm9ybXMgfHwgdGhpcy5vcHRpb25zLnVuaWZvcm1zLFxuICAgICAgICAgICAgICAgIHVuaWZvcm1CdWZmZXJzTmFtZXM6IHRoaXMub3B0aW9ucy51bmlmb3JtQnVmZmVycyxcbiAgICAgICAgICAgICAgICBzYW1wbGVyczogc2FtcGxlcnMgfHwgdGhpcy5vcHRpb25zLnNhbXBsZXJzLFxuICAgICAgICAgICAgICAgIGRlZmluZXM6IGRlZmluZXMgIT09IG51bGwgPyBkZWZpbmVzIDogXCJcIixcbiAgICAgICAgICAgICAgICBmYWxsYmFja3M6IG51bGwsXG4gICAgICAgICAgICAgICAgb25Db21waWxlZDogb25Db21waWxlZCA/PyB0aGlzLm9wdGlvbnMub25Db21waWxlZCxcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yID8/IG51bGwsXG4gICAgICAgICAgICAgICAgaW5kZXhQYXJhbWV0ZXJzOiBpbmRleFBhcmFtZXRlcnMgfHwgdGhpcy5vcHRpb25zLmluZGV4UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29kZUFmdGVySW5jbHVkZXM6IGN1c3RvbVNoYWRlckNvZGVQcm9jZXNzaW5nPy5wcm9jZXNzQ29kZUFmdGVySW5jbHVkZXNcbiAgICAgICAgICAgICAgICAgICAgPyAoc2hhZGVyVHlwZSwgY29kZSkgPT4gY3VzdG9tU2hhZGVyQ29kZVByb2Nlc3NpbmcucHJvY2Vzc0NvZGVBZnRlckluY2x1ZGVzKHRoaXMubmFtZSwgc2hhZGVyVHlwZSwgY29kZSlcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NGaW5hbENvZGU6IGN1c3RvbVNoYWRlckNvZGVQcm9jZXNzaW5nPy5wcm9jZXNzRmluYWxDb2RlXG4gICAgICAgICAgICAgICAgICAgID8gKHNoYWRlclR5cGUsIGNvZGUpID0+IGN1c3RvbVNoYWRlckNvZGVQcm9jZXNzaW5nLnByb2Nlc3NGaW5hbENvZGUodGhpcy5uYW1lLCBzaGFkZXJUeXBlLCBjb2RlKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgc2hhZGVyTGFuZ3VhZ2U6IHRoaXMub3B0aW9ucy5zaGFkZXJMYW5ndWFnZSxcbiAgICAgICAgICAgICAgICBleHRyYUluaXRpYWxpemF0aW9uc0FzeW5jLFxuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmVuZ2luZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3V3JhcHBlci5lZmZlY3QgPSBuZXcgRWZmZWN0KHRoaXMuX3NoYWRlclBhdGgsIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVOYW1lcywgdW5pZm9ybXMgfHwgdGhpcy5vcHRpb25zLnVuaWZvcm1zLCBzYW1wbGVycyB8fCB0aGlzLm9wdGlvbnMuc2FtcGxlck5hbWVzLCB0aGlzLm9wdGlvbnMuZW5naW5lLCBkZWZpbmVzLCB1bmRlZmluZWQsIG9uQ29tcGlsZWQgfHwgdGhpcy5vcHRpb25zLm9uQ29tcGlsZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5zaGFkZXJMYW5ndWFnZSwgZXh0cmFJbml0aWFsaXphdGlvbnNBc3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkVmZmVjdENyZWF0ZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyh0aGlzLl9kcmF3V3JhcHBlci5lZmZlY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgZGF0YSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwYXJhbSBub0RlZmF1bHRCaW5kaW5ncyBpZiB0cnVlLCB0aGUgZGVmYXVsdCBiaW5kaW5ncyAoc2NhbGUgYW5kIGFscGhhIG1vZGUpIHdpbGwgbm90IGJlIHNldC5cbiAgICAgKi9cbiAgICBiaW5kKG5vRGVmYXVsdEJpbmRpbmdzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VBc1Bvc3RQcm9jZXNzICYmICFub0RlZmF1bHRCaW5kaW5ncykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVuZ2luZS5zZXRBbHBoYU1vZGUodGhpcy5hbHBoYU1vZGUpO1xuICAgICAgICAgICAgdGhpcy5kcmF3V3JhcHBlci5lZmZlY3Quc2V0RmxvYXQyKFwic2NhbGVcIiwgMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgRWZmZWN0V3JhcHBlci5fR2V0U2hhZGVyQ29kZVByb2Nlc3NpbmcodGhpcy5uYW1lKT8uYmluZEN1c3RvbUJpbmRpbmdzPy4odGhpcy5uYW1lLCB0aGlzLl9kcmF3V3JhcHBlci5lZmZlY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBvZiB0aGUgZWZmZWN0IHdyYXBwZXJcbiAgICAgKiBAcGFyYW0gX2lnbm9yZWQga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAqL1xuICAgIGRpc3Bvc2UoX2lnbm9yZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fb25Db250ZXh0UmVzdG9yZWRPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5lZmZlY3QuZ2V0RW5naW5lKCkub25Db250ZXh0UmVzdG9yZWRPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9vbkNvbnRleHRSZXN0b3JlZE9ic2VydmVyKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29udGV4dFJlc3RvcmVkT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25FZmZlY3RDcmVhdGVkT2JzZXJ2YWJsZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9kcmF3V3JhcHBlci5kaXNwb3NlKHRydWUpO1xuICAgIH1cbn1cbi8qKlxuICogRm9yY2UgY29kZSB0byBjb21waWxlIHRvIGdsc2wgZXZlbiBvbiBXZWJHUFUgZW5naW5lcy5cbiAqIEZhbHNlIGJ5IGRlZmF1bHQuIFRoaXMgaXMgbW9zdGx5IG1lYW50IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICovXG5FZmZlY3RXcmFwcGVyLkZvcmNlR0xTTCA9IGZhbHNlO1xuRWZmZWN0V3JhcHBlci5fQ3VzdG9tU2hhZGVyQ29kZVByb2Nlc3NpbmcgPSB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVmZmVjdFJlbmRlcmVyLmpzLm1hcCIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwiLi9tYXRoLnZlY3Rvci5qc1wiO1xuLyoqIERlZmluZXMgc3VwcG9ydGVkIHNwYWNlcyAqL1xuZXhwb3J0IHZhciBTcGFjZTtcbihmdW5jdGlvbiAoU3BhY2UpIHtcbiAgICAvKiogTG9jYWwgKG9iamVjdCkgc3BhY2UgKi9cbiAgICBTcGFjZVtTcGFjZVtcIkxPQ0FMXCJdID0gMF0gPSBcIkxPQ0FMXCI7XG4gICAgLyoqIFdvcmxkIHNwYWNlICovXG4gICAgU3BhY2VbU3BhY2VbXCJXT1JMRFwiXSA9IDFdID0gXCJXT1JMRFwiO1xuICAgIC8qKiBCb25lIHNwYWNlICovXG4gICAgU3BhY2VbU3BhY2VbXCJCT05FXCJdID0gMl0gPSBcIkJPTkVcIjtcbn0pKFNwYWNlIHx8IChTcGFjZSA9IHt9KSk7XG4vKiogRGVmaW5lcyB0aGUgMyBtYWluIGF4ZXMgKi9cbmV4cG9ydCBjbGFzcyBBeGlzIHtcbn1cbi8qKiBYIGF4aXMgKi9cbkF4aXMuWCA9IG5ldyBWZWN0b3IzKDEuMCwgMC4wLCAwLjApO1xuLyoqIFkgYXhpcyAqL1xuQXhpcy5ZID0gbmV3IFZlY3RvcjMoMC4wLCAxLjAsIDAuMCk7XG4vKiogWiBheGlzICovXG5BeGlzLlogPSBuZXcgVmVjdG9yMygwLjAsIDAuMCwgMS4wKTtcbi8qKlxuICogRGVmaW5lcyBjYXJ0ZXNpYW4gY29tcG9uZW50cy5cbiAqL1xuZXhwb3J0IHZhciBDb29yZGluYXRlO1xuKGZ1bmN0aW9uIChDb29yZGluYXRlKSB7XG4gICAgLyoqIFggYXhpcyAqL1xuICAgIENvb3JkaW5hdGVbQ29vcmRpbmF0ZVtcIlhcIl0gPSAwXSA9IFwiWFwiO1xuICAgIC8qKiBZIGF4aXMgKi9cbiAgICBDb29yZGluYXRlW0Nvb3JkaW5hdGVbXCJZXCJdID0gMV0gPSBcIllcIjtcbiAgICAvKiogWiBheGlzICovXG4gICAgQ29vcmRpbmF0ZVtDb29yZGluYXRlW1wiWlwiXSA9IDJdID0gXCJaXCI7XG59KShDb29yZGluYXRlIHx8IChDb29yZGluYXRlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGguYXhpcy5qcy5tYXAiLCJleHBvcnQgKiBmcm9tIFwiLi9tYXRoLmF4aXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21hdGguY29sb3IuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21hdGguY29uc3RhbnRzLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tYXRoLmZydXN0dW0uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21hdGgucGF0aC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vbWF0aC5wbGFuZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vbWF0aC5zaXplLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tYXRoLnZlY3Rvci5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vbWF0aC52ZXJ0ZXhGb3JtYXQuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21hdGgudmlld3BvcnQuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGguanMubWFwIiwiaW1wb3J0IHsgQ2xhbXAsIFdpdGhpbkVwc2lsb24gfSBmcm9tIFwiLi9tYXRoLnNjYWxhci5mdW5jdGlvbnMuanNcIjtcbmltcG9ydCB7IFZlY3RvcjIsIFZlY3RvcjMsIFF1YXRlcm5pb24sIE1hdHJpeCB9IGZyb20gXCIuL21hdGgudmVjdG9yLmpzXCI7XG5pbXBvcnQgeyBFcHNpbG9uIH0gZnJvbSBcIi4vbWF0aC5jb25zdGFudHMuanNcIjtcbi8qKlxuICogRGVmaW5lcyBwb3RlbnRpYWwgb3JpZW50YXRpb24gZm9yIGJhY2sgZmFjZSBjdWxsaW5nXG4gKi9cbmV4cG9ydCB2YXIgT3JpZW50YXRpb247XG4oZnVuY3Rpb24gKE9yaWVudGF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ2xvY2t3aXNlXG4gICAgICovXG4gICAgT3JpZW50YXRpb25bT3JpZW50YXRpb25bXCJDV1wiXSA9IDBdID0gXCJDV1wiO1xuICAgIC8qKiBDb3VudGVyIGNsb2Nrd2lzZSAqL1xuICAgIE9yaWVudGF0aW9uW09yaWVudGF0aW9uW1wiQ0NXXCJdID0gMV0gPSBcIkNDV1wiO1xufSkoT3JpZW50YXRpb24gfHwgKE9yaWVudGF0aW9uID0ge30pKTtcbi8qKiBDbGFzcyB1c2VkIHRvIHJlcHJlc2VudCBhIEJlemllciBjdXJ2ZSAqL1xuZXhwb3J0IGNsYXNzIEJlemllckN1cnZlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdWJpYyBCZXppZXIgaW50ZXJwb2xhdGVkIHZhbHVlIChmbG9hdCkgYXQgXCJ0XCIgKGZsb2F0KSBmcm9tIHRoZSBnaXZlbiB4MSwgeTEsIHgyLCB5MiBmbG9hdHNcbiAgICAgKiBAcGFyYW0gdCBkZWZpbmVzIHRoZSB0aW1lXG4gICAgICogQHBhcmFtIHgxIGRlZmluZXMgdGhlIGxlZnQgY29vcmRpbmF0ZSBvbiBYIGF4aXNcbiAgICAgKiBAcGFyYW0geTEgZGVmaW5lcyB0aGUgbGVmdCBjb29yZGluYXRlIG9uIFkgYXhpc1xuICAgICAqIEBwYXJhbSB4MiBkZWZpbmVzIHRoZSByaWdodCBjb29yZGluYXRlIG9uIFggYXhpc1xuICAgICAqIEBwYXJhbSB5MiBkZWZpbmVzIHRoZSByaWdodCBjb29yZGluYXRlIG9uIFkgYXhpc1xuICAgICAqIEByZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgSW50ZXJwb2xhdGUodCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgaWYgKHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJhY3QgWCAod2hpY2ggaXMgZXF1YWwgdG8gdGltZSBoZXJlKVxuICAgICAgICBjb25zdCBmMCA9IDEgLSAzICogeDIgKyAzICogeDE7XG4gICAgICAgIGNvbnN0IGYxID0gMyAqIHgyIC0gNiAqIHgxO1xuICAgICAgICBjb25zdCBmMiA9IDMgKiB4MTtcbiAgICAgICAgbGV0IHJlZmluZWRUID0gdDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZmluZWRUMiA9IHJlZmluZWRUICogcmVmaW5lZFQ7XG4gICAgICAgICAgICBjb25zdCByZWZpbmVkVDMgPSByZWZpbmVkVDIgKiByZWZpbmVkVDtcbiAgICAgICAgICAgIGNvbnN0IHggPSBmMCAqIHJlZmluZWRUMyArIGYxICogcmVmaW5lZFQyICsgZjIgKiByZWZpbmVkVDtcbiAgICAgICAgICAgIGNvbnN0IHNsb3BlID0gMS4wIC8gKDMuMCAqIGYwICogcmVmaW5lZFQyICsgMi4wICogZjEgKiByZWZpbmVkVCArIGYyKTtcbiAgICAgICAgICAgIHJlZmluZWRUIC09ICh4IC0gdCkgKiBzbG9wZTtcbiAgICAgICAgICAgIHJlZmluZWRUID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgcmVmaW5lZFQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNvbHZlIGN1YmljIGJlemllciBmb3IgdGhlIGdpdmVuIHhcbiAgICAgICAgcmV0dXJuIDMgKiBNYXRoLnBvdygxIC0gcmVmaW5lZFQsIDIpICogcmVmaW5lZFQgKiB5MSArIDMgKiAoMSAtIHJlZmluZWRUKSAqIE1hdGgucG93KHJlZmluZWRULCAyKSAqIHkyICsgTWF0aC5wb3cocmVmaW5lZFQsIDMpO1xuICAgIH1cbn1cbi8qKlxuICogRGVmaW5lcyBhbmdsZSByZXByZXNlbnRhdGlvblxuICovXG5leHBvcnQgY2xhc3MgQW5nbGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gQW5nbGUgb2JqZWN0IG9mIFwicmFkaWFuc1wiIHJhZGlhbnMgKGZsb2F0KS5cbiAgICAgKiBAcGFyYW0gcmFkaWFucyB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJhZGlhbnMpIHtcbiAgICAgICAgdGhpcy5fcmFkaWFucyA9IHJhZGlhbnM7XG4gICAgICAgIGlmICh0aGlzLl9yYWRpYW5zIDwgMC4wKSB7XG4gICAgICAgICAgICB0aGlzLl9yYWRpYW5zICs9IDIuMCAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJucyB0aGUgQW5nbGUgdmFsdWUgaW4gZGVncmVlcyAoZmxvYXQpXG4gICAgICovXG4gICAgZGVncmVlcygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9yYWRpYW5zICogMTgwLjApIC8gTWF0aC5QSTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlIGluIHJhZGlhbnNcbiAgICAgKiBAcmV0dXJucyB0aGUgQW5nbGUgdmFsdWUgaW4gcmFkaWFucyAoZmxvYXQpXG4gICAgICovXG4gICAgcmFkaWFucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGlhbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcgQW5nbGUgb2JqZWN0IHdpdGggYSB2YWx1ZSBvZiB0aGUgYW5nbGUgKGluIHJhZGlhbnMpIGJldHdlZW4gdGhlIGxpbmUgY29ubmVjdGluZyB0aGUgdHdvIHBvaW50cyBhbmQgdGhlIHgtYXhpc1xuICAgICAqIEBwYXJhbSBhIGRlZmluZXMgZmlyc3QgcG9pbnQgYXMgdGhlIG9yaWdpblxuICAgICAqIEBwYXJhbSBiIGRlZmluZXMgcG9pbnRcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBBbmdsZVxuICAgICAqL1xuICAgIHN0YXRpYyBCZXR3ZWVuVHdvUG9pbnRzKGEsIGIpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBiLnN1YnRyYWN0KGEpO1xuICAgICAgICBjb25zdCB0aGV0YSA9IE1hdGguYXRhbjIoZGVsdGEueSwgZGVsdGEueCk7XG4gICAgICAgIHJldHVybiBuZXcgQW5nbGUodGhldGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB0d28gdmVjdG9yc1xuICAgICAqIEBwYXJhbSBhIGRlZmluZXMgZmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIGIgZGVmaW5lcyB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGFuIG5ldyBBbmdsZSBiZXR3ZWVuIDAgYW5kIFBJXG4gICAgICovXG4gICAgc3RhdGljIEJldHdlZW5Ud29WZWN0b3JzKGEsIGIpIHtcbiAgICAgICAgbGV0IHByb2R1Y3QgPSBhLmxlbmd0aFNxdWFyZWQoKSAqIGIubGVuZ3RoU3F1YXJlZCgpO1xuICAgICAgICBpZiAocHJvZHVjdCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbmdsZShNYXRoLlBJIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgcHJvZHVjdCA9IE1hdGguc3FydChwcm9kdWN0KTtcbiAgICAgICAgbGV0IGNvc1ZhbCA9IGEuZG90KGIpIC8gcHJvZHVjdDtcbiAgICAgICAgY29zVmFsID0gQ2xhbXAoY29zVmFsLCAtMSwgMSk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hY29zKGNvc1ZhbCk7XG4gICAgICAgIHJldHVybiBuZXcgQW5nbGUoYW5nbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmV3IEFuZ2xlIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBmbG9hdCBpbiByYWRpYW5zXG4gICAgICogQHBhcmFtIHJhZGlhbnMgZGVmaW5lcyB0aGUgYW5nbGUgdmFsdWUgaW4gcmFkaWFuc1xuICAgICAqIEByZXR1cm5zIGEgbmV3IEFuZ2xlXG4gICAgICovXG4gICAgc3RhdGljIEZyb21SYWRpYW5zKHJhZGlhbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmdsZShyYWRpYW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIG5ldyBBbmdsZSBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZmxvYXQgaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSBkZWdyZWVzIGRlZmluZXMgdGhlIGFuZ2xlIHZhbHVlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBBbmdsZVxuICAgICAqL1xuICAgIHN0YXRpYyBGcm9tRGVncmVlcyhkZWdyZWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5nbGUoKGRlZ3JlZXMgKiBNYXRoLlBJKSAvIDE4MC4wKTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgcmVwcmVzZW50cyBhbiBhcmMgaW4gYSAyZCBzcGFjZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEFyYzIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gQXJjIG9iamVjdCBmcm9tIHRoZSB0aHJlZSBnaXZlbiBwb2ludHMgOiBzdGFydCwgbWlkZGxlIGFuZCBlbmQuXG4gICAgICogQHBhcmFtIHN0YXJ0UG9pbnQgRGVmaW5lcyB0aGUgc3RhcnQgcG9pbnQgb2YgdGhlIGFyY1xuICAgICAqIEBwYXJhbSBtaWRQb2ludCBEZWZpbmVzIHRoZSBtaWRkbGUgcG9pbnQgb2YgdGhlIGFyY1xuICAgICAqIEBwYXJhbSBlbmRQb2ludCBEZWZpbmVzIHRoZSBlbmQgcG9pbnQgb2YgdGhlIGFyY1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBEZWZpbmVzIHRoZSBzdGFydCBwb2ludCBvZiB0aGUgYXJjICovXG4gICAgc3RhcnRQb2ludCwgXG4gICAgLyoqIERlZmluZXMgdGhlIG1pZCBwb2ludCBvZiB0aGUgYXJjICovXG4gICAgbWlkUG9pbnQsIFxuICAgIC8qKiBEZWZpbmVzIHRoZSBlbmQgcG9pbnQgb2YgdGhlIGFyYyAqL1xuICAgIGVuZFBvaW50KSB7XG4gICAgICAgIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XG4gICAgICAgIHRoaXMubWlkUG9pbnQgPSBtaWRQb2ludDtcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IGVuZFBvaW50O1xuICAgICAgICBjb25zdCB0ZW1wID0gTWF0aC5wb3cobWlkUG9pbnQueCwgMikgKyBNYXRoLnBvdyhtaWRQb2ludC55LCAyKTtcbiAgICAgICAgY29uc3Qgc3RhcnRUb01pZCA9IChNYXRoLnBvdyhzdGFydFBvaW50LngsIDIpICsgTWF0aC5wb3coc3RhcnRQb2ludC55LCAyKSAtIHRlbXApIC8gMjtcbiAgICAgICAgY29uc3QgbWlkVG9FbmQgPSAodGVtcCAtIE1hdGgucG93KGVuZFBvaW50LngsIDIpIC0gTWF0aC5wb3coZW5kUG9pbnQueSwgMikpIC8gMjtcbiAgICAgICAgY29uc3QgZGV0ID0gKHN0YXJ0UG9pbnQueCAtIG1pZFBvaW50LngpICogKG1pZFBvaW50LnkgLSBlbmRQb2ludC55KSAtIChtaWRQb2ludC54IC0gZW5kUG9pbnQueCkgKiAoc3RhcnRQb2ludC55IC0gbWlkUG9pbnQueSk7XG4gICAgICAgIHRoaXMuY2VudGVyUG9pbnQgPSBuZXcgVmVjdG9yMigoc3RhcnRUb01pZCAqIChtaWRQb2ludC55IC0gZW5kUG9pbnQueSkgLSBtaWRUb0VuZCAqIChzdGFydFBvaW50LnkgLSBtaWRQb2ludC55KSkgLyBkZXQsICgoc3RhcnRQb2ludC54IC0gbWlkUG9pbnQueCkgKiBtaWRUb0VuZCAtIChtaWRQb2ludC54IC0gZW5kUG9pbnQueCkgKiBzdGFydFRvTWlkKSAvIGRldCk7XG4gICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy5jZW50ZXJQb2ludC5zdWJ0cmFjdCh0aGlzLnN0YXJ0UG9pbnQpLmxlbmd0aCgpO1xuICAgICAgICB0aGlzLnN0YXJ0QW5nbGUgPSBBbmdsZS5CZXR3ZWVuVHdvUG9pbnRzKHRoaXMuY2VudGVyUG9pbnQsIHRoaXMuc3RhcnRQb2ludCk7XG4gICAgICAgIGNvbnN0IGExID0gdGhpcy5zdGFydEFuZ2xlLmRlZ3JlZXMoKTtcbiAgICAgICAgbGV0IGEyID0gQW5nbGUuQmV0d2VlblR3b1BvaW50cyh0aGlzLmNlbnRlclBvaW50LCB0aGlzLm1pZFBvaW50KS5kZWdyZWVzKCk7XG4gICAgICAgIGxldCBhMyA9IEFuZ2xlLkJldHdlZW5Ud29Qb2ludHModGhpcy5jZW50ZXJQb2ludCwgdGhpcy5lbmRQb2ludCkuZGVncmVlcygpO1xuICAgICAgICAvLyBhbmdsZXMgY29ycmVjdGlvblxuICAgICAgICBpZiAoYTIgLSBhMSA+ICsxODAuMCkge1xuICAgICAgICAgICAgYTIgLT0gMzYwLjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEyIC0gYTEgPCAtMTgwLjApIHtcbiAgICAgICAgICAgIGEyICs9IDM2MC4wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhMyAtIGEyID4gKzE4MC4wKSB7XG4gICAgICAgICAgICBhMyAtPSAzNjAuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYTMgLSBhMiA8IC0xODAuMCkge1xuICAgICAgICAgICAgYTMgKz0gMzYwLjA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IGEyIC0gYTEgPCAwID8gMCAvKiBPcmllbnRhdGlvbi5DVyAqLyA6IDEgLyogT3JpZW50YXRpb24uQ0NXICovO1xuICAgICAgICB0aGlzLmFuZ2xlID0gQW5nbGUuRnJvbURlZ3JlZXModGhpcy5vcmllbnRhdGlvbiA9PT0gMCAvKiBPcmllbnRhdGlvbi5DVyAqLyA/IGExIC0gYTMgOiBhMyAtIGExKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSAyRCBwYXRoIG1hZGUgdXAgb2YgbXVsdGlwbGUgMkQgcG9pbnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXRoMiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFBhdGgyIG9iamVjdCBmcm9tIHRoZSBzdGFydGluZyAyRCBjb29yZGluYXRlcyB4IGFuZCB5LlxuICAgICAqIEBwYXJhbSB4IHRoZSBzdGFydGluZyBwb2ludHMgeCB2YWx1ZVxuICAgICAqIEBwYXJhbSB5IHRoZSBzdGFydGluZyBwb2ludHMgeSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDAuMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBwYXRoIHN0YXJ0IGFuZCBlbmQgcG9pbnQgYXJlIHRoZSBzYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wb2ludHMucHVzaChuZXcgVmVjdG9yMih4LCB5KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgc2VnbWVudCB1bnRpbCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMgKHgsIHkpIHRvIHRoZSBjdXJyZW50IFBhdGgyLlxuICAgICAqIEBwYXJhbSB4IHRoZSBhZGRlZCBwb2ludHMgeCB2YWx1ZVxuICAgICAqIEBwYXJhbSB5IHRoZSBhZGRlZCBwb2ludHMgeSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIFBhdGgyLlxuICAgICAqL1xuICAgIGFkZExpbmVUbyh4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3UG9pbnQgPSBuZXcgVmVjdG9yMih4LCB5KTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNQb2ludCA9IHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuX3BvaW50cy5wdXNoKG5ld1BvaW50KTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoICs9IG5ld1BvaW50LnN1YnRyYWN0KHByZXZpb3VzUG9pbnQpLmxlbmd0aCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBfbnVtYmVyT2ZTZWdtZW50c18gc2VnbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBhcmMgZGVmaW5pdGlvbiAobWlkZGxlIHBvaW50IGNvb3JkaW5hdGVzLCBlbmQgcG9pbnQgY29vcmRpbmF0ZXMsIHRoZSBhcmMgc3RhcnQgcG9pbnQgYmVpbmcgdGhlIGN1cnJlbnQgUGF0aDIgbGFzdCBwb2ludCkgdG8gdGhlIGN1cnJlbnQgUGF0aDIuXG4gICAgICogQHBhcmFtIG1pZFggbWlkZGxlIHBvaW50IHggdmFsdWVcbiAgICAgKiBAcGFyYW0gbWlkWSBtaWRkbGUgcG9pbnQgeSB2YWx1ZVxuICAgICAqIEBwYXJhbSBlbmRYIGVuZCBwb2ludCB4IHZhbHVlXG4gICAgICogQHBhcmFtIGVuZFkgZW5kIHBvaW50IHkgdmFsdWVcbiAgICAgKiBAcGFyYW0gbnVtYmVyT2ZTZWdtZW50cyAoZGVmYXVsdDogMzYpXG4gICAgICogQHJldHVybnMgdGhlIHVwZGF0ZWQgUGF0aDIuXG4gICAgICovXG4gICAgYWRkQXJjVG8obWlkWCwgbWlkWSwgZW5kWCwgZW5kWSwgbnVtYmVyT2ZTZWdtZW50cyA9IDM2KSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRQb2ludCA9IHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IG1pZFBvaW50ID0gbmV3IFZlY3RvcjIobWlkWCwgbWlkWSk7XG4gICAgICAgIGNvbnN0IGVuZFBvaW50ID0gbmV3IFZlY3RvcjIoZW5kWCwgZW5kWSk7XG4gICAgICAgIGNvbnN0IGFyYyA9IG5ldyBBcmMyKHN0YXJ0UG9pbnQsIG1pZFBvaW50LCBlbmRQb2ludCk7XG4gICAgICAgIGxldCBpbmNyZW1lbnQgPSBhcmMuYW5nbGUucmFkaWFucygpIC8gbnVtYmVyT2ZTZWdtZW50cztcbiAgICAgICAgaWYgKGFyYy5vcmllbnRhdGlvbiA9PT0gMCAvKiBPcmllbnRhdGlvbi5DVyAqLykge1xuICAgICAgICAgICAgaW5jcmVtZW50ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50QW5nbGUgPSBhcmMuc3RhcnRBbmdsZS5yYWRpYW5zKCkgKyBpbmNyZW1lbnQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZTZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5jb3MoY3VycmVudEFuZ2xlKSAqIGFyYy5yYWRpdXMgKyBhcmMuY2VudGVyUG9pbnQueDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLnNpbihjdXJyZW50QW5nbGUpICogYXJjLnJhZGl1cyArIGFyYy5jZW50ZXJQb2ludC55O1xuICAgICAgICAgICAgdGhpcy5hZGRMaW5lVG8oeCwgeSk7XG4gICAgICAgICAgICBjdXJyZW50QW5nbGUgKz0gaW5jcmVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIF9udW1iZXJPZlNlZ21lbnRzXyBzZWdtZW50cyBhY2NvcmRpbmcgdG8gdGhlIHF1YWRyYXRpYyBjdXJ2ZSBkZWZpbml0aW9uIHRvIHRoZSBjdXJyZW50IFBhdGgyLlxuICAgICAqIEBwYXJhbSBjb250cm9sWCBjb250cm9sIHBvaW50IHggdmFsdWVcbiAgICAgKiBAcGFyYW0gY29udHJvbFkgY29udHJvbCBwb2ludCB5IHZhbHVlXG4gICAgICogQHBhcmFtIGVuZFggZW5kIHBvaW50IHggdmFsdWVcbiAgICAgKiBAcGFyYW0gZW5kWSBlbmQgcG9pbnQgeSB2YWx1ZVxuICAgICAqIEBwYXJhbSBudW1iZXJPZlNlZ21lbnRzIChkZWZhdWx0OiAzNilcbiAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBQYXRoMi5cbiAgICAgKi9cbiAgICBhZGRRdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xYLCBjb250cm9sWSwgZW5kWCwgZW5kWSwgbnVtYmVyT2ZTZWdtZW50cyA9IDM2KSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXF1YXRpb24gPSAodCwgdmFsMCwgdmFsMSwgdmFsMikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gKDEuMCAtIHQpICogKDEuMCAtIHQpICogdmFsMCArIDIuMCAqIHQgKiAoMS4wIC0gdCkgKiB2YWwxICsgdCAqIHQgKiB2YWwyO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RhcnRQb2ludCA9IHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG51bWJlck9mU2VnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IGkgLyBudW1iZXJPZlNlZ21lbnRzO1xuICAgICAgICAgICAgY29uc3QgeCA9IGVxdWF0aW9uKHN0ZXAsIHN0YXJ0UG9pbnQueCwgY29udHJvbFgsIGVuZFgpO1xuICAgICAgICAgICAgY29uc3QgeSA9IGVxdWF0aW9uKHN0ZXAsIHN0YXJ0UG9pbnQueSwgY29udHJvbFksIGVuZFkpO1xuICAgICAgICAgICAgdGhpcy5hZGRMaW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgX251bWJlck9mU2VnbWVudHNfIHNlZ21lbnRzIGFjY29yZGluZyB0byB0aGUgYmV6aWVyIGN1cnZlIGRlZmluaXRpb24gdG8gdGhlIGN1cnJlbnQgUGF0aDIuXG4gICAgICogQHBhcmFtIG9yaWdpblRhbmdlbnRYIHRhbmdlbnQgdmVjdG9yIGF0IHRoZSBvcmlnaW4gcG9pbnQgeCB2YWx1ZVxuICAgICAqIEBwYXJhbSBvcmlnaW5UYW5nZW50WSB0YW5nZW50IHZlY3RvciBhdCB0aGUgb3JpZ2luIHBvaW50IHkgdmFsdWVcbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb25UYW5nZW50WCB0YW5nZW50IHZlY3RvciBhdCB0aGUgZGVzdGluYXRpb24gcG9pbnQgeCB2YWx1ZVxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvblRhbmdlbnRZIHRhbmdlbnQgdmVjdG9yIGF0IHRoZSBkZXN0aW5hdGlvbiBwb2ludCB5IHZhbHVlXG4gICAgICogQHBhcmFtIGVuZFggZW5kIHBvaW50IHggdmFsdWVcbiAgICAgKiBAcGFyYW0gZW5kWSBlbmQgcG9pbnQgeSB2YWx1ZVxuICAgICAqIEBwYXJhbSBudW1iZXJPZlNlZ21lbnRzIChkZWZhdWx0OiAzNilcbiAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBQYXRoMi5cbiAgICAgKi9cbiAgICBhZGRCZXppZXJDdXJ2ZVRvKG9yaWdpblRhbmdlbnRYLCBvcmlnaW5UYW5nZW50WSwgZGVzdGluYXRpb25UYW5nZW50WCwgZGVzdGluYXRpb25UYW5nZW50WSwgZW5kWCwgZW5kWSwgbnVtYmVyT2ZTZWdtZW50cyA9IDM2KSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXF1YXRpb24gPSAodCwgdmFsMCwgdmFsMSwgdmFsMiwgdmFsMykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gKDEuMCAtIHQpICogKDEuMCAtIHQpICogKDEuMCAtIHQpICogdmFsMCArIDMuMCAqIHQgKiAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgKiB2YWwxICsgMy4wICogdCAqIHQgKiAoMS4wIC0gdCkgKiB2YWwyICsgdCAqIHQgKiB0ICogdmFsMztcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSB0aGlzLl9wb2ludHNbdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBudW1iZXJPZlNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSBpIC8gbnVtYmVyT2ZTZWdtZW50cztcbiAgICAgICAgICAgIGNvbnN0IHggPSBlcXVhdGlvbihzdGVwLCBzdGFydFBvaW50LngsIG9yaWdpblRhbmdlbnRYLCBkZXN0aW5hdGlvblRhbmdlbnRYLCBlbmRYKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBlcXVhdGlvbihzdGVwLCBzdGFydFBvaW50LnksIG9yaWdpblRhbmdlbnRZLCBkZXN0aW5hdGlvblRhbmdlbnRZLCBlbmRZKTtcbiAgICAgICAgICAgIHRoaXMuYWRkTGluZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGlmIGEgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIHRoZSBwb2x5Z29uIGRlZmluZXMgYnkgdGhlIHBhdGhcbiAgICAgKiBAcGFyYW0gcG9pbnQgZGVmaW5lcyB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZVxuICAgICAqL1xuICAgIGlzUG9pbnRJbnNpZGUocG9pbnQpIHtcbiAgICAgICAgbGV0IGlzSW5zaWRlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcCA9IGNvdW50IC0gMSwgcSA9IDA7IHEgPCBjb3VudDsgcCA9IHErKykge1xuICAgICAgICAgICAgbGV0IGVkZ2VMb3cgPSB0aGlzLl9wb2ludHNbcF07XG4gICAgICAgICAgICBsZXQgZWRnZUhpZ2ggPSB0aGlzLl9wb2ludHNbcV07XG4gICAgICAgICAgICBsZXQgZWRnZUR4ID0gZWRnZUhpZ2gueCAtIGVkZ2VMb3cueDtcbiAgICAgICAgICAgIGxldCBlZGdlRHkgPSBlZGdlSGlnaC55IC0gZWRnZUxvdy55O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGVkZ2VEeSkgPiBOdW1iZXIuRVBTSUxPTikge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBwYXJhbGxlbFxuICAgICAgICAgICAgICAgIGlmIChlZGdlRHkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VMb3cgPSB0aGlzLl9wb2ludHNbcV07XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VEeCA9IC1lZGdlRHg7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VIaWdoID0gdGhpcy5fcG9pbnRzW3BdO1xuICAgICAgICAgICAgICAgICAgICBlZGdlRHkgPSAtZWRnZUR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9pbnQueSA8IGVkZ2VMb3cueSB8fCBwb2ludC55ID4gZWRnZUhpZ2gueSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50LnkgPT09IGVkZ2VMb3cueSAmJiBwb2ludC54ID09PSBlZGdlTG93LngpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJwRWRnZSA9IGVkZ2VEeSAqIChwb2ludC54IC0gZWRnZUxvdy54KSAtIGVkZ2VEeCAqIChwb2ludC55IC0gZWRnZUxvdy55KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlcnBFZGdlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGVycEVkZ2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc0luc2lkZSA9ICFpc0luc2lkZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnQueSAhPT0gZWRnZUxvdy55KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGVkZ2VIaWdoLnggPD0gcG9pbnQueCAmJiBwb2ludC54IDw9IGVkZ2VMb3cueCkgfHwgKGVkZ2VMb3cueCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gZWRnZUhpZ2gueCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0luc2lkZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBQYXRoMi5cbiAgICAgKiBAcmV0dXJucyB0aGUgUGF0aDIuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN1bSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBlYWNoIHNlcXVlbnRpYWwgcG9pbnQgaW4gdGhlIHBhdGhcbiAgICAgKiBAcmV0dXJucyB0aGUgUGF0aDIgdG90YWwgbGVuZ3RoIChmbG9hdCkuXG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fbGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RQb2ludCA9IHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gdGhpcy5fcG9pbnRzWzBdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGZpcnN0UG9pbnQuc3VidHJhY3QobGFzdFBvaW50KS5sZW5ndGgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcmVhIG9mIHRoZSBwb2x5Z29uIGRlZmluZWQgYnkgdGhlIHBhdGhcbiAgICAgKiBAcmV0dXJucyBhcmVhIHZhbHVlXG4gICAgICovXG4gICAgYXJlYSgpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX3BvaW50cy5sZW5ndGg7XG4gICAgICAgIGxldCB2YWx1ZSA9IDAuMDtcbiAgICAgICAgZm9yIChsZXQgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxKyspIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3BvaW50c1twXS54ICogdGhpcy5fcG9pbnRzW3FdLnkgLSB0aGlzLl9wb2ludHNbcV0ueCAqIHRoaXMuX3BvaW50c1twXS55O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZSAqIDAuNTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcG9pbnRzIHdoaWNoIGNvbnN0cnVjdCB0aGUgcGF0aFxuICAgICAqIEByZXR1cm5zIHRoZSBQYXRoMiBpbnRlcm5hbCBhcnJheSBvZiBwb2ludHMuXG4gICAgICovXG4gICAgZ2V0UG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHBvaW50IGF0IHRoZSBkaXN0YW5jZSBhd2F5cyBmcm9tIHRoZSBzdGFydGluZyBwb2ludFxuICAgICAqIEBwYXJhbSBub3JtYWxpemVkTGVuZ3RoUG9zaXRpb24gdGhlIGxlbmd0aCBhbG9uZyB0aGUgcGF0aCB0byByZXRyaWV2ZSB0aGUgcG9pbnQgZnJvbVxuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjIgbG9jYXRlZCBhdCBhIHBlcmNlbnRhZ2Ugb2YgdGhlIFBhdGgyIHRvdGFsIGxlbmd0aCBvbiB0aGlzIHBhdGguXG4gICAgICovXG4gICAgZ2V0UG9pbnRBdExlbmd0aFBvc2l0aW9uKG5vcm1hbGl6ZWRMZW5ndGhQb3NpdGlvbikge1xuICAgICAgICBpZiAobm9ybWFsaXplZExlbmd0aFBvc2l0aW9uIDwgMCB8fCBub3JtYWxpemVkTGVuZ3RoUG9zaXRpb24gPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yMi5aZXJvKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoUG9zaXRpb24gPSBub3JtYWxpemVkTGVuZ3RoUG9zaXRpb24gKiB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBsZXQgcHJldmlvdXNPZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaiA9IChpICsgMSkgJSB0aGlzLl9wb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuX3BvaW50c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLl9wb2ludHNbal07XG4gICAgICAgICAgICBjb25zdCBiVG9BID0gYi5zdWJ0cmFjdChhKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSBiVG9BLmxlbmd0aCgpICsgcHJldmlvdXNPZmZzZXQ7XG4gICAgICAgICAgICBpZiAobGVuZ3RoUG9zaXRpb24gPj0gcHJldmlvdXNPZmZzZXQgJiYgbGVuZ3RoUG9zaXRpb24gPD0gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpciA9IGJUb0Eubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxPZmZzZXQgPSBsZW5ndGhQb3NpdGlvbiAtIHByZXZpb3VzT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMihhLnggKyBkaXIueCAqIGxvY2FsT2Zmc2V0LCBhLnkgKyBkaXIueSAqIGxvY2FsT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzT2Zmc2V0ID0gbmV4dE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmVjdG9yMi5aZXJvKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcGF0aCBzdGFydGluZyBmcm9tIGFuIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0geCBzdGFydGluZyB4IHZhbHVlXG4gICAgICogQHBhcmFtIHkgc3RhcnRpbmcgeSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IFBhdGgyIHN0YXJ0aW5nIGF0IHRoZSBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICovXG4gICAgc3RhdGljIFN0YXJ0aW5nQXQoeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGgyKHgsIHkpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIDNEIHBhdGggbWFkZSB1cCBvZiBtdWx0aXBsZSAzRCBwb2ludHNcbiAqIEBzZWUgaHR0cHM6Ly9kb2MuYmFieWxvbmpzLmNvbS9mZWF0dXJlcy9mZWF0dXJlc0RlZXBEaXZlL21lc2gvcGF0aDNEXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXRoM0Qge1xuICAgIC8qKlxuICAgICAqIG5ldyBQYXRoM0QocGF0aCwgbm9ybWFsLCByYXcpXG4gICAgICogQ3JlYXRlcyBhIFBhdGgzRC4gQSBQYXRoM0QgaXMgYSBsb2dpY2FsIG1hdGggb2JqZWN0LCBzbyBub3QgYSBtZXNoLlxuICAgICAqIHBsZWFzZSByZWFkIHRoZSBkZXNjcmlwdGlvbiBpbiB0aGUgdHV0b3JpYWwgOiBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL2ZlYXR1cmVzL2ZlYXR1cmVzRGVlcERpdmUvbWVzaC9wYXRoM0RcbiAgICAgKiBAcGFyYW0gcGF0aCBhbiBhcnJheSBvZiBWZWN0b3IzLCB0aGUgY3VydmUgYXhpcyBvZiB0aGUgUGF0aDNEXG4gICAgICogQHBhcmFtIGZpcnN0Tm9ybWFsIChvcHRpb25zKSBWZWN0b3IzLCB0aGUgZmlyc3Qgd2FudGVkIG5vcm1hbCB0byB0aGUgY3VydmUuIEV4ICgwLCAxLCAwKSBmb3IgYSB2ZXJ0aWNhbCBub3JtYWwuXG4gICAgICogQHBhcmFtIHJhdyAob3B0aW9uYWwsIGRlZmF1bHQgZmFsc2UpIDogYm9vbGVhbiwgaWYgdHJ1ZSB0aGUgcmV0dXJuZWQgUGF0aDNEIGlzbid0IG5vcm1hbGl6ZWQuIFVzZWZ1bCB0byBkZXBpY3QgcGF0aCBhY2NlbGVyYXRpb24gb3Igc3BlZWQuXG4gICAgICogQHBhcmFtIGFsaWduVGFuZ2VudHNXaXRoUGF0aCAob3B0aW9uYWwsIGRlZmF1bHQgZmFsc2UpIDogYm9vbGVhbiwgaWYgdHJ1ZSB0aGUgdGFuZ2VudHMgd2lsbCBiZSBhbGlnbmVkIHdpdGggdGhlIHBhdGguXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogYW4gYXJyYXkgb2YgVmVjdG9yMywgdGhlIGN1cnZlIGF4aXMgb2YgdGhlIFBhdGgzRFxuICAgICAqL1xuICAgIHBhdGgsIGZpcnN0Tm9ybWFsID0gbnVsbCwgcmF3LCBhbGlnblRhbmdlbnRzV2l0aFBhdGggPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLl9jdXJ2ZSA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5fdGFuZ2VudHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5fbm9ybWFscyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLl9iaW5vcm1hbHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgLy8gaG9sZHMgaW50ZXJwb2xhdGVkIHBvaW50IGRhdGFcbiAgICAgICAgdGhpcy5fcG9pbnRBdERhdGEgPSB7XG4gICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgIHBvaW50OiBWZWN0b3IzLlplcm8oKSxcbiAgICAgICAgICAgIHByZXZpb3VzUG9pbnRBcnJheUluZGV4OiAwLFxuICAgICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgICBzdWJQb3NpdGlvbjogMCxcbiAgICAgICAgICAgIGludGVycG9sYXRlUmVhZHk6IGZhbHNlLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbk1hdHJpeDogTWF0cml4LklkZW50aXR5KCksXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcGF0aC5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgdGhpcy5fY3VydmVbcF0gPSBwYXRoW3BdLmNsb25lKCk7IC8vIGhhcmQgY29weVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JhdyA9IHJhdyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWxpZ25UYW5nZW50c1dpdGhQYXRoID0gYWxpZ25UYW5nZW50c1dpdGhQYXRoO1xuICAgICAgICB0aGlzLl9jb21wdXRlKGZpcnN0Tm9ybWFsLCBhbGlnblRhbmdlbnRzV2l0aFBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBQYXRoM0QgYXJyYXkgb2Ygc3VjY2Vzc2l2ZSBWZWN0b3IzIGRlc2lnbmluZyBpdHMgY3VydmUuXG4gICAgICogQHJldHVybnMgdGhlIFBhdGgzRCBhcnJheSBvZiBzdWNjZXNzaXZlIFZlY3RvcjMgZGVzaWduaW5nIGl0cyBjdXJ2ZS5cbiAgICAgKi9cbiAgICBnZXRDdXJ2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnZlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBQYXRoM0QgYXJyYXkgb2Ygc3VjY2Vzc2l2ZSBWZWN0b3IzIGRlc2lnbmluZyBpdHMgY3VydmUuXG4gICAgICogQHJldHVybnMgdGhlIFBhdGgzRCBhcnJheSBvZiBzdWNjZXNzaXZlIFZlY3RvcjMgZGVzaWduaW5nIGl0cyBjdXJ2ZS5cbiAgICAgKi9cbiAgICBnZXRQb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJ2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdGhlIGNvbXB1dGVkIGxlbmd0aCAoZmxvYXQpIG9mIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlc1t0aGlzLl9kaXN0YW5jZXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggdGFuZ2VudCB2ZWN0b3JzIG9uIGVhY2ggUGF0aDNEIGN1cnZlIHBvaW50LlxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IHBvcHVsYXRlZCB3aXRoIHRhbmdlbnQgdmVjdG9ycyBvbiBlYWNoIFBhdGgzRCBjdXJ2ZSBwb2ludC5cbiAgICAgKi9cbiAgICBnZXRUYW5nZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhbmdlbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHBvcHVsYXRlZCB3aXRoIG5vcm1hbCB2ZWN0b3JzIG9uIGVhY2ggUGF0aDNEIGN1cnZlIHBvaW50LlxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IHBvcHVsYXRlZCB3aXRoIG5vcm1hbCB2ZWN0b3JzIG9uIGVhY2ggUGF0aDNEIGN1cnZlIHBvaW50LlxuICAgICAqL1xuICAgIGdldE5vcm1hbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHBvcHVsYXRlZCB3aXRoIGJpbm9ybWFsIHZlY3RvcnMgb24gZWFjaCBQYXRoM0QgY3VydmUgcG9pbnQuXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggYmlub3JtYWwgdmVjdG9ycyBvbiBlYWNoIFBhdGgzRCBjdXJ2ZSBwb2ludC5cbiAgICAgKi9cbiAgICBnZXRCaW5vcm1hbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5vcm1hbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggZGlzdGFuY2VzIChmbG9hdCkgb2YgdGhlIGktdGggcG9pbnQgZnJvbSB0aGUgZmlyc3QgY3VydmUgcG9pbnQuXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggZGlzdGFuY2VzIChmbG9hdCkgb2YgdGhlIGktdGggcG9pbnQgZnJvbSB0aGUgZmlyc3QgY3VydmUgcG9pbnQuXG4gICAgICovXG4gICAgZ2V0RGlzdGFuY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGludGVycG9sYXRlZCBwb2ludCBhbG9uZyB0aGlzIHBhdGhcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBhbG9uZyB0aGlzIHBhdGgsIGZyb20gMC4wIHRvIDEuMFxuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjMgYXMgdGhlIHBvaW50XG4gICAgICovXG4gICAgZ2V0UG9pbnRBdChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlUG9pbnRBdERhdGEocG9zaXRpb24pLnBvaW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0YW5nZW50IHZlY3RvciBvZiBhbiBpbnRlcnBvbGF0ZWQgUGF0aDNEIGN1cnZlIHBvaW50IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gYWxvbmcgdGhpcyBwYXRoLlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIHBvaW50IGFsb25nIHRoaXMgcGF0aCwgZnJvbSAwLjAgdG8gMS4wXG4gICAgICogQHBhcmFtIGludGVycG9sYXRlZCAob3B0aW9uYWwsIGRlZmF1bHQgZmFsc2UpIDogYm9vbGVhbiwgaWYgdHJ1ZSByZXR1cm5zIGFuIGludGVycG9sYXRlZCB0YW5nZW50IGluc3RlYWQgb2YgdGhlIHRhbmdlbnQgb2YgdGhlIHByZXZpb3VzIHBhdGggcG9pbnQuXG4gICAgICogQHJldHVybnMgYSB0YW5nZW50IHZlY3RvciBjb3JyZXNwb25kaW5nIHRvIHRoZSBpbnRlcnBvbGF0ZWQgUGF0aDNEIGN1cnZlIHBvaW50LCBpZiBub3QgaW50ZXJwb2xhdGVkLCB0aGUgdGFuZ2VudCBpcyB0YWtlbiBmcm9tIHRoZSBwcmVjb21wdXRlZCB0YW5nZW50cyBhcnJheS5cbiAgICAgKi9cbiAgICBnZXRUYW5nZW50QXQocG9zaXRpb24sIGludGVycG9sYXRlZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvaW50QXREYXRhKHBvc2l0aW9uLCBpbnRlcnBvbGF0ZWQpO1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVkID8gVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhWZWN0b3IzLkZvcndhcmQoKSwgdGhpcy5fcG9pbnRBdERhdGEuaW50ZXJwb2xhdGlvbk1hdHJpeCkgOiB0aGlzLl90YW5nZW50c1t0aGlzLl9wb2ludEF0RGF0YS5wcmV2aW91c1BvaW50QXJyYXlJbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRhbmdlbnQgdmVjdG9yIG9mIGFuIGludGVycG9sYXRlZCBQYXRoM0QgY3VydmUgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBhbG9uZyB0aGlzIHBhdGguXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgYWxvbmcgdGhpcyBwYXRoLCBmcm9tIDAuMCB0byAxLjBcbiAgICAgKiBAcGFyYW0gaW50ZXJwb2xhdGVkIChvcHRpb25hbCwgZGVmYXVsdCBmYWxzZSkgOiBib29sZWFuLCBpZiB0cnVlIHJldHVybnMgYW4gaW50ZXJwb2xhdGVkIG5vcm1hbCBpbnN0ZWFkIG9mIHRoZSBub3JtYWwgb2YgdGhlIHByZXZpb3VzIHBhdGggcG9pbnQuXG4gICAgICogQHJldHVybnMgYSBub3JtYWwgdmVjdG9yIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGludGVycG9sYXRlZCBQYXRoM0QgY3VydmUgcG9pbnQsIGlmIG5vdCBpbnRlcnBvbGF0ZWQsIHRoZSBub3JtYWwgaXMgdGFrZW4gZnJvbSB0aGUgcHJlY29tcHV0ZWQgbm9ybWFscyBhcnJheS5cbiAgICAgKi9cbiAgICBnZXROb3JtYWxBdChwb3NpdGlvbiwgaW50ZXJwb2xhdGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9pbnRBdERhdGEocG9zaXRpb24sIGludGVycG9sYXRlZCk7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZWQgPyBWZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKFZlY3RvcjMuUmlnaHQoKSwgdGhpcy5fcG9pbnRBdERhdGEuaW50ZXJwb2xhdGlvbk1hdHJpeCkgOiB0aGlzLl9ub3JtYWxzW3RoaXMuX3BvaW50QXREYXRhLnByZXZpb3VzUG9pbnRBcnJheUluZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmlub3JtYWwgdmVjdG9yIG9mIGFuIGludGVycG9sYXRlZCBQYXRoM0QgY3VydmUgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBhbG9uZyB0aGlzIHBhdGguXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgYWxvbmcgdGhpcyBwYXRoLCBmcm9tIDAuMCB0byAxLjBcbiAgICAgKiBAcGFyYW0gaW50ZXJwb2xhdGVkIChvcHRpb25hbCwgZGVmYXVsdCBmYWxzZSkgOiBib29sZWFuLCBpZiB0cnVlIHJldHVybnMgYW4gaW50ZXJwb2xhdGVkIGJpbm9ybWFsIGluc3RlYWQgb2YgdGhlIGJpbm9ybWFsIG9mIHRoZSBwcmV2aW91cyBwYXRoIHBvaW50LlxuICAgICAqIEByZXR1cm5zIGEgYmlub3JtYWwgdmVjdG9yIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGludGVycG9sYXRlZCBQYXRoM0QgY3VydmUgcG9pbnQsIGlmIG5vdCBpbnRlcnBvbGF0ZWQsIHRoZSBiaW5vcm1hbCBpcyB0YWtlbiBmcm9tIHRoZSBwcmVjb21wdXRlZCBiaW5vcm1hbHMgYXJyYXkuXG4gICAgICovXG4gICAgZ2V0Qmlub3JtYWxBdChwb3NpdGlvbiwgaW50ZXJwb2xhdGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9pbnRBdERhdGEocG9zaXRpb24sIGludGVycG9sYXRlZCk7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZWQgPyBWZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKFZlY3RvcjMuVXBSZWFkT25seSwgdGhpcy5fcG9pbnRBdERhdGEuaW50ZXJwb2xhdGlvbk1hdHJpeCkgOiB0aGlzLl9iaW5vcm1hbHNbdGhpcy5fcG9pbnRBdERhdGEucHJldmlvdXNQb2ludEFycmF5SW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoZmxvYXQpIG9mIGFuIGludGVycG9sYXRlZCBQYXRoM0QgY3VydmUgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBhbG9uZyB0aGlzIHBhdGguXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgYWxvbmcgdGhpcyBwYXRoLCBmcm9tIDAuMCB0byAxLjBcbiAgICAgKiBAcmV0dXJucyB0aGUgZGlzdGFuY2Ugb2YgdGhlIGludGVycG9sYXRlZCBQYXRoM0QgY3VydmUgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBhbG9uZyB0aGlzIHBhdGguXG4gICAgICovXG4gICAgZ2V0RGlzdGFuY2VBdChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGgoKSAqIHBvc2l0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBpbmRleCBvZiB0aGUgcHJldmlvdXMgcG9pbnQgb2YgYW4gaW50ZXJwb2xhdGVkIHBvaW50IGFsb25nIHRoaXMgcGF0aFxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIHBvaW50IHRvIGludGVycG9sYXRlIGFsb25nIHRoaXMgcGF0aCwgZnJvbSAwLjAgdG8gMS4wXG4gICAgICogQHJldHVybnMgdGhlIGFycmF5IGluZGV4XG4gICAgICovXG4gICAgZ2V0UHJldmlvdXNQb2ludEluZGV4QXQocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9pbnRBdERhdGEocG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRBdERhdGEucHJldmlvdXNQb2ludEFycmF5SW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIGFuIGludGVycG9sYXRlZCBwb2ludCByZWxhdGl2ZSB0byB0aGUgdHdvIHBhdGggcG9pbnRzIGl0IGxpZXMgYmV0d2VlbiwgZnJvbSAwLjAgKHBvaW50IEEpIHRvIDEuMCAocG9pbnQgQilcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludCB0byBpbnRlcnBvbGF0ZSBhbG9uZyB0aGlzIHBhdGgsIGZyb20gMC4wIHRvIDEuMFxuICAgICAqIEByZXR1cm5zIHRoZSBzdWIgcG9zaXRpb25cbiAgICAgKi9cbiAgICBnZXRTdWJQb3NpdGlvbkF0KHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvaW50QXREYXRhKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50QXREYXRhLnN1YlBvc2l0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY2xvc2VzdCB2aXJ0dWFsIHBvaW50IG9uIHRoaXMgcGF0aCB0byBhbiBhcmJpdHJhcnkgVmVjdG9yMywgZnJvbSAwLjAgdG8gMS4wXG4gICAgICogQHBhcmFtIHRhcmdldCB0aGUgdmVjdG9yIG9mIHdoaWNoIHRvIGdldCB0aGUgY2xvc2VzdCBwb3NpdGlvbiB0b1xuICAgICAqIEByZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY2xvc2VzdCB2aXJ0dWFsIHBvaW50IG9uIHRoaXMgcGF0aCB0byB0aGUgdGFyZ2V0IHZlY3RvclxuICAgICAqL1xuICAgIGdldENsb3Nlc3RQb3NpdGlvblRvKHRhcmdldCkge1xuICAgICAgICBsZXQgc21hbGxlc3REaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGxldCBjbG9zZXN0UG9zaXRpb24gPSAwLjA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY3VydmUubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX2N1cnZlW2kgKyAwXTtcbiAgICAgICAgICAgIGNvbnN0IHRhbmdlbnQgPSB0aGlzLl9jdXJ2ZVtpICsgMV0uc3VidHJhY3QocG9pbnQpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgY29uc3Qgc3ViTGVuZ3RoID0gdGhpcy5fZGlzdGFuY2VzW2kgKyAxXSAtIHRoaXMuX2Rpc3RhbmNlc1tpICsgMF07XG4gICAgICAgICAgICBjb25zdCBzdWJQb3NpdGlvbiA9IE1hdGgubWluKChNYXRoLm1heChWZWN0b3IzLkRvdCh0YW5nZW50LCB0YXJnZXQuc3VidHJhY3QocG9pbnQpLm5vcm1hbGl6ZSgpKSwgMC4wKSAqIFZlY3RvcjMuRGlzdGFuY2UocG9pbnQsIHRhcmdldCkpIC8gc3ViTGVuZ3RoLCAxLjApO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBWZWN0b3IzLkRpc3RhbmNlKHBvaW50LmFkZCh0YW5nZW50LnNjYWxlKHN1YlBvc2l0aW9uICogc3ViTGVuZ3RoKSksIHRhcmdldCk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBzbWFsbGVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgc21hbGxlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RQb3NpdGlvbiA9ICh0aGlzLl9kaXN0YW5jZXNbaSArIDBdICsgc3ViTGVuZ3RoICogc3ViUG9zaXRpb24pIC8gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvc2VzdFBvc2l0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3ViIHBhdGggKHNsaWNlKSBvZiB0aGlzIHBhdGhcbiAgICAgKiBAcGFyYW0gc3RhcnQgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXN0IHBhdGggcG9pbnQsIGZyb20gMC4wIHRvIDEuMCwgb3IgYSBuZWdhdGl2ZSB2YWx1ZSwgd2hpY2ggd2lsbCBnZXQgd3JhcHBlZCBhcm91bmQgZnJvbSB0aGUgZW5kIG9mIHRoZSBwYXRoIHRvIDAuMCB0byAxLjAgdmFsdWVzXG4gICAgICogQHBhcmFtIGVuZCB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgcGF0aCBwb2ludCwgZnJvbSAwLjAgdG8gMS4wLCBvciBhIG5lZ2F0aXZlIHZhbHVlLCB3aGljaCB3aWxsIGdldCB3cmFwcGVkIGFyb3VuZCBmcm9tIHRoZSBlbmQgb2YgdGhlIHBhdGggdG8gMC4wIHRvIDEuMCB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyBhIHN1YiBwYXRoIChzbGljZSkgb2YgdGhpcyBwYXRoXG4gICAgICovXG4gICAgc2xpY2Uoc3RhcnQgPSAwLjAsIGVuZCA9IDEuMCkge1xuICAgICAgICBpZiAoc3RhcnQgPCAwLjApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMSAtICgoc3RhcnQgKiAtMS4wKSAlIDEuMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA8IDAuMCkge1xuICAgICAgICAgICAgZW5kID0gMSAtICgoZW5kICogLTEuMCkgJSAxLjApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgX3N0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIGVuZCA9IF9zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJ2ZVBvaW50cyA9IHRoaXMuZ2V0Q3VydmUoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRQb2ludCA9IHRoaXMuZ2V0UG9pbnRBdChzdGFydCk7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gdGhpcy5nZXRQcmV2aW91c1BvaW50SW5kZXhBdChzdGFydCk7XG4gICAgICAgIGNvbnN0IGVuZFBvaW50ID0gdGhpcy5nZXRQb2ludEF0KGVuZCk7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5nZXRQcmV2aW91c1BvaW50SW5kZXhBdChlbmQpICsgMTtcbiAgICAgICAgY29uc3Qgc2xpY2VQb2ludHMgPSBbXTtcbiAgICAgICAgaWYgKHN0YXJ0ICE9PSAwLjApIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgICAgIHNsaWNlUG9pbnRzLnB1c2goc3RhcnRQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgc2xpY2VQb2ludHMucHVzaCguLi5jdXJ2ZVBvaW50cy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCkpO1xuICAgICAgICBpZiAoZW5kICE9PSAxLjAgfHwgc3RhcnQgPT09IDEuMCkge1xuICAgICAgICAgICAgc2xpY2VQb2ludHMucHVzaChlbmRQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoM0Qoc2xpY2VQb2ludHMsIHRoaXMuZ2V0Tm9ybWFsQXQoc3RhcnQpLCB0aGlzLl9yYXcsIHRoaXMuX2FsaWduVGFuZ2VudHNXaXRoUGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgUGF0aDNEIHRhbmdlbnQsIG5vcm1hbCwgYmlub3JtYWwgYW5kIGRpc3RhbmNlIHJlY29tcHV0YXRpb24uXG4gICAgICogQHBhcmFtIHBhdGggcGF0aCB3aGljaCBhbGwgdmFsdWVzIGFyZSBjb3BpZWQgaW50byB0aGUgY3VydmVzIHBvaW50c1xuICAgICAqIEBwYXJhbSBmaXJzdE5vcm1hbCB3aGljaCBzaG91bGQgYmUgcHJvamVjdGVkIG9udG8gdGhlIGN1cnZlXG4gICAgICogQHBhcmFtIGFsaWduVGFuZ2VudHNXaXRoUGF0aCAob3B0aW9uYWwsIGRlZmF1bHQgZmFsc2UpIDogYm9vbGVhbiwgaWYgdHJ1ZSB0aGUgdGFuZ2VudHMgd2lsbCBiZSBhbGlnbmVkIHdpdGggdGhlIHBhdGhcbiAgICAgKiBAcmV0dXJucyB0aGUgc2FtZSBvYmplY3QgdXBkYXRlZC5cbiAgICAgKi9cbiAgICB1cGRhdGUocGF0aCwgZmlyc3ROb3JtYWwgPSBudWxsLCBhbGlnblRhbmdlbnRzV2l0aFBhdGggPSBmYWxzZSkge1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHBhdGgubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlW3BdLnggPSBwYXRoW3BdLng7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZVtwXS55ID0gcGF0aFtwXS55O1xuICAgICAgICAgICAgdGhpcy5fY3VydmVbcF0ueiA9IHBhdGhbcF0uejtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb21wdXRlKGZpcnN0Tm9ybWFsLCBhbGlnblRhbmdlbnRzV2l0aFBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcHJpdmF0ZSBmdW5jdGlvbiBjb21wdXRlKCkgOiBjb21wdXRlcyB0YW5nZW50cywgbm9ybWFscyBhbmQgYmlub3JtYWxzXG4gICAgX2NvbXB1dGUoZmlyc3ROb3JtYWwsIGFsaWduVGFuZ2VudHNXaXRoUGF0aCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLl9jdXJ2ZS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IGFuZCBsYXN0IHRhbmdlbnRzXG4gICAgICAgIHRoaXMuX3RhbmdlbnRzWzBdID0gdGhpcy5fZ2V0Rmlyc3ROb25OdWxsVmVjdG9yKDApO1xuICAgICAgICBpZiAoIXRoaXMuX3Jhdykge1xuICAgICAgICAgICAgdGhpcy5fdGFuZ2VudHNbMF0ubm9ybWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGFuZ2VudHNbbCAtIDFdID0gdGhpcy5fY3VydmVbbCAtIDFdLnN1YnRyYWN0KHRoaXMuX2N1cnZlW2wgLSAyXSk7XG4gICAgICAgIGlmICghdGhpcy5fcmF3KSB7XG4gICAgICAgICAgICB0aGlzLl90YW5nZW50c1tsIC0gMV0ubm9ybWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm9ybWFscyBhbmQgYmlub3JtYWxzIGF0IGZpcnN0IHBvaW50IDogYXJiaXRyYXJ5IHZlY3RvciB3aXRoIF9ub3JtYWxWZWN0b3IoKVxuICAgICAgICBjb25zdCB0ZzAgPSB0aGlzLl90YW5nZW50c1swXTtcbiAgICAgICAgY29uc3QgcHAwID0gdGhpcy5fbm9ybWFsVmVjdG9yKHRnMCwgZmlyc3ROb3JtYWwpO1xuICAgICAgICB0aGlzLl9ub3JtYWxzWzBdID0gcHAwO1xuICAgICAgICBpZiAoIXRoaXMuX3Jhdykge1xuICAgICAgICAgICAgdGhpcy5fbm9ybWFsc1swXS5ub3JtYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iaW5vcm1hbHNbMF0gPSBWZWN0b3IzLkNyb3NzKHRnMCwgdGhpcy5fbm9ybWFsc1swXSk7XG4gICAgICAgIGlmICghdGhpcy5fcmF3KSB7XG4gICAgICAgICAgICB0aGlzLl9iaW5vcm1hbHNbMF0ubm9ybWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzdGFuY2VzWzBdID0gMC4wO1xuICAgICAgICAvLyBub3JtYWxzIGFuZCBiaW5vcm1hbHMgOiBuZXh0IHBvaW50c1xuICAgICAgICBsZXQgcHJldjsgLy8gcHJldmlvdXMgdmVjdG9yIChzZWdtZW50KVxuICAgICAgICBsZXQgY3VyOyAvLyBjdXJyZW50IHZlY3RvciAoc2VnbWVudClcbiAgICAgICAgbGV0IGN1clRhbmc7IC8vIGN1cnJlbnQgdGFuZ2VudFxuICAgICAgICAvLyBwcmV2aW91cyBub3JtYWxcbiAgICAgICAgbGV0IHByZXZOb3I7IC8vIHByZXZpb3VzIG5vcm1hbFxuICAgICAgICBsZXQgcHJldkJpbm9yOyAvLyBwcmV2aW91cyBiaW5vcm1hbFxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gdGFuZ2VudHNcbiAgICAgICAgICAgIHByZXYgPSB0aGlzLl9nZXRMYXN0Tm9uTnVsbFZlY3RvcihpKTtcbiAgICAgICAgICAgIGlmIChpIDwgbCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjdXIgPSB0aGlzLl9nZXRGaXJzdE5vbk51bGxWZWN0b3IoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFuZ2VudHNbaV0gPSBhbGlnblRhbmdlbnRzV2l0aFBhdGggPyBjdXIgOiBwcmV2LmFkZChjdXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhbmdlbnRzW2ldLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VzW2ldID0gdGhpcy5fZGlzdGFuY2VzW2kgLSAxXSArIHRoaXMuX2N1cnZlW2ldLnN1YnRyYWN0KHRoaXMuX2N1cnZlW2kgLSAxXSkubGVuZ3RoKCk7XG4gICAgICAgICAgICAvLyBub3JtYWxzIGFuZCBiaW5vcm1hbHNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cuY3MuY211LmVkdS9hZnMvYW5kcmV3L3Njcy9jcy8xNS00NjIvd2ViL29sZC9hc3N0MmNhbWVyYS5odG1sXG4gICAgICAgICAgICBjdXJUYW5nID0gdGhpcy5fdGFuZ2VudHNbaV07XG4gICAgICAgICAgICBwcmV2Qmlub3IgPSB0aGlzLl9iaW5vcm1hbHNbaSAtIDFdO1xuICAgICAgICAgICAgdGhpcy5fbm9ybWFsc1tpXSA9IFZlY3RvcjMuQ3Jvc3MocHJldkJpbm9yLCBjdXJUYW5nKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmF3KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25vcm1hbHNbaV0ubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldk5vciA9IHRoaXMuX25vcm1hbHNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxzW2ldID0gcHJldk5vci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsc1tpXS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9iaW5vcm1hbHNbaV0gPSBWZWN0b3IzLkNyb3NzKGN1clRhbmcsIHRoaXMuX25vcm1hbHNbaV0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5vcm1hbHNbaV0ubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9pbnRBdERhdGEuaWQgPSBOYU47XG4gICAgfVxuICAgIC8vIHByaXZhdGUgZnVuY3Rpb24gZ2V0Rmlyc3ROb25OdWxsVmVjdG9yKGluZGV4KVxuICAgIC8vIHJldHVybnMgdGhlIGZpcnN0IG5vbiBudWxsIHZlY3RvciBmcm9tIGluZGV4IDogY3VydmVbaW5kZXggKyBOXS5zdWJ0cmFjdChjdXJ2ZVtpbmRleF0pXG4gICAgX2dldEZpcnN0Tm9uTnVsbFZlY3RvcihpbmRleCkge1xuICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgIGxldCBuTlZlY3RvciA9IHRoaXMuX2N1cnZlW2luZGV4ICsgaV0uc3VidHJhY3QodGhpcy5fY3VydmVbaW5kZXhdKTtcbiAgICAgICAgd2hpbGUgKG5OVmVjdG9yLmxlbmd0aCgpID09PSAwICYmIGluZGV4ICsgaSArIDEgPCB0aGlzLl9jdXJ2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIG5OVmVjdG9yID0gdGhpcy5fY3VydmVbaW5kZXggKyBpXS5zdWJ0cmFjdCh0aGlzLl9jdXJ2ZVtpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuTlZlY3RvcjtcbiAgICB9XG4gICAgLy8gcHJpdmF0ZSBmdW5jdGlvbiBnZXRMYXN0Tm9uTnVsbFZlY3RvcihpbmRleClcbiAgICAvLyByZXR1cm5zIHRoZSBsYXN0IG5vbiBudWxsIHZlY3RvciBmcm9tIGluZGV4IDogY3VydmVbaW5kZXhdLnN1YnRyYWN0KGN1cnZlW2luZGV4IC0gTl0pXG4gICAgX2dldExhc3ROb25OdWxsVmVjdG9yKGluZGV4KSB7XG4gICAgICAgIGxldCBpID0gMTtcbiAgICAgICAgbGV0IG5MVmVjdG9yID0gdGhpcy5fY3VydmVbaW5kZXhdLnN1YnRyYWN0KHRoaXMuX2N1cnZlW2luZGV4IC0gaV0pO1xuICAgICAgICB3aGlsZSAobkxWZWN0b3IubGVuZ3RoKCkgPT09IDAgJiYgaW5kZXggPiBpICsgMSkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgbkxWZWN0b3IgPSB0aGlzLl9jdXJ2ZVtpbmRleF0uc3VidHJhY3QodGhpcy5fY3VydmVbaW5kZXggLSBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5MVmVjdG9yO1xuICAgIH1cbiAgICAvLyBwcml2YXRlIGZ1bmN0aW9uIG5vcm1hbFZlY3Rvcih2MCwgdnQsIHZhKSA6XG4gICAgLy8gcmV0dXJucyBhbiBhcmJpdHJhcnkgcG9pbnQgaW4gdGhlIHBsYW5lIGRlZmluZWQgYnkgdGhlIHBvaW50IHYwIGFuZCB0aGUgdmVjdG9yIHZ0IG9ydGhvZ29uYWwgdG8gdGhpcyBwbGFuZVxuICAgIC8vIGlmIHZhIGlzIHBhc3NlZCwgaXQgcmV0dXJucyB0aGUgdmEgcHJvamVjdGlvbiBvbiB0aGUgcGxhbmUgb3J0aG9nb25hbCB0byB2dCBhdCB0aGUgcG9pbnQgdjBcbiAgICBfbm9ybWFsVmVjdG9yKHZ0LCB2YSkge1xuICAgICAgICBsZXQgbm9ybWFsMDtcbiAgICAgICAgbGV0IHRnbCA9IHZ0Lmxlbmd0aCgpO1xuICAgICAgICBpZiAodGdsID09PSAwLjApIHtcbiAgICAgICAgICAgIHRnbCA9IDEuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmEgPT09IHVuZGVmaW5lZCB8fCB2YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHBvaW50O1xuICAgICAgICAgICAgaWYgKCFXaXRoaW5FcHNpbG9uKE1hdGguYWJzKHZ0LnkpIC8gdGdsLCAxLjAsIEVwc2lsb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvciBhIHBvaW50IGluIHRoZSBwbGFuZVxuICAgICAgICAgICAgICAgIHBvaW50ID0gbmV3IFZlY3RvcjMoMC4wLCAtMS4wLCAwLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIVdpdGhpbkVwc2lsb24oTWF0aC5hYnModnQueCkgLyB0Z2wsIDEuMCwgRXBzaWxvbikpIHtcbiAgICAgICAgICAgICAgICBwb2ludCA9IG5ldyBWZWN0b3IzKDEuMCwgMC4wLCAwLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIVdpdGhpbkVwc2lsb24oTWF0aC5hYnModnQueikgLyB0Z2wsIDEuMCwgRXBzaWxvbikpIHtcbiAgICAgICAgICAgICAgICBwb2ludCA9IG5ldyBWZWN0b3IzKDAuMCwgMC4wLCAxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBWZWN0b3IzLlplcm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1hbDAgPSBWZWN0b3IzLkNyb3NzKHZ0LCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtYWwwID0gVmVjdG9yMy5Dcm9zcyh2dCwgdmEpO1xuICAgICAgICAgICAgVmVjdG9yMy5Dcm9zc1RvUmVmKG5vcm1hbDAsIHZ0LCBub3JtYWwwKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWwwLm5vcm1hbGl6ZSgpO1xuICAgICAgICByZXR1cm4gbm9ybWFsMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcG9pbnQgYXQgZGF0YSBmb3IgYW4gaW50ZXJwb2xhdGVkIHBvaW50IGFsb25nIHRoaXMgY3VydmVcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBhbG9uZyB0aGlzIGN1cnZlLCBmcm9tIDAuMCB0byAxLjBcbiAgICAgKiBAcGFyYW0gaW50ZXJwb2xhdGVUTkJcbiAgICAgKiBAaW50ZXJwb2xhdGVUTkIgd2hldGhlciB0byBjb21wdXRlIHRoZSBpbnRlcnBvbGF0ZWQgdGFuZ2VudCwgbm9ybWFsIGFuZCBiaW5vcm1hbFxuICAgICAqIEByZXR1cm5zIHRoZSAodXBkYXRlZCkgcG9pbnQgYXQgZGF0YVxuICAgICAqL1xuICAgIF91cGRhdGVQb2ludEF0RGF0YShwb3NpdGlvbiwgaW50ZXJwb2xhdGVUTkIgPSBmYWxzZSkge1xuICAgICAgICAvLyBzZXQgYW4gaWQgZm9yIGNhY2hpbmcgdGhlIHJlc3VsdFxuICAgICAgICBpZiAodGhpcy5fcG9pbnRBdERhdGEuaWQgPT09IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BvaW50QXREYXRhLmludGVycG9sYXRlUmVhZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVJbnRlcnBvbGF0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRBdERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludEF0RGF0YS5pZCA9IHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnZlUG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTtcbiAgICAgICAgLy8gY2xhbXAgcG9zaXRpb24gYmV0d2VlbiAwLjAgYW5kIDEuMFxuICAgICAgICBpZiAocG9zaXRpb24gPD0gMC4wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0UG9pbnRBdERhdGEoMC4wLCAwLjAsIGN1cnZlUG9pbnRzWzBdLCAwLCBpbnRlcnBvbGF0ZVROQik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24gPj0gMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0UG9pbnRBdERhdGEoMS4wLCAxLjAsIGN1cnZlUG9pbnRzW2N1cnZlUG9pbnRzLmxlbmd0aCAtIDFdLCBjdXJ2ZVBvaW50cy5sZW5ndGggLSAxLCBpbnRlcnBvbGF0ZVROQik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXZpb3VzUG9pbnQgPSBjdXJ2ZVBvaW50c1swXTtcbiAgICAgICAgbGV0IGN1cnJlbnRQb2ludDtcbiAgICAgICAgbGV0IGN1cnJlbnRMZW5ndGggPSAwLjA7XG4gICAgICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IHBvc2l0aW9uICogdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjdXJ2ZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFBvaW50ID0gY3VydmVQb2ludHNbaV07XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IFZlY3RvcjMuRGlzdGFuY2UocHJldmlvdXNQb2ludCwgY3VycmVudFBvaW50KTtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICBpZiAoY3VycmVudExlbmd0aCA9PT0gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFBvaW50QXREYXRhKHBvc2l0aW9uLCAxLjAsIGN1cnJlbnRQb2ludCwgaSwgaW50ZXJwb2xhdGVUTkIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudExlbmd0aCA+IHRhcmdldExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvTGVuZ3RoID0gY3VycmVudExlbmd0aCAtIHRhcmdldExlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gdG9MZW5ndGggLyBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXIgPSBwcmV2aW91c1BvaW50LnN1YnRyYWN0KGN1cnJlbnRQb2ludCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBjdXJyZW50UG9pbnQuYWRkKGRpci5zY2FsZUluUGxhY2UoZGlmZikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRQb2ludEF0RGF0YShwb3NpdGlvbiwgMSAtIGRpZmYsIHBvaW50LCBpIC0gMSwgaW50ZXJwb2xhdGVUTkIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXNQb2ludCA9IGN1cnJlbnRQb2ludDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRBdERhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHBvaW50IGF0IGRhdGEgZnJvbSB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gd2hlcmUgYWxvbmcgdGhlIHBhdGggdGhlIGludGVycG9sYXRlZCBwb2ludCBpcywgZnJvbSAwLjAgdG8gMS4wXG4gICAgICogQHBhcmFtIHN1YlBvc2l0aW9uXG4gICAgICogQHBhcmFtIHBvaW50IHRoZSBpbnRlcnBvbGF0ZWQgcG9pbnRcbiAgICAgKiBAcGFyYW0gcGFyZW50SW5kZXggdGhlIGluZGV4IG9mIGFuIGV4aXN0aW5nIGN1cnZlIHBvaW50IHRoYXQgaXMgb24sIG9yIGVsc2UgcG9zaXRpb25hbGx5IHRoZSBmaXJzdCBiZWhpbmQsIHRoZSBpbnRlcnBvbGF0ZWQgcG9pbnRcbiAgICAgKiBAcGFyYW0gaW50ZXJwb2xhdGVUTkIgd2hldGhlciB0byBjb21wdXRlIHRoZSBpbnRlcnBvbGF0ZWQgdGFuZ2VudCwgbm9ybWFsIGFuZCBiaW5vcm1hbFxuICAgICAqIEByZXR1cm5zIHRoZSAodXBkYXRlZCkgcG9pbnQgYXQgZGF0YVxuICAgICAqL1xuICAgIF9zZXRQb2ludEF0RGF0YShwb3NpdGlvbiwgc3ViUG9zaXRpb24sIHBvaW50LCBwYXJlbnRJbmRleCwgaW50ZXJwb2xhdGVUTkIpIHtcbiAgICAgICAgdGhpcy5fcG9pbnRBdERhdGEucG9pbnQgPSBwb2ludDtcbiAgICAgICAgdGhpcy5fcG9pbnRBdERhdGEucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5fcG9pbnRBdERhdGEuc3ViUG9zaXRpb24gPSBzdWJQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5fcG9pbnRBdERhdGEucHJldmlvdXNQb2ludEFycmF5SW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgdGhpcy5fcG9pbnRBdERhdGEuaW50ZXJwb2xhdGVSZWFkeSA9IGludGVycG9sYXRlVE5CO1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGVUTkIpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUludGVycG9sYXRpb25NYXRyaXgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRBdERhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHBvaW50IGF0IGludGVycG9sYXRpb24gbWF0cml4IGZvciB0aGUgdGFuZ2VudHMsIG5vcm1hbHMgYW5kIGJpbm9ybWFsc1xuICAgICAqL1xuICAgIF91cGRhdGVJbnRlcnBvbGF0aW9uTWF0cml4KCkge1xuICAgICAgICB0aGlzLl9wb2ludEF0RGF0YS5pbnRlcnBvbGF0aW9uTWF0cml4ID0gTWF0cml4LklkZW50aXR5KCk7XG4gICAgICAgIGNvbnN0IHBhcmVudEluZGV4ID0gdGhpcy5fcG9pbnRBdERhdGEucHJldmlvdXNQb2ludEFycmF5SW5kZXg7XG4gICAgICAgIGlmIChwYXJlbnRJbmRleCAhPT0gdGhpcy5fdGFuZ2VudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnRJbmRleCArIDE7XG4gICAgICAgICAgICBjb25zdCB0YW5nZW50RnJvbSA9IHRoaXMuX3RhbmdlbnRzW3BhcmVudEluZGV4XS5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsRnJvbSA9IHRoaXMuX25vcm1hbHNbcGFyZW50SW5kZXhdLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCBiaW5vcm1hbEZyb20gPSB0aGlzLl9iaW5vcm1hbHNbcGFyZW50SW5kZXhdLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCB0YW5nZW50VG8gPSB0aGlzLl90YW5nZW50c1tpbmRleF0uY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbFRvID0gdGhpcy5fbm9ybWFsc1tpbmRleF0uY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGJpbm9ybWFsVG8gPSB0aGlzLl9iaW5vcm1hbHNbaW5kZXhdLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCBxdWF0RnJvbSA9IFF1YXRlcm5pb24uUm90YXRpb25RdWF0ZXJuaW9uRnJvbUF4aXMobm9ybWFsRnJvbSwgYmlub3JtYWxGcm9tLCB0YW5nZW50RnJvbSk7XG4gICAgICAgICAgICBjb25zdCBxdWF0VG8gPSBRdWF0ZXJuaW9uLlJvdGF0aW9uUXVhdGVybmlvbkZyb21BeGlzKG5vcm1hbFRvLCBiaW5vcm1hbFRvLCB0YW5nZW50VG8pO1xuICAgICAgICAgICAgY29uc3QgcXVhdEF0ID0gUXVhdGVybmlvbi5TbGVycChxdWF0RnJvbSwgcXVhdFRvLCB0aGlzLl9wb2ludEF0RGF0YS5zdWJQb3NpdGlvbik7XG4gICAgICAgICAgICBxdWF0QXQudG9Sb3RhdGlvbk1hdHJpeCh0aGlzLl9wb2ludEF0RGF0YS5pbnRlcnBvbGF0aW9uTWF0cml4KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBDdXJ2ZTMgb2JqZWN0IGlzIGEgbG9naWNhbCBvYmplY3QsIHNvIG5vdCBhIG1lc2gsIHRvIGhhbmRsZSBjdXJ2ZXMgaW4gdGhlIDNEIGdlb21ldHJpYyBzcGFjZS5cbiAqIEEgQ3VydmUzIGlzIGRlc2lnbmVkIGZyb20gYSBzZXJpZXMgb2Ygc3VjY2Vzc2l2ZSBWZWN0b3IzLlxuICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL2ZlYXR1cmVzL2ZlYXR1cmVzRGVlcERpdmUvbWVzaC9kcmF3Q3VydmVzXG4gKi9cbmV4cG9ydCBjbGFzcyBDdXJ2ZTMge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBDdXJ2ZTMgb2JqZWN0IGFsb25nIGEgUXVhZHJhdGljIEJlemllciBjdXJ2ZSA6IGh0dHBzOi8vZG9jLmJhYnlsb25qcy5jb20vZmVhdHVyZXMvZmVhdHVyZXNEZWVwRGl2ZS9tZXNoL2RyYXdDdXJ2ZXMjcXVhZHJhdGljLWJlemllci1jdXJ2ZVxuICAgICAqIEBwYXJhbSB2MCAoVmVjdG9yMykgdGhlIG9yaWdpbiBwb2ludCBvZiB0aGUgUXVhZHJhdGljIEJlemllclxuICAgICAqIEBwYXJhbSB2MSAoVmVjdG9yMykgdGhlIGNvbnRyb2wgcG9pbnRcbiAgICAgKiBAcGFyYW0gdjIgKFZlY3RvcjMpIHRoZSBlbmQgcG9pbnQgb2YgdGhlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAgKiBAcGFyYW0gbmJQb2ludHMgKGludGVnZXIpIHRoZSB3YW50ZWQgbnVtYmVyIG9mIHBvaW50cyBpbiB0aGUgY3VydmVcbiAgICAgKiBAcmV0dXJucyB0aGUgY3JlYXRlZCBDdXJ2ZTNcbiAgICAgKi9cbiAgICBzdGF0aWMgQ3JlYXRlUXVhZHJhdGljQmV6aWVyKHYwLCB2MSwgdjIsIG5iUG9pbnRzKSB7XG4gICAgICAgIG5iUG9pbnRzID0gbmJQb2ludHMgPiAyID8gbmJQb2ludHMgOiAzO1xuICAgICAgICBjb25zdCBiZXogPSBbXTtcbiAgICAgICAgY29uc3QgZXF1YXRpb24gPSAodCwgdmFsMCwgdmFsMSwgdmFsMikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gKDEuMCAtIHQpICogKDEuMCAtIHQpICogdmFsMCArIDIuMCAqIHQgKiAoMS4wIC0gdCkgKiB2YWwxICsgdCAqIHQgKiB2YWwyO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbmJQb2ludHM7IGkrKykge1xuICAgICAgICAgICAgYmV6LnB1c2gobmV3IFZlY3RvcjMoZXF1YXRpb24oaSAvIG5iUG9pbnRzLCB2MC54LCB2MS54LCB2Mi54KSwgZXF1YXRpb24oaSAvIG5iUG9pbnRzLCB2MC55LCB2MS55LCB2Mi55KSwgZXF1YXRpb24oaSAvIG5iUG9pbnRzLCB2MC56LCB2MS56LCB2Mi56KSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ3VydmUzKGJleik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBDdXJ2ZTMgb2JqZWN0IGFsb25nIGEgQ3ViaWMgQmV6aWVyIGN1cnZlIDogaHR0cHM6Ly9kb2MuYmFieWxvbmpzLmNvbS9mZWF0dXJlcy9mZWF0dXJlc0RlZXBEaXZlL21lc2gvZHJhd0N1cnZlcyNjdWJpYy1iZXppZXItY3VydmVcbiAgICAgKiBAcGFyYW0gdjAgKFZlY3RvcjMpIHRoZSBvcmlnaW4gcG9pbnQgb2YgdGhlIEN1YmljIEJlemllclxuICAgICAqIEBwYXJhbSB2MSAoVmVjdG9yMykgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICAgKiBAcGFyYW0gdjIgKFZlY3RvcjMpIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludFxuICAgICAqIEBwYXJhbSB2MyAoVmVjdG9yMykgdGhlIGVuZCBwb2ludCBvZiB0aGUgQ3ViaWMgQmV6aWVyXG4gICAgICogQHBhcmFtIG5iUG9pbnRzIChpbnRlZ2VyKSB0aGUgd2FudGVkIG51bWJlciBvZiBwb2ludHMgaW4gdGhlIGN1cnZlXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgQ3VydmUzXG4gICAgICovXG4gICAgc3RhdGljIENyZWF0ZUN1YmljQmV6aWVyKHYwLCB2MSwgdjIsIHYzLCBuYlBvaW50cykge1xuICAgICAgICBuYlBvaW50cyA9IG5iUG9pbnRzID4gMyA/IG5iUG9pbnRzIDogNDtcbiAgICAgICAgY29uc3QgYmV6ID0gW107XG4gICAgICAgIGNvbnN0IGVxdWF0aW9uID0gKHQsIHZhbDAsIHZhbDEsIHZhbDIsIHZhbDMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9ICgxLjAgLSB0KSAqICgxLjAgLSB0KSAqICgxLjAgLSB0KSAqIHZhbDAgKyAzLjAgKiB0ICogKDEuMCAtIHQpICogKDEuMCAtIHQpICogdmFsMSArIDMuMCAqIHQgKiB0ICogKDEuMCAtIHQpICogdmFsMiArIHQgKiB0ICogdCAqIHZhbDM7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuYlBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBiZXoucHVzaChuZXcgVmVjdG9yMyhlcXVhdGlvbihpIC8gbmJQb2ludHMsIHYwLngsIHYxLngsIHYyLngsIHYzLngpLCBlcXVhdGlvbihpIC8gbmJQb2ludHMsIHYwLnksIHYxLnksIHYyLnksIHYzLnkpLCBlcXVhdGlvbihpIC8gbmJQb2ludHMsIHYwLnosIHYxLnosIHYyLnosIHYzLnopKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDdXJ2ZTMoYmV6KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEN1cnZlMyBvYmplY3QgYWxvbmcgYSBIZXJtaXRlIFNwbGluZSBjdXJ2ZSA6IGh0dHBzOi8vZG9jLmJhYnlsb25qcy5jb20vZmVhdHVyZXMvZmVhdHVyZXNEZWVwRGl2ZS9tZXNoL2RyYXdDdXJ2ZXMjaGVybWl0ZS1zcGxpbmVcbiAgICAgKiBAcGFyYW0gcDEgKFZlY3RvcjMpIHRoZSBvcmlnaW4gcG9pbnQgb2YgdGhlIEhlcm1pdGUgU3BsaW5lXG4gICAgICogQHBhcmFtIHQxIChWZWN0b3IzKSB0aGUgdGFuZ2VudCB2ZWN0b3IgYXQgdGhlIG9yaWdpbiBwb2ludFxuICAgICAqIEBwYXJhbSBwMiAoVmVjdG9yMykgdGhlIGVuZCBwb2ludCBvZiB0aGUgSGVybWl0ZSBTcGxpbmVcbiAgICAgKiBAcGFyYW0gdDIgKFZlY3RvcjMpIHRoZSB0YW5nZW50IHZlY3RvciBhdCB0aGUgZW5kIHBvaW50XG4gICAgICogQHBhcmFtIG5TZWcgKGludGVnZXIpIHRoZSBudW1iZXIgb2YgY3VydmUgc2VnbWVudHMgb3IgblNlZyArIDEgcG9pbnRzIGluIHRoZSBhcnJheVxuICAgICAqIEByZXR1cm5zIHRoZSBjcmVhdGVkIEN1cnZlM1xuICAgICAqL1xuICAgIHN0YXRpYyBDcmVhdGVIZXJtaXRlU3BsaW5lKHAxLCB0MSwgcDIsIHQyLCBuU2VnKSB7XG4gICAgICAgIGNvbnN0IGhlcm1pdGUgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RlcCA9IDEuMCAvIG5TZWc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG5TZWc7IGkrKykge1xuICAgICAgICAgICAgaGVybWl0ZS5wdXNoKFZlY3RvcjMuSGVybWl0ZShwMSwgdDEsIHAyLCB0MiwgaSAqIHN0ZXApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEN1cnZlMyhoZXJtaXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEN1cnZlMyBvYmplY3QgYWxvbmcgYSBDYXRtdWxsUm9tIFNwbGluZSBjdXJ2ZSA6XG4gICAgICogQHBhcmFtIHBvaW50cyAoYXJyYXkgb2YgVmVjdG9yMykgdGhlIHBvaW50cyB0aGUgc3BsaW5lIG11c3QgcGFzcyB0aHJvdWdoLiBBdCBsZWFzdCwgZm91ciBwb2ludHMgcmVxdWlyZWRcbiAgICAgKiBAcGFyYW0gbmJQb2ludHMgKGludGVnZXIpIHRoZSB3YW50ZWQgbnVtYmVyIG9mIHBvaW50cyBiZXR3ZWVuIGVhY2ggY3VydmUgY29udHJvbCBwb2ludHNcbiAgICAgKiBAcGFyYW0gY2xvc2VkIChib29sZWFuKSBvcHRpb25hbCB3aXRoIGRlZmF1bHQgZmFsc2UsIHdoZW4gdHJ1ZSBmb3JtcyBhIGNsb3NlZCBsb29wIGZyb20gdGhlIHBvaW50c1xuICAgICAqIEByZXR1cm5zIHRoZSBjcmVhdGVkIEN1cnZlM1xuICAgICAqL1xuICAgIHN0YXRpYyBDcmVhdGVDYXRtdWxsUm9tU3BsaW5lKHBvaW50cywgbmJQb2ludHMsIGNsb3NlZCkge1xuICAgICAgICBjb25zdCBjYXRtdWxsUm9tID0gW107XG4gICAgICAgIGNvbnN0IHN0ZXAgPSAxLjAgLyBuYlBvaW50cztcbiAgICAgICAgbGV0IGFtb3VudCA9IDAuMDtcbiAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzQ291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW1vdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IG5iUG9pbnRzOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0bXVsbFJvbS5wdXNoKFZlY3RvcjMuQ2F0bXVsbFJvbShwb2ludHNbaSAlIHBvaW50c0NvdW50XSwgcG9pbnRzWyhpICsgMSkgJSBwb2ludHNDb3VudF0sIHBvaW50c1soaSArIDIpICUgcG9pbnRzQ291bnRdLCBwb2ludHNbKGkgKyAzKSAlIHBvaW50c0NvdW50XSwgYW1vdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGFtb3VudCArPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdG11bGxSb20ucHVzaChjYXRtdWxsUm9tWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsUG9pbnRzID0gW107XG4gICAgICAgICAgICB0b3RhbFBvaW50cy5wdXNoKHBvaW50c1swXS5jbG9uZSgpKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRvdGFsUG9pbnRzLCBwb2ludHMpO1xuICAgICAgICAgICAgdG90YWxQb2ludHMucHVzaChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLmNsb25lKCkpO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCB0b3RhbFBvaW50cy5sZW5ndGggLSAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbW91bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbmJQb2ludHM7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICBjYXRtdWxsUm9tLnB1c2goVmVjdG9yMy5DYXRtdWxsUm9tKHRvdGFsUG9pbnRzW2ldLCB0b3RhbFBvaW50c1tpICsgMV0sIHRvdGFsUG9pbnRzW2kgKyAyXSwgdG90YWxQb2ludHNbaSArIDNdLCBhbW91bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50ICs9IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgY2F0bXVsbFJvbS5wdXNoKFZlY3RvcjMuQ2F0bXVsbFJvbSh0b3RhbFBvaW50c1tpXSwgdG90YWxQb2ludHNbaSArIDFdLCB0b3RhbFBvaW50c1tpICsgMl0sIHRvdGFsUG9pbnRzW2kgKyAzXSwgYW1vdW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDdXJ2ZTMoY2F0bXVsbFJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBDdXJ2ZTMgb2JqZWN0IGFsb25nIGFuIGFyYyB0aHJvdWdoIHRocmVlIHZlY3RvcjMgcG9pbnRzOlxuICAgICAqIFRoZSB0aHJlZSBwb2ludHMgc2hvdWxkIG5vdCBiZSBjb2xpbmVhci4gV2hlbiB0aGV5IGFyZSB0aGUgQ3VydmUzIGlzIGVtcHR5LlxuICAgICAqIEBwYXJhbSBmaXJzdCAoVmVjdG9yMykgdGhlIGZpcnN0IHBvaW50IHRoZSBhcmMgbXVzdCBwYXNzIHRocm91Z2guXG4gICAgICogQHBhcmFtIHNlY29uZCAoVmVjdG9yMykgdGhlIHNlY29uZCBwb2ludCB0aGUgYXJjIG11c3QgcGFzcyB0aHJvdWdoLlxuICAgICAqIEBwYXJhbSB0aGlyZCAoVmVjdG9yMykgdGhlIHRoaXJkIHBvaW50IHRoZSBhcmMgbXVzdCBwYXNzIHRocm91Z2guXG4gICAgICogQHBhcmFtIHN0ZXBzIChudW1iZXIpIHRoZSBsYXJnZXIgdGhlIG51bWJlciBvZiBzdGVwcyB0aGUgbW9yZSBkZXRhaWxlZCB0aGUgYXJjLlxuICAgICAqIEBwYXJhbSBjbG9zZWQgKGJvb2xlYW4pIG9wdGlvbmFsIHdpdGggZGVmYXVsdCBmYWxzZSwgd2hlbiB0cnVlIGZvcm1zIHRoZSBjaG9yZCBmcm9tIHRoZSBmaXJzdCBhbmQgdGhpcmQgcG9pbnRcbiAgICAgKiBAcGFyYW0gZnVsbENpcmNsZSBDaXJjbGUgKGJvb2xlYW4pIG9wdGlvbmFsIHdpdGggZGVmYXVsdCBmYWxzZSwgd2hlbiB0cnVlIGZvcm1zIHRoZSBjb21wbGV0ZSBjaXJjbGUgdGhyb3VnaCB0aGUgdGhyZWUgcG9pbnRzXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgQ3VydmUzXG4gICAgICovXG4gICAgc3RhdGljIEFyY1RocnUzUG9pbnRzKGZpcnN0LCBzZWNvbmQsIHRoaXJkLCBzdGVwcyA9IDMyLCBjbG9zZWQgPSBmYWxzZSwgZnVsbENpcmNsZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGFyYyA9IFtdO1xuICAgICAgICBjb25zdCB2ZWMxID0gc2Vjb25kLnN1YnRyYWN0KGZpcnN0KTtcbiAgICAgICAgY29uc3QgdmVjMiA9IHRoaXJkLnN1YnRyYWN0KHNlY29uZCk7XG4gICAgICAgIGNvbnN0IHZlYzMgPSBmaXJzdC5zdWJ0cmFjdCh0aGlyZCk7XG4gICAgICAgIGNvbnN0IHpBeGlzID0gVmVjdG9yMy5Dcm9zcyh2ZWMxLCB2ZWMyKTtcbiAgICAgICAgY29uc3QgbGVuNCA9IHpBeGlzLmxlbmd0aCgpO1xuICAgICAgICBpZiAobGVuNCA8IE1hdGgucG93KDEwLCAtOCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VydmUzKGFyYyk7IC8vIGNvbGluZWFyIHBvaW50cyBhcmMgaXMgZW1wdHlcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4xU3EgPSB2ZWMxLmxlbmd0aFNxdWFyZWQoKTtcbiAgICAgICAgY29uc3QgbGVuMlNxID0gdmVjMi5sZW5ndGhTcXVhcmVkKCk7XG4gICAgICAgIGNvbnN0IGxlbjNTcSA9IHZlYzMubGVuZ3RoU3F1YXJlZCgpO1xuICAgICAgICBjb25zdCBsZW40U3EgPSB6QXhpcy5sZW5ndGhTcXVhcmVkKCk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSB2ZWMxLmxlbmd0aCgpO1xuICAgICAgICBjb25zdCBsZW4yID0gdmVjMi5sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgbGVuMyA9IHZlYzMubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9ICgwLjUgKiBsZW4xICogbGVuMiAqIGxlbjMpIC8gbGVuNDtcbiAgICAgICAgY29uc3QgZG90MSA9IFZlY3RvcjMuRG90KHZlYzEsIHZlYzMpO1xuICAgICAgICBjb25zdCBkb3QyID0gVmVjdG9yMy5Eb3QodmVjMSwgdmVjMik7XG4gICAgICAgIGNvbnN0IGRvdDMgPSBWZWN0b3IzLkRvdCh2ZWMyLCB2ZWMzKTtcbiAgICAgICAgY29uc3QgYSA9ICgtMC41ICogbGVuMlNxICogZG90MSkgLyBsZW40U3E7XG4gICAgICAgIGNvbnN0IGIgPSAoLTAuNSAqIGxlbjNTcSAqIGRvdDIpIC8gbGVuNFNxO1xuICAgICAgICBjb25zdCBjID0gKC0wLjUgKiBsZW4xU3EgKiBkb3QzKSAvIGxlbjRTcTtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZmlyc3Quc2NhbGUoYSkuYWRkKHNlY29uZC5zY2FsZShiKSkuYWRkKHRoaXJkLnNjYWxlKGMpKTtcbiAgICAgICAgY29uc3QgcmFkaXVzVmVjID0gZmlyc3Quc3VidHJhY3QoY2VudGVyKTtcbiAgICAgICAgY29uc3QgeEF4aXMgPSByYWRpdXNWZWMubm9ybWFsaXplKCk7XG4gICAgICAgIGNvbnN0IHlBeGlzID0gVmVjdG9yMy5Dcm9zcyh6QXhpcywgeEF4aXMpLm5vcm1hbGl6ZSgpO1xuICAgICAgICBpZiAoZnVsbENpcmNsZSkge1xuICAgICAgICAgICAgY29uc3QgZFN0ZXAgPSAoMiAqIE1hdGguUEkpIC8gc3RlcHM7XG4gICAgICAgICAgICBmb3IgKGxldCB0aGV0YSA9IDA7IHRoZXRhIDw9IDIgKiBNYXRoLlBJOyB0aGV0YSArPSBkU3RlcCkge1xuICAgICAgICAgICAgICAgIGFyYy5wdXNoKGNlbnRlci5hZGQoeEF4aXMuc2NhbGUocmFkaXVzICogTWF0aC5jb3ModGhldGEpKS5hZGQoeUF4aXMuc2NhbGUocmFkaXVzICogTWF0aC5zaW4odGhldGEpKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyYy5wdXNoKGZpcnN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRTdGVwID0gMSAvIHN0ZXBzO1xuICAgICAgICAgICAgbGV0IHRoZXRhID0gMDtcbiAgICAgICAgICAgIGxldCBwb2ludCA9IFZlY3RvcjMuWmVybygpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gY2VudGVyLmFkZCh4QXhpcy5zY2FsZShyYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSkpLmFkZCh5QXhpcy5zY2FsZShyYWRpdXMgKiBNYXRoLnNpbih0aGV0YSkpKSk7XG4gICAgICAgICAgICAgICAgYXJjLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgIHRoZXRhICs9IGRTdGVwO1xuICAgICAgICAgICAgfSB3aGlsZSAoIXBvaW50LmVxdWFsc1dpdGhFcHNpbG9uKHRoaXJkLCByYWRpdXMgKiBkU3RlcCAqIDEuMSkpO1xuICAgICAgICAgICAgYXJjLnB1c2godGhpcmQpO1xuICAgICAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGFyYy5wdXNoKGZpcnN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEN1cnZlMyhhcmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEN1cnZlMyBvYmplY3QgaXMgYSBsb2dpY2FsIG9iamVjdCwgc28gbm90IGEgbWVzaCwgdG8gaGFuZGxlIGN1cnZlcyBpbiB0aGUgM0QgZ2VvbWV0cmljIHNwYWNlLlxuICAgICAqIEEgQ3VydmUzIGlzIGRlc2lnbmVkIGZyb20gYSBzZXJpZXMgb2Ygc3VjY2Vzc2l2ZSBWZWN0b3IzLlxuICAgICAqIFR1dG8gOiBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL2ZlYXR1cmVzL2ZlYXR1cmVzRGVlcERpdmUvbWVzaC9kcmF3Q3VydmVzI2N1cnZlMy1vYmplY3RcbiAgICAgKiBAcGFyYW0gcG9pbnRzIHBvaW50cyB3aGljaCBtYWtlIHVwIHRoZSBjdXJ2ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBvaW50cykge1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwLjA7XG4gICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5fY29tcHV0ZUxlbmd0aChwb2ludHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgQ3VydmUzIHN0b3JlZCBhcnJheSBvZiBzdWNjZXNzaXZlIFZlY3RvcjNcbiAgICAgKi9cbiAgICBnZXRQb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRoZSBjb21wdXRlZCBsZW5ndGggKGZsb2F0KSBvZiB0aGUgY3VydmUuXG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIEN1cnZlMyBvYmplY3QgOiB2YXIgY3VydmUgPSBjdXJ2ZUEuY29udGludWUoY3VydmVCKTtcbiAgICAgKiBUaGlzIG5ldyBDdXJ2ZTMgaXMgYnVpbHQgYnkgdHJhbnNsYXRpbmcgYW5kIHN0aWNraW5nIHRoZSBjdXJ2ZUIgYXQgdGhlIGVuZCBvZiB0aGUgY3VydmVBLlxuICAgICAqIGN1cnZlQSBhbmQgY3VydmVCIGtlZXAgdW5jaGFuZ2VkLlxuICAgICAqIEBwYXJhbSBjdXJ2ZSB0aGUgY3VydmUgdG8gY29udGludWUgZnJvbSB0aGlzIGN1cnZlXG4gICAgICogQHJldHVybnMgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIGN1cnZlXG4gICAgICovXG4gICAgY29udGludWUoY3VydmUpIHtcbiAgICAgICAgY29uc3QgbGFzdFBvaW50ID0gdGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgY29udGludWVkUG9pbnRzID0gdGhpcy5fcG9pbnRzLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IGN1cnZlUG9pbnRzID0gY3VydmUuZ2V0UG9pbnRzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY3VydmVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRpbnVlZFBvaW50cy5wdXNoKGN1cnZlUG9pbnRzW2ldLnN1YnRyYWN0KGN1cnZlUG9pbnRzWzBdKS5hZGQobGFzdFBvaW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGludWVkQ3VydmUgPSBuZXcgQ3VydmUzKGNvbnRpbnVlZFBvaW50cyk7XG4gICAgICAgIHJldHVybiBjb250aW51ZWRDdXJ2ZTtcbiAgICB9XG4gICAgX2NvbXB1dGVMZW5ndGgocGF0aCkge1xuICAgICAgICBsZXQgbCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbCArPSBwYXRoW2ldLnN1YnRyYWN0KHBhdGhbaSAtIDFdKS5sZW5ndGgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLnBhdGguanMubWFwIiwiaW1wb3J0IHsgVmVjdG9yMywgVmVjdG9yMiB9IGZyb20gXCIuL21hdGgudmVjdG9yLmpzXCI7XG4vKipcbiAqIENvbnRhaW5zIHBvc2l0aW9uIGFuZCBub3JtYWwgdmVjdG9ycyBmb3IgYSB2ZXJ0ZXhcbiAqL1xuZXhwb3J0IGNsYXNzIFBvc2l0aW9uTm9ybWFsVmVydGV4IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUG9zaXRpb25Ob3JtYWxWZXJ0ZXhcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXggKGRlZmF1dDogMCwwLDApXG4gICAgICogQHBhcmFtIG5vcm1hbCB0aGUgbm9ybWFsIG9mIHRoZSB2ZXJ0ZXggKGRlZmF1dDogMCwxLDApXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFtWZWN0b3IzLlplcm8oKV0gdGhlIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXggKGRlZmF1dDogMCwwLDApICovXG4gICAgcG9zaXRpb24gPSBWZWN0b3IzLlplcm8oKSwgXG4gICAgLyoqIFtWZWN0b3IzLlVwKCldIHRoZSBub3JtYWwgb2YgdGhlIHZlcnRleCAoZGVmYXV0OiAwLDEsMCkgKi9cbiAgICBub3JtYWwgPSBWZWN0b3IzLlVwKCkpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBQb3NpdGlvbk5vcm1hbFZlcnRleFxuICAgICAqIEByZXR1cm5zIHRoZSBjbG9uZWQgUG9zaXRpb25Ob3JtYWxWZXJ0ZXhcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbk5vcm1hbFZlcnRleCh0aGlzLnBvc2l0aW9uLmNsb25lKCksIHRoaXMubm9ybWFsLmNsb25lKCkpO1xuICAgIH1cbn1cbi8qKlxuICogQ29udGFpbnMgcG9zaXRpb24sIG5vcm1hbCBhbmQgdXYgdmVjdG9ycyBmb3IgYSB2ZXJ0ZXhcbiAqL1xuZXhwb3J0IGNsYXNzIFBvc2l0aW9uTm9ybWFsVGV4dHVyZVZlcnRleCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFBvc2l0aW9uTm9ybWFsVGV4dHVyZVZlcnRleFxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIHZlcnRleCAoZGVmYXV0OiAwLDAsMClcbiAgICAgKiBAcGFyYW0gbm9ybWFsIHRoZSBub3JtYWwgb2YgdGhlIHZlcnRleCAoZGVmYXV0OiAwLDEsMClcbiAgICAgKiBAcGFyYW0gdXYgdGhlIHV2IG9mIHRoZSB2ZXJ0ZXggKGRlZmF1bHQ6IDAsMClcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogW1ZlY3RvcjMuWmVybygpXSB0aGUgcG9zaXRpb24gb2YgdGhlIHZlcnRleCAoZGVmYXV0OiAwLDAsMCkgKi9cbiAgICBwb3NpdGlvbiA9IFZlY3RvcjMuWmVybygpLCBcbiAgICAvKiogW1ZlY3RvcjMuVXAoKV0gdGhlIG5vcm1hbCBvZiB0aGUgdmVydGV4IChkZWZhdXQ6IDAsMSwwKSAqL1xuICAgIG5vcm1hbCA9IFZlY3RvcjMuVXAoKSwgXG4gICAgLyoqIFtWZWN0b3IzLlplcm8oKV0gdGhlIHV2IG9mIHRoZSB2ZXJ0ZXggKGRlZmF1bHQ6IDAsMCkgKi9cbiAgICB1diA9IFZlY3RvcjIuWmVybygpKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgICAgIHRoaXMudXYgPSB1djtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBQb3NpdGlvbk5vcm1hbFRleHR1cmVWZXJ0ZXhcbiAgICAgKiBAcmV0dXJucyB0aGUgY2xvbmVkIFBvc2l0aW9uTm9ybWFsVGV4dHVyZVZlcnRleFxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uTm9ybWFsVGV4dHVyZVZlcnRleCh0aGlzLnBvc2l0aW9uLmNsb25lKCksIHRoaXMubm9ybWFsLmNsb25lKCksIHRoaXMudXYuY2xvbmUoKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC52ZXJ0ZXhGb3JtYXQuanMubWFwIiwiLyoqXG4gKiBDbGFzcyB1c2VkIHRvIHJlcHJlc2VudCBhIHZpZXdwb3J0IG9uIHNjcmVlblxuICovXG5leHBvcnQgY2xhc3MgVmlld3BvcnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBWaWV3cG9ydCBvYmplY3QgbG9jYXRlZCBhdCAoeCwgeSkgYW5kIHNpemVkICh3aWR0aCwgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB4IGRlZmluZXMgdmlld3BvcnQgbGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHkgZGVmaW5lcyB2aWV3cG9ydCB0b3AgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB3aWR0aCBkZWZpbmVzIHRoZSB2aWV3cG9ydCB3aWR0aFxuICAgICAqIEBwYXJhbSBoZWlnaHQgZGVmaW5lcyB0aGUgdmlld3BvcnQgaGVpZ2h0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIHZpZXdwb3J0IGxlZnQgY29vcmRpbmF0ZSAqL1xuICAgIHgsIFxuICAgIC8qKiB2aWV3cG9ydCB0b3AgY29vcmRpbmF0ZSAqL1xuICAgIHksIFxuICAgIC8qKnZpZXdwb3J0IHdpZHRoICovXG4gICAgd2lkdGgsIFxuICAgIC8qKiB2aWV3cG9ydCBoZWlnaHQgKi9cbiAgICBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2aWV3cG9ydCB1c2luZyBhYnNvbHV0ZSBzaXppbmcgKGZyb20gMC0+IHdpZHRoLCAwLT4gaGVpZ2h0IGluc3RlYWQgb2YgMC0+MSlcbiAgICAgKiBAcGFyYW0gcmVuZGVyV2lkdGggZGVmaW5lcyB0aGUgcmVuZGVyaW5nIHdpZHRoXG4gICAgICogQHBhcmFtIHJlbmRlckhlaWdodCBkZWZpbmVzIHRoZSByZW5kZXJpbmcgaGVpZ2h0XG4gICAgICogQHJldHVybnMgYSBuZXcgVmlld3BvcnRcbiAgICAgKi9cbiAgICB0b0dsb2JhbChyZW5kZXJXaWR0aCwgcmVuZGVySGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld3BvcnQodGhpcy54ICogcmVuZGVyV2lkdGgsIHRoaXMueSAqIHJlbmRlckhlaWdodCwgdGhpcy53aWR0aCAqIHJlbmRlcldpZHRoLCB0aGlzLmhlaWdodCAqIHJlbmRlckhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3JlcyBhYnNvbHV0ZSB2aWV3cG9ydCB2YWx1ZSBpbnRvIGEgdGFyZ2V0IHZpZXdwb3J0IChmcm9tIDAtPiB3aWR0aCwgMC0+IGhlaWdodCBpbnN0ZWFkIG9mIDAtPjEpXG4gICAgICogQHBhcmFtIHJlbmRlcldpZHRoIGRlZmluZXMgdGhlIHJlbmRlcmluZyB3aWR0aFxuICAgICAqIEBwYXJhbSByZW5kZXJIZWlnaHQgZGVmaW5lcyB0aGUgcmVuZGVyaW5nIGhlaWdodFxuICAgICAqIEBwYXJhbSByZWYgZGVmaW5lcyB0aGUgdGFyZ2V0IHZpZXdwb3J0XG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdmlld3BvcnRcbiAgICAgKi9cbiAgICB0b0dsb2JhbFRvUmVmKHJlbmRlcldpZHRoLCByZW5kZXJIZWlnaHQsIHJlZikge1xuICAgICAgICByZWYueCA9IHRoaXMueCAqIHJlbmRlcldpZHRoO1xuICAgICAgICByZWYueSA9IHRoaXMueSAqIHJlbmRlckhlaWdodDtcbiAgICAgICAgcmVmLndpZHRoID0gdGhpcy53aWR0aCAqIHJlbmRlcldpZHRoO1xuICAgICAgICByZWYuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiByZW5kZXJIZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZpZXdwb3J0IGNvcGllZCBmcm9tIHRoZSBjdXJyZW50IG9uZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IFZpZXdwb3J0XG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld3BvcnQodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLnZpZXdwb3J0LmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCIuLi9NYXRocy9tYXRoLnZlY3Rvci5qc1wiO1xuaW1wb3J0IHsgVG1wVmVjdG9ycyB9IGZyb20gXCIuL21hdGguanNcIjtcbi8vIGh0dHBzOi8vZGlja3lqaW0ud29yZHByZXNzLmNvbS8yMDEzLzA5LzA0L3NwaGVyaWNhbC1oYXJtb25pY3MtZm9yLWJlZ2lubmVycy9cbi8vIGh0dHA6Ly9zaWx2aW9qZW1tYS5jb20vcHVibGljL3BhcGVycy9saWdodGluZy9zcGhlcmljYWwtaGFybW9uaWMtbGlnaHRpbmcucGRmXG4vLyBodHRwczovL3d3dy5wcHNsb2FuLm9yZy9wdWJsaWNhdGlvbnMvU3R1cGlkU0gzNi5wZGZcbi8vIGh0dHA6Ly9jc2V3ZWIudWNzZC5lZHUvfnJhdmlyL3BhcGVycy9lbnZtYXAvZW52bWFwLnBkZlxuLy8gaHR0cHM6Ly93d3cucHBzbG9hbi5vcmcvcHVibGljYXRpb25zL1NISkNHVC5wZGZcbi8vIGh0dHBzOi8vd3d3LnBwc2xvYW4ub3JnL3B1YmxpY2F0aW9ucy9zaGRlcmluZy5wZGZcbi8vIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9maWxhbWVudC9GaWxhbWVudC5tZC5odG1sI2FubmV4L3NwaGVyaWNhbGhhcm1vbmljc1xuLy8gaHR0cHM6Ly9wYXRhcG9tLmNvbS9ibG9nL1NIUG9ydGFsL1xuLy8gaHR0cHM6Ly9pbWRvaW5naXR3cm9uZy53b3JkcHJlc3MuY29tLzIwMTEvMDQvMTQvc3BoZXJpY2FsLWhhcm1vbmljcy13dGYvXG4vLyBVc2luZyByZWFsIFNIIGJhc2lzOlxuLy8gIG0+MCAgICAgICAgICAgICBtICAgbVxuLy8geSAgID0gc3FydCgyKSAqIEsgKiBQICogY29zKG0qcGhpKSAqIGNvcyh0aGV0YSlcbi8vICBsICAgICAgICAgICAgICAgbCAgIGxcbi8vXG4vLyAgbTwwICAgICAgICAgICAgIG0gICB8bXxcbi8vIHkgICA9IHNxcnQoMikgKiBLICogUCAqIHNpbihtKnBoaSkgKiBjb3ModGhldGEpXG4vLyAgbCAgICAgICAgICAgICAgIGwgICBsXG4vL1xuLy8gIG09MCAgIDAgICAwXG4vLyB5ICAgPSBLICogUCAqIHRyaWdvbm8gdGVybXNcbi8vICBsICAgICBsICAgbFxuLy9cbi8vICBtICAgICAgICgybCArIDEpKGwgLSB8bXwpIVxuLy8gSyA9IHNxcnQoLS0tLS0tLS0tLS0tLS0tLS0tKVxuLy8gIGwgICAgICAgICAgIDRwaShsICsgfG18KSFcbi8vXG4vLyBhbmQgUCBieSByZWN1cnNpb246XG4vL1xuLy8gUDAwKHgpID0gMVxuLy8gUDAxKHgpID0geFxuLy8gUGxsKHgpID0gKC0xXmwpKDJsIC0gMSkhISgxLXgqeCleKDEvMilcbi8vICAgICAgICAgICgoMmwgLSAxKXhbUGwtMS9tXS0obCArIG0gLSAxKVtQbC0yL21dKVxuLy8gUGxtKHgpID0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBsIC0gbVxuLy8gTGVhdmluZyB0aGUgdHJpZ29ub21ldHJpYyB0ZXJtcyBhc2lkZSB3ZSBjYW4gcHJlY29tcHV0ZSB0aGUgY29uc3RhbnRzIHRvIDpcbmNvbnN0IFNIM3lsbUJhc2lzQ29uc3RhbnRzID0gW1xuICAgIE1hdGguc3FydCgxIC8gKDQgKiBNYXRoLlBJKSksIC8vIGwwMFxuICAgIC1NYXRoLnNxcnQoMyAvICg0ICogTWF0aC5QSSkpLCAvLyBsMV8xXG4gICAgTWF0aC5zcXJ0KDMgLyAoNCAqIE1hdGguUEkpKSwgLy8gbDEwXG4gICAgLU1hdGguc3FydCgzIC8gKDQgKiBNYXRoLlBJKSksIC8vIGwxMVxuICAgIE1hdGguc3FydCgxNSAvICg0ICogTWF0aC5QSSkpLCAvLyBsMl8yXG4gICAgLU1hdGguc3FydCgxNSAvICg0ICogTWF0aC5QSSkpLCAvLyBsMl8xXG4gICAgTWF0aC5zcXJ0KDUgLyAoMTYgKiBNYXRoLlBJKSksIC8vIGwyMFxuICAgIC1NYXRoLnNxcnQoMTUgLyAoNCAqIE1hdGguUEkpKSwgLy8gbDIxXG4gICAgTWF0aC5zcXJ0KDE1IC8gKDE2ICogTWF0aC5QSSkpLCAvLyBsMjJcbl07XG4vLyBjbSA9IGNvcyhtICogcGhpKVxuLy8gc20gPSBzaW4obSAqIHBoaSlcbi8vIHt4LHksen0gPSB7Y29zKHBoaSlzaW4odGhldGEpLCBzaW4ocGhpKXNpbih0aGV0YSksIGNvcyh0aGV0YSl9XG4vLyBCeSByZWN1cnNpb24gb24gdXNpbmcgdHJpZ28gaWRlbnRpdGllczpcbmNvbnN0IFNIM3lsbUJhc2lzVHJpZ29ub21ldHJpY1Rlcm1zID0gW1xuICAgICgpID0+IDEsIC8vIGwwMFxuICAgIChkaXJlY3Rpb24pID0+IGRpcmVjdGlvbi55LCAvLyBsMV8xXG4gICAgKGRpcmVjdGlvbikgPT4gZGlyZWN0aW9uLnosIC8vIGwxMFxuICAgIChkaXJlY3Rpb24pID0+IGRpcmVjdGlvbi54LCAvLyBsMTFcbiAgICAoZGlyZWN0aW9uKSA9PiBkaXJlY3Rpb24ueCAqIGRpcmVjdGlvbi55LCAvLyBsMl8yXG4gICAgKGRpcmVjdGlvbikgPT4gZGlyZWN0aW9uLnkgKiBkaXJlY3Rpb24ueiwgLy8gbDJfMVxuICAgIChkaXJlY3Rpb24pID0+IDMgKiBkaXJlY3Rpb24ueiAqIGRpcmVjdGlvbi56IC0gMSwgLy8gbDIwXG4gICAgKGRpcmVjdGlvbikgPT4gZGlyZWN0aW9uLnggKiBkaXJlY3Rpb24ueiwgLy8gbDIxXG4gICAgKGRpcmVjdGlvbikgPT4gZGlyZWN0aW9uLnggKiBkaXJlY3Rpb24ueCAtIGRpcmVjdGlvbi55ICogZGlyZWN0aW9uLnksIC8vIGwyMlxuXTtcbi8vIFdyYXAgdGhlIGZ1bGwgY29tcHV0ZVxuY29uc3QgYXBwbHlTSDMgPSAobG0sIGRpcmVjdGlvbikgPT4ge1xuICAgIHJldHVybiBTSDN5bG1CYXNpc0NvbnN0YW50c1tsbV0gKiBTSDN5bG1CYXNpc1RyaWdvbm9tZXRyaWNUZXJtc1tsbV0oZGlyZWN0aW9uKTtcbn07XG4vLyBEZXJpdmVkIGZyb20gdGhlIGludGVncmF0aW9uIG9mIHRoZSBhIGtlcm5lbCBjb252b2x1dGlvbiB0byBTSC5cbi8vIEdyZWF0IGV4cGxhbmF0aW9uIGhlcmU6IGh0dHBzOi8vcGF0YXBvbS5jb20vYmxvZy9TSFBvcnRhbC8jYWJvdXQtZGlzdGFudC1yYWRpYW5jZS1hbmQtaXJyYWRpYW5jZS1lbnZpcm9ubWVudHNcbmNvbnN0IFNIQ29zS2VybmVsQ29udm9sdXRpb24gPSBbTWF0aC5QSSwgKDIgKiBNYXRoLlBJKSAvIDMsICgyICogTWF0aC5QSSkgLyAzLCAoMiAqIE1hdGguUEkpIC8gMywgTWF0aC5QSSAvIDQsIE1hdGguUEkgLyA0LCBNYXRoLlBJIC8gNCwgTWF0aC5QSSAvIDQsIE1hdGguUEkgLyA0XTtcbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIHNwaGVyaWNhbCBoYXJtb25pY3MgY29lZmZpY2llbnRzIHRvIHRoZSAzcmQgZGVncmVlXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGhlcmljYWxIYXJtb25pY3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgaGFybW9uaWNzIGhhdmUgYmVlbiBwcmVzY2FsZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJlU2NhbGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbDAsMCBjb2VmZmljaWVudHMgb2YgdGhlIHNwaGVyaWNhbCBoYXJtb25pY3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubDAwID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbDEsLTEgY29lZmZpY2llbnRzIG9mIHRoZSBzcGhlcmljYWwgaGFybW9uaWNzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmwxXzEgPSBWZWN0b3IzLlplcm8oKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsMSwwIGNvZWZmaWNpZW50cyBvZiB0aGUgc3BoZXJpY2FsIGhhcm1vbmljc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sMTAgPSBWZWN0b3IzLlplcm8oKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsMSwxIGNvZWZmaWNpZW50cyBvZiB0aGUgc3BoZXJpY2FsIGhhcm1vbmljc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sMTEgPSBWZWN0b3IzLlplcm8oKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsMiwtMiBjb2VmZmljaWVudHMgb2YgdGhlIHNwaGVyaWNhbCBoYXJtb25pY3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubDJfMiA9IFZlY3RvcjMuWmVybygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGwyLC0xIGNvZWZmaWNpZW50cyBvZiB0aGUgc3BoZXJpY2FsIGhhcm1vbmljc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sMl8xID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbDIsMCBjb2VmZmljaWVudHMgb2YgdGhlIHNwaGVyaWNhbCBoYXJtb25pY3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubDIwID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbDIsMSBjb2VmZmljaWVudHMgb2YgdGhlIHNwaGVyaWNhbCBoYXJtb25pY3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubDIxID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbDIsMiBjb2VmZmljaWVudHMgb2YgdGhlIHNwaGVyaWNhbCBoYXJtb25pY3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubDIyID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaWdodCB0byB0aGUgc3BoZXJpY2FsIGhhcm1vbmljc1xuICAgICAqIEBwYXJhbSBkaXJlY3Rpb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGlnaHRcbiAgICAgKiBAcGFyYW0gY29sb3IgdGhlIGNvbG9yIG9mIHRoZSBsaWdodFxuICAgICAqIEBwYXJhbSBkZWx0YVNvbGlkQW5nbGUgdGhlIGRlbHRhIHNvbGlkIGFuZ2xlIG9mIHRoZSBsaWdodFxuICAgICAqL1xuICAgIGFkZExpZ2h0KGRpcmVjdGlvbiwgY29sb3IsIGRlbHRhU29saWRBbmdsZSkge1xuICAgICAgICBUbXBWZWN0b3JzLlZlY3RvcjNbMF0uc2V0KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgICAgICBjb25zdCBjb2xvclZlY3RvciA9IFRtcFZlY3RvcnMuVmVjdG9yM1swXTtcbiAgICAgICAgY29uc3QgYyA9IFRtcFZlY3RvcnMuVmVjdG9yM1sxXTtcbiAgICAgICAgY29sb3JWZWN0b3Iuc2NhbGVUb1JlZihkZWx0YVNvbGlkQW5nbGUsIGMpO1xuICAgICAgICBjLnNjYWxlVG9SZWYoYXBwbHlTSDMoMCwgZGlyZWN0aW9uKSwgVG1wVmVjdG9ycy5WZWN0b3IzWzJdKTtcbiAgICAgICAgdGhpcy5sMDAuYWRkSW5QbGFjZShUbXBWZWN0b3JzLlZlY3RvcjNbMl0pO1xuICAgICAgICBjLnNjYWxlVG9SZWYoYXBwbHlTSDMoMSwgZGlyZWN0aW9uKSwgVG1wVmVjdG9ycy5WZWN0b3IzWzJdKTtcbiAgICAgICAgdGhpcy5sMV8xLmFkZEluUGxhY2UoVG1wVmVjdG9ycy5WZWN0b3IzWzJdKTtcbiAgICAgICAgYy5zY2FsZVRvUmVmKGFwcGx5U0gzKDIsIGRpcmVjdGlvbiksIFRtcFZlY3RvcnMuVmVjdG9yM1syXSk7XG4gICAgICAgIHRoaXMubDEwLmFkZEluUGxhY2UoVG1wVmVjdG9ycy5WZWN0b3IzWzJdKTtcbiAgICAgICAgYy5zY2FsZVRvUmVmKGFwcGx5U0gzKDMsIGRpcmVjdGlvbiksIFRtcFZlY3RvcnMuVmVjdG9yM1syXSk7XG4gICAgICAgIHRoaXMubDExLmFkZEluUGxhY2UoVG1wVmVjdG9ycy5WZWN0b3IzWzJdKTtcbiAgICAgICAgYy5zY2FsZVRvUmVmKGFwcGx5U0gzKDQsIGRpcmVjdGlvbiksIFRtcFZlY3RvcnMuVmVjdG9yM1syXSk7XG4gICAgICAgIHRoaXMubDJfMi5hZGRJblBsYWNlKFRtcFZlY3RvcnMuVmVjdG9yM1syXSk7XG4gICAgICAgIGMuc2NhbGVUb1JlZihhcHBseVNIMyg1LCBkaXJlY3Rpb24pLCBUbXBWZWN0b3JzLlZlY3RvcjNbMl0pO1xuICAgICAgICB0aGlzLmwyXzEuYWRkSW5QbGFjZShUbXBWZWN0b3JzLlZlY3RvcjNbMl0pO1xuICAgICAgICBjLnNjYWxlVG9SZWYoYXBwbHlTSDMoNiwgZGlyZWN0aW9uKSwgVG1wVmVjdG9ycy5WZWN0b3IzWzJdKTtcbiAgICAgICAgdGhpcy5sMjAuYWRkSW5QbGFjZShUbXBWZWN0b3JzLlZlY3RvcjNbMl0pO1xuICAgICAgICBjLnNjYWxlVG9SZWYoYXBwbHlTSDMoNywgZGlyZWN0aW9uKSwgVG1wVmVjdG9ycy5WZWN0b3IzWzJdKTtcbiAgICAgICAgdGhpcy5sMjEuYWRkSW5QbGFjZShUbXBWZWN0b3JzLlZlY3RvcjNbMl0pO1xuICAgICAgICBjLnNjYWxlVG9SZWYoYXBwbHlTSDMoOCwgZGlyZWN0aW9uKSwgVG1wVmVjdG9ycy5WZWN0b3IzWzJdKTtcbiAgICAgICAgdGhpcy5sMjIuYWRkSW5QbGFjZShUbXBWZWN0b3JzLlZlY3RvcjNbMl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgdGhlIHNwaGVyaWNhbCBoYXJtb25pY3MgYnkgdGhlIGdpdmVuIGFtb3VudFxuICAgICAqIEBwYXJhbSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlXG4gICAgICovXG4gICAgc2NhbGVJblBsYWNlKHNjYWxlKSB7XG4gICAgICAgIHRoaXMubDAwLnNjYWxlSW5QbGFjZShzY2FsZSk7XG4gICAgICAgIHRoaXMubDFfMS5zY2FsZUluUGxhY2Uoc2NhbGUpO1xuICAgICAgICB0aGlzLmwxMC5zY2FsZUluUGxhY2Uoc2NhbGUpO1xuICAgICAgICB0aGlzLmwxMS5zY2FsZUluUGxhY2Uoc2NhbGUpO1xuICAgICAgICB0aGlzLmwyXzIuc2NhbGVJblBsYWNlKHNjYWxlKTtcbiAgICAgICAgdGhpcy5sMl8xLnNjYWxlSW5QbGFjZShzY2FsZSk7XG4gICAgICAgIHRoaXMubDIwLnNjYWxlSW5QbGFjZShzY2FsZSk7XG4gICAgICAgIHRoaXMubDIxLnNjYWxlSW5QbGFjZShzY2FsZSk7XG4gICAgICAgIHRoaXMubDIyLnNjYWxlSW5QbGFjZShzY2FsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZnJvbSBpbmNpZGVudCByYWRpYW5jZSAoTGkpIHRvIGlycmFkaWFuY2UgKEUpIGJ5IGFwcGx5aW5nIGNvbnZvbHV0aW9uIHdpdGggdGhlIGNvc2luZS13ZWlnaHRlZCBoZW1pc3BoZXJlLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogRV9sbSA9IEFfbCAqIExfbG1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEluIHNwaGVyaWNhbCBoYXJtb25pY3MgdGhpcyBjb252b2x1dGlvbiBhbW91bnRzIHRvIHNjYWxpbmcgZmFjdG9ycyBmb3IgZWFjaCBmcmVxdWVuY3kgYmFuZC5cbiAgICAgKiBUaGlzIGNvcnJlc3BvbmRzIHRvIGVxdWF0aW9uIDUgaW4gXCJBbiBFZmZpY2llbnQgUmVwcmVzZW50YXRpb24gZm9yIElycmFkaWFuY2UgRW52aXJvbm1lbnQgTWFwc1wiLCB3aGVyZVxuICAgICAqIHRoZSBzY2FsaW5nIGZhY3RvcnMgYXJlIGdpdmVuIGluIGVxdWF0aW9uIDkuXG4gICAgICovXG4gICAgY29udmVydEluY2lkZW50UmFkaWFuY2VUb0lycmFkaWFuY2UoKSB7XG4gICAgICAgIC8vIENvbnN0YW50IChCYW5kIDApXG4gICAgICAgIHRoaXMubDAwLnNjYWxlSW5QbGFjZShTSENvc0tlcm5lbENvbnZvbHV0aW9uWzBdKTtcbiAgICAgICAgLy8gTGluZWFyIChCYW5kIDEpXG4gICAgICAgIHRoaXMubDFfMS5zY2FsZUluUGxhY2UoU0hDb3NLZXJuZWxDb252b2x1dGlvblsxXSk7XG4gICAgICAgIHRoaXMubDEwLnNjYWxlSW5QbGFjZShTSENvc0tlcm5lbENvbnZvbHV0aW9uWzJdKTtcbiAgICAgICAgdGhpcy5sMTEuc2NhbGVJblBsYWNlKFNIQ29zS2VybmVsQ29udm9sdXRpb25bM10pO1xuICAgICAgICAvLyBRdWFkcmF0aWMgKEJhbmQgMilcbiAgICAgICAgdGhpcy5sMl8yLnNjYWxlSW5QbGFjZShTSENvc0tlcm5lbENvbnZvbHV0aW9uWzRdKTtcbiAgICAgICAgdGhpcy5sMl8xLnNjYWxlSW5QbGFjZShTSENvc0tlcm5lbENvbnZvbHV0aW9uWzVdKTtcbiAgICAgICAgdGhpcy5sMjAuc2NhbGVJblBsYWNlKFNIQ29zS2VybmVsQ29udm9sdXRpb25bNl0pO1xuICAgICAgICB0aGlzLmwyMS5zY2FsZUluUGxhY2UoU0hDb3NLZXJuZWxDb252b2x1dGlvbls3XSk7XG4gICAgICAgIHRoaXMubDIyLnNjYWxlSW5QbGFjZShTSENvc0tlcm5lbENvbnZvbHV0aW9uWzhdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBmcm9tIGlycmFkaWFuY2UgdG8gb3V0Z29pbmcgcmFkaWFuY2UgZm9yIExhbWJlcnRpYW4gQkRSRiwgc3VpdGFibGUgZm9yIGVmZmljaWVudCBzaGFkZXIgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEwgPSAoMS9waSkgKiBFICogcmhvXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGRvbmUgYnkgYW4gYWRkaXRpb25hbCBzY2FsZSBieSAxL3BpLCBzbyBpcyBhIGZhaXJseSB0cml2aWFsIG9wZXJhdGlvbiBidXQgaW1wb3J0YW50IGNvbmNlcHR1YWxseS5cbiAgICAgKi9cbiAgICBjb252ZXJ0SXJyYWRpYW5jZVRvTGFtYmVydGlhblJhZGlhbmNlKCkge1xuICAgICAgICB0aGlzLnNjYWxlSW5QbGFjZSgxLjAgLyBNYXRoLlBJKTtcbiAgICAgICAgLy8gVGhlIHJlc3VsdGFudCBTSCBub3cgcmVwcmVzZW50cyBvdXRnb2luZyByYWRpYW5jZSwgc28gaW5jbHVkZXMgdGhlIExhbWJlcnQgMS9waSBub3JtYWxpc2F0aW9uIGZhY3RvciBidXQgd2l0aG91dCBhbGJlZG8gKHJobykgYXBwbGllZFxuICAgICAgICAvLyAoVGhlIHBpeGVsIHNoYWRlciBtdXN0IGFwcGx5IGFsYmVkbyBhZnRlciB0ZXh0dXJlIGZldGNoZXMsIGV0YykuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVncmF0ZXMgdGhlIHJlY29uc3RydWN0aW9uIGNvZWZmaWNpZW50cyBkaXJlY3RseSBpbiB0byB0aGUgU0ggcHJldmVudGluZyBmdXJ0aGVyXG4gICAgICogcmVxdWlyZWQgb3BlcmF0aW9ucyBhdCBydW4gdGltZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgc2ltcGx5IGRvbmUgYnkgc2NhbGluZyBiYWNrIHRoZSBTSCB3aXRoIFlsbSBjb25zdGFudHMgcGFyYW1ldGVyLlxuICAgICAqIFRoZSB0cmlnb25vbWV0cmljIHBhcnQgYmVpbmcgYXBwbGllZCBieSB0aGUgc2hhZGVyIGF0IHJ1biB0aW1lLlxuICAgICAqL1xuICAgIHByZVNjYWxlRm9yUmVuZGVyaW5nKCkge1xuICAgICAgICB0aGlzLnByZVNjYWxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubDAwLnNjYWxlSW5QbGFjZShTSDN5bG1CYXNpc0NvbnN0YW50c1swXSk7XG4gICAgICAgIHRoaXMubDFfMS5zY2FsZUluUGxhY2UoU0gzeWxtQmFzaXNDb25zdGFudHNbMV0pO1xuICAgICAgICB0aGlzLmwxMC5zY2FsZUluUGxhY2UoU0gzeWxtQmFzaXNDb25zdGFudHNbMl0pO1xuICAgICAgICB0aGlzLmwxMS5zY2FsZUluUGxhY2UoU0gzeWxtQmFzaXNDb25zdGFudHNbM10pO1xuICAgICAgICB0aGlzLmwyXzIuc2NhbGVJblBsYWNlKFNIM3lsbUJhc2lzQ29uc3RhbnRzWzRdKTtcbiAgICAgICAgdGhpcy5sMl8xLnNjYWxlSW5QbGFjZShTSDN5bG1CYXNpc0NvbnN0YW50c1s1XSk7XG4gICAgICAgIHRoaXMubDIwLnNjYWxlSW5QbGFjZShTSDN5bG1CYXNpc0NvbnN0YW50c1s2XSk7XG4gICAgICAgIHRoaXMubDIxLnNjYWxlSW5QbGFjZShTSDN5bG1CYXNpc0NvbnN0YW50c1s3XSk7XG4gICAgICAgIHRoaXMubDIyLnNjYWxlSW5QbGFjZShTSDN5bG1CYXNpc0NvbnN0YW50c1s4XSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgc3BoZXJpY2FsIGhhcm1vbmljcyBjb2VmZmljaWVudHMgZnJvbSB0aGUgZ2l2ZW4gYXJyYXlcbiAgICAgKiBAcGFyYW0gZGF0YSBkZWZpbmVzIHRoZSA5eDMgY29lZmZpY2llbnRzIChsMDAsIGwxLTEsIGwxMCwgbDExLCBsMi0yLCBsMi0xLCBsMjAsIGwyMSwgbDIyKVxuICAgICAqIEByZXR1cm5zIHRoZSBzcGhlcmljYWwgaGFybW9uaWNzICh0aGlzKVxuICAgICAqL1xuICAgIHVwZGF0ZUZyb21BcnJheShkYXRhKSB7XG4gICAgICAgIFZlY3RvcjMuRnJvbUFycmF5VG9SZWYoZGF0YVswXSwgMCwgdGhpcy5sMDApO1xuICAgICAgICBWZWN0b3IzLkZyb21BcnJheVRvUmVmKGRhdGFbMV0sIDAsIHRoaXMubDFfMSk7XG4gICAgICAgIFZlY3RvcjMuRnJvbUFycmF5VG9SZWYoZGF0YVsyXSwgMCwgdGhpcy5sMTApO1xuICAgICAgICBWZWN0b3IzLkZyb21BcnJheVRvUmVmKGRhdGFbM10sIDAsIHRoaXMubDExKTtcbiAgICAgICAgVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZihkYXRhWzRdLCAwLCB0aGlzLmwyXzIpO1xuICAgICAgICBWZWN0b3IzLkZyb21BcnJheVRvUmVmKGRhdGFbNV0sIDAsIHRoaXMubDJfMSk7XG4gICAgICAgIFZlY3RvcjMuRnJvbUFycmF5VG9SZWYoZGF0YVs2XSwgMCwgdGhpcy5sMjApO1xuICAgICAgICBWZWN0b3IzLkZyb21BcnJheVRvUmVmKGRhdGFbN10sIDAsIHRoaXMubDIxKTtcbiAgICAgICAgVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZihkYXRhWzhdLCAwLCB0aGlzLmwyMik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIHNwaGVyaWNhbCBoYXJtb25pY3MgY29lZmZpY2llbnRzIGZyb20gdGhlIGdpdmVuIGZsb2F0cyBhcnJheVxuICAgICAqIEBwYXJhbSBkYXRhIGRlZmluZXMgdGhlIDl4MyBjb2VmZmljaWVudHMgKGwwMCwgbDEtMSwgbDEwLCBsMTEsIGwyLTIsIGwyLTEsIGwyMCwgbDIxLCBsMjIpXG4gICAgICogQHJldHVybnMgdGhlIHNwaGVyaWNhbCBoYXJtb25pY3MgKHRoaXMpXG4gICAgICovXG4gICAgdXBkYXRlRnJvbUZsb2F0c0FycmF5KGRhdGEpIHtcbiAgICAgICAgVmVjdG9yMy5Gcm9tRmxvYXRzVG9SZWYoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgdGhpcy5sMDApO1xuICAgICAgICBWZWN0b3IzLkZyb21GbG9hdHNUb1JlZihkYXRhWzNdLCBkYXRhWzRdLCBkYXRhWzVdLCB0aGlzLmwxXzEpO1xuICAgICAgICBWZWN0b3IzLkZyb21GbG9hdHNUb1JlZihkYXRhWzZdLCBkYXRhWzddLCBkYXRhWzhdLCB0aGlzLmwxMCk7XG4gICAgICAgIFZlY3RvcjMuRnJvbUZsb2F0c1RvUmVmKGRhdGFbOV0sIGRhdGFbMTBdLCBkYXRhWzExXSwgdGhpcy5sMTEpO1xuICAgICAgICBWZWN0b3IzLkZyb21GbG9hdHNUb1JlZihkYXRhWzEyXSwgZGF0YVsxM10sIGRhdGFbMTRdLCB0aGlzLmwyXzIpO1xuICAgICAgICBWZWN0b3IzLkZyb21GbG9hdHNUb1JlZihkYXRhWzE1XSwgZGF0YVsxNl0sIGRhdGFbMTddLCB0aGlzLmwyXzEpO1xuICAgICAgICBWZWN0b3IzLkZyb21GbG9hdHNUb1JlZihkYXRhWzE4XSwgZGF0YVsxOV0sIGRhdGFbMjBdLCB0aGlzLmwyMCk7XG4gICAgICAgIFZlY3RvcjMuRnJvbUZsb2F0c1RvUmVmKGRhdGFbMjFdLCBkYXRhWzIyXSwgZGF0YVsyM10sIHRoaXMubDIxKTtcbiAgICAgICAgVmVjdG9yMy5Gcm9tRmxvYXRzVG9SZWYoZGF0YVsyNF0sIGRhdGFbMjVdLCBkYXRhWzI2XSwgdGhpcy5sMjIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIHNwaGVyaWNhbCBoYXJtb25pY3MgZnJvbSBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0gZGF0YSBkZWZpbmVzIHRoZSA5eDMgY29lZmZpY2llbnRzIChsMDAsIGwxLTEsIGwxMCwgbDExLCBsMi0yLCBsMi0xLCBsMjAsIGwyMSwgbDIyKVxuICAgICAqIEByZXR1cm5zIHRoZSBzcGhlcmljYWwgaGFybW9uaWNzXG4gICAgICovXG4gICAgc3RhdGljIEZyb21BcnJheShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHNoID0gbmV3IFNwaGVyaWNhbEhhcm1vbmljcygpO1xuICAgICAgICByZXR1cm4gc2gudXBkYXRlRnJvbUFycmF5KGRhdGEpO1xuICAgIH1cbiAgICAvLyBLZWVwIGZvciByZWZlcmVuY2VzLlxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNwaGVyaWNhbCBoYXJtb25pY3MgZnJvbSBwb2x5bm9taWFsXG4gICAgICogQHBhcmFtIHBvbHlub21pYWwgdGhlIHNwaGVyaWNhbCBwb2x5bm9taWFsXG4gICAgICogQHJldHVybnMgdGhlIHNwaGVyaWNhbCBoYXJtb25pY3NcbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbVBvbHlub21pYWwocG9seW5vbWlhbCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU3BoZXJpY2FsSGFybW9uaWNzKCk7XG4gICAgICAgIHJlc3VsdC5sMDAgPSBwb2x5bm9taWFsLnh4LnNjYWxlKDAuMzc2MTI3KS5hZGQocG9seW5vbWlhbC55eS5zY2FsZSgwLjM3NjEyNykpLmFkZChwb2x5bm9taWFsLnp6LnNjYWxlKDAuMzc2MTI2KSk7XG4gICAgICAgIHJlc3VsdC5sMV8xID0gcG9seW5vbWlhbC55LnNjYWxlKDAuOTc3MjA0KTtcbiAgICAgICAgcmVzdWx0LmwxMCA9IHBvbHlub21pYWwuei5zY2FsZSgwLjk3NzIwNCk7XG4gICAgICAgIHJlc3VsdC5sMTEgPSBwb2x5bm9taWFsLnguc2NhbGUoMC45NzcyMDQpO1xuICAgICAgICByZXN1bHQubDJfMiA9IHBvbHlub21pYWwueHkuc2NhbGUoMS4xNjUzOCk7XG4gICAgICAgIHJlc3VsdC5sMl8xID0gcG9seW5vbWlhbC55ei5zY2FsZSgxLjE2NTM4KTtcbiAgICAgICAgcmVzdWx0LmwyMCA9IHBvbHlub21pYWwuenouc2NhbGUoMS4zNDU2Nykuc3VidHJhY3QocG9seW5vbWlhbC54eC5zY2FsZSgwLjY3MjgzNCkpLnN1YnRyYWN0KHBvbHlub21pYWwueXkuc2NhbGUoMC42NzI4MzQpKTtcbiAgICAgICAgcmVzdWx0LmwyMSA9IHBvbHlub21pYWwuenguc2NhbGUoMS4xNjUzOCk7XG4gICAgICAgIHJlc3VsdC5sMjIgPSBwb2x5bm9taWFsLnh4LnNjYWxlKDEuMTY1MzgpLnN1YnRyYWN0KHBvbHlub21pYWwueXkuc2NhbGUoMS4xNjUzOCkpO1xuICAgICAgICByZXN1bHQubDFfMS5zY2FsZUluUGxhY2UoLTEpO1xuICAgICAgICByZXN1bHQubDExLnNjYWxlSW5QbGFjZSgtMSk7XG4gICAgICAgIHJlc3VsdC5sMl8xLnNjYWxlSW5QbGFjZSgtMSk7XG4gICAgICAgIHJlc3VsdC5sMjEuc2NhbGVJblBsYWNlKC0xKTtcbiAgICAgICAgcmVzdWx0LnNjYWxlSW5QbGFjZShNYXRoLlBJKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBzcGhlcmljYWwgcG9seW5vbWlhbCBjb2VmZmljaWVudHMgdG8gdGhlIDNyZCBkZWdyZWVcbiAqL1xuZXhwb3J0IGNsYXNzIFNwaGVyaWNhbFBvbHlub21pYWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHggY29lZmZpY2llbnRzIG9mIHRoZSBzcGhlcmljYWwgcG9seW5vbWlhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgeSBjb2VmZmljaWVudHMgb2YgdGhlIHNwaGVyaWNhbCBwb2x5bm9taWFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnkgPSBWZWN0b3IzLlplcm8oKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB6IGNvZWZmaWNpZW50cyBvZiB0aGUgc3BoZXJpY2FsIHBvbHlub21pYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueiA9IFZlY3RvcjMuWmVybygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHh4IGNvZWZmaWNpZW50cyBvZiB0aGUgc3BoZXJpY2FsIHBvbHlub21pYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueHggPSBWZWN0b3IzLlplcm8oKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB5eSBjb2VmZmljaWVudHMgb2YgdGhlIHNwaGVyaWNhbCBwb2x5bm9taWFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnl5ID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgenogY29lZmZpY2llbnRzIG9mIHRoZSBzcGhlcmljYWwgcG9seW5vbWlhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy56eiA9IFZlY3RvcjMuWmVybygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHh5IGNvZWZmaWNpZW50cyBvZiB0aGUgc3BoZXJpY2FsIHBvbHlub21pYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueHkgPSBWZWN0b3IzLlplcm8oKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB5eiBjb2VmZmljaWVudHMgb2YgdGhlIHNwaGVyaWNhbCBwb2x5bm9taWFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnl6ID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgenggY29lZmZpY2llbnRzIG9mIHRoZSBzcGhlcmljYWwgcG9seW5vbWlhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy56eCA9IFZlY3RvcjMuWmVybygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc3BoZXJpY2FsIGhhcm1vbmljcyB1c2VkIHRvIGNyZWF0ZSB0aGUgcG9seW5vbWlhbHMuXG4gICAgICovXG4gICAgZ2V0IHByZVNjYWxlZEhhcm1vbmljcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXJtb25pY3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhcm1vbmljcyA9IFNwaGVyaWNhbEhhcm1vbmljcy5Gcm9tUG9seW5vbWlhbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2hhcm1vbmljcy5wcmVTY2FsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhcm1vbmljcy5wcmVTY2FsZUZvclJlbmRlcmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXJtb25pY3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gYW1iaWVudCBjb2xvciB0byB0aGUgc3BoZXJpY2FsIHBvbHlub21pYWxcbiAgICAgKiBAcGFyYW0gY29sb3IgdGhlIGNvbG9yIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZEFtYmllbnQoY29sb3IpIHtcbiAgICAgICAgVG1wVmVjdG9ycy5WZWN0b3IzWzBdLmNvcHlGcm9tRmxvYXRzKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgICAgICBjb25zdCBjb2xvclZlY3RvciA9IFRtcFZlY3RvcnMuVmVjdG9yM1swXTtcbiAgICAgICAgdGhpcy54eC5hZGRJblBsYWNlKGNvbG9yVmVjdG9yKTtcbiAgICAgICAgdGhpcy55eS5hZGRJblBsYWNlKGNvbG9yVmVjdG9yKTtcbiAgICAgICAgdGhpcy56ei5hZGRJblBsYWNlKGNvbG9yVmVjdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbGVzIHRoZSBzcGhlcmljYWwgcG9seW5vbWlhbCBieSB0aGUgZ2l2ZW4gYW1vdW50XG4gICAgICogQHBhcmFtIHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGVcbiAgICAgKi9cbiAgICBzY2FsZUluUGxhY2Uoc2NhbGUpIHtcbiAgICAgICAgdGhpcy54LnNjYWxlSW5QbGFjZShzY2FsZSk7XG4gICAgICAgIHRoaXMueS5zY2FsZUluUGxhY2Uoc2NhbGUpO1xuICAgICAgICB0aGlzLnouc2NhbGVJblBsYWNlKHNjYWxlKTtcbiAgICAgICAgdGhpcy54eC5zY2FsZUluUGxhY2Uoc2NhbGUpO1xuICAgICAgICB0aGlzLnl5LnNjYWxlSW5QbGFjZShzY2FsZSk7XG4gICAgICAgIHRoaXMuenouc2NhbGVJblBsYWNlKHNjYWxlKTtcbiAgICAgICAgdGhpcy55ei5zY2FsZUluUGxhY2Uoc2NhbGUpO1xuICAgICAgICB0aGlzLnp4LnNjYWxlSW5QbGFjZShzY2FsZSk7XG4gICAgICAgIHRoaXMueHkuc2NhbGVJblBsYWNlKHNjYWxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc3BoZXJpY2FsIHBvbHlub21pYWwgZnJvbSBoYXJtb25pY3NcbiAgICAgKiBAcGFyYW0gaGFybW9uaWNzIHRoZSBzcGhlcmljYWwgaGFybW9uaWNzXG4gICAgICogQHJldHVybnMgdGhlIHNwaGVyaWNhbCBwb2x5bm9taWFsXG4gICAgICovXG4gICAgdXBkYXRlRnJvbUhhcm1vbmljcyhoYXJtb25pY3MpIHtcbiAgICAgICAgdGhpcy5faGFybW9uaWNzID0gaGFybW9uaWNzO1xuICAgICAgICB0aGlzLnguY29weUZyb20oaGFybW9uaWNzLmwxMSk7XG4gICAgICAgIHRoaXMueC5zY2FsZUluUGxhY2UoMS4wMjMzMykuc2NhbGVJblBsYWNlKC0xKTtcbiAgICAgICAgdGhpcy55LmNvcHlGcm9tKGhhcm1vbmljcy5sMV8xKTtcbiAgICAgICAgdGhpcy55LnNjYWxlSW5QbGFjZSgxLjAyMzMzKS5zY2FsZUluUGxhY2UoLTEpO1xuICAgICAgICB0aGlzLnouY29weUZyb20oaGFybW9uaWNzLmwxMCk7XG4gICAgICAgIHRoaXMuei5zY2FsZUluUGxhY2UoMS4wMjMzMyk7XG4gICAgICAgIHRoaXMueHguY29weUZyb20oaGFybW9uaWNzLmwwMCk7XG4gICAgICAgIFRtcFZlY3RvcnMuVmVjdG9yM1swXS5jb3B5RnJvbShoYXJtb25pY3MubDIwKS5zY2FsZUluUGxhY2UoMC4yNDc3MDgpO1xuICAgICAgICBUbXBWZWN0b3JzLlZlY3RvcjNbMV0uY29weUZyb20oaGFybW9uaWNzLmwyMikuc2NhbGVJblBsYWNlKDAuNDI5MDQzKTtcbiAgICAgICAgdGhpcy54eC5zY2FsZUluUGxhY2UoMC44ODYyNzcpLnN1YnRyYWN0SW5QbGFjZShUbXBWZWN0b3JzLlZlY3RvcjNbMF0pLmFkZEluUGxhY2UoVG1wVmVjdG9ycy5WZWN0b3IzWzFdKTtcbiAgICAgICAgdGhpcy55eS5jb3B5RnJvbShoYXJtb25pY3MubDAwKTtcbiAgICAgICAgdGhpcy55eS5zY2FsZUluUGxhY2UoMC44ODYyNzcpLnN1YnRyYWN0SW5QbGFjZShUbXBWZWN0b3JzLlZlY3RvcjNbMF0pLnN1YnRyYWN0SW5QbGFjZShUbXBWZWN0b3JzLlZlY3RvcjNbMV0pO1xuICAgICAgICB0aGlzLnp6LmNvcHlGcm9tKGhhcm1vbmljcy5sMDApO1xuICAgICAgICBUbXBWZWN0b3JzLlZlY3RvcjNbMF0uY29weUZyb20oaGFybW9uaWNzLmwyMCkuc2NhbGVJblBsYWNlKDAuNDk1NDE3KTtcbiAgICAgICAgdGhpcy56ei5zY2FsZUluUGxhY2UoMC44ODYyNzcpLmFkZEluUGxhY2UoVG1wVmVjdG9ycy5WZWN0b3IzWzBdKTtcbiAgICAgICAgdGhpcy55ei5jb3B5RnJvbShoYXJtb25pY3MubDJfMSk7XG4gICAgICAgIHRoaXMueXouc2NhbGVJblBsYWNlKDAuODU4MDg2KS5zY2FsZUluUGxhY2UoLTEpO1xuICAgICAgICB0aGlzLnp4LmNvcHlGcm9tKGhhcm1vbmljcy5sMjEpO1xuICAgICAgICB0aGlzLnp4LnNjYWxlSW5QbGFjZSgwLjg1ODA4Nikuc2NhbGVJblBsYWNlKC0xKTtcbiAgICAgICAgdGhpcy54eS5jb3B5RnJvbShoYXJtb25pY3MubDJfMik7XG4gICAgICAgIHRoaXMueHkuc2NhbGVJblBsYWNlKDAuODU4MDg2KTtcbiAgICAgICAgdGhpcy5zY2FsZUluUGxhY2UoMS4wIC8gTWF0aC5QSSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzcGhlcmljYWwgcG9seW5vbWlhbCBmcm9tIGhhcm1vbmljc1xuICAgICAqIEBwYXJhbSBoYXJtb25pY3MgdGhlIHNwaGVyaWNhbCBoYXJtb25pY3NcbiAgICAgKiBAcmV0dXJucyB0aGUgc3BoZXJpY2FsIHBvbHlub21pYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbUhhcm1vbmljcyhoYXJtb25pY3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNwaGVyaWNhbFBvbHlub21pYWwoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC51cGRhdGVGcm9tSGFybW9uaWNzKGhhcm1vbmljcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBzcGhlcmljYWwgcG9seW5vbWlhbCBmcm9tIGFuIGFycmF5LlxuICAgICAqIEBwYXJhbSBkYXRhIGRlZmluZXMgdGhlIDl4MyBjb2VmZmljaWVudHMgKHgsIHksIHosIHh4LCB5eSwgenosIHl6LCB6eCwgeHkpXG4gICAgICogQHJldHVybnMgdGhlIHNwaGVyaWNhbCBwb2x5bm9taWFsXG4gICAgICovXG4gICAgc3RhdGljIEZyb21BcnJheShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHNwID0gbmV3IFNwaGVyaWNhbFBvbHlub21pYWwoKTtcbiAgICAgICAgVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZihkYXRhWzBdLCAwLCBzcC54KTtcbiAgICAgICAgVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZihkYXRhWzFdLCAwLCBzcC55KTtcbiAgICAgICAgVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZihkYXRhWzJdLCAwLCBzcC56KTtcbiAgICAgICAgVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZihkYXRhWzNdLCAwLCBzcC54eCk7XG4gICAgICAgIFZlY3RvcjMuRnJvbUFycmF5VG9SZWYoZGF0YVs0XSwgMCwgc3AueXkpO1xuICAgICAgICBWZWN0b3IzLkZyb21BcnJheVRvUmVmKGRhdGFbNV0sIDAsIHNwLnp6KTtcbiAgICAgICAgVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZihkYXRhWzZdLCAwLCBzcC55eik7XG4gICAgICAgIFZlY3RvcjMuRnJvbUFycmF5VG9SZWYoZGF0YVs3XSwgMCwgc3AuengpO1xuICAgICAgICBWZWN0b3IzLkZyb21BcnJheVRvUmVmKGRhdGFbOF0sIDAsIHNwLnh5KTtcbiAgICAgICAgcmV0dXJuIHNwO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwaGVyaWNhbFBvbHlub21pYWwuanMubWFwIiwiaW1wb3J0IHsgRGF0YUJ1ZmZlciB9IGZyb20gXCIuLi8uLi9CdWZmZXJzL2RhdGFCdWZmZXIuanNcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBXZWJHTERhdGFCdWZmZXIgZXh0ZW5kcyBEYXRhQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNvdXJjZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9idWZmZXIgPSByZXNvdXJjZTtcbiAgICB9XG4gICAgZ2V0IHVuZGVybHlpbmdSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJHTERhdGFCdWZmZXIuanMubWFwIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCIuLi8uLi9NYXRocy9tYXRoLnZlY3Rvci5qc1wiO1xuaW1wb3J0IHsgQ2xhbXAgfSBmcm9tIFwiLi4vLi4vTWF0aHMvbWF0aC5zY2FsYXIuZnVuY3Rpb25zLmpzXCI7XG5pbXBvcnQgeyBTcGhlcmljYWxQb2x5bm9taWFsLCBTcGhlcmljYWxIYXJtb25pY3MgfSBmcm9tIFwiLi4vLi4vTWF0aHMvc3BoZXJpY2FsUG9seW5vbWlhbC5qc1wiO1xuXG5pbXBvcnQgeyBUb0xpbmVhclNwYWNlIH0gZnJvbSBcIi4uLy4uL01hdGhzL21hdGguY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBDb2xvcjMgfSBmcm9tIFwiLi4vLi4vTWF0aHMvbWF0aC5jb2xvci5qc1wiO1xuY2xhc3MgRmlsZUZhY2VPcmllbnRhdGlvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgd29ybGRBeGlzRm9yTm9ybWFsLCB3b3JsZEF4aXNGb3JGaWxlWCwgd29ybGRBeGlzRm9yRmlsZVkpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy53b3JsZEF4aXNGb3JOb3JtYWwgPSB3b3JsZEF4aXNGb3JOb3JtYWw7XG4gICAgICAgIHRoaXMud29ybGRBeGlzRm9yRmlsZVggPSB3b3JsZEF4aXNGb3JGaWxlWDtcbiAgICAgICAgdGhpcy53b3JsZEF4aXNGb3JGaWxlWSA9IHdvcmxkQXhpc0ZvckZpbGVZO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIGNsYXNzIGRlYWxpbmcgd2l0aCB0aGUgZXh0cmFjdGlvbiBvZiBzcGhlcmljYWwgcG9seW5vbWlhbCBkYXRhQXJyYXlcbiAqIGZyb20gYSBjdWJlIG1hcC5cbiAqL1xuZXhwb3J0IGNsYXNzIEN1YmVNYXBUb1NwaGVyaWNhbFBvbHlub21pYWxUb29scyB7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSB0ZXh0dXJlIHRvIHRoZSBhY2NvcmRpbmcgU3BoZXJpY2FsIFBvbHlub21pYWwgZGF0YS5cbiAgICAgKiBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCAzIG9yZGVycyBvbmx5IGFzIHRoZXkgYXJlIHRoZSBvbmx5IG9uZSB1c2VkIGluIHRoZSBsaWdodGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIFRoZSB0ZXh0dXJlIHRvIGV4dHJhY3QgdGhlIGluZm9ybWF0aW9uIGZyb20uXG4gICAgICogQHJldHVybnMgVGhlIFNwaGVyaWNhbCBQb2x5bm9taWFsIGRhdGEuXG4gICAgICovXG4gICAgc3RhdGljIENvbnZlcnRDdWJlTWFwVGV4dHVyZVRvU3BoZXJpY2FsUG9seW5vbWlhbCh0ZXh0dXJlKSB7XG4gICAgICAgIGlmICghdGV4dHVyZS5pc0N1YmUpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgc3VwcG9ydHMgY3ViZSBUZXh0dXJlcyBjdXJyZW50bHkuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0dXJlLmdldFNjZW5lKCk/LmdldEVuZ2luZSgpLmZsdXNoRnJhbWVidWZmZXIoKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRleHR1cmUuZ2V0U2l6ZSgpLndpZHRoO1xuICAgICAgICBjb25zdCByaWdodFByb21pc2UgPSB0ZXh0dXJlLnJlYWRQaXhlbHMoMCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgbGVmdFByb21pc2UgPSB0ZXh0dXJlLnJlYWRQaXhlbHMoMSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgICAgbGV0IHVwUHJvbWlzZTtcbiAgICAgICAgbGV0IGRvd25Qcm9taXNlO1xuICAgICAgICBpZiAodGV4dHVyZS5pc1JlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgdXBQcm9taXNlID0gdGV4dHVyZS5yZWFkUGl4ZWxzKDMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgICAgICBkb3duUHJvbWlzZSA9IHRleHR1cmUucmVhZFBpeGVscygyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBQcm9taXNlID0gdGV4dHVyZS5yZWFkUGl4ZWxzKDIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgICAgICBkb3duUHJvbWlzZSA9IHRleHR1cmUucmVhZFBpeGVscygzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyb250UHJvbWlzZSA9IHRleHR1cmUucmVhZFBpeGVscyg0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBiYWNrUHJvbWlzZSA9IHRleHR1cmUucmVhZFBpeGVscyg1LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBnYW1tYVNwYWNlID0gdGV4dHVyZS5nYW1tYVNwYWNlO1xuICAgICAgICAvLyBBbHdheXMgcmVhZCBhcyBSR0JBLlxuICAgICAgICBjb25zdCBmb3JtYXQgPSA1O1xuICAgICAgICBsZXQgdHlwZSA9IDA7XG4gICAgICAgIGlmICh0ZXh0dXJlLnRleHR1cmVUeXBlID09IDEgfHwgdGV4dHVyZS50ZXh0dXJlVHlwZSA9PSAyKSB7XG4gICAgICAgICAgICB0eXBlID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtsZWZ0UHJvbWlzZSwgcmlnaHRQcm9taXNlLCB1cFByb21pc2UsIGRvd25Qcm9taXNlLCBmcm9udFByb21pc2UsIGJhY2tQcm9taXNlXSkudGhlbigoW2xlZnQsIHJpZ2h0LCB1cCwgZG93biwgZnJvbnQsIGJhY2tdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3ViZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICB1cCxcbiAgICAgICAgICAgICAgICAgICAgZG93bixcbiAgICAgICAgICAgICAgICAgICAgZnJvbnQsXG4gICAgICAgICAgICAgICAgICAgIGJhY2ssXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZ2FtbWFTcGFjZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5Db252ZXJ0Q3ViZU1hcFRvU3BoZXJpY2FsUG9seW5vbWlhbChjdWJlSW5mbykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBhcmVhIG9uIHRoZSB1bml0IHNwaGVyZSBvZiB0aGUgcmVjdGFuZ2xlIGRlZmluZWQgYnkgKHgseSkgYW5kIHRoZSBvcmlnaW5cbiAgICAgKiBTZWUgaHR0cHM6Ly93d3cucm9yeWRyaXNjb2xsLmNvbS8yMDEyLzAxLzE1L2N1YmVtYXAtdGV4ZWwtc29saWQtYW5nbGUvXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHRoZSBhcmVhXG4gICAgICovXG4gICAgc3RhdGljIF9BcmVhRWxlbWVudCh4LCB5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHggKiB5LCBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIDEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBjdWJlbWFwIHRvIHRoZSBhY2NvcmRpbmcgU3BoZXJpY2FsIFBvbHlub21pYWwgZGF0YS5cbiAgICAgKiBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCAzIG9yZGVycyBvbmx5IGFzIHRoZXkgYXJlIHRoZSBvbmx5IG9uZSB1c2VkIGluIHRoZSBsaWdodGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdWJlSW5mbyBUaGUgQ3ViZSBtYXAgdG8gZXh0cmFjdCB0aGUgaW5mb3JtYXRpb24gZnJvbS5cbiAgICAgKiBAcmV0dXJucyBUaGUgU3BoZXJpY2FsIFBvbHlub21pYWwgZGF0YS5cbiAgICAgKi9cbiAgICBzdGF0aWMgQ29udmVydEN1YmVNYXBUb1NwaGVyaWNhbFBvbHlub21pYWwoY3ViZUluZm8pIHtcbiAgICAgICAgY29uc3Qgc3BoZXJpY2FsSGFybW9uaWNzID0gbmV3IFNwaGVyaWNhbEhhcm1vbmljcygpO1xuICAgICAgICBsZXQgdG90YWxTb2xpZEFuZ2xlID0gMC4wO1xuICAgICAgICAvLyBUaGUgKHUsdikgcmFuZ2UgaXMgWy0xLCsxXSwgc28gdGhlIGRpc3RhbmNlIGJldHdlZW4gZWFjaCB0ZXhlbCBpcyAyL1NpemUuXG4gICAgICAgIGNvbnN0IGR1ID0gMi4wIC8gY3ViZUluZm8uc2l6ZTtcbiAgICAgICAgY29uc3QgZHYgPSBkdTtcbiAgICAgICAgY29uc3QgaGFsZlRleGVsID0gMC41ICogZHU7XG4gICAgICAgIC8vIFRoZSAodSx2KSBvZiB0aGUgZmlyc3QgdGV4ZWwgaXMgaGFsZiBhIHRleGVsIGZyb20gdGhlIGNvcm5lciAoLTEsLTEpLlxuICAgICAgICBjb25zdCBtaW5VViA9IGhhbGZUZXhlbCAtIDEuMDtcbiAgICAgICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgNjsgZmFjZUluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVGYWNlID0gdGhpcy5fRmlsZUZhY2VzW2ZhY2VJbmRleF07XG4gICAgICAgICAgICBjb25zdCBkYXRhQXJyYXkgPSBjdWJlSW5mb1tmaWxlRmFjZS5uYW1lXTtcbiAgICAgICAgICAgIGxldCB2ID0gbWluVVY7XG4gICAgICAgICAgICAvLyBUT0RPOiB3ZSBjb3VsZCBwZXJmb3JtIHRoZSBzdW1tYXRpb24gZGlyZWN0bHkgaW50byBhIFNwaGVyaWNhbFBvbHlub21pYWwgKFNQKSwgd2hpY2ggaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBTcGhlcmljYWxIYXJtb25pYyAoU0gpLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIGR1cmluZyB0aGUgc3VtbWF0aW9uIHdlIGRvIG5vdCBuZWVkIHRoZSBTSC1zcGVjaWZpYyBwcm9wZXJ0aWVzLCBlLmcuIG9ydGhvZ29uYWxpdHkuXG4gICAgICAgICAgICAvLyBCZWNhdXNlIFNQIGlzIHN0aWxsIGxpbmVhciwgc28gc3VtbWF0aW9uIGlzIGZpbmUgaW4gdGhhdCBiYXNpcy5cbiAgICAgICAgICAgIGNvbnN0IHN0cmlkZSA9IGN1YmVJbmZvLmZvcm1hdCA9PT0gNSA/IDQgOiAzO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjdWJlSW5mby5zaXplOyB5KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdSA9IG1pblVWO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgY3ViZUluZm8uc2l6ZTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmxkIGRpcmVjdGlvbiAobm90IG5vcm1hbGlzZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdvcmxkRGlyZWN0aW9uID0gZmlsZUZhY2Uud29ybGRBeGlzRm9yRmlsZVguc2NhbGUodSkuYWRkKGZpbGVGYWNlLndvcmxkQXhpc0ZvckZpbGVZLnNjYWxlKHYpKS5hZGQoZmlsZUZhY2Uud29ybGRBeGlzRm9yTm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgd29ybGREaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhU29saWRBbmdsZSA9IHRoaXMuX0FyZWFFbGVtZW50KHUgLSBoYWxmVGV4ZWwsIHYgLSBoYWxmVGV4ZWwpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX0FyZWFFbGVtZW50KHUgLSBoYWxmVGV4ZWwsIHYgKyBoYWxmVGV4ZWwpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX0FyZWFFbGVtZW50KHUgKyBoYWxmVGV4ZWwsIHYgLSBoYWxmVGV4ZWwpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX0FyZWFFbGVtZW50KHUgKyBoYWxmVGV4ZWwsIHYgKyBoYWxmVGV4ZWwpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgciA9IGRhdGFBcnJheVt5ICogY3ViZUluZm8uc2l6ZSAqIHN0cmlkZSArIHggKiBzdHJpZGUgKyAwXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGcgPSBkYXRhQXJyYXlbeSAqIGN1YmVJbmZvLnNpemUgKiBzdHJpZGUgKyB4ICogc3RyaWRlICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBiID0gZGF0YUFycmF5W3kgKiBjdWJlSW5mby5zaXplICogc3RyaWRlICsgeCAqIHN0cmlkZSArIDJdO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IE5hTiBoYXJtb25pY3Mgd2l0aCBleHRyZW1lIEhEUkkgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIEludGVnZXIgdHlwZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdWJlSW5mby50eXBlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByIC89IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgYiAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIEdhbW1hIHNwYWNlIHRleHR1cmVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY3ViZUluZm8uZ2FtbWFTcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IE1hdGgucG93KENsYW1wKHIpLCBUb0xpbmVhclNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBNYXRoLnBvdyhDbGFtcChnKSwgVG9MaW5lYXJTcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gTWF0aC5wb3coQ2xhbXAoYiksIFRvTGluZWFyU3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdG8gZXhwbG9kZSBpbiBjYXNlIG9mIHJlYWxseSBoaWdoIGR5bmFtaWMgcmFuZ2VzLlxuICAgICAgICAgICAgICAgICAgICAvLyBzaCAzIHdvdWxkIG5vdCBiZSBlbm91Z2ggdG8gYWNjdXJhdGVseSByZXByZXNlbnQgaXQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMuTUFYX0hEUklfVkFMVUU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLlBSRVNFUlZFX0NMQU1QRURfQ09MT1JTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE1heCA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvciA9IG1heCAvIGN1cnJlbnRNYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciAqPSBmYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyAqPSBmYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiAqPSBmYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gQ2xhbXAociwgMCwgbWF4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBDbGFtcChnLCAwLCBtYXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IENsYW1wKGIsIDAsIG1heCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IzKHIsIGcsIGIpO1xuICAgICAgICAgICAgICAgICAgICBzcGhlcmljYWxIYXJtb25pY3MuYWRkTGlnaHQod29ybGREaXJlY3Rpb24sIGNvbG9yLCBkZWx0YVNvbGlkQW5nbGUpO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbFNvbGlkQW5nbGUgKz0gZGVsdGFTb2xpZEFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICB1ICs9IGR1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2ICs9IGR2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNvbGlkIGFuZ2xlIGZvciBlbnRpcmUgc3BoZXJlIGlzIDQqcGlcbiAgICAgICAgY29uc3Qgc3BoZXJlU29saWRBbmdsZSA9IDQuMCAqIE1hdGguUEk7XG4gICAgICAgIC8vIEFkanVzdCB0aGUgc29saWQgYW5nbGUgdG8gYWxsb3cgZm9yIGhvdyBtYW55IGZhY2VzIHdlIHByb2Nlc3NlZC5cbiAgICAgICAgY29uc3QgZmFjZXNQcm9jZXNzZWQgPSA2LjA7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkU29saWRBbmdsZSA9IChzcGhlcmVTb2xpZEFuZ2xlICogZmFjZXNQcm9jZXNzZWQpIC8gNi4wO1xuICAgICAgICAvLyBBZGp1c3QgdGhlIGhhcm1vbmljcyBzbyB0aGF0IHRoZSBhY2N1bXVsYXRlZCBzb2xpZCBhbmdsZSBtYXRjaGVzIHRoZSBleHBlY3RlZCBzb2xpZCBhbmdsZS5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgbnVtZXJpY2FsIGludGVncmF0aW9uIG92ZXIgdGhlIGN1YmUgdXNlcyBhXG4gICAgICAgIC8vIHNtYWxsIGFuZ2xlIGFwcHJveGltYXRpb24gb2Ygc29saWQgYW5nbGUgZm9yIGVhY2ggdGV4ZWwgKHNlZSBkZWx0YVNvbGlkQW5nbGUpLFxuICAgICAgICAvLyBhbmQgYWxzbyB0byBjb21wZW5zYXRlIGZvciBhY2N1bXVsYXRpdmUgZXJyb3IgZHVlIHRvIGZsb2F0IHByZWNpc2lvbiBpbiB0aGUgc3VtbWF0aW9uLlxuICAgICAgICBjb25zdCBjb3JyZWN0aW9uRmFjdG9yID0gZXhwZWN0ZWRTb2xpZEFuZ2xlIC8gdG90YWxTb2xpZEFuZ2xlO1xuICAgICAgICBzcGhlcmljYWxIYXJtb25pY3Muc2NhbGVJblBsYWNlKGNvcnJlY3Rpb25GYWN0b3IpO1xuICAgICAgICBzcGhlcmljYWxIYXJtb25pY3MuY29udmVydEluY2lkZW50UmFkaWFuY2VUb0lycmFkaWFuY2UoKTtcbiAgICAgICAgc3BoZXJpY2FsSGFybW9uaWNzLmNvbnZlcnRJcnJhZGlhbmNlVG9MYW1iZXJ0aWFuUmFkaWFuY2UoKTtcbiAgICAgICAgcmV0dXJuIFNwaGVyaWNhbFBvbHlub21pYWwuRnJvbUhhcm1vbmljcyhzcGhlcmljYWxIYXJtb25pY3MpO1xuICAgIH1cbn1cbkN1YmVNYXBUb1NwaGVyaWNhbFBvbHlub21pYWxUb29scy5fRmlsZUZhY2VzID0gW1xuICAgIG5ldyBGaWxlRmFjZU9yaWVudGF0aW9uKFwicmlnaHRcIiwgbmV3IFZlY3RvcjMoMSwgMCwgMCksIG5ldyBWZWN0b3IzKDAsIDAsIC0xKSwgbmV3IFZlY3RvcjMoMCwgLTEsIDApKSwgLy8gK1ggZWFzdFxuICAgIG5ldyBGaWxlRmFjZU9yaWVudGF0aW9uKFwibGVmdFwiLCBuZXcgVmVjdG9yMygtMSwgMCwgMCksIG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBuZXcgVmVjdG9yMygwLCAtMSwgMCkpLCAvLyAtWCB3ZXN0XG4gICAgbmV3IEZpbGVGYWNlT3JpZW50YXRpb24oXCJ1cFwiLCBuZXcgVmVjdG9yMygwLCAxLCAwKSwgbmV3IFZlY3RvcjMoMSwgMCwgMCksIG5ldyBWZWN0b3IzKDAsIDAsIDEpKSwgLy8gK1kgbm9ydGhcbiAgICBuZXcgRmlsZUZhY2VPcmllbnRhdGlvbihcImRvd25cIiwgbmV3IFZlY3RvcjMoMCwgLTEsIDApLCBuZXcgVmVjdG9yMygxLCAwLCAwKSwgbmV3IFZlY3RvcjMoMCwgMCwgLTEpKSwgLy8gLVkgc291dGhcbiAgICBuZXcgRmlsZUZhY2VPcmllbnRhdGlvbihcImZyb250XCIsIG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBuZXcgVmVjdG9yMygxLCAwLCAwKSwgbmV3IFZlY3RvcjMoMCwgLTEsIDApKSwgLy8gK1ogdG9wXG4gICAgbmV3IEZpbGVGYWNlT3JpZW50YXRpb24oXCJiYWNrXCIsIG5ldyBWZWN0b3IzKDAsIDAsIC0xKSwgbmV3IFZlY3RvcjMoLTEsIDAsIDApLCBuZXcgVmVjdG9yMygwLCAtMSwgMCkpLCAvLyAtWiBib3R0b21cbl07XG4vKiogQGludGVybmFsICovXG5DdWJlTWFwVG9TcGhlcmljYWxQb2x5bm9taWFsVG9vbHMuTUFYX0hEUklfVkFMVUUgPSA0MDk2O1xuLyoqIEBpbnRlcm5hbCAqL1xuQ3ViZU1hcFRvU3BoZXJpY2FsUG9seW5vbWlhbFRvb2xzLlBSRVNFUlZFX0NMQU1QRURfQ09MT1JTID0gZmFsc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdWJlbWFwVG9TcGhlcmljYWxQb2x5bm9taWFsLmpzLm1hcCIsImltcG9ydCB7IFByZWNpc2lvbkRhdGUgfSBmcm9tIFwiLi9wcmVjaXNpb25EYXRlLmpzXCI7XG4vKipcbiAqIFBlcmZvcm1hbmNlIG1vbml0b3IgdHJhY2tzIHJvbGxpbmcgYXZlcmFnZSBmcmFtZS10aW1lIGFuZCBmcmFtZS10aW1lIHZhcmlhbmNlIG92ZXIgYSB1c2VyIGRlZmluZWQgc2xpZGluZy13aW5kb3dcbiAqL1xuZXhwb3J0IGNsYXNzIFBlcmZvcm1hbmNlTW9uaXRvciB7XG4gICAgLyoqXG4gICAgICogY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gZnJhbWVTYW1wbGVTaXplIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyByZXF1aXJlZCB0byBzYXR1cmF0ZSB0aGUgc2xpZGluZyB3aW5kb3dcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFtZVNhbXBsZVNpemUgPSAzMCkge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcm9sbGluZ0ZyYW1lVGltZSA9IG5ldyBSb2xsaW5nQXZlcmFnZShmcmFtZVNhbXBsZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYW1wbGVzIGN1cnJlbnQgZnJhbWVcbiAgICAgKiBAcGFyYW0gdGltZU1zIEEgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcyBvZiB0aGUgY3VycmVudCBmcmFtZSB0byBjb21wYXJlIHdpdGggb3RoZXIgZnJhbWVzXG4gICAgICovXG4gICAgc2FtcGxlRnJhbWUodGltZU1zID0gUHJlY2lzaW9uRGF0ZS5Ob3cpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xhc3RGcmFtZVRpbWVNcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRpbWVNcyAtIHRoaXMuX2xhc3RGcmFtZVRpbWVNcztcbiAgICAgICAgICAgIHRoaXMuX3JvbGxpbmdGcmFtZVRpbWUuYWRkKGR0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0RnJhbWVUaW1lTXMgPSB0aW1lTXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGF2ZXJhZ2UgZnJhbWUgdGltZSBpbiBtaWxsaXNlY29uZHMgb3ZlciB0aGUgc2xpZGluZyB3aW5kb3cgKG9yIHRoZSBzdWJzZXQgb2YgZnJhbWVzIHNhbXBsZWQgc28gZmFyKVxuICAgICAqL1xuICAgIGdldCBhdmVyYWdlRnJhbWVUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9sbGluZ0ZyYW1lVGltZS5hdmVyYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YXJpYW5jZSBmcmFtZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBvdmVyIHRoZSBzbGlkaW5nIHdpbmRvdyAob3IgdGhlIHN1YnNldCBvZiBmcmFtZXMgc2FtcGxlZCBzbyBmYXIpXG4gICAgICovXG4gICAgZ2V0IGF2ZXJhZ2VGcmFtZVRpbWVWYXJpYW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvbGxpbmdGcmFtZVRpbWUudmFyaWFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZyYW1lIHRpbWUgb2YgdGhlIG1vc3QgcmVjZW50IGZyYW1lXG4gICAgICovXG4gICAgZ2V0IGluc3RhbnRhbmVvdXNGcmFtZVRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb2xsaW5nRnJhbWVUaW1lLmhpc3RvcnkoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGF2ZXJhZ2UgZnJhbWVyYXRlIGluIGZyYW1lcyBwZXIgc2Vjb25kIG92ZXIgdGhlIHNsaWRpbmcgd2luZG93IChvciB0aGUgc3Vic2V0IG9mIGZyYW1lcyBzYW1wbGVkIHNvIGZhcilcbiAgICAgKi9cbiAgICBnZXQgYXZlcmFnZUZQUygpIHtcbiAgICAgICAgcmV0dXJuIDEwMDAuMCAvIHRoaXMuX3JvbGxpbmdGcmFtZVRpbWUuYXZlcmFnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXZlcmFnZSBmcmFtZXJhdGUgaW4gZnJhbWVzIHBlciBzZWNvbmQgdXNpbmcgdGhlIG1vc3QgcmVjZW50IGZyYW1lIHRpbWVcbiAgICAgKi9cbiAgICBnZXQgaW5zdGFudGFuZW91c0ZQUygpIHtcbiAgICAgICAgY29uc3QgaGlzdG9yeSA9IHRoaXMuX3JvbGxpbmdGcmFtZVRpbWUuaGlzdG9yeSgwKTtcbiAgICAgICAgaWYgKGhpc3RvcnkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxMDAwLjAgLyBoaXN0b3J5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgZW5vdWdoIHNhbXBsZXMgaGF2ZSBiZWVuIHRha2VuIHRvIGNvbXBsZXRlbHkgZmlsbCB0aGUgc2xpZGluZyB3aW5kb3dcbiAgICAgKi9cbiAgICBnZXQgaXNTYXR1cmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb2xsaW5nRnJhbWVUaW1lLmlzU2F0dXJhdGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgY29udHJpYnV0aW9ucyB0byB0aGUgc2xpZGluZyB3aW5kb3cgc2FtcGxlIHNldFxuICAgICAqL1xuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGNvbnRyaWJ1dGlvbnMgdG8gdGhlIHNsaWRpbmcgd2luZG93IHNhbXBsZSBzZXRcbiAgICAgKiBTYW1wbGVzIHdpbGwgbm90IGJlIGludGVycG9sYXRlZCBvdmVyIHRoZSBkaXNhYmxlZCBwZXJpb2RcbiAgICAgKi9cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIC8vY2xlYXIgbGFzdCBzYW1wbGUgdG8gYXZvaWQgaW50ZXJwb2xhdGluZyBvdmVyIHRoZSBkaXNhYmxlZCBwZXJpb2Qgd2hlbiBuZXh0IGVuYWJsZWRcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lVGltZU1zID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHNhbXBsaW5nIGlzIGVuYWJsZWRcbiAgICAgKi9cbiAgICBnZXQgaXNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHBlcmZvcm1hbmNlIG1vbml0b3JcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgLy9jbGVhciBsYXN0IHNhbXBsZSB0byBhdm9pZCBpbnRlcnBvbGF0aW5nIG92ZXIgdGhlIGRpc2FibGVkIHBlcmlvZCB3aGVuIG5leHQgZW5hYmxlZFxuICAgICAgICB0aGlzLl9sYXN0RnJhbWVUaW1lTXMgPSBudWxsO1xuICAgICAgICAvL3dpcGUgcmVjb3JkXG4gICAgICAgIHRoaXMuX3JvbGxpbmdGcmFtZVRpbWUucmVzZXQoKTtcbiAgICB9XG59XG4vKipcbiAqIFJvbGxpbmdBdmVyYWdlXG4gKlxuICogVXRpbGl0eSB0byBlZmZpY2llbnRseSBjb21wdXRlIHRoZSByb2xsaW5nIGF2ZXJhZ2UgYW5kIHZhcmlhbmNlIG92ZXIgYSBzbGlkaW5nIHdpbmRvdyBvZiBzYW1wbGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBSb2xsaW5nQXZlcmFnZSB7XG4gICAgLyoqXG4gICAgICogY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyByZXF1aXJlZCB0byBzYXR1cmF0ZSB0aGUgc2xpZGluZyB3aW5kb3dcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fc2FtcGxlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzYW1wbGUgdG8gdGhlIHNhbXBsZSBzZXRcbiAgICAgKiBAcGFyYW0gdiBUaGUgc2FtcGxlIHZhbHVlXG4gICAgICovXG4gICAgYWRkKHYpIHtcbiAgICAgICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FsZ29yaXRobXNfZm9yX2NhbGN1bGF0aW5nX3ZhcmlhbmNlXG4gICAgICAgIGxldCBkZWx0YTtcbiAgICAgICAgLy93ZSBuZWVkIHRvIGNoZWNrIGlmIHdlJ3ZlIGFscmVhZHkgd3JhcHBlZCByb3VuZFxuICAgICAgICBpZiAodGhpcy5pc1NhdHVyYXRlZCgpKSB7XG4gICAgICAgICAgICAvL3JlbW92ZSBib3R0b20gb2Ygc3RhY2sgZnJvbSBtZWFuXG4gICAgICAgICAgICBjb25zdCBib3R0b21WYWx1ZSA9IHRoaXMuX3NhbXBsZXNbdGhpcy5fcG9zXTtcbiAgICAgICAgICAgIGRlbHRhID0gYm90dG9tVmFsdWUgLSB0aGlzLmF2ZXJhZ2U7XG4gICAgICAgICAgICB0aGlzLmF2ZXJhZ2UgLT0gZGVsdGEgLyAodGhpcy5fc2FtcGxlQ291bnQgLSAxKTtcbiAgICAgICAgICAgIHRoaXMuX20yIC09IGRlbHRhICogKGJvdHRvbVZhbHVlIC0gdGhpcy5hdmVyYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NhbXBsZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgLy9hZGQgbmV3IHZhbHVlIHRvIG1lYW5cbiAgICAgICAgZGVsdGEgPSB2IC0gdGhpcy5hdmVyYWdlO1xuICAgICAgICB0aGlzLmF2ZXJhZ2UgKz0gZGVsdGEgLyB0aGlzLl9zYW1wbGVDb3VudDtcbiAgICAgICAgdGhpcy5fbTIgKz0gZGVsdGEgKiAodiAtIHRoaXMuYXZlcmFnZSk7XG4gICAgICAgIC8vc2V0IHRoZSBuZXcgdmFyaWFuY2VcbiAgICAgICAgdGhpcy52YXJpYW5jZSA9IHRoaXMuX20yIC8gKHRoaXMuX3NhbXBsZUNvdW50IC0gMSk7XG4gICAgICAgIHRoaXMuX3NhbXBsZXNbdGhpcy5fcG9zXSA9IHY7XG4gICAgICAgIHRoaXMuX3BvcysrO1xuICAgICAgICB0aGlzLl9wb3MgJT0gdGhpcy5fc2FtcGxlcy5sZW5ndGg7IC8vcG9zaXRpdmUgd3JhcCBhcm91bmRcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwcmV2aW91c2x5IGFkZGVkIHZhbHVlcyBvciBudWxsIGlmIG91dHNpZGUgb2YgaGlzdG9yeSBvciBvdXRzaWRlIHRoZSBzbGlkaW5nIHdpbmRvdyBkb21haW5cbiAgICAgKiBAcGFyYW0gaSBJbmRleCBpbiBoaXN0b3J5LiBGb3IgZXhhbXBsZSwgcGFzcyAwIGZvciB0aGUgbW9zdCByZWNlbnQgdmFsdWUgYW5kIDEgZm9yIHRoZSB2YWx1ZSBiZWZvcmUgdGhhdFxuICAgICAqIEByZXR1cm5zIFZhbHVlIHByZXZpb3VzbHkgcmVjb3JkZWQgd2l0aCBhZGQoKSBvciBudWxsIGlmIG91dHNpZGUgb2YgcmFuZ2VcbiAgICAgKi9cbiAgICBoaXN0b3J5KGkpIHtcbiAgICAgICAgaWYgKGkgPj0gdGhpcy5fc2FtcGxlQ291bnQgfHwgaSA+PSB0aGlzLl9zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaTAgPSB0aGlzLl93cmFwUG9zaXRpb24odGhpcy5fcG9zIC0gMS4wKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhbXBsZXNbdGhpcy5fd3JhcFBvc2l0aW9uKGkwIC0gaSldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgZW5vdWdoIHNhbXBsZXMgaGF2ZSBiZWVuIHRha2VuIHRvIGNvbXBsZXRlbHkgZmlsbCB0aGUgc2xpZGluZyB3aW5kb3dcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHNhbXBsZS1zZXQgc2F0dXJhdGVkXG4gICAgICovXG4gICAgaXNTYXR1cmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zYW1wbGVDb3VudCA+PSB0aGlzLl9zYW1wbGVzLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSByb2xsaW5nIGF2ZXJhZ2UgKGVxdWl2YWxlbnQgdG8gMCBzYW1wbGVzIHRha2VuIHNvIGZhcilcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5hdmVyYWdlID0gMDtcbiAgICAgICAgdGhpcy52YXJpYW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX3NhbXBsZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcG9zID0gMDtcbiAgICAgICAgdGhpcy5fbTIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcmFwcyBhIHZhbHVlIGFyb3VuZCB0aGUgc2FtcGxlIHJhbmdlIGJvdW5kYXJpZXNcbiAgICAgKiBAcGFyYW0gaSBQb3NpdGlvbiBpbiBzYW1wbGUgcmFuZ2UsIGZvciBleGFtcGxlIGlmIHRoZSBzYW1wbGUgbGVuZ3RoIGlzIDUsIGFuZCBpIGlzIC0zLCB0aGVuIDIgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJucyBXcmFwcGVkIHBvc2l0aW9uIGluIHNhbXBsZSByYW5nZVxuICAgICAqL1xuICAgIF93cmFwUG9zaXRpb24oaSkge1xuICAgICAgICBjb25zdCBtYXggPSB0aGlzLl9zYW1wbGVzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuICgoaSAlIG1heCkgKyBtYXgpICUgbWF4O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmZvcm1hbmNlTW9uaXRvci5qcy5tYXAiLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcIi4uL01hdGVyaWFscy9UZXh0dXJlcy90ZXh0dXJlLmpzXCI7XG5pbXBvcnQgeyBSZW5kZXJUYXJnZXRUZXh0dXJlIH0gZnJvbSBcIi4uL01hdGVyaWFscy9UZXh0dXJlcy9yZW5kZXJUYXJnZXRUZXh0dXJlLmpzXCI7XG5pbXBvcnQgeyBQYXNzUG9zdFByb2Nlc3MgfSBmcm9tIFwiLi4vUG9zdFByb2Nlc3Nlcy9wYXNzUG9zdFByb2Nlc3MuanNcIjtcblxuaW1wb3J0IHsgUG9zdFByb2Nlc3MgfSBmcm9tIFwiLi4vUG9zdFByb2Nlc3Nlcy9wb3N0UHJvY2Vzcy5qc1wiO1xuLyoqXG4gKiBVc2VzIHRoZSBHUFUgdG8gY3JlYXRlIGEgY29weSB0ZXh0dXJlIHJlc2NhbGVkIGF0IGEgZ2l2ZW4gc2l6ZVxuICogQHBhcmFtIHRleHR1cmUgVGV4dHVyZSB0byBjb3B5IGZyb21cbiAqIEBwYXJhbSB3aWR0aCBkZWZpbmVzIHRoZSBkZXNpcmVkIHdpZHRoXG4gKiBAcGFyYW0gaGVpZ2h0IGRlZmluZXMgdGhlIGRlc2lyZWQgaGVpZ2h0XG4gKiBAcGFyYW0gdXNlQmlsaW5lYXJNb2RlIGRlZmluZXMgaWYgYmlsaW5lYXIgbW9kZSBoYXMgdG8gYmUgdXNlZFxuICogQHJldHVybnMgdGhlIGdlbmVyYXRlZCB0ZXh0dXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDcmVhdGVSZXNpemVkQ29weSh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCB1c2VCaWxpbmVhck1vZGUgPSB0cnVlKSB7XG4gICAgY29uc3Qgc2NlbmUgPSB0ZXh0dXJlLmdldFNjZW5lKCk7XG4gICAgY29uc3QgZW5naW5lID0gc2NlbmUuZ2V0RW5naW5lKCk7XG4gICAgY29uc3QgcnR0ID0gbmV3IFJlbmRlclRhcmdldFRleHR1cmUoXCJyZXNpemVkXCIgKyB0ZXh0dXJlLm5hbWUsIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9LCBzY2VuZSwgIXRleHR1cmUubm9NaXBtYXAsIHRydWUsIHRleHR1cmUuX3RleHR1cmUudHlwZSwgZmFsc2UsIHRleHR1cmUuc2FtcGxpbmdNb2RlLCBmYWxzZSk7XG4gICAgcnR0LndyYXBVID0gdGV4dHVyZS53cmFwVTtcbiAgICBydHQud3JhcFYgPSB0ZXh0dXJlLndyYXBWO1xuICAgIHJ0dC51T2Zmc2V0ID0gdGV4dHVyZS51T2Zmc2V0O1xuICAgIHJ0dC52T2Zmc2V0ID0gdGV4dHVyZS52T2Zmc2V0O1xuICAgIHJ0dC51U2NhbGUgPSB0ZXh0dXJlLnVTY2FsZTtcbiAgICBydHQudlNjYWxlID0gdGV4dHVyZS52U2NhbGU7XG4gICAgcnR0LnVBbmcgPSB0ZXh0dXJlLnVBbmc7XG4gICAgcnR0LnZBbmcgPSB0ZXh0dXJlLnZBbmc7XG4gICAgcnR0LndBbmcgPSB0ZXh0dXJlLndBbmc7XG4gICAgcnR0LmNvb3JkaW5hdGVzSW5kZXggPSB0ZXh0dXJlLmNvb3JkaW5hdGVzSW5kZXg7XG4gICAgcnR0LmxldmVsID0gdGV4dHVyZS5sZXZlbDtcbiAgICBydHQuYW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCA9IHRleHR1cmUuYW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbDtcbiAgICBydHQuX3RleHR1cmUuaXNSZWFkeSA9IGZhbHNlO1xuICAgIHRleHR1cmUud3JhcFUgPSBUZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFO1xuICAgIHRleHR1cmUud3JhcFYgPSBUZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFO1xuICAgIGNvbnN0IHBhc3NQb3N0UHJvY2VzcyA9IG5ldyBQYXNzUG9zdFByb2Nlc3MoXCJwYXNzXCIsIDEsIG51bGwsIHVzZUJpbGluZWFyTW9kZSA/IFRleHR1cmUuQklMSU5FQVJfU0FNUExJTkdNT0RFIDogVGV4dHVyZS5ORUFSRVNUX1NBTVBMSU5HTU9ERSwgZW5naW5lLCBmYWxzZSwgMCk7XG4gICAgcGFzc1Bvc3RQcm9jZXNzLmV4dGVybmFsVGV4dHVyZVNhbXBsZXJCaW5kaW5nID0gdHJ1ZTtcbiAgICBwYXNzUG9zdFByb2Nlc3Mub25FZmZlY3RDcmVhdGVkT2JzZXJ2YWJsZS5hZGRPbmNlKChlKSA9PiB7XG4gICAgICAgIGUuZXhlY3V0ZVdoZW5Db21waWxlZCgoKSA9PiB7XG4gICAgICAgICAgICBwYXNzUG9zdFByb2Nlc3Mub25BcHBseSA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBlZmZlY3Quc2V0VGV4dHVyZShcInRleHR1cmVTYW1wbGVyXCIsIHRleHR1cmUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsVGV4dHVyZSA9IHJ0dC5yZW5kZXJUYXJnZXQ7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUucG9zdFByb2Nlc3NNYW5hZ2VyLmRpcmVjdFJlbmRlcihbcGFzc1Bvc3RQcm9jZXNzXSwgaW50ZXJuYWxUZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBlbmdpbmUudW5CaW5kRnJhbWVidWZmZXIoaW50ZXJuYWxUZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBydHQuZGlzcG9zZUZyYW1lYnVmZmVyT2JqZWN0cygpO1xuICAgICAgICAgICAgICAgIHBhc3NQb3N0UHJvY2Vzcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcnR0LmdldEludGVybmFsVGV4dHVyZSgpLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnR0O1xufVxuLyoqXG4gKiBBcHBseSBhIHBvc3QgcHJvY2VzcyB0byBhIHRleHR1cmVcbiAqIEBwYXJhbSBwb3N0UHJvY2Vzc05hbWUgbmFtZSBvZiB0aGUgZnJhZ21lbnQgcG9zdCBwcm9jZXNzXG4gKiBAcGFyYW0gaW50ZXJuYWxUZXh0dXJlIHRoZSB0ZXh0dXJlIHRvIGVuY29kZVxuICogQHBhcmFtIHNjZW5lIHRoZSBzY2VuZSBob3N0aW5nIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gdHlwZSB0eXBlIG9mIHRoZSBvdXRwdXQgdGV4dHVyZS4gSWYgbm90IHByb3ZpZGVkLCB1c2UgdGhlIG9uZSBmcm9tIGludGVybmFsVGV4dHVyZVxuICogQHBhcmFtIHNhbXBsaW5nTW9kZSBzYW1wbGluZyBtb2RlIHRvIHVzZSB0byBzYW1wbGUgdGhlIHNvdXJjZSB0ZXh0dXJlLiBJZiBub3QgcHJvdmlkZWQsIHVzZSB0aGUgb25lIGZyb20gaW50ZXJuYWxUZXh0dXJlXG4gKiBAcGFyYW0gZm9ybWF0IGZvcm1hdCBvZiB0aGUgb3V0cHV0IHRleHR1cmUuIElmIG5vdCBwcm92aWRlZCwgdXNlIHRoZSBvbmUgZnJvbSBpbnRlcm5hbFRleHR1cmVcbiAqIEBwYXJhbSB3aWR0aCB3aWR0aCBvZiB0aGUgb3V0cHV0IHRleHR1cmUuIElmIG5vdCBwcm92aWRlZCwgdXNlIHRoZSBvbmUgZnJvbSBpbnRlcm5hbFRleHR1cmVcbiAqIEBwYXJhbSBoZWlnaHQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgdGV4dHVyZS4gSWYgbm90IHByb3ZpZGVkLCB1c2UgdGhlIG9uZSBmcm9tIGludGVybmFsVGV4dHVyZVxuICogQHJldHVybnMgYSBwcm9taXNlIHdpdGggdGhlIGludGVybmFsVGV4dHVyZSBoYXZpbmcgaXRzIHRleHR1cmUgcmVwbGFjZWQgYnkgdGhlIHJlc3VsdCBvZiB0aGUgcHJvY2Vzc2luZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gQXBwbHlQb3N0UHJvY2Vzcyhwb3N0UHJvY2Vzc05hbWUsIGludGVybmFsVGV4dHVyZSwgc2NlbmUsIHR5cGUsIHNhbXBsaW5nTW9kZSwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gR2V0cyBldmVyeXRoaW5nIHJlYWR5LlxuICAgIGNvbnN0IGVuZ2luZSA9IGludGVybmFsVGV4dHVyZS5nZXRFbmdpbmUoKTtcbiAgICBpbnRlcm5hbFRleHR1cmUuaXNSZWFkeSA9IGZhbHNlO1xuICAgIHNhbXBsaW5nTW9kZSA9IHNhbXBsaW5nTW9kZSA/PyBpbnRlcm5hbFRleHR1cmUuc2FtcGxpbmdNb2RlO1xuICAgIHR5cGUgPSB0eXBlID8/IGludGVybmFsVGV4dHVyZS50eXBlO1xuICAgIGZvcm1hdCA9IGZvcm1hdCA/PyBpbnRlcm5hbFRleHR1cmUuZm9ybWF0O1xuICAgIHdpZHRoID0gd2lkdGggPz8gaW50ZXJuYWxUZXh0dXJlLndpZHRoO1xuICAgIGhlaWdodCA9IGhlaWdodCA/PyBpbnRlcm5hbFRleHR1cmUuaGVpZ2h0O1xuICAgIGlmICh0eXBlID09PSAtMSkge1xuICAgICAgICB0eXBlID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgcG9zdCBwcm9jZXNzXG4gICAgICAgIGNvbnN0IHBvc3RQcm9jZXNzID0gbmV3IFBvc3RQcm9jZXNzKFwicG9zdHByb2Nlc3NcIiwgcG9zdFByb2Nlc3NOYW1lLCBudWxsLCBudWxsLCAxLCBudWxsLCBzYW1wbGluZ01vZGUsIGVuZ2luZSwgZmFsc2UsIHVuZGVmaW5lZCwgdHlwZSwgdW5kZWZpbmVkLCBudWxsLCBmYWxzZSwgZm9ybWF0KTtcbiAgICAgICAgcG9zdFByb2Nlc3MuZXh0ZXJuYWxUZXh0dXJlU2FtcGxlckJpbmRpbmcgPSB0cnVlO1xuICAgICAgICAvLyBIb2xkIHRoZSBvdXRwdXQgb2YgdGhlIGRlY29kaW5nLlxuICAgICAgICBjb25zdCBlbmNvZGVkVGV4dHVyZSA9IGVuZ2luZS5jcmVhdGVSZW5kZXJUYXJnZXRUZXh0dXJlKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9LCB7XG4gICAgICAgICAgICBnZW5lcmF0ZURlcHRoQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGdlbmVyYXRlTWlwTWFwczogZmFsc2UsXG4gICAgICAgICAgICBnZW5lcmF0ZVN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgc2FtcGxpbmdNb2RlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHBvc3RQcm9jZXNzLm9uRWZmZWN0Q3JlYXRlZE9ic2VydmFibGUuYWRkT25jZSgoZSkgPT4ge1xuICAgICAgICAgICAgZS5leGVjdXRlV2hlbkNvbXBpbGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQUCBSZW5kZXIgUGFzc1xuICAgICAgICAgICAgICAgIHBvc3RQcm9jZXNzLm9uQXBwbHkgPSAoZWZmZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdC5fYmluZFRleHR1cmUoXCJ0ZXh0dXJlU2FtcGxlclwiLCBpbnRlcm5hbFRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3Quc2V0RmxvYXQyKFwic2NhbGVcIiwgMSwgMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY2VuZS5wb3N0UHJvY2Vzc01hbmFnZXIuZGlyZWN0UmVuZGVyKFtwb3N0UHJvY2Vzc10sIGVuY29kZWRUZXh0dXJlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBDbGVhbnVwXG4gICAgICAgICAgICAgICAgZW5naW5lLnJlc3RvcmVEZWZhdWx0RnJhbWVidWZmZXIoKTtcbiAgICAgICAgICAgICAgICBlbmdpbmUuX3JlbGVhc2VUZXh0dXJlKGludGVybmFsVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3RQcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RQcm9jZXNzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuYWwgU3dhcFxuICAgICAgICAgICAgICAgIGVuY29kZWRUZXh0dXJlLl9zd2FwQW5kRGllKGludGVybmFsVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgLy8gUmVhZHkgdG8gZ2V0IHJvbGxpbmcgYWdhaW4uXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGludGVybmFsVGV4dHVyZS5mb3JtYXQgPSA1O1xuICAgICAgICAgICAgICAgIGludGVybmFsVGV4dHVyZS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGludGVybmFsVGV4dHVyZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyByZWY6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzI2MzM1ODUvaG93LWRvLXlvdS1jb252ZXJ0LXRvLWhhbGYtZmxvYXRzLWluLWphdmFzY3JpcHRcbmxldCBmbG9hdFZpZXc7XG5sZXQgaW50MzJWaWV3O1xuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciB0byBoYWxmIGZsb2F0XG4gKiBAcGFyYW0gdmFsdWUgbnVtYmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIGNvbnZlcnRlZCBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRvSGFsZkZsb2F0KHZhbHVlKSB7XG4gICAgaWYgKCFmbG9hdFZpZXcpIHtcbiAgICAgICAgZmxvYXRWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbiAgICAgICAgaW50MzJWaWV3ID0gbmV3IEludDMyQXJyYXkoZmxvYXRWaWV3LmJ1ZmZlcik7XG4gICAgfVxuICAgIGZsb2F0Vmlld1swXSA9IHZhbHVlO1xuICAgIGNvbnN0IHggPSBpbnQzMlZpZXdbMF07XG4gICAgbGV0IGJpdHMgPSAoeCA+PiAxNikgJiAweDgwMDA7IC8qIEdldCB0aGUgc2lnbiAqL1xuICAgIGxldCBtID0gKHggPj4gMTIpICYgMHgwN2ZmOyAvKiBLZWVwIG9uZSBleHRyYSBiaXQgZm9yIHJvdW5kaW5nICovXG4gICAgY29uc3QgZSA9ICh4ID4+IDIzKSAmIDB4ZmY7IC8qIFVzaW5nIGludCBpcyBmYXN0ZXIgaGVyZSAqL1xuICAgIC8qIElmIHplcm8sIG9yIGRlbm9ybWFsLCBvciBleHBvbmVudCB1bmRlcmZsb3dzIHRvbyBtdWNoIGZvciBhIGRlbm9ybWFsXG4gICAgICogaGFsZiwgcmV0dXJuIHNpZ25lZCB6ZXJvLiAqL1xuICAgIGlmIChlIDwgMTAzKSB7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cbiAgICAvKiBJZiBOYU4sIHJldHVybiBOYU4uIElmIEluZiBvciBleHBvbmVudCBvdmVyZmxvdywgcmV0dXJuIEluZi4gKi9cbiAgICBpZiAoZSA+IDE0Mikge1xuICAgICAgICBiaXRzIHw9IDB4N2MwMDtcbiAgICAgICAgLyogSWYgZXhwb25lbnQgd2FzIDB4ZmYgYW5kIG9uZSBtYW50aXNzYSBiaXQgd2FzIHNldCwgaXQgbWVhbnMgTmFOLFxuICAgICAgICAgKiBub3QgSW5mLCBzbyBtYWtlIHN1cmUgd2Ugc2V0IG9uZSBtYW50aXNzYSBiaXQgdG9vLiAqL1xuICAgICAgICBiaXRzIHw9IChlID09IDI1NSA/IDAgOiAxKSAmJiB4ICYgMHgwMDdmZmZmZjtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIC8qIElmIGV4cG9uZW50IHVuZGVyZmxvd3MgYnV0IG5vdCB0b28gbXVjaCwgcmV0dXJuIGEgZGVub3JtYWwgKi9cbiAgICBpZiAoZSA8IDExMykge1xuICAgICAgICBtIHw9IDB4MDgwMDtcbiAgICAgICAgLyogRXh0cmEgcm91bmRpbmcgbWF5IG92ZXJmbG93IGFuZCBzZXQgbWFudGlzc2EgdG8gMCBhbmQgZXhwb25lbnRcbiAgICAgICAgICogdG8gMSwgd2hpY2ggaXMgT0suICovXG4gICAgICAgIGJpdHMgfD0gKG0gPj4gKDExNCAtIGUpKSArICgobSA+PiAoMTEzIC0gZSkpICYgMSk7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cbiAgICBiaXRzIHw9ICgoZSAtIDExMikgPDwgMTApIHwgKG0gPj4gMSk7XG4gICAgYml0cyArPSBtICYgMTtcbiAgICByZXR1cm4gYml0cztcbn1cbi8qKlxuICogQ29udmVydHMgYSBoYWxmIGZsb2F0IHRvIGEgbnVtYmVyXG4gKiBAcGFyYW0gdmFsdWUgaGFsZiBmbG9hdCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyBjb252ZXJ0ZWQgaGFsZiBmbG9hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gRnJvbUhhbGZGbG9hdCh2YWx1ZSkge1xuICAgIGNvbnN0IHMgPSAodmFsdWUgJiAweDgwMDApID4+IDE1O1xuICAgIGNvbnN0IGUgPSAodmFsdWUgJiAweDdjMDApID4+IDEwO1xuICAgIGNvbnN0IGYgPSB2YWx1ZSAmIDB4MDNmZjtcbiAgICBpZiAoZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogTWF0aC5wb3coMiwgLTE0KSAqIChmIC8gTWF0aC5wb3coMiwgMTApKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZSA9PSAweDFmKSB7XG4gICAgICAgIHJldHVybiBmID8gTmFOIDogKHMgPyAtMSA6IDEpICogSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiAocyA/IC0xIDogMSkgKiBNYXRoLnBvdygyLCBlIC0gMTUpICogKDEgKyBmIC8gTWF0aC5wb3coMiwgMTApKTtcbn1cbmNvbnN0IFByb2Nlc3NBc3luYyA9IGFzeW5jICh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBmYWNlLCBsb2QpID0+IHtcbiAgICBjb25zdCBzY2VuZSA9IHRleHR1cmUuZ2V0U2NlbmUoKTtcbiAgICBjb25zdCBlbmdpbmUgPSBzY2VuZS5nZXRFbmdpbmUoKTtcbiAgICBpZiAoIWVuZ2luZS5pc1dlYkdQVSkge1xuICAgICAgICBpZiAodGV4dHVyZS5pc0N1YmUpIHtcbiAgICAgICAgICAgIGF3YWl0IGltcG9ydChcIi4uL1NoYWRlcnMvbG9kQ3ViZS5mcmFnbWVudC5qc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGltcG9ydChcIi4uL1NoYWRlcnMvbG9kLmZyYWdtZW50LmpzXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodGV4dHVyZS5pc0N1YmUpIHtcbiAgICAgICAgICAgIGF3YWl0IGltcG9ydChcIi4uL1NoYWRlcnNXR1NML2xvZEN1YmUuZnJhZ21lbnQuanNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBpbXBvcnQoXCIuLi9TaGFkZXJzV0dTTC9sb2QuZnJhZ21lbnQuanNcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxvZFBvc3RQcm9jZXNzO1xuICAgIGlmICghdGV4dHVyZS5pc0N1YmUpIHtcbiAgICAgICAgbG9kUG9zdFByb2Nlc3MgPSBuZXcgUG9zdFByb2Nlc3MoXCJsb2RcIiwgXCJsb2RcIiwge1xuICAgICAgICAgICAgdW5pZm9ybXM6IFtcImxvZFwiLCBcImdhbW1hXCJdLFxuICAgICAgICAgICAgc2FtcGxpbmdNb2RlOiBUZXh0dXJlLk5FQVJFU1RfTkVBUkVTVF9NSVBORUFSRVNULFxuICAgICAgICAgICAgZW5naW5lLFxuICAgICAgICAgICAgc2hhZGVyTGFuZ3VhZ2U6IGVuZ2luZS5pc1dlYkdQVSA/IDEgLyogU2hhZGVyTGFuZ3VhZ2UuV0dTTCAqLyA6IDAgLyogU2hhZGVyTGFuZ3VhZ2UuR0xTTCAqLyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBmYWNlRGVmaW5lcyA9IFtcIiNkZWZpbmUgUE9TSVRJVkVYXCIsIFwiI2RlZmluZSBORUdBVElWRVhcIiwgXCIjZGVmaW5lIFBPU0lUSVZFWVwiLCBcIiNkZWZpbmUgTkVHQVRJVkVZXCIsIFwiI2RlZmluZSBQT1NJVElWRVpcIiwgXCIjZGVmaW5lIE5FR0FUSVZFWlwiXTtcbiAgICAgICAgbG9kUG9zdFByb2Nlc3MgPSBuZXcgUG9zdFByb2Nlc3MoXCJsb2RDdWJlXCIsIFwibG9kQ3ViZVwiLCB7XG4gICAgICAgICAgICB1bmlmb3JtczogW1wibG9kXCIsIFwiZ2FtbWFcIl0sXG4gICAgICAgICAgICBzYW1wbGluZ01vZGU6IFRleHR1cmUuTkVBUkVTVF9ORUFSRVNUX01JUE5FQVJFU1QsXG4gICAgICAgICAgICBlbmdpbmUsXG4gICAgICAgICAgICBkZWZpbmVzOiBmYWNlRGVmaW5lc1tmYWNlXSxcbiAgICAgICAgICAgIHNoYWRlckxhbmd1YWdlOiBlbmdpbmUuaXNXZWJHUFUgPyAxIC8qIFNoYWRlckxhbmd1YWdlLldHU0wgKi8gOiAwIC8qIFNoYWRlckxhbmd1YWdlLkdMU0wgKi8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBsb2RQb3N0UHJvY2Vzcy5vbkVmZmVjdENyZWF0ZWRPYnNlcnZhYmxlLmFkZE9uY2UoKGUpID0+IHtcbiAgICAgICAgICAgIGUuZXhlY3V0ZVdoZW5Db21waWxlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBydHQgPSBuZXcgUmVuZGVyVGFyZ2V0VGV4dHVyZShcInRlbXBcIiwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0sIHNjZW5lLCBmYWxzZSk7XG4gICAgbG9kUG9zdFByb2Nlc3Mub25BcHBseSA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICAgICAgZWZmZWN0LnNldFRleHR1cmUoXCJ0ZXh0dXJlU2FtcGxlclwiLCB0ZXh0dXJlKTtcbiAgICAgICAgZWZmZWN0LnNldEZsb2F0KFwibG9kXCIsIGxvZCk7XG4gICAgICAgIGVmZmVjdC5zZXRJbnQoXCJnYW1tYVwiLCB0ZXh0dXJlLmdhbW1hU3BhY2UgPyAxIDogMCk7XG4gICAgfTtcbiAgICBjb25zdCBpbnRlcm5hbFRleHR1cmUgPSB0ZXh0dXJlLmdldEludGVybmFsVGV4dHVyZSgpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChydHQucmVuZGVyVGFyZ2V0ICYmIGludGVybmFsVGV4dHVyZSkge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxpbmdNb2RlID0gaW50ZXJuYWxUZXh0dXJlLnNhbXBsaW5nTW9kZTtcbiAgICAgICAgICAgIGlmIChsb2QgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnVwZGF0ZVNhbXBsaW5nTW9kZShUZXh0dXJlLk5FQVJFU1RfTkVBUkVTVF9NSVBORUFSRVNUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHR1cmUudXBkYXRlU2FtcGxpbmdNb2RlKFRleHR1cmUuTkVBUkVTVF9ORUFSRVNUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjZW5lLnBvc3RQcm9jZXNzTWFuYWdlci5kaXJlY3RSZW5kZXIoW2xvZFBvc3RQcm9jZXNzXSwgcnR0LnJlbmRlclRhcmdldCwgdHJ1ZSk7XG4gICAgICAgICAgICB0ZXh0dXJlLnVwZGF0ZVNhbXBsaW5nTW9kZShzYW1wbGluZ01vZGUpO1xuICAgICAgICAgICAgLy9SZWFkaW5nIGRhdGFzIGZyb20gV2ViR0xcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBhd2FpdCBlbmdpbmUucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXJWaWV3LmJ1ZmZlciwgMCwgYnVmZmVyVmlldy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIFVuYmluZFxuICAgICAgICAgICAgZW5naW5lLnVuQmluZEZyYW1lYnVmZmVyKHJ0dC5yZW5kZXJUYXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlJlbmRlciB0byB0ZXh0dXJlIGZhaWxlZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHJ0dC5kaXNwb3NlKCk7XG4gICAgICAgIGxvZFBvc3RQcm9jZXNzLmRpc3Bvc2UoKTtcbiAgICB9XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIG9mIHRoZSBzcGVjaWZpZWQgdGV4dHVyZSBieSByZW5kZXJpbmcgaXQgdG8gYW4gaW50ZXJtZWRpYXRlIFJHQkEgdGV4dHVyZSBhbmQgcmV0cmlldmluZyB0aGUgYnl0ZXMgZnJvbSBpdC5cbiAqIFRoaXMgaXMgY29udmllbmVudCB0byBnZXQgOC1iaXQgUkdCQSB2YWx1ZXMgZm9yIGEgdGV4dHVyZSBpbiBhIEdQVSBjb21wcmVzc2VkIGZvcm1hdC5cbiAqIEBwYXJhbSB0ZXh0dXJlIHRoZSBzb3VyY2UgdGV4dHVyZVxuICogQHBhcmFtIHdpZHRoIHRoZSB3aWR0aCBvZiB0aGUgcmVzdWx0LCB3aGljaCBkb2VzIG5vdCBoYXZlIHRvIG1hdGNoIHRoZSBzb3VyY2UgdGV4dHVyZSB3aWR0aFxuICogQHBhcmFtIGhlaWdodCB0aGUgaGVpZ2h0IG9mIHRoZSByZXN1bHQsIHdoaWNoIGRvZXMgbm90IGhhdmUgdG8gbWF0Y2ggdGhlIHNvdXJjZSB0ZXh0dXJlIGhlaWdodFxuICogQHBhcmFtIGZhY2UgaWYgdGhlIHRleHR1cmUgaGFzIG11bHRpcGxlIGZhY2VzLCB0aGUgZmFjZSBpbmRleCB0byB1c2UgZm9yIHRoZSBzb3VyY2VcbiAqIEBwYXJhbSBsb2QgaWYgdGhlIHRleHR1cmUgaGFzIG11bHRpcGxlIExPRHMsIHRoZSBsb2QgaW5kZXggdG8gdXNlIGZvciB0aGUgc291cmNlXG4gKiBAcmV0dXJucyB0aGUgOC1iaXQgdGV4dHVyZSBkYXRhXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHZXRUZXh0dXJlRGF0YUFzeW5jKHRleHR1cmUsIHdpZHRoLCBoZWlnaHQsIGZhY2UgPSAwLCBsb2QgPSAwKSB7XG4gICAgaWYgKCF0ZXh0dXJlLmlzUmVhZHkoKSAmJiB0ZXh0dXJlLl90ZXh0dXJlKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLl90ZXh0dXJlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHR1cmUuX3RleHR1cmUub25Mb2FkZWRPYnNlcnZhYmxlLmFkZE9uY2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBQcm9jZXNzQXN5bmModGV4dHVyZSwgd2lkdGgsIGhlaWdodCwgZmFjZSwgbG9kKTtcbn1cbi8qKlxuICogQ2xhc3MgdXNlZCB0byBob3N0IHRleHR1cmUgc3BlY2lmaWMgdXRpbGl0aWVzXG4gKi9cbmV4cG9ydCBjb25zdCBUZXh0dXJlVG9vbHMgPSB7XG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgR1BVIHRvIGNyZWF0ZSBhIGNvcHkgdGV4dHVyZSByZXNjYWxlZCBhdCBhIGdpdmVuIHNpemVcbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBUZXh0dXJlIHRvIGNvcHkgZnJvbVxuICAgICAqIEBwYXJhbSB3aWR0aCBkZWZpbmVzIHRoZSBkZXNpcmVkIHdpZHRoXG4gICAgICogQHBhcmFtIGhlaWdodCBkZWZpbmVzIHRoZSBkZXNpcmVkIGhlaWdodFxuICAgICAqIEBwYXJhbSB1c2VCaWxpbmVhck1vZGUgZGVmaW5lcyBpZiBiaWxpbmVhciBtb2RlIGhhcyB0byBiZSB1c2VkXG4gICAgICogQHJldHVybnMgdGhlIGdlbmVyYXRlZCB0ZXh0dXJlXG4gICAgICovXG4gICAgQ3JlYXRlUmVzaXplZENvcHksXG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBwb3N0IHByb2Nlc3MgdG8gYSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHBvc3RQcm9jZXNzTmFtZSBuYW1lIG9mIHRoZSBmcmFnbWVudCBwb3N0IHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gaW50ZXJuYWxUZXh0dXJlIHRoZSB0ZXh0dXJlIHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSBzY2VuZSB0aGUgc2NlbmUgaG9zdGluZyB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB0eXBlIHR5cGUgb2YgdGhlIG91dHB1dCB0ZXh0dXJlLiBJZiBub3QgcHJvdmlkZWQsIHVzZSB0aGUgb25lIGZyb20gaW50ZXJuYWxUZXh0dXJlXG4gICAgICogQHBhcmFtIHNhbXBsaW5nTW9kZSBzYW1wbGluZyBtb2RlIHRvIHVzZSB0byBzYW1wbGUgdGhlIHNvdXJjZSB0ZXh0dXJlLiBJZiBub3QgcHJvdmlkZWQsIHVzZSB0aGUgb25lIGZyb20gaW50ZXJuYWxUZXh0dXJlXG4gICAgICogQHBhcmFtIGZvcm1hdCBmb3JtYXQgb2YgdGhlIG91dHB1dCB0ZXh0dXJlLiBJZiBub3QgcHJvdmlkZWQsIHVzZSB0aGUgb25lIGZyb20gaW50ZXJuYWxUZXh0dXJlXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIHdpdGggdGhlIGludGVybmFsVGV4dHVyZSBoYXZpbmcgaXRzIHRleHR1cmUgcmVwbGFjZWQgYnkgdGhlIHJlc3VsdCBvZiB0aGUgcHJvY2Vzc2luZ1xuICAgICAqL1xuICAgIEFwcGx5UG9zdFByb2Nlc3MsXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBudW1iZXIgdG8gaGFsZiBmbG9hdFxuICAgICAqIEBwYXJhbSB2YWx1ZSBudW1iZXIgdG8gY29udmVydFxuICAgICAqIEByZXR1cm5zIGNvbnZlcnRlZCBudW1iZXJcbiAgICAgKi9cbiAgICBUb0hhbGZGbG9hdCxcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGhhbGYgZmxvYXQgdG8gYSBudW1iZXJcbiAgICAgKiBAcGFyYW0gdmFsdWUgaGFsZiBmbG9hdCB0byBjb252ZXJ0XG4gICAgICogQHJldHVybnMgY29udmVydGVkIGhhbGYgZmxvYXRcbiAgICAgKi9cbiAgICBGcm9tSGFsZkZsb2F0LFxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGEgb2YgdGhlIHNwZWNpZmllZCB0ZXh0dXJlIGJ5IHJlbmRlcmluZyBpdCB0byBhbiBpbnRlcm1lZGlhdGUgUkdCQSB0ZXh0dXJlIGFuZCByZXRyaWV2aW5nIHRoZSBieXRlcyBmcm9tIGl0LlxuICAgICAqIFRoaXMgaXMgY29udmllbmVudCB0byBnZXQgOC1iaXQgUkdCQSB2YWx1ZXMgZm9yIGEgdGV4dHVyZSBpbiBhIEdQVSBjb21wcmVzc2VkIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gdGV4dHVyZSB0aGUgc291cmNlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gd2lkdGggdGhlIHdpZHRoIG9mIHRoZSByZXN1bHQsIHdoaWNoIGRvZXMgbm90IGhhdmUgdG8gbWF0Y2ggdGhlIHNvdXJjZSB0ZXh0dXJlIHdpZHRoXG4gICAgICogQHBhcmFtIGhlaWdodCB0aGUgaGVpZ2h0IG9mIHRoZSByZXN1bHQsIHdoaWNoIGRvZXMgbm90IGhhdmUgdG8gbWF0Y2ggdGhlIHNvdXJjZSB0ZXh0dXJlIGhlaWdodFxuICAgICAqIEBwYXJhbSBmYWNlIGlmIHRoZSB0ZXh0dXJlIGhhcyBtdWx0aXBsZSBmYWNlcywgdGhlIGZhY2UgaW5kZXggdG8gdXNlIGZvciB0aGUgc291cmNlXG4gICAgICogQHBhcmFtIGNoYW5uZWxzIGEgZmlsdGVyIGZvciB3aGljaCBvZiB0aGUgUkdCQSBjaGFubmVscyB0byByZXR1cm4gaW4gdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSBsb2QgaWYgdGhlIHRleHR1cmUgaGFzIG11bHRpcGxlIExPRHMsIHRoZSBsb2QgaW5kZXggdG8gdXNlIGZvciB0aGUgc291cmNlXG4gICAgICogQHJldHVybnMgdGhlIDgtYml0IHRleHR1cmUgZGF0YVxuICAgICAqL1xuICAgIEdldFRleHR1cmVEYXRhQXN5bmMsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZVRvb2xzLmpzLm1hcCIsImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tIFwiLi4vdHNsaWIuZXM2LmpzXCI7XG5cbmltcG9ydCB7IFBvc3RQcm9jZXNzIH0gZnJvbSBcIi4vcG9zdFByb2Nlc3MuanNcIjtcbmltcG9ydCB7IEFic3RyYWN0RW5naW5lIH0gZnJvbSBcIi4uL0VuZ2luZXMvYWJzdHJhY3RFbmdpbmUuanNcIjtcbmltcG9ydCB7IFJlZ2lzdGVyQ2xhc3MgfSBmcm9tIFwiLi4vTWlzYy90eXBlU3RvcmUuanNcIjtcbmltcG9ydCB7IFNlcmlhbGl6YXRpb25IZWxwZXIgfSBmcm9tIFwiLi4vTWlzYy9kZWNvcmF0b3JzLnNlcmlhbGl6YXRpb24uanNcIjtcbmltcG9ydCB7IFRoaW5QYXNzQ3ViZVBvc3RQcm9jZXNzLCBUaGluUGFzc1Bvc3RQcm9jZXNzIH0gZnJvbSBcIi4vdGhpblBhc3NQb3N0UHJvY2Vzcy5qc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplIH0gZnJvbSBcIi4uL01pc2MvZGVjb3JhdG9ycy5qc1wiO1xuLyoqXG4gKiBQYXNzUG9zdFByb2Nlc3Mgd2hpY2ggcHJvZHVjZXMgYW4gb3V0cHV0IHRoZSBzYW1lIGFzIGl0J3MgaW5wdXRcbiAqL1xuZXhwb3J0IGNsYXNzIFBhc3NQb3N0UHJvY2VzcyBleHRlbmRzIFBvc3RQcm9jZXNzIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgICAqIEByZXR1cm5zIFwiUGFzc1Bvc3RQcm9jZXNzXCIgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJQYXNzUG9zdFByb2Nlc3NcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgUGFzc1Bvc3RQcm9jZXNzXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgcmVxdWlyZWQgd2lkdGgvaGVpZ2h0IHJhdGlvIHRvIGRvd25zaXplIHRvIGJlZm9yZSBjb21wdXRpbmcgdGhlIHJlbmRlciBwYXNzLlxuICAgICAqIEBwYXJhbSBjYW1lcmEgVGhlIGNhbWVyYSB0byBhcHBseSB0aGUgcmVuZGVyIHBhc3MgdG8uXG4gICAgICogQHBhcmFtIHNhbXBsaW5nTW9kZSBUaGUgc2FtcGxpbmcgbW9kZSB0byBiZSB1c2VkIHdoZW4gY29tcHV0aW5nIHRoZSBwYXNzLiAoZGVmYXVsdDogMClcbiAgICAgKiBAcGFyYW0gZW5naW5lIFRoZSBlbmdpbmUgd2hpY2ggdGhlIHBvc3QgcHJvY2VzcyB3aWxsIGJlIGFwcGxpZWQuIChkZWZhdWx0OiBjdXJyZW50IGVuZ2luZSlcbiAgICAgKiBAcGFyYW0gcmV1c2FibGUgSWYgdGhlIHBvc3QgcHJvY2VzcyBjYW4gYmUgcmV1c2VkIG9uIHRoZSBzYW1lIGZyYW1lLiAoZGVmYXVsdDogZmFsc2UpXG4gICAgICogQHBhcmFtIHRleHR1cmVUeXBlIFRoZSB0eXBlIG9mIHRleHR1cmUgdG8gYmUgdXNlZCB3aGVuIHBlcmZvcm1pbmcgdGhlIHBvc3QgcHJvY2Vzc2luZy5cbiAgICAgKiBAcGFyYW0gYmxvY2tDb21waWxhdGlvbiBJZiBjb21waWxhdGlvbiBvZiB0aGUgc2hhZGVyIHNob3VsZCBub3QgYmUgZG9uZSBpbiB0aGUgY29uc3RydWN0b3IuIFRoZSB1cGRhdGVFZmZlY3QgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBhdCBhIGxhdGVyIHRpbWUuIChkZWZhdWx0OiBmYWxzZSlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBvcHRpb25zLCBjYW1lcmEgPSBudWxsLCBzYW1wbGluZ01vZGUsIGVuZ2luZSwgcmV1c2FibGUsIHRleHR1cmVUeXBlID0gMCwgYmxvY2tDb21waWxhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNpemU6IHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiID8gb3B0aW9ucyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNhbWVyYSxcbiAgICAgICAgICAgIHNhbXBsaW5nTW9kZSxcbiAgICAgICAgICAgIGVuZ2luZSxcbiAgICAgICAgICAgIHJldXNhYmxlLFxuICAgICAgICAgICAgdGV4dHVyZVR5cGUsXG4gICAgICAgICAgICBibG9ja0NvbXBpbGF0aW9uLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIobmFtZSwgVGhpblBhc3NQb3N0UHJvY2Vzcy5GcmFnbWVudFVybCwge1xuICAgICAgICAgICAgZWZmZWN0V3JhcHBlcjogdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgfHwgIW9wdGlvbnMuZWZmZWN0V3JhcHBlciA/IG5ldyBUaGluUGFzc1Bvc3RQcm9jZXNzKG5hbWUsIGVuZ2luZSwgbG9jYWxPcHRpb25zKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC4uLmxvY2FsT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBfUGFyc2UocGFyc2VkUG9zdFByb2Nlc3MsIHRhcmdldENhbWVyYSwgc2NlbmUsIHJvb3RVcmwpIHtcbiAgICAgICAgcmV0dXJuIFNlcmlhbGl6YXRpb25IZWxwZXIuUGFyc2UoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXNzUG9zdFByb2Nlc3MocGFyc2VkUG9zdFByb2Nlc3MubmFtZSwgcGFyc2VkUG9zdFByb2Nlc3Mub3B0aW9ucywgdGFyZ2V0Q2FtZXJhLCBwYXJzZWRQb3N0UHJvY2Vzcy5yZW5kZXJUYXJnZXRTYW1wbGluZ01vZGUsIHBhcnNlZFBvc3RQcm9jZXNzLl9lbmdpbmUsIHBhcnNlZFBvc3RQcm9jZXNzLnJldXNhYmxlKTtcbiAgICAgICAgfSwgcGFyc2VkUG9zdFByb2Nlc3MsIHNjZW5lLCByb290VXJsKTtcbiAgICB9XG59XG5SZWdpc3RlckNsYXNzKFwiQkFCWUxPTi5QYXNzUG9zdFByb2Nlc3NcIiwgUGFzc1Bvc3RQcm9jZXNzKTtcbi8qKlxuICogUGFzc0N1YmVQb3N0UHJvY2VzcyB3aGljaCBwcm9kdWNlcyBhbiBvdXRwdXQgdGhlIHNhbWUgYXMgaXQncyBpbnB1dCAod2hpY2ggbXVzdCBiZSBhIGN1YmUgdGV4dHVyZSlcbiAqL1xuZXhwb3J0IGNsYXNzIFBhc3NDdWJlUG9zdFByb2Nlc3MgZXh0ZW5kcyBQb3N0UHJvY2VzcyB7XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBjdWJlIGZhY2UgdG8gZGlzcGxheS5cbiAgICAgKiAgKiAwIGlzICtYXG4gICAgICogICogMSBpcyAtWFxuICAgICAqICAqIDIgaXMgK1lcbiAgICAgKiAgKiAzIGlzIC1ZXG4gICAgICogICogNCBpcyArWlxuICAgICAqICAqIDUgaXMgLVpcbiAgICAgKi9cbiAgICBnZXQgZmFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VmZmVjdFdyYXBwZXIuZmFjZTtcbiAgICB9XG4gICAgc2V0IGZhY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZWZmZWN0V3JhcHBlci5mYWNlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgICogQHJldHVybnMgXCJQYXNzQ3ViZVBvc3RQcm9jZXNzXCIgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJQYXNzQ3ViZVBvc3RQcm9jZXNzXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFBhc3NDdWJlUG9zdFByb2Nlc3NcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZWZmZWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSByZXF1aXJlZCB3aWR0aC9oZWlnaHQgcmF0aW8gdG8gZG93bnNpemUgdG8gYmVmb3JlIGNvbXB1dGluZyB0aGUgcmVuZGVyIHBhc3MuXG4gICAgICogQHBhcmFtIGNhbWVyYSBUaGUgY2FtZXJhIHRvIGFwcGx5IHRoZSByZW5kZXIgcGFzcyB0by5cbiAgICAgKiBAcGFyYW0gc2FtcGxpbmdNb2RlIFRoZSBzYW1wbGluZyBtb2RlIHRvIGJlIHVzZWQgd2hlbiBjb21wdXRpbmcgdGhlIHBhc3MuIChkZWZhdWx0OiAwKVxuICAgICAqIEBwYXJhbSBlbmdpbmUgVGhlIGVuZ2luZSB3aGljaCB0aGUgcG9zdCBwcm9jZXNzIHdpbGwgYmUgYXBwbGllZC4gKGRlZmF1bHQ6IGN1cnJlbnQgZW5naW5lKVxuICAgICAqIEBwYXJhbSByZXVzYWJsZSBJZiB0aGUgcG9zdCBwcm9jZXNzIGNhbiBiZSByZXVzZWQgb24gdGhlIHNhbWUgZnJhbWUuIChkZWZhdWx0OiBmYWxzZSlcbiAgICAgKiBAcGFyYW0gdGV4dHVyZVR5cGUgVGhlIHR5cGUgb2YgdGV4dHVyZSB0byBiZSB1c2VkIHdoZW4gcGVyZm9ybWluZyB0aGUgcG9zdCBwcm9jZXNzaW5nLlxuICAgICAqIEBwYXJhbSBibG9ja0NvbXBpbGF0aW9uIElmIGNvbXBpbGF0aW9uIG9mIHRoZSBzaGFkZXIgc2hvdWxkIG5vdCBiZSBkb25lIGluIHRoZSBjb25zdHJ1Y3Rvci4gVGhlIHVwZGF0ZUVmZmVjdCBtZXRob2QgY2FuIGJlIHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIGF0IGEgbGF0ZXIgdGltZS4gKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wdGlvbnMsIGNhbWVyYSA9IG51bGwsIHNhbXBsaW5nTW9kZSwgZW5naW5lLCByZXVzYWJsZSwgdGV4dHVyZVR5cGUgPSAwLCBibG9ja0NvbXBpbGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgbG9jYWxPcHRpb25zID0ge1xuICAgICAgICAgICAgc2l6ZTogdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2FtZXJhLFxuICAgICAgICAgICAgc2FtcGxpbmdNb2RlLFxuICAgICAgICAgICAgZW5naW5lLFxuICAgICAgICAgICAgcmV1c2FibGUsXG4gICAgICAgICAgICB0ZXh0dXJlVHlwZSxcbiAgICAgICAgICAgIGJsb2NrQ29tcGlsYXRpb24sXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihuYW1lLCBUaGluUGFzc1Bvc3RQcm9jZXNzLkZyYWdtZW50VXJsLCB7XG4gICAgICAgICAgICBlZmZlY3RXcmFwcGVyOiB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiB8fCAhb3B0aW9ucy5lZmZlY3RXcmFwcGVyID8gbmV3IFRoaW5QYXNzQ3ViZVBvc3RQcm9jZXNzKG5hbWUsIGVuZ2luZSwgbG9jYWxPcHRpb25zKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC4uLmxvY2FsT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBfUGFyc2UocGFyc2VkUG9zdFByb2Nlc3MsIHRhcmdldENhbWVyYSwgc2NlbmUsIHJvb3RVcmwpIHtcbiAgICAgICAgcmV0dXJuIFNlcmlhbGl6YXRpb25IZWxwZXIuUGFyc2UoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXNzQ3ViZVBvc3RQcm9jZXNzKHBhcnNlZFBvc3RQcm9jZXNzLm5hbWUsIHBhcnNlZFBvc3RQcm9jZXNzLm9wdGlvbnMsIHRhcmdldENhbWVyYSwgcGFyc2VkUG9zdFByb2Nlc3MucmVuZGVyVGFyZ2V0U2FtcGxpbmdNb2RlLCBwYXJzZWRQb3N0UHJvY2Vzcy5fZW5naW5lLCBwYXJzZWRQb3N0UHJvY2Vzcy5yZXVzYWJsZSk7XG4gICAgICAgIH0sIHBhcnNlZFBvc3RQcm9jZXNzLCBzY2VuZSwgcm9vdFVybCk7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIFBhc3NDdWJlUG9zdFByb2Nlc3MucHJvdG90eXBlLCBcImZhY2VcIiwgbnVsbCk7XG5BYnN0cmFjdEVuZ2luZS5fUmVzY2FsZVBvc3RQcm9jZXNzRmFjdG9yeSA9IChlbmdpbmUpID0+IHtcbiAgICByZXR1cm4gbmV3IFBhc3NQb3N0UHJvY2VzcyhcInJlc2NhbGVcIiwgMSwgbnVsbCwgMiwgZW5naW5lLCBmYWxzZSwgMCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFzc1Bvc3RQcm9jZXNzLmpzLm1hcCIsImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tIFwiLi4vdHNsaWIuZXM2LmpzXCI7XG5pbXBvcnQgeyBTbWFydEFycmF5IH0gZnJvbSBcIi4uL01pc2Mvc21hcnRBcnJheS5qc1wiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCIuLi9NaXNjL29ic2VydmFibGUuanNcIjtcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tIFwiLi4vTWF0aHMvbWF0aC52ZWN0b3IuanNcIjtcbmltcG9ydCB7IEVmZmVjdCB9IGZyb20gXCIuLi9NYXRlcmlhbHMvZWZmZWN0LmpzXCI7XG5cbmltcG9ydCB7IHNlcmlhbGl6ZSwgc2VyaWFsaXplQXNDb2xvcjQgfSBmcm9tIFwiLi4vTWlzYy9kZWNvcmF0b3JzLmpzXCI7XG5pbXBvcnQgeyBTZXJpYWxpemF0aW9uSGVscGVyIH0gZnJvbSBcIi4uL01pc2MvZGVjb3JhdG9ycy5zZXJpYWxpemF0aW9uLmpzXCI7XG5pbXBvcnQgeyBHZXRDbGFzcywgUmVnaXN0ZXJDbGFzcyB9IGZyb20gXCIuLi9NaXNjL3R5cGVTdG9yZS5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RFbmdpbmUgfSBmcm9tIFwiLi4vRW5naW5lcy9hYnN0cmFjdEVuZ2luZS5qc1wiO1xuaW1wb3J0IHsgR2V0RXhwb25lbnRPZlR3byB9IGZyb20gXCIuLi9NaXNjL3Rvb2xzLmZ1bmN0aW9ucy5qc1wiO1xuaW1wb3J0IHsgRWZmZWN0V3JhcHBlciB9IGZyb20gXCIuLi9NYXRlcmlhbHMvZWZmZWN0UmVuZGVyZXIuanNcIjtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5zZXRUZXh0dXJlRnJvbVBvc3RQcm9jZXNzID0gZnVuY3Rpb24gKGNoYW5uZWwsIHBvc3RQcm9jZXNzLCBuYW1lKSB7XG4gICAgbGV0IHBvc3RQcm9jZXNzSW5wdXQgPSBudWxsO1xuICAgIGlmIChwb3N0UHJvY2Vzcykge1xuICAgICAgICBpZiAocG9zdFByb2Nlc3MuX2ZvcmNlZE91dHB1dFRleHR1cmUpIHtcbiAgICAgICAgICAgIHBvc3RQcm9jZXNzSW5wdXQgPSBwb3N0UHJvY2Vzcy5fZm9yY2VkT3V0cHV0VGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3N0UHJvY2Vzcy5fdGV4dHVyZXMuZGF0YVtwb3N0UHJvY2Vzcy5fY3VycmVudFJlbmRlclRleHR1cmVJbmRdKSB7XG4gICAgICAgICAgICBwb3N0UHJvY2Vzc0lucHV0ID0gcG9zdFByb2Nlc3MuX3RleHR1cmVzLmRhdGFbcG9zdFByb2Nlc3MuX2N1cnJlbnRSZW5kZXJUZXh0dXJlSW5kXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9iaW5kVGV4dHVyZShjaGFubmVsLCBwb3N0UHJvY2Vzc0lucHV0Py50ZXh0dXJlID8/IG51bGwsIG5hbWUpO1xufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5zZXRUZXh0dXJlRnJvbVBvc3RQcm9jZXNzT3V0cHV0ID0gZnVuY3Rpb24gKGNoYW5uZWwsIHBvc3RQcm9jZXNzLCBuYW1lKSB7XG4gICAgdGhpcy5fYmluZFRleHR1cmUoY2hhbm5lbCwgcG9zdFByb2Nlc3M/Ll9vdXRwdXRUZXh0dXJlPy50ZXh0dXJlID8/IG51bGwsIG5hbWUpO1xufTtcbi8qKlxuICogU2V0cyBhIHRleHR1cmUgdG8gYmUgdGhlIGlucHV0IG9mIHRoZSBzcGVjaWZpZWQgcG9zdCBwcm9jZXNzLiAoVG8gdXNlIHRoZSBvdXRwdXQsIHBhc3MgaW4gdGhlIG5leHQgcG9zdCBwcm9jZXNzIGluIHRoZSBwaXBlbGluZSlcbiAqIEBwYXJhbSBjaGFubmVsIE5hbWUgb2YgdGhlIHNhbXBsZXIgdmFyaWFibGUuXG4gKiBAcGFyYW0gcG9zdFByb2Nlc3MgUG9zdCBwcm9jZXNzIHRvIGdldCB0aGUgaW5wdXQgdGV4dHVyZSBmcm9tLlxuICovXG5FZmZlY3QucHJvdG90eXBlLnNldFRleHR1cmVGcm9tUG9zdFByb2Nlc3MgPSBmdW5jdGlvbiAoY2hhbm5lbCwgcG9zdFByb2Nlc3MpIHtcbiAgICB0aGlzLl9lbmdpbmUuc2V0VGV4dHVyZUZyb21Qb3N0UHJvY2Vzcyh0aGlzLl9zYW1wbGVyc1tjaGFubmVsXSwgcG9zdFByb2Nlc3MsIGNoYW5uZWwpO1xufTtcbi8qKlxuICogKFdhcm5pbmchIHNldFRleHR1cmVGcm9tUG9zdFByb2Nlc3NPdXRwdXQgbWF5IGJlIGRlc2lyZWQgaW5zdGVhZClcbiAqIFNldHMgdGhlIGlucHV0IHRleHR1cmUgb2YgdGhlIHBhc3NlZCBpbiBwb3N0IHByb2Nlc3MgdG8gYmUgaW5wdXQgb2YgdGhpcyBlZmZlY3QuIChUbyB1c2UgdGhlIG91dHB1dCBvZiB0aGUgcGFzc2VkIGluIHBvc3QgcHJvY2VzcyB1c2Ugc2V0VGV4dHVyZUZyb21Qb3N0UHJvY2Vzc091dHB1dClcbiAqIEBwYXJhbSBjaGFubmVsIE5hbWUgb2YgdGhlIHNhbXBsZXIgdmFyaWFibGUuXG4gKiBAcGFyYW0gcG9zdFByb2Nlc3MgUG9zdCBwcm9jZXNzIHRvIGdldCB0aGUgb3V0cHV0IHRleHR1cmUgZnJvbS5cbiAqL1xuRWZmZWN0LnByb3RvdHlwZS5zZXRUZXh0dXJlRnJvbVBvc3RQcm9jZXNzT3V0cHV0ID0gZnVuY3Rpb24gKGNoYW5uZWwsIHBvc3RQcm9jZXNzKSB7XG4gICAgdGhpcy5fZW5naW5lLnNldFRleHR1cmVGcm9tUG9zdFByb2Nlc3NPdXRwdXQodGhpcy5fc2FtcGxlcnNbY2hhbm5lbF0sIHBvc3RQcm9jZXNzLCBjaGFubmVsKTtcbn07XG4vKipcbiAqIFBvc3RQcm9jZXNzIGNhbiBiZSB1c2VkIHRvIGFwcGx5IGEgc2hhZGVyIHRvIGEgdGV4dHVyZSBhZnRlciBpdCBoYXMgYmVlbiByZW5kZXJlZFxuICogU2VlIGh0dHBzOi8vZG9jLmJhYnlsb25qcy5jb20vZmVhdHVyZXMvZmVhdHVyZXNEZWVwRGl2ZS9wb3N0UHJvY2Vzc2VzL3VzZVBvc3RQcm9jZXNzZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFBvc3RQcm9jZXNzIHtcbiAgICAvKipcbiAgICAgKiBGb3JjZSBhbGwgdGhlIHBvc3Rwcm9jZXNzZXMgdG8gY29tcGlsZSB0byBnbHNsIGV2ZW4gb24gV2ViR1BVIGVuZ2luZXMuXG4gICAgICogRmFsc2UgYnkgZGVmYXVsdC4gVGhpcyBpcyBtb3N0bHkgbWVhbnQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gICAgc3RhdGljIGdldCBGb3JjZUdMU0woKSB7XG4gICAgICAgIHJldHVybiBFZmZlY3RXcmFwcGVyLkZvcmNlR0xTTDtcbiAgICB9XG4gICAgc3RhdGljIHNldCBGb3JjZUdMU0woZm9yY2UpIHtcbiAgICAgICAgRWZmZWN0V3JhcHBlci5Gb3JjZUdMU0wgPSBmb3JjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgc2hhZGVyIGNvZGUgcHJvY2Vzc2luZyB3aXRoIGEgcG9zdCBwcm9jZXNzIG5hbWUuXG4gICAgICogQHBhcmFtIHBvc3RQcm9jZXNzTmFtZSBuYW1lIG9mIHRoZSBwb3N0IHByb2Nlc3MuIFVzZSBudWxsIGZvciB0aGUgZmFsbGJhY2sgc2hhZGVyIGNvZGUgcHJvY2Vzc2luZy4gVGhpcyBpcyB0aGUgc2hhZGVyIGNvZGUgcHJvY2Vzc2luZyB0aGF0IHdpbGwgYmUgdXNlZCBpbiBjYXNlIG5vIHNwZWNpZmljIHNoYWRlciBjb2RlIHByb2Nlc3NpbmcgaGFzIGJlZW4gYXNzb2NpYXRlZCB0byBhIHBvc3QgcHJvY2VzcyBuYW1lXG4gICAgICogQHBhcmFtIGN1c3RvbVNoYWRlckNvZGVQcm9jZXNzaW5nIHNoYWRlciBjb2RlIHByb2Nlc3NpbmcgdG8gYXNzb2NpYXRlIHRvIHRoZSBwb3N0IHByb2Nlc3MgbmFtZVxuICAgICAqL1xuICAgIHN0YXRpYyBSZWdpc3RlclNoYWRlckNvZGVQcm9jZXNzaW5nKHBvc3RQcm9jZXNzTmFtZSwgY3VzdG9tU2hhZGVyQ29kZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgRWZmZWN0V3JhcHBlci5SZWdpc3RlclNoYWRlckNvZGVQcm9jZXNzaW5nKHBvc3RQcm9jZXNzTmFtZSwgY3VzdG9tU2hhZGVyQ29kZVByb2Nlc3NpbmcpO1xuICAgIH1cbiAgICAvKiogTmFtZSBvZiB0aGUgUG9zdFByb2Nlc3MuICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lZmZlY3RXcmFwcGVyLm5hbWU7XG4gICAgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2VmZmVjdFdyYXBwZXIubmFtZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFscGhhIG1vZGUgdG8gdXNlIHdoZW4gcGVyZm9ybWluZyB0aGUgcG9zdCBwcm9jZXNzIChkZWZhdWx0OiBFbmdpbmUuQUxQSEFfRElTQUJMRSlcbiAgICAgKi9cbiAgICBnZXQgYWxwaGFNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWZmZWN0V3JhcHBlci5hbHBoYU1vZGU7XG4gICAgfVxuICAgIHNldCBhbHBoYU1vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZWZmZWN0V3JhcHBlci5hbHBoYU1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHNhbXBsZSB0ZXh0dXJlcyAoZGVmYXVsdDogMSlcbiAgICAgKi9cbiAgICBnZXQgc2FtcGxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhbXBsZXM7XG4gICAgfVxuICAgIHNldCBzYW1wbGVzKG4pIHtcbiAgICAgICAgdGhpcy5fc2FtcGxlcyA9IE1hdGgubWluKG4sIHRoaXMuX2VuZ2luZS5nZXRDYXBzKCkubWF4TVNBQVNhbXBsZXMpO1xuICAgICAgICB0aGlzLl90ZXh0dXJlcy5mb3JFYWNoKCh0ZXh0dXJlKSA9PiB7XG4gICAgICAgICAgICB0ZXh0dXJlLnNldFNhbXBsZXModGhpcy5fc2FtcGxlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaGFkZXIgbGFuZ3VhZ2UgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIHZlcnRleCBhbmQgZnJhZ21lbnQgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgZ2V0IHNoYWRlckxhbmd1YWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hhZGVyTGFuZ3VhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZyYWdtZW50IHVybCBvciBzaGFkZXIgbmFtZSB1c2VkIGluIHRoZSBwb3N0IHByb2Nlc3MuXG4gICAgICogQHJldHVybnMgdGhlIGZyYWdtZW50IHVybCBvciBuYW1lIGluIHRoZSBzaGFkZXIgc3RvcmUuXG4gICAgICovXG4gICAgZ2V0RWZmZWN0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYWdtZW50VXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgaXMgYWRkZWQgdG8gdGhlIG9uQWN0aXZhdGVPYnNlcnZhYmxlXG4gICAgICovXG4gICAgc2V0IG9uQWN0aXZhdGUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX29uQWN0aXZhdGVPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5vbkFjdGl2YXRlT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25BY3RpdmF0ZU9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX29uQWN0aXZhdGVPYnNlcnZlciA9IHRoaXMub25BY3RpdmF0ZU9ic2VydmFibGUuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgaXMgYWRkZWQgdG8gdGhlIG9uU2l6ZUNoYW5nZWRPYnNlcnZhYmxlXG4gICAgICovXG4gICAgc2V0IG9uU2l6ZUNoYW5nZWQoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX29uU2l6ZUNoYW5nZWRPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5vblNpemVDaGFuZ2VkT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25TaXplQ2hhbmdlZE9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vblNpemVDaGFuZ2VkT2JzZXJ2ZXIgPSB0aGlzLm9uU2l6ZUNoYW5nZWRPYnNlcnZhYmxlLmFkZChjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBpcyBhZGRlZCB0byB0aGUgb25BcHBseU9ic2VydmFibGVcbiAgICAgKi9cbiAgICBzZXQgb25BcHBseShjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5fb25BcHBseU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9uQXBwbHlPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9vbkFwcGx5T2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uQXBwbHlPYnNlcnZlciA9IHRoaXMub25BcHBseU9ic2VydmFibGUuYWRkKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGlzIGFkZGVkIHRvIHRoZSBvbkJlZm9yZVJlbmRlck9ic2VydmFibGVcbiAgICAgKi9cbiAgICBzZXQgb25CZWZvcmVSZW5kZXIoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX29uQmVmb3JlUmVuZGVyT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub25CZWZvcmVSZW5kZXJPYnNlcnZhYmxlLnJlbW92ZSh0aGlzLl9vbkJlZm9yZVJlbmRlck9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbkJlZm9yZVJlbmRlck9ic2VydmVyID0gdGhpcy5vbkJlZm9yZVJlbmRlck9ic2VydmFibGUuYWRkKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGlzIGFkZGVkIHRvIHRoZSBvbkFmdGVyUmVuZGVyT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIHNldCBvbkFmdGVyUmVuZGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbkFmdGVyUmVuZGVyT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub25BZnRlclJlbmRlck9ic2VydmFibGUucmVtb3ZlKHRoaXMuX29uQWZ0ZXJSZW5kZXJPYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25BZnRlclJlbmRlck9ic2VydmVyID0gdGhpcy5vbkFmdGVyUmVuZGVyT2JzZXJ2YWJsZS5hZGQoY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgaW5wdXQgdGV4dHVyZSBmb3IgdGhpcyBwb3N0IHByb2Nlc3MgYW5kIHRoZSBvdXRwdXQgdGV4dHVyZSBvZiB0aGUgcHJldmlvdXMgcG9zdCBwcm9jZXNzLiBXaGVuIGFkZGVkIHRvIGEgcGlwZWxpbmUgdGhlIHByZXZpb3VzIHBvc3QgcHJvY2VzcyB3aWxsXG4gICAgICogcmVuZGVyIGl0J3Mgb3V0cHV0IGludG8gdGhpcyB0ZXh0dXJlIGFuZCB0aGlzIHRleHR1cmUgd2lsbCBiZSB1c2VkIGFzIHRleHR1cmVTYW1wbGVyIGluIHRoZSBmcmFnbWVudCBzaGFkZXIgb2YgdGhpcyBwb3N0IHByb2Nlc3MuXG4gICAgICovXG4gICAgZ2V0IGlucHV0VGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzLmRhdGFbdGhpcy5fY3VycmVudFJlbmRlclRleHR1cmVJbmRdO1xuICAgIH1cbiAgICBzZXQgaW5wdXRUZXh0dXJlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2ZvcmNlZE91dHB1dFRleHR1cmUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2luY2UgaW5wdXRUZXh0dXJlIHNob3VsZCBhbHdheXMgYmUgZGVmaW5lZCwgaWYgd2UgcHJldmlvdXNseSBtYW51YWxseSBzZXQgYGlucHV0VGV4dHVyZWAsXG4gICAgICogdGhlIG9ubHkgd2F5IHRvIHVuc2V0IGl0IGlzIHRvIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIHJlc3RvcmUgaXRzIGludGVybmFsIHN0YXRlXG4gICAgICovXG4gICAgcmVzdG9yZURlZmF1bHRJbnB1dFRleHR1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9mb3JjZWRPdXRwdXRUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZWRPdXRwdXRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubWFya1RleHR1cmVEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNhbWVyYSB3aGljaCBwb3N0IHByb2Nlc3MgaXMgYXBwbGllZCB0by5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2FtZXJhIHRoZSBwb3N0IHByb2Nlc3MgaXMgYXBwbGllZCB0by5cbiAgICAgKi9cbiAgICBnZXRDYW1lcmEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW1lcmE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRleGVsIHNpemUgb2YgdGhlIHBvc3Rwcm9jZXNzLlxuICAgICAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UZXhlbF8oZ3JhcGhpY3MpXG4gICAgICovXG4gICAgZ2V0IHRleGVsU2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NoYXJlT3V0cHV0V2l0aFBvc3RQcm9jZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hhcmVPdXRwdXRXaXRoUG9zdFByb2Nlc3MudGV4ZWxTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mb3JjZWRPdXRwdXRUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXhlbFNpemUuY29weUZyb21GbG9hdHMoMS4wIC8gdGhpcy5fZm9yY2VkT3V0cHV0VGV4dHVyZS53aWR0aCwgMS4wIC8gdGhpcy5fZm9yY2VkT3V0cHV0VGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXhlbFNpemU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBmcmFnbWVudFVybCwgcGFyYW1ldGVycywgc2FtcGxlcnMsIF9zaXplLCBjYW1lcmEsIHNhbXBsaW5nTW9kZSA9IDEsIGVuZ2luZSwgcmV1c2FibGUsIGRlZmluZXMgPSBudWxsLCB0ZXh0dXJlVHlwZSA9IDAsIHZlcnRleFVybCA9IFwicG9zdHByb2Nlc3NcIiwgaW5kZXhQYXJhbWV0ZXJzLCBibG9ja0NvbXBpbGF0aW9uID0gZmFsc2UsIHRleHR1cmVGb3JtYXQgPSA1LCBzaGFkZXJMYW5ndWFnZSwgZXh0cmFJbml0aWFsaXphdGlvbnMpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9wYXJlbnRDb250YWluZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lkdGggb2YgdGhlIHRleHR1cmUgdG8gYXBwbHkgdGhlIHBvc3QgcHJvY2VzcyBvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVpZ2h0IG9mIHRoZSB0ZXh0dXJlIHRvIGFwcGx5IHRoZSBwb3N0IHByb2Nlc3Mgb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBub2RlIG1hdGVyaWFsIHVzZWQgdG8gY3JlYXRlIHRoaXMgcG9zdHByb2Nlc3MgKG51bGwgaWYgdGhlIHBvc3Rwcm9jZXNzIHdhcyBtYW51YWxseSBjcmVhdGVkKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub2RlTWF0ZXJpYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwsIHJlZmVyZW5jZSB0byB0aGUgbG9jYXRpb24gd2hlcmUgdGhpcyBwb3N0cHJvY2VzcyB3YXMgb3V0cHV0IHRvLiAoVHlwaWNhbGx5IHRoZSB0ZXh0dXJlIG9uIHRoZSBuZXh0IHBvc3Rwcm9jZXNzIGluIHRoZSBjaGFpbilcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vdXRwdXRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBidWZmZXIgbmVlZHMgdG8gYmUgY2xlYXJlZCBiZWZvcmUgYXBwbHlpbmcgdGhlIHBvc3QgcHJvY2Vzcy4gKGRlZmF1bHQ6IHRydWUpXG4gICAgICAgICAqIFNob3VsZCBiZSBzZXQgdG8gZmFsc2UgaWYgc2hhZGVyIHdpbGwgb3ZlcndyaXRlIGFsbCBwcmV2aW91cyBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9DbGVhciA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBjbGVhcmluZyB0aGUgYnVmZmVyIHNob3VsZCBiZSBmb3JjZWQgaW4gYXV0b0NsZWFyIG1vZGUsIGV2ZW4gd2hlbiBhbHBoYSBtb2RlIGlzIGVuYWJsZWQgKGRlZmF1bHQ6IGZhbHNlKS5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGJ1ZmZlciB3aWxsIG9ubHkgYmUgY2xlYXJlZCBpZiBhbHBoYSBtb2RlIGlzIGRpc2FibGVkIChhbmQgYXV0b0NsZWFyIGlzIHRydWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JjZUF1dG9DbGVhckluQWxwaGFNb2RlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbmltYXRpb25zIHRvIGJlIHVzZWQgZm9yIHRoZSBwb3N0IHByb2Nlc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlIFBpeGVsIFBlcmZlY3QgbW9kZSB3aGVyZSB0ZXh0dXJlIGlzIG5vdCBzY2FsZWQgdG8gYmUgcG93ZXIgb2YgMi5cbiAgICAgICAgICogQ2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBwb3N0cHJvY2VzcyBvciBvbiB0aGUgbGFzdCBvbmUgb2YgYSBjaGFpbi4gKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmFibGVQaXhlbFBlcmZlY3RNb2RlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZSB0aGUgcG9zdHByb2Nlc3MgdG8gYmUgYXBwbGllZCB3aXRob3V0IHRha2luZyBpbiBhY2NvdW50IHZpZXdwb3J0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvcmNlRnVsbHNjcmVlblZpZXdwb3J0ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlIG1vZGUgZm9yIHRoZSBwb3N0IHByb2Nlc3MgKGRlZmF1bHQ6IEVuZ2luZS5TQ0FMRU1PREVfRkxPT1IpXG4gICAgICAgICAqXG4gICAgICAgICAqIHwgVmFsdWUgfCBUeXBlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uIHxcbiAgICAgICAgICogfCAtLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0gfFxuICAgICAgICAgKiB8IDEgICAgIHwgU0NBTEVNT0RFX0ZMT09SICAgICAgICAgICAgICAgICAgICAgfCBbZW5naW5lLnNjYWxlbW9kZV9mbG9vcl0oaHR0cHM6Ly9kb2MuYmFieWxvbmpzLmNvbS9hcGkvY2xhc3Nlcy9iYWJ5bG9uLmVuZ2luZSNzY2FsZW1vZGVfZmxvb3IpIHxcbiAgICAgICAgICogfCAyICAgICB8IFNDQUxFTU9ERV9ORUFSRVNUICAgICAgICAgICAgICAgICAgIHwgW2VuZ2luZS5zY2FsZW1vZGVfbmVhcmVzdF0oaHR0cHM6Ly9kb2MuYmFieWxvbmpzLmNvbS9hcGkvY2xhc3Nlcy9iYWJ5bG9uLmVuZ2luZSNzY2FsZW1vZGVfbmVhcmVzdCkgfFxuICAgICAgICAgKiB8IDMgICAgIHwgU0NBTEVNT0RFX0NFSUxJTkcgICAgICAgICAgICAgICAgICAgfCBbZW5naW5lLnNjYWxlbW9kZV9jZWlsaW5nXShodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL2FwaS9jbGFzc2VzL2JhYnlsb24uZW5naW5lI3NjYWxlbW9kZV9jZWlsaW5nKSB8XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjYWxlTW9kZSA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZSB0ZXh0dXJlcyB0byBiZSBhIHBvd2VyIG9mIHR3byAoZGVmYXVsdDogZmFsc2UpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsd2F5c0ZvcmNlUE9UID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NhbXBsZXMgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogTW9kaWZ5IHRoZSBzY2FsZSBvZiB0aGUgcG9zdCBwcm9jZXNzIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSB2aWV3cG9ydCAoZGVmYXVsdDogZmFsc2UpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFkYXB0U2NhbGVUb0N1cnJlbnRWaWV3cG9ydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl93ZWJHUFVSZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXVzYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZW5kZXJJZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiBleHRlcm5hbFRleHR1cmVTYW1wbGVyQmluZGluZyBpcyB0cnVlLCB0aGUgXCJhcHBseVwiIG1ldGhvZCB3b24ndCBiaW5kIHRoZSB0ZXh0dXJlU2FtcGxlciB0ZXh0dXJlLCBpdCBpcyBleHBlY3RlZCB0byBiZSBkb25lIGJ5IHRoZSBcIm91dHNpZGVcIiAoYnkgdGhlIG9uQXBwbHlPYnNlcnZhYmxlIG9ic2VydmVyIG1vc3QgcHJvYmFibHkpLlxuICAgICAgICAgKiBjb3VudGVyLXByb2R1Y3RpdmUgaW4gc29tZSBjYXNlcyBiZWNhdXNlIGlmIHRoZSB0ZXh0dXJlIGJvdW5kIGJ5IFwiYXBwbHlcIiBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudGx5IHRleHR1cmUgYm91bmQsICh0aGUgb25lIHNldCBieSB0aGUgb25BcHBseU9ic2VydmFibGUgb2JzZXJ2ZXIsIGZvciBlZykgc29tZVxuICAgICAgICAgKiBpbnRlcm5hbCBzdHJ1Y3R1cmVzIChtYXRlcmlhbENvbnRleHQpIHdpbGwgYmUgZGlydGlmaWVkLCB3aGljaCBtYXkgaW1wYWN0IHBlcmZvcm1hbmNlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHRlcm5hbFRleHR1cmVTYW1wbGVyQmluZGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU21hcnQgYXJyYXkgb2YgaW5wdXQgYW5kIG91dHB1dCB0ZXh0dXJlcyBmb3IgdGhlIHBvc3QgcHJvY2Vzcy5cbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IG5ldyBTbWFydEFycmF5KDIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU21hcnQgYXJyYXkgb2YgaW5wdXQgYW5kIG91dHB1dCB0ZXh0dXJlcyBmb3IgdGhlIHBvc3QgcHJvY2Vzcy5cbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90ZXh0dXJlQ2FjaGUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCBpbiBfdGV4dHVyZXMgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgb3V0cHV0IHRleHR1cmUuXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudFJlbmRlclRleHR1cmVJbmQgPSAwO1xuICAgICAgICB0aGlzLl9zY2FsZVJhdGlvID0gbmV3IFZlY3RvcjIoMSwgMSk7XG4gICAgICAgIHRoaXMuX3RleGVsU2l6ZSA9IFZlY3RvcjIuWmVybygpO1xuICAgICAgICAvLyBFdmVudHNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBwb3N0cHJvY2VzcyBpcyBhY3RpdmF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQWN0aXZhdGVPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBwb3N0cHJvY2VzcyBjaGFuZ2VzIGl0cyBzaXplLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblNpemVDaGFuZ2VkT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgcG9zdHByb2Nlc3MgYXBwbGllcyBpdHMgZWZmZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkFwcGx5T2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgYmVmb3JlIHJlbmRlcmluZyB0aGUgcG9zdHByb2Nlc3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CZWZvcmVSZW5kZXJPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRyaWdnZXJlZCBhZnRlciByZW5kZXJpbmcgdGhlIHBvc3Rwcm9jZXNzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQWZ0ZXJSZW5kZXJPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBwb3N0LXByb2Nlc3MgaXMgZGlzcG9zZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25EaXNwb3NlT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIGxldCBzaXplID0gMTtcbiAgICAgICAgbGV0IHVuaWZvcm1CdWZmZXJzID0gbnVsbDtcbiAgICAgICAgbGV0IGVmZmVjdFdyYXBwZXI7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzICYmICFBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSBvcHRpb25zLnVuaWZvcm1zID8/IG51bGw7XG4gICAgICAgICAgICBzYW1wbGVycyA9IG9wdGlvbnMuc2FtcGxlcnMgPz8gbnVsbDtcbiAgICAgICAgICAgIHNpemUgPSBvcHRpb25zLnNpemUgPz8gMTtcbiAgICAgICAgICAgIGNhbWVyYSA9IG9wdGlvbnMuY2FtZXJhID8/IG51bGw7XG4gICAgICAgICAgICBzYW1wbGluZ01vZGUgPSBvcHRpb25zLnNhbXBsaW5nTW9kZSA/PyAxO1xuICAgICAgICAgICAgZW5naW5lID0gb3B0aW9ucy5lbmdpbmU7XG4gICAgICAgICAgICByZXVzYWJsZSA9IG9wdGlvbnMucmV1c2FibGU7XG4gICAgICAgICAgICBkZWZpbmVzID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmRlZmluZXMpID8gb3B0aW9ucy5kZWZpbmVzLmpvaW4oXCJcXG5cIikgOiAob3B0aW9ucy5kZWZpbmVzID8/IG51bGwpO1xuICAgICAgICAgICAgdGV4dHVyZVR5cGUgPSBvcHRpb25zLnRleHR1cmVUeXBlID8/IDA7XG4gICAgICAgICAgICB2ZXJ0ZXhVcmwgPSBvcHRpb25zLnZlcnRleFVybCA/PyBcInBvc3Rwcm9jZXNzXCI7XG4gICAgICAgICAgICBpbmRleFBhcmFtZXRlcnMgPSBvcHRpb25zLmluZGV4UGFyYW1ldGVycztcbiAgICAgICAgICAgIGJsb2NrQ29tcGlsYXRpb24gPSBvcHRpb25zLmJsb2NrQ29tcGlsYXRpb24gPz8gZmFsc2U7XG4gICAgICAgICAgICB0ZXh0dXJlRm9ybWF0ID0gb3B0aW9ucy50ZXh0dXJlRm9ybWF0ID8/IDU7XG4gICAgICAgICAgICBzaGFkZXJMYW5ndWFnZSA9IG9wdGlvbnMuc2hhZGVyTGFuZ3VhZ2UgPz8gMCAvKiBTaGFkZXJMYW5ndWFnZS5HTFNMICovO1xuICAgICAgICAgICAgdW5pZm9ybUJ1ZmZlcnMgPSBvcHRpb25zLnVuaWZvcm1CdWZmZXJzID8/IG51bGw7XG4gICAgICAgICAgICBleHRyYUluaXRpYWxpemF0aW9ucyA9IG9wdGlvbnMuZXh0cmFJbml0aWFsaXphdGlvbnM7XG4gICAgICAgICAgICBlZmZlY3RXcmFwcGVyID0gb3B0aW9ucy5lZmZlY3RXcmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9zaXplKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF9zaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IF9zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHsgd2lkdGg6IF9zaXplLndpZHRoLCBoZWlnaHQ6IF9zaXplLmhlaWdodCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VzZUV4aXN0aW5nVGhpblBvc3RQcm9jZXNzID0gISFlZmZlY3RXcmFwcGVyO1xuICAgICAgICB0aGlzLl9lZmZlY3RXcmFwcGVyID1cbiAgICAgICAgICAgIGVmZmVjdFdyYXBwZXIgPz9cbiAgICAgICAgICAgICAgICBuZXcgRWZmZWN0V3JhcHBlcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHVzZVNoYWRlclN0b3JlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1c2VBc1Bvc3RQcm9jZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnRVcmwsXG4gICAgICAgICAgICAgICAgICAgIGVuZ2luZTogZW5naW5lIHx8IGNhbWVyYT8uZ2V0U2NlbmUoKS5nZXRFbmdpbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXM6IHBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXJzLFxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtQnVmZmVycyxcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lcyxcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4VXJsLFxuICAgICAgICAgICAgICAgICAgICBpbmRleFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ29tcGlsYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNoYWRlckxhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICBleHRyYUluaXRpYWxpemF0aW9uczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm9uRWZmZWN0Q3JlYXRlZE9ic2VydmFibGUgPSB0aGlzLl9lZmZlY3RXcmFwcGVyLm9uRWZmZWN0Q3JlYXRlZE9ic2VydmFibGU7XG4gICAgICAgIGlmIChjYW1lcmEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xuICAgICAgICAgICAgdGhpcy5fc2NlbmUgPSBjYW1lcmEuZ2V0U2NlbmUoKTtcbiAgICAgICAgICAgIGNhbWVyYS5hdHRhY2hQb3N0UHJvY2Vzcyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2NlbmUucG9zdFByb2Nlc3Nlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51bmlxdWVJZCA9IHRoaXMuX3NjZW5lLmdldFVuaXF1ZUlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5naW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUucG9zdFByb2Nlc3Nlcy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBzaXplO1xuICAgICAgICB0aGlzLnJlbmRlclRhcmdldFNhbXBsaW5nTW9kZSA9IHNhbXBsaW5nTW9kZSA/IHNhbXBsaW5nTW9kZSA6IDE7XG4gICAgICAgIHRoaXMuX3JldXNhYmxlID0gcmV1c2FibGUgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuX3RleHR1cmVUeXBlID0gdGV4dHVyZVR5cGU7XG4gICAgICAgIHRoaXMuX3RleHR1cmVGb3JtYXQgPSB0ZXh0dXJlRm9ybWF0O1xuICAgICAgICB0aGlzLl9zaGFkZXJMYW5ndWFnZSA9IHNoYWRlckxhbmd1YWdlIHx8IDAgLyogU2hhZGVyTGFuZ3VhZ2UuR0xTTCAqLztcbiAgICAgICAgdGhpcy5fc2FtcGxlcnMgPSBzYW1wbGVycyB8fCBbXTtcbiAgICAgICAgaWYgKHRoaXMuX3NhbXBsZXJzLmluZGV4T2YoXCJ0ZXh0dXJlU2FtcGxlclwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhbXBsZXJzLnB1c2goXCJ0ZXh0dXJlU2FtcGxlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mcmFnbWVudFVybCA9IGZyYWdtZW50VXJsO1xuICAgICAgICB0aGlzLl92ZXJ0ZXhVcmwgPSB2ZXJ0ZXhVcmw7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IFtdO1xuICAgICAgICBpZiAodGhpcy5fcGFyYW1ldGVycy5pbmRleE9mKFwic2NhbGVcIikgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbWV0ZXJzLnB1c2goXCJzY2FsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91bmlmb3JtQnVmZmVycyA9IHVuaWZvcm1CdWZmZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9pbmRleFBhcmFtZXRlcnMgPSBpbmRleFBhcmFtZXRlcnM7XG4gICAgICAgIGlmICghdGhpcy5fdXNlRXhpc3RpbmdUaGluUG9zdFByb2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlYkdQVVJlYWR5ID0gdGhpcy5fc2hhZGVyTGFuZ3VhZ2UgPT09IDEgLyogU2hhZGVyTGFuZ3VhZ2UuV0dTTCAqLztcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydFByb21pc2VzID0gW107XG4gICAgICAgICAgICB0aGlzLl9nYXRoZXJJbXBvcnRzKHRoaXMuX2VuZ2luZS5pc1dlYkdQVSAmJiAhUG9zdFByb2Nlc3MuRm9yY2VHTFNMLCBpbXBvcnRQcm9taXNlcyk7XG4gICAgICAgICAgICB0aGlzLl9lZmZlY3RXcmFwcGVyLl93ZWJHUFVSZWFkeSA9IHRoaXMuX3dlYkdQVVJlYWR5O1xuICAgICAgICAgICAgdGhpcy5fZWZmZWN0V3JhcHBlci5fcG9zdENvbnN0cnVjdG9yKGJsb2NrQ29tcGlsYXRpb24sIGRlZmluZXMsIGV4dHJhSW5pdGlhbGl6YXRpb25zLCBpbXBvcnRQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dhdGhlckltcG9ydHModXNlV2ViR1BVID0gZmFsc2UsIGxpc3QpIHtcbiAgICAgICAgLy8gdGhpcy5fd2ViR1BVUmVhZHkgaXMgdXNlZCB0byBkZXRlY3Qgd2hlbiBhIHBvc3Rwcm9jZXNzIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aCBXZWJHUFVcbiAgICAgICAgaWYgKHVzZVdlYkdQVSAmJiB0aGlzLl93ZWJHUFVSZWFkeSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKFByb21pc2UuYWxsKFtpbXBvcnQoXCIuLi9TaGFkZXJzV0dTTC9wb3N0cHJvY2Vzcy52ZXJ0ZXguanNcIildKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goUHJvbWlzZS5hbGwoW2ltcG9ydChcIi4uL1NoYWRlcnMvcG9zdHByb2Nlc3MudmVydGV4LmpzXCIpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgICogQHJldHVybnMgXCJQb3N0UHJvY2Vzc1wiIHN0cmluZ1xuICAgICAqL1xuICAgIGdldENsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUG9zdFByb2Nlc3NcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZW5naW5lIHdoaWNoIHRoaXMgcG9zdCBwcm9jZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHJldHVybnMgVGhlIGVuZ2luZSB0aGUgcG9zdCBwcm9jZXNzIHdhcyBlbmFibGVkIHdpdGguXG4gICAgICovXG4gICAgZ2V0RW5naW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5naW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZWZmZWN0IHRoYXQgaXMgY3JlYXRlZCB3aGVuIGluaXRpYWxpemluZyB0aGUgcG9zdCBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGVmZmVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwb3N0cHJvY2Vzcy5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lZmZlY3RXcmFwcGVyLmRyYXdXcmFwcGVyLmVmZmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYXZvaWQgbXVsdGlwbGUgcmVkdW5kYW50IHRleHR1cmVzIGZvciBtdWx0aXBsZSBwb3N0IHByb2Nlc3MsIHRoZSBvdXRwdXQgdGhlIG91dHB1dCB0ZXh0dXJlIGZvciB0aGlzIHBvc3QgcHJvY2VzcyBjYW4gYmUgc2hhcmVkIHdpdGggYW5vdGhlci5cbiAgICAgKiBAcGFyYW0gcG9zdFByb2Nlc3MgVGhlIHBvc3QgcHJvY2VzcyB0byBzaGFyZSB0aGUgb3V0cHV0IHdpdGguXG4gICAgICogQHJldHVybnMgVGhpcyBwb3N0IHByb2Nlc3MuXG4gICAgICovXG4gICAgc2hhcmVPdXRwdXRXaXRoKHBvc3RQcm9jZXNzKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VUZXh0dXJlcygpO1xuICAgICAgICB0aGlzLl9zaGFyZU91dHB1dFdpdGhQb3N0UHJvY2VzcyA9IHBvc3RQcm9jZXNzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGVmZmVjdCBvZiBjYWxsaW5nIHNoYXJlT3V0cHV0V2l0aCBhbmQgcmV0dXJucyB0aGUgcG9zdCBwcm9jZXNzIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHN0YXRlLlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpZiB0aGUgcG9zdCBwcm9jZXNzIHRoYXQgc2hhcmVzIG91dHB1dCB3aXRoIHRoaXMgcG9zdCBwcm9jZXNzIGlzIGRpc2FibGVkL2Rpc3Bvc2VkLlxuICAgICAqL1xuICAgIHVzZU93bk91dHB1dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IG5ldyBTbWFydEFycmF5KDIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NoYXJlT3V0cHV0V2l0aFBvc3RQcm9jZXNzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZWZmZWN0IHdpdGggdGhlIGN1cnJlbnQgcG9zdCBwcm9jZXNzIGNvbXBpbGUgdGltZSB2YWx1ZXMgYW5kIHJlY29tcGlsZXMgdGhlIHNoYWRlci5cbiAgICAgKiBAcGFyYW0gZGVmaW5lcyBEZWZpbmUgc3RhdGVtZW50cyB0aGF0IHNob3VsZCBiZSBhZGRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzaGFkZXIuIChkZWZhdWx0OiBudWxsKVxuICAgICAqIEBwYXJhbSB1bmlmb3JtcyBTZXQgb2YgdW5pZm9ybSB2YXJpYWJsZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgc2hhZGVyLiAoZGVmYXVsdDogbnVsbClcbiAgICAgKiBAcGFyYW0gc2FtcGxlcnMgU2V0IG9mIFRleHR1cmUyRCB2YXJpYWJsZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgc2hhZGVyLiAoZGVmYXVsdDogbnVsbClcbiAgICAgKiBAcGFyYW0gaW5kZXhQYXJhbWV0ZXJzIFRoZSBpbmRleCBwYXJhbWV0ZXJzIHRvIGJlIHVzZWQgZm9yIGJhYnlsb25zIGluY2x1ZGUgc3ludGF4IFwiI2luY2x1ZGU8a2VybmVsQmx1clZhcnlpbmdEZWNsYXJhdGlvbj5bMC4udmFyeWluZ0NvdW50XVwiLiAoZGVmYXVsdDogdW5kZWZpbmVkKSBTZWUgdXNhZ2UgaW4gYmFieWxvbi5ibHVyUG9zdFByb2Nlc3MudHMgYW5kIGtlcm5lbEJsdXIudmVydGV4LmZ4XG4gICAgICogQHBhcmFtIG9uQ29tcGlsZWQgQ2FsbGVkIHdoZW4gdGhlIHNoYWRlciBoYXMgYmVlbiBjb21waWxlZC5cbiAgICAgKiBAcGFyYW0gb25FcnJvciBDYWxsZWQgaWYgdGhlcmUgaXMgYW4gZXJyb3Igd2hlbiBjb21waWxpbmcgYSBzaGFkZXIuXG4gICAgICogQHBhcmFtIHZlcnRleFVybCBUaGUgdXJsIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyIHRvIGJlIHVzZWQgKGRlZmF1bHQ6IHRoZSBvbmUgZ2l2ZW4gYXQgY29uc3RydWN0aW9uIHRpbWUpXG4gICAgICogQHBhcmFtIGZyYWdtZW50VXJsIFRoZSB1cmwgb2YgdGhlIGZyYWdtZW50IHNoYWRlciB0byBiZSB1c2VkIChkZWZhdWx0OiB0aGUgb25lIGdpdmVuIGF0IGNvbnN0cnVjdGlvbiB0aW1lKVxuICAgICAqL1xuICAgIHVwZGF0ZUVmZmVjdChkZWZpbmVzID0gbnVsbCwgdW5pZm9ybXMgPSBudWxsLCBzYW1wbGVycyA9IG51bGwsIGluZGV4UGFyYW1ldGVycywgb25Db21waWxlZCwgb25FcnJvciwgdmVydGV4VXJsLCBmcmFnbWVudFVybCkge1xuICAgICAgICB0aGlzLl9lZmZlY3RXcmFwcGVyLnVwZGF0ZUVmZmVjdChkZWZpbmVzLCB1bmlmb3Jtcywgc2FtcGxlcnMsIGluZGV4UGFyYW1ldGVycywgb25Db21waWxlZCwgb25FcnJvciwgdmVydGV4VXJsLCBmcmFnbWVudFVybCk7XG4gICAgICAgIHRoaXMuX3Bvc3RQcm9jZXNzRGVmaW5lcyA9IEFycmF5LmlzQXJyYXkodGhpcy5fZWZmZWN0V3JhcHBlci5vcHRpb25zLmRlZmluZXMpID8gdGhpcy5fZWZmZWN0V3JhcHBlci5vcHRpb25zLmRlZmluZXMuam9pbihcIlxcblwiKSA6IHRoaXMuX2VmZmVjdFdyYXBwZXIub3B0aW9ucy5kZWZpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zdCBwcm9jZXNzIGlzIHJldXNhYmxlIGlmIGl0IGNhbiBiZSB1c2VkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiBvbmUgZnJhbWUuXG4gICAgICogQHJldHVybnMgSWYgdGhlIHBvc3QgcHJvY2VzcyBpcyByZXVzYWJsZVxuICAgICAqL1xuICAgIGlzUmV1c2FibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXVzYWJsZTtcbiAgICB9XG4gICAgLyoqIGludmFsaWRhdGUgZnJhbWVCdWZmZXIgdG8gaGludCB0aGUgcG9zdHByb2Nlc3MgdG8gY3JlYXRlIGEgZGVwdGggYnVmZmVyICovXG4gICAgbWFya1RleHR1cmVEaXJ0eSgpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IC0xO1xuICAgIH1cbiAgICBfY3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZSh0ZXh0dXJlU2l6ZSwgdGV4dHVyZU9wdGlvbnMsIGNoYW5uZWwgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGV4dHVyZUNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZUNhY2hlW2ldLnRleHR1cmUud2lkdGggPT09IHRleHR1cmVTaXplLndpZHRoICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZUNhY2hlW2ldLnRleHR1cmUuaGVpZ2h0ID09PSB0ZXh0dXJlU2l6ZS5oZWlnaHQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlQ2FjaGVbaV0ucG9zdFByb2Nlc3NDaGFubmVsID09PSBjaGFubmVsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZUNhY2hlW2ldLnRleHR1cmUuX2dlbmVyYXRlRGVwdGhCdWZmZXIgPT09IHRleHR1cmVPcHRpb25zLmdlbmVyYXRlRGVwdGhCdWZmZXIgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlQ2FjaGVbaV0udGV4dHVyZS5zYW1wbGVzID09PSB0ZXh0dXJlT3B0aW9ucy5zYW1wbGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVDYWNoZVtpXS50ZXh0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleCA9IHRoaXMuX2VuZ2luZS5jcmVhdGVSZW5kZXJUYXJnZXRUZXh0dXJlKHRleHR1cmVTaXplLCB0ZXh0dXJlT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3RleHR1cmVDYWNoZS5wdXNoKHsgdGV4dHVyZTogdGV4LCBwb3N0UHJvY2Vzc0NoYW5uZWw6IGNoYW5uZWwsIGxhc3RVc2VkUmVuZGVySWQ6IC0xIH0pO1xuICAgICAgICByZXR1cm4gdGV4O1xuICAgIH1cbiAgICBfZmx1c2hUZXh0dXJlQ2FjaGUoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZW5kZXJJZCA9IHRoaXMuX3JlbmRlcklkO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fdGV4dHVyZUNhY2hlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFJlbmRlcklkIC0gdGhpcy5fdGV4dHVyZUNhY2hlW2ldLmxhc3RVc2VkUmVuZGVySWQgPiAxMDApIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudGx5VXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fdGV4dHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmVzLmRhdGFbal0gPT09IHRoaXMuX3RleHR1cmVDYWNoZVtpXS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudGx5VXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlQ2FjaGVbaV0udGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmVDYWNoZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIHBvc3QtcHJvY2VzcyB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHdpZHRoIFdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGhlaWdodCBIZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gY2FtZXJhIFRoZSBjYW1lcmEgdGhpcyBwb3N0LXByb2Nlc3MgaXMgYXBwbGllZCB0by4gUGFzcyBudWxsIGlmIHRoZSBwb3N0LXByb2Nlc3MgaXMgdXNlZCBvdXRzaWRlIHRoZSBjb250ZXh0IG9mIGEgY2FtZXJhIHBvc3QtcHJvY2VzcyBjaGFpbiAoZGVmYXVsdDogbnVsbClcbiAgICAgKiBAcGFyYW0gbmVlZE1pcE1hcHMgVHJ1ZSBpZiBtaXAgbWFwcyBuZWVkIHRvIGJlIGdlbmVyYXRlZCBhZnRlciByZW5kZXIgKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAqIEBwYXJhbSBmb3JjZURlcHRoU3RlbmNpbCBUcnVlIHRvIGZvcmNlIHBvc3QtcHJvY2VzcyB0ZXh0dXJlIGNyZWF0aW9uIHdpdGggc3RlbmNpbCBkZXB0aCBhbmQgYnVmZmVyIChkZWZhdWx0OiBmYWxzZSlcbiAgICAgKi9cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCwgY2FtZXJhID0gbnVsbCwgbmVlZE1pcE1hcHMgPSBmYWxzZSwgZm9yY2VEZXB0aFN0ZW5jaWwgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBsZXQgZmlyc3RQUCA9IG51bGw7XG4gICAgICAgIGlmIChjYW1lcmEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FtZXJhLl9wb3N0UHJvY2Vzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbWVyYS5fcG9zdFByb2Nlc3Nlc1tpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFBQID0gY2FtZXJhLl9wb3N0UHJvY2Vzc2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dHVyZVNpemUgPSB7IHdpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IH07XG4gICAgICAgIGNvbnN0IHRleHR1cmVPcHRpb25zID0ge1xuICAgICAgICAgICAgZ2VuZXJhdGVNaXBNYXBzOiBuZWVkTWlwTWFwcyxcbiAgICAgICAgICAgIGdlbmVyYXRlRGVwdGhCdWZmZXI6IGZvcmNlRGVwdGhTdGVuY2lsIHx8IGZpcnN0UFAgPT09IHRoaXMsXG4gICAgICAgICAgICBnZW5lcmF0ZVN0ZW5jaWxCdWZmZXI6IChmb3JjZURlcHRoU3RlbmNpbCB8fCBmaXJzdFBQID09PSB0aGlzKSAmJiB0aGlzLl9lbmdpbmUuaXNTdGVuY2lsRW5hYmxlLFxuICAgICAgICAgICAgc2FtcGxpbmdNb2RlOiB0aGlzLnJlbmRlclRhcmdldFNhbXBsaW5nTW9kZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX3RleHR1cmVUeXBlLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl90ZXh0dXJlRm9ybWF0LFxuICAgICAgICAgICAgc2FtcGxlczogdGhpcy5fc2FtcGxlcyxcbiAgICAgICAgICAgIGxhYmVsOiBcIlBvc3RQcm9jZXNzUlRULVwiICsgdGhpcy5uYW1lLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl90ZXh0dXJlcy5wdXNoKHRoaXMuX2NyZWF0ZVJlbmRlclRhcmdldFRleHR1cmUodGV4dHVyZVNpemUsIHRleHR1cmVPcHRpb25zLCAwKSk7XG4gICAgICAgIGlmICh0aGlzLl9yZXVzYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXMucHVzaCh0aGlzLl9jcmVhdGVSZW5kZXJUYXJnZXRUZXh0dXJlKHRleHR1cmVTaXplLCB0ZXh0dXJlT3B0aW9ucywgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RleGVsU2l6ZS5jb3B5RnJvbUZsb2F0cygxLjAgLyB0aGlzLndpZHRoLCAxLjAgLyB0aGlzLmhlaWdodCk7XG4gICAgICAgIHRoaXMub25TaXplQ2hhbmdlZE9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xuICAgIH1cbiAgICBfZ2V0VGFyZ2V0KCkge1xuICAgICAgICBsZXQgdGFyZ2V0O1xuICAgICAgICBpZiAodGhpcy5fc2hhcmVPdXRwdXRXaXRoUG9zdFByb2Nlc3MpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuX3NoYXJlT3V0cHV0V2l0aFBvc3RQcm9jZXNzLmlucHV0VGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9mb3JjZWRPdXRwdXRUZXh0dXJlKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9mb3JjZWRPdXRwdXRUZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2ZvcmNlZE91dHB1dFRleHR1cmUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2ZvcmNlZE91dHB1dFRleHR1cmUuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5pbnB1dFRleHR1cmU7XG4gICAgICAgICAgICBsZXQgY2FjaGU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RleHR1cmVDYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0dXJlQ2FjaGVbaV0udGV4dHVyZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0gdGhpcy5fdGV4dHVyZUNhY2hlW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5sYXN0VXNlZFJlbmRlcklkID0gdGhpcy5fcmVuZGVySWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBwb3N0IHByb2Nlc3MgYnkgaW50aWFsaXppbmcgdGhlIHRleHR1cmVzIHRvIGJlIHVzZWQgd2hlbiBleGVjdXRlZC4gTm90aWZpZXMgb25BY3RpdmF0ZU9ic2VydmFibGUuXG4gICAgICogV2hlbiB0aGlzIHBvc3QgcHJvY2VzcyBpcyB1c2VkIGluIGEgcGlwZWxpbmUsIHRoaXMgaXMgY2FsbCB3aWxsIGJpbmQgdGhlIGlucHV0IHRleHR1cmUgb2YgdGhpcyBwb3N0IHByb2Nlc3MgdG8gdGhlIG91dHB1dCBvZiB0aGUgcHJldmlvdXMuXG4gICAgICogQHBhcmFtIGNhbWVyYU9yU2NlbmUgVGhlIGNhbWVyYSB0aGF0IHdpbGwgYmUgdXNlZCBpbiB0aGUgcG9zdCBwcm9jZXNzLiBUaGlzIGNhbWVyYSB3aWxsIGJlIHVzZWQgd2hlbiBjYWxsaW5nIG9uQWN0aXZhdGVPYnNlcnZhYmxlLiBZb3UgY2FuIGFsc28gcGFzcyB0aGUgc2NlbmUgaWYgbm8gY2FtZXJhIGlzIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0gc291cmNlVGV4dHVyZSBUaGUgc291cmNlIHRleHR1cmUgdG8gYmUgaW5zcGVjdGVkIHRvIGdldCB0aGUgd2lkdGggYW5kIGhlaWdodCBpZiBub3Qgc3BlY2lmaWVkIGluIHRoZSBwb3N0IHByb2Nlc3MgY29uc3RydWN0b3IuIChkZWZhdWx0OiBudWxsKVxuICAgICAqIEBwYXJhbSBmb3JjZURlcHRoU3RlbmNpbCBJZiB0cnVlLCBhIGRlcHRoIGFuZCBzdGVuY2lsIGJ1ZmZlciB3aWxsIGJlIGdlbmVyYXRlZC4gKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAqIEByZXR1cm5zIFRoZSByZW5kZXIgdGFyZ2V0IHdyYXBwZXIgdGhhdCB3YXMgYm91bmQgdG8gYmUgd3JpdHRlbiB0by5cbiAgICAgKi9cbiAgICBhY3RpdmF0ZShjYW1lcmFPclNjZW5lLCBzb3VyY2VUZXh0dXJlID0gbnVsbCwgZm9yY2VEZXB0aFN0ZW5jaWwpIHtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gY2FtZXJhT3JTY2VuZSA9PT0gbnVsbCB8fCBjYW1lcmFPclNjZW5lLmNhbWVyYVJpZ01vZGUgIT09IHVuZGVmaW5lZCA/IGNhbWVyYU9yU2NlbmUgfHwgdGhpcy5fY2FtZXJhIDogbnVsbDtcbiAgICAgICAgY29uc3Qgc2NlbmUgPSBjYW1lcmE/LmdldFNjZW5lKCkgPz8gY2FtZXJhT3JTY2VuZTtcbiAgICAgICAgY29uc3QgZW5naW5lID0gc2NlbmUuZ2V0RW5naW5lKCk7XG4gICAgICAgIGNvbnN0IG1heFNpemUgPSBlbmdpbmUuZ2V0Q2FwcygpLm1heFRleHR1cmVTaXplO1xuICAgICAgICBjb25zdCByZXF1aXJlZFdpZHRoID0gKChzb3VyY2VUZXh0dXJlID8gc291cmNlVGV4dHVyZS53aWR0aCA6IHRoaXMuX2VuZ2luZS5nZXRSZW5kZXJXaWR0aCh0cnVlKSkgKiB0aGlzLl9vcHRpb25zKSB8IDA7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkSGVpZ2h0ID0gKChzb3VyY2VUZXh0dXJlID8gc291cmNlVGV4dHVyZS5oZWlnaHQgOiB0aGlzLl9lbmdpbmUuZ2V0UmVuZGVySGVpZ2h0KHRydWUpKSAqIHRoaXMuX29wdGlvbnMpIHwgMDtcbiAgICAgICAgbGV0IGRlc2lyZWRXaWR0aCA9IHRoaXMuX29wdGlvbnMud2lkdGggfHwgcmVxdWlyZWRXaWR0aDtcbiAgICAgICAgbGV0IGRlc2lyZWRIZWlnaHQgPSB0aGlzLl9vcHRpb25zLmhlaWdodCB8fCByZXF1aXJlZEhlaWdodDtcbiAgICAgICAgY29uc3QgbmVlZE1pcE1hcHMgPSB0aGlzLnJlbmRlclRhcmdldFNhbXBsaW5nTW9kZSAhPT0gNyAmJlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXRTYW1wbGluZ01vZGUgIT09IDEgJiZcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0U2FtcGxpbmdNb2RlICE9PSAyO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLl9zaGFyZU91dHB1dFdpdGhQb3N0UHJvY2VzcyAmJiAhdGhpcy5fZm9yY2VkT3V0cHV0VGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRhcHRTY2FsZVRvQ3VycmVudFZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZpZXdwb3J0ID0gZW5naW5lLmN1cnJlbnRWaWV3cG9ydDtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2lyZWRXaWR0aCAqPSBjdXJyZW50Vmlld3BvcnQud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGRlc2lyZWRIZWlnaHQgKj0gY3VycmVudFZpZXdwb3J0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmVlZE1pcE1hcHMgfHwgdGhpcy5hbHdheXNGb3JjZVBPVCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNpcmVkV2lkdGggPSBlbmdpbmUubmVlZFBPVFRleHR1cmVzID8gR2V0RXhwb25lbnRPZlR3byhkZXNpcmVkV2lkdGgsIG1heFNpemUsIHRoaXMuc2NhbGVNb2RlKSA6IGRlc2lyZWRXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNpcmVkSGVpZ2h0ID0gZW5naW5lLm5lZWRQT1RUZXh0dXJlcyA/IEdldEV4cG9uZW50T2ZUd28oZGVzaXJlZEhlaWdodCwgbWF4U2l6ZSwgdGhpcy5zY2FsZU1vZGUpIDogZGVzaXJlZEhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCAhPT0gZGVzaXJlZFdpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSBkZXNpcmVkSGVpZ2h0IHx8ICEodGFyZ2V0ID0gdGhpcy5fZ2V0VGFyZ2V0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoZGVzaXJlZFdpZHRoLCBkZXNpcmVkSGVpZ2h0LCBjYW1lcmEsIG5lZWRNaXBNYXBzLCBmb3JjZURlcHRoU3RlbmNpbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlcy5mb3JFYWNoKCh0ZXh0dXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmUuc2FtcGxlcyAhPT0gdGhpcy5zYW1wbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS51cGRhdGVSZW5kZXJUYXJnZXRUZXh0dXJlU2FtcGxlQ291bnQodGV4dHVyZSwgdGhpcy5zYW1wbGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2ZsdXNoVGV4dHVyZUNhY2hlKCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJJZCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9nZXRUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCaW5kIHRoZSBpbnB1dCBvZiB0aGlzIHBvc3QgcHJvY2VzcyB0byBiZSB1c2VkIGFzIHRoZSBvdXRwdXQgb2YgdGhlIHByZXZpb3VzIHBvc3QgcHJvY2Vzcy5cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUGl4ZWxQZXJmZWN0TW9kZSkge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVSYXRpby5jb3B5RnJvbUZsb2F0cyhyZXF1aXJlZFdpZHRoIC8gZGVzaXJlZFdpZHRoLCByZXF1aXJlZEhlaWdodCAvIGRlc2lyZWRIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lLmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIDAsIHJlcXVpcmVkV2lkdGgsIHJlcXVpcmVkSGVpZ2h0LCB0aGlzLmZvcmNlRnVsbHNjcmVlblZpZXdwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlUmF0aW8uY29weUZyb21GbG9hdHMoMSwgMSk7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUuYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgMCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMuZm9yY2VGdWxsc2NyZWVuVmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VuZ2luZS5fZGVidWdJbnNlcnRNYXJrZXI/LihgcG9zdCBwcm9jZXNzICR7dGhpcy5uYW1lfSBpbnB1dGApO1xuICAgICAgICB0aGlzLm9uQWN0aXZhdGVPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhjYW1lcmEpO1xuICAgICAgICAvLyBDbGVhclxuICAgICAgICBpZiAodGhpcy5hdXRvQ2xlYXIgJiYgKHRoaXMuYWxwaGFNb2RlID09PSAwIHx8IHRoaXMuZm9yY2VBdXRvQ2xlYXJJbkFscGhhTW9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5jbGVhcih0aGlzLmNsZWFyQ29sb3IgPyB0aGlzLmNsZWFyQ29sb3IgOiBzY2VuZS5jbGVhckNvbG9yLCBzY2VuZS5fYWxsb3dQb3N0UHJvY2Vzc0NsZWFyQ29sb3IsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZXVzYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJlbmRlclRleHR1cmVJbmQgPSAodGhpcy5fY3VycmVudFJlbmRlclRleHR1cmVJbmQgKyAxKSAlIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHBvc3QgcHJvY2VzcyBpcyBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgZ2V0IGlzU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWZmZWN0V3JhcHBlci5kcmF3V3JhcHBlci5lZmZlY3QuaXNTdXBwb3J0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIG91dHB1dCB0ZXh0dXJlLlxuICAgICAqL1xuICAgIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NoYXJlT3V0cHV0V2l0aFBvc3RQcm9jZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hhcmVPdXRwdXRXaXRoUG9zdFByb2Nlc3MuYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZvcmNlZE91dHB1dFRleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JjZWRPdXRwdXRUZXh0dXJlLndpZHRoIC8gdGhpcy5fZm9yY2VkT3V0cHV0VGV4dHVyZS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgcG9zdC1wcm9jZXNzIGlzIHJlYWR5IHRvIGJlIHVzZWRcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwb3N0LXByb2Nlc3MgaXMgcmVhZHkgKHNoYWRlciBpcyBjb21waWxlZClcbiAgICAgKi9cbiAgICBpc1JlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWZmZWN0V3JhcHBlci5pc1JlYWR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIGFsbCB0ZXh0dXJlcyBhbmQgdW5pZm9ybXMgdG8gdGhlIHNoYWRlciwgdGhpcyB3aWxsIGJlIHJ1biBvbiBldmVyeSBwYXNzLlxuICAgICAqIEByZXR1cm5zIHRoZSBlZmZlY3QgY29ycmVzcG9uZGluZyB0byB0aGlzIHBvc3QgcHJvY2Vzcy4gTnVsbCBpZiBub3QgY29tcGlsZWQgb3Igbm90IHJlYWR5LlxuICAgICAqL1xuICAgIGFwcGx5KCkge1xuICAgICAgICAvLyBDaGVja1xuICAgICAgICBpZiAoIXRoaXMuX2VmZmVjdFdyYXBwZXIuaXNSZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGF0ZXNcbiAgICAgICAgdGhpcy5fZW5naW5lLmVuYWJsZUVmZmVjdCh0aGlzLl9lZmZlY3RXcmFwcGVyLmRyYXdXcmFwcGVyKTtcbiAgICAgICAgdGhpcy5fZW5naW5lLnNldFN0YXRlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZW5naW5lLnNldERlcHRoQnVmZmVyKGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZW5naW5lLnNldERlcHRoV3JpdGUoZmFsc2UpO1xuICAgICAgICAvLyBBbHBoYVxuICAgICAgICBpZiAodGhpcy5hbHBoYUNvbnN0YW50cykge1xuICAgICAgICAgICAgdGhpcy5nZXRFbmdpbmUoKS5zZXRBbHBoYUNvbnN0YW50cyh0aGlzLmFscGhhQ29uc3RhbnRzLnIsIHRoaXMuYWxwaGFDb25zdGFudHMuZywgdGhpcy5hbHBoYUNvbnN0YW50cy5iLCB0aGlzLmFscGhhQ29uc3RhbnRzLmEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VuZ2luZS5zZXRBbHBoYU1vZGUodGhpcy5hbHBoYU1vZGUpO1xuICAgICAgICAvLyBCaW5kIHRoZSBvdXRwdXQgdGV4dHVyZSBvZiB0aGUgcHJlaXZvdXMgcG9zdCBwcm9jZXNzIGFzIHRoZSBpbnB1dCB0byB0aGlzIHBvc3QgcHJvY2Vzcy5cbiAgICAgICAgbGV0IHNvdXJjZTtcbiAgICAgICAgaWYgKHRoaXMuX3NoYXJlT3V0cHV0V2l0aFBvc3RQcm9jZXNzKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zaGFyZU91dHB1dFdpdGhQb3N0UHJvY2Vzcy5pbnB1dFRleHR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZm9yY2VkT3V0cHV0VGV4dHVyZSkge1xuICAgICAgICAgICAgc291cmNlID0gdGhpcy5fZm9yY2VkT3V0cHV0VGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMuaW5wdXRUZXh0dXJlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5leHRlcm5hbFRleHR1cmVTYW1wbGVyQmluZGluZykge1xuICAgICAgICAgICAgdGhpcy5fZWZmZWN0V3JhcHBlci5kcmF3V3JhcHBlci5lZmZlY3QuX2JpbmRUZXh0dXJlKFwidGV4dHVyZVNhbXBsZXJcIiwgc291cmNlPy50ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAgIHRoaXMuX2VmZmVjdFdyYXBwZXIuZHJhd1dyYXBwZXIuZWZmZWN0LnNldFZlY3RvcjIoXCJzY2FsZVwiLCB0aGlzLl9zY2FsZVJhdGlvKTtcbiAgICAgICAgdGhpcy5vbkFwcGx5T2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnModGhpcy5fZWZmZWN0V3JhcHBlci5kcmF3V3JhcHBlci5lZmZlY3QpO1xuICAgICAgICB0aGlzLl9lZmZlY3RXcmFwcGVyLmJpbmQodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lZmZlY3RXcmFwcGVyLmRyYXdXcmFwcGVyLmVmZmVjdDtcbiAgICB9XG4gICAgX2Rpc3Bvc2VUZXh0dXJlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NoYXJlT3V0cHV0V2l0aFBvc3RQcm9jZXNzIHx8IHRoaXMuX2ZvcmNlZE91dHB1dFRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VUZXh0dXJlQ2FjaGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNwb3NlVGV4dHVyZUNhY2hlKCk7XG4gICAgICAgIHRoaXMuX3RleHR1cmVzLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgX2Rpc3Bvc2VUZXh0dXJlQ2FjaGUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl90ZXh0dXJlQ2FjaGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVDYWNoZVtpXS50ZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXh0dXJlQ2FjaGUubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmVxdWlyZWQgdmFsdWVzIHRvIHRoZSBwcmVwYXNzIHJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSBwcmVQYXNzUmVuZGVyZXIgZGVmaW5lcyB0aGUgcHJlcGFzcyByZW5kZXJlciB0byBzZXR1cC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcmUgcGFzcyBpcyBuZWVkZWQuXG4gICAgICovXG4gICAgc2V0UHJlUGFzc1JlbmRlcmVyKHByZVBhc3NSZW5kZXJlcikge1xuICAgICAgICBpZiAodGhpcy5fcHJlUGFzc0VmZmVjdENvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZVBhc3NFZmZlY3RDb25maWd1cmF0aW9uID0gcHJlUGFzc1JlbmRlcmVyLmFkZEVmZmVjdENvbmZpZ3VyYXRpb24odGhpcy5fcHJlUGFzc0VmZmVjdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fcHJlUGFzc0VmZmVjdENvbmZpZ3VyYXRpb24uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIHRoZSBwb3N0IHByb2Nlc3MuXG4gICAgICogQHBhcmFtIGNhbWVyYSBUaGUgY2FtZXJhIHRvIGRpc3Bvc2UgdGhlIHBvc3QgcHJvY2VzcyBvbi5cbiAgICAgKi9cbiAgICBkaXNwb3NlKGNhbWVyYSkge1xuICAgICAgICBjYW1lcmEgPSBjYW1lcmEgfHwgdGhpcy5fY2FtZXJhO1xuICAgICAgICBpZiAoIXRoaXMuX3VzZUV4aXN0aW5nVGhpblBvc3RQcm9jZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9lZmZlY3RXcmFwcGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNwb3NlVGV4dHVyZXMoKTtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBpZiAodGhpcy5fc2NlbmUpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5fc2NlbmUucG9zdFByb2Nlc3Nlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjZW5lLnBvc3RQcm9jZXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyZW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3BhcmVudENvbnRhaW5lci5wb3N0UHJvY2Vzc2VzLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudENvbnRhaW5lci5wb3N0UHJvY2Vzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRDb250YWluZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gdGhpcy5fZW5naW5lLnBvc3RQcm9jZXNzZXMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnBvc3RQcm9jZXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRGlzcG9zZU9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKCk7XG4gICAgICAgIGlmICghY2FtZXJhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FtZXJhLmRldGFjaFBvc3RQcm9jZXNzKHRoaXMpO1xuICAgICAgICBpbmRleCA9IGNhbWVyYS5fcG9zdFByb2Nlc3Nlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgY2FtZXJhLl9wb3N0UHJvY2Vzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UG9zdFByb2Nlc3MgPSB0aGlzLl9jYW1lcmEuX2dldEZpcnN0UG9zdFByb2Nlc3MoKTtcbiAgICAgICAgICAgIGlmIChmaXJzdFBvc3RQcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RQb3N0UHJvY2Vzcy5tYXJrVGV4dHVyZURpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkFjdGl2YXRlT2JzZXJ2YWJsZS5jbGVhcigpO1xuICAgICAgICB0aGlzLm9uQWZ0ZXJSZW5kZXJPYnNlcnZhYmxlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMub25BcHBseU9ic2VydmFibGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5vbkJlZm9yZVJlbmRlck9ic2VydmFibGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5vblNpemVDaGFuZ2VkT2JzZXJ2YWJsZS5jbGVhcigpO1xuICAgICAgICB0aGlzLm9uRWZmZWN0Q3JlYXRlZE9ic2VydmFibGUuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgcG9zdCBwcm9jZXNzIHRvIGEgSlNPTiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB0aGUgSlNPTiBvYmplY3RcbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6YXRpb25PYmplY3QgPSBTZXJpYWxpemF0aW9uSGVscGVyLlNlcmlhbGl6ZSh0aGlzKTtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5nZXRDYW1lcmEoKSB8fCAodGhpcy5fc2NlbmUgJiYgdGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhKTtcbiAgICAgICAgc2VyaWFsaXphdGlvbk9iamVjdC5jdXN0b21UeXBlID0gXCJCQUJZTE9OLlwiICsgdGhpcy5nZXRDbGFzc05hbWUoKTtcbiAgICAgICAgc2VyaWFsaXphdGlvbk9iamVjdC5jYW1lcmFJZCA9IGNhbWVyYSA/IGNhbWVyYS5pZCA6IG51bGw7XG4gICAgICAgIHNlcmlhbGl6YXRpb25PYmplY3QucmV1c2FibGUgPSB0aGlzLl9yZXVzYWJsZTtcbiAgICAgICAgc2VyaWFsaXphdGlvbk9iamVjdC50ZXh0dXJlVHlwZSA9IHRoaXMuX3RleHR1cmVUeXBlO1xuICAgICAgICBzZXJpYWxpemF0aW9uT2JqZWN0LmZyYWdtZW50VXJsID0gdGhpcy5fZnJhZ21lbnRVcmw7XG4gICAgICAgIHNlcmlhbGl6YXRpb25PYmplY3QucGFyYW1ldGVycyA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gICAgICAgIHNlcmlhbGl6YXRpb25PYmplY3Quc2FtcGxlcnMgPSB0aGlzLl9zYW1wbGVycztcbiAgICAgICAgc2VyaWFsaXphdGlvbk9iamVjdC51bmlmb3JtQnVmZmVycyA9IHRoaXMuX3VuaWZvcm1CdWZmZXJzO1xuICAgICAgICBzZXJpYWxpemF0aW9uT2JqZWN0Lm9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICBzZXJpYWxpemF0aW9uT2JqZWN0LmRlZmluZXMgPSB0aGlzLl9wb3N0UHJvY2Vzc0RlZmluZXM7XG4gICAgICAgIHNlcmlhbGl6YXRpb25PYmplY3QudGV4dHVyZUZvcm1hdCA9IHRoaXMuX3RleHR1cmVGb3JtYXQ7XG4gICAgICAgIHNlcmlhbGl6YXRpb25PYmplY3QudmVydGV4VXJsID0gdGhpcy5fdmVydGV4VXJsO1xuICAgICAgICBzZXJpYWxpemF0aW9uT2JqZWN0LmluZGV4UGFyYW1ldGVycyA9IHRoaXMuX2luZGV4UGFyYW1ldGVycztcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb25PYmplY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGlzIHBvc3QgcHJvY2Vzc1xuICAgICAqIEByZXR1cm5zIGEgbmV3IHBvc3QgcHJvY2VzcyBzaW1pbGFyIHRvIHRoaXMgb25lXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6YXRpb25PYmplY3QgPSB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICBzZXJpYWxpemF0aW9uT2JqZWN0Ll9lbmdpbmUgPSB0aGlzLl9lbmdpbmU7XG4gICAgICAgIHNlcmlhbGl6YXRpb25PYmplY3QuY2FtZXJhSWQgPSBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBQb3N0UHJvY2Vzcy5QYXJzZShzZXJpYWxpemF0aW9uT2JqZWN0LCB0aGlzLl9zY2VuZSwgXCJcIik7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQub25BY3RpdmF0ZU9ic2VydmFibGUgPSB0aGlzLm9uQWN0aXZhdGVPYnNlcnZhYmxlLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5vblNpemVDaGFuZ2VkT2JzZXJ2YWJsZSA9IHRoaXMub25TaXplQ2hhbmdlZE9ic2VydmFibGUuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Lm9uQXBwbHlPYnNlcnZhYmxlID0gdGhpcy5vbkFwcGx5T2JzZXJ2YWJsZS5jbG9uZSgpO1xuICAgICAgICByZXN1bHQub25CZWZvcmVSZW5kZXJPYnNlcnZhYmxlID0gdGhpcy5vbkJlZm9yZVJlbmRlck9ic2VydmFibGUuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Lm9uQWZ0ZXJSZW5kZXJPYnNlcnZhYmxlID0gdGhpcy5vbkFmdGVyUmVuZGVyT2JzZXJ2YWJsZS5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX3ByZVBhc3NFZmZlY3RDb25maWd1cmF0aW9uID0gdGhpcy5fcHJlUGFzc0VmZmVjdENvbmZpZ3VyYXRpb247XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXRlcmlhbCBmcm9tIHBhcnNlZCBtYXRlcmlhbCBkYXRhXG4gICAgICogQHBhcmFtIHBhcnNlZFBvc3RQcm9jZXNzIGRlZmluZXMgcGFyc2VkIHBvc3QgcHJvY2VzcyBkYXRhXG4gICAgICogQHBhcmFtIHNjZW5lIGRlZmluZXMgdGhlIGhvc3Rpbmcgc2NlbmVcbiAgICAgKiBAcGFyYW0gcm9vdFVybCBkZWZpbmVzIHRoZSByb290IFVSTCB0byB1c2UgdG8gbG9hZCB0ZXh0dXJlc1xuICAgICAqIEByZXR1cm5zIGEgbmV3IHBvc3QgcHJvY2Vzc1xuICAgICAqL1xuICAgIHN0YXRpYyBQYXJzZShwYXJzZWRQb3N0UHJvY2Vzcywgc2NlbmUsIHJvb3RVcmwpIHtcbiAgICAgICAgY29uc3QgcG9zdFByb2Nlc3NUeXBlID0gR2V0Q2xhc3MocGFyc2VkUG9zdFByb2Nlc3MuY3VzdG9tVHlwZSk7XG4gICAgICAgIGlmICghcG9zdFByb2Nlc3NUeXBlIHx8ICFwb3N0UHJvY2Vzc1R5cGUuX1BhcnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW1lcmEgPSBzY2VuZSA/IHNjZW5lLmdldENhbWVyYUJ5SWQocGFyc2VkUG9zdFByb2Nlc3MuY2FtZXJhSWQpIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHBvc3RQcm9jZXNzVHlwZS5fUGFyc2UocGFyc2VkUG9zdFByb2Nlc3MsIGNhbWVyYSwgc2NlbmUsIHJvb3RVcmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgX1BhcnNlKHBhcnNlZFBvc3RQcm9jZXNzLCB0YXJnZXRDYW1lcmEsIHNjZW5lLCByb290VXJsKSB7XG4gICAgICAgIHJldHVybiBTZXJpYWxpemF0aW9uSGVscGVyLlBhcnNlKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zdFByb2Nlc3MocGFyc2VkUG9zdFByb2Nlc3MubmFtZSwgcGFyc2VkUG9zdFByb2Nlc3MuZnJhZ21lbnRVcmwsIHBhcnNlZFBvc3RQcm9jZXNzLnBhcmFtZXRlcnMsIHBhcnNlZFBvc3RQcm9jZXNzLnNhbXBsZXJzLCBwYXJzZWRQb3N0UHJvY2Vzcy5vcHRpb25zLCB0YXJnZXRDYW1lcmEsIHBhcnNlZFBvc3RQcm9jZXNzLnJlbmRlclRhcmdldFNhbXBsaW5nTW9kZSwgcGFyc2VkUG9zdFByb2Nlc3MuX2VuZ2luZSwgcGFyc2VkUG9zdFByb2Nlc3MucmV1c2FibGUsIHBhcnNlZFBvc3RQcm9jZXNzLmRlZmluZXMsIHBhcnNlZFBvc3RQcm9jZXNzLnRleHR1cmVUeXBlLCBwYXJzZWRQb3N0UHJvY2Vzcy52ZXJ0ZXhVcmwsIHBhcnNlZFBvc3RQcm9jZXNzLmluZGV4UGFyYW1ldGVycywgZmFsc2UsIHBhcnNlZFBvc3RQcm9jZXNzLnRleHR1cmVGb3JtYXQpO1xuICAgICAgICB9LCBwYXJzZWRQb3N0UHJvY2Vzcywgc2NlbmUsIHJvb3RVcmwpO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBQb3N0UHJvY2Vzcy5wcm90b3R5cGUsIFwidW5pcXVlSWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBQb3N0UHJvY2Vzcy5wcm90b3R5cGUsIFwibmFtZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBQb3N0UHJvY2Vzcy5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBQb3N0UHJvY2Vzcy5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgUG9zdFByb2Nlc3MucHJvdG90eXBlLCBcInJlbmRlclRhcmdldFNhbXBsaW5nTW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplQXNDb2xvcjQoKVxuXSwgUG9zdFByb2Nlc3MucHJvdG90eXBlLCBcImNsZWFyQ29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBQb3N0UHJvY2Vzcy5wcm90b3R5cGUsIFwiYXV0b0NsZWFyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgUG9zdFByb2Nlc3MucHJvdG90eXBlLCBcImZvcmNlQXV0b0NsZWFySW5BbHBoYU1vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBQb3N0UHJvY2Vzcy5wcm90b3R5cGUsIFwiYWxwaGFNb2RlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIFBvc3RQcm9jZXNzLnByb3RvdHlwZSwgXCJhbHBoYUNvbnN0YW50c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIFBvc3RQcm9jZXNzLnByb3RvdHlwZSwgXCJlbmFibGVQaXhlbFBlcmZlY3RNb2RlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgUG9zdFByb2Nlc3MucHJvdG90eXBlLCBcImZvcmNlRnVsbHNjcmVlblZpZXdwb3J0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgUG9zdFByb2Nlc3MucHJvdG90eXBlLCBcInNjYWxlTW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIFBvc3RQcm9jZXNzLnByb3RvdHlwZSwgXCJhbHdheXNGb3JjZVBPVFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKFwic2FtcGxlc1wiKVxuXSwgUG9zdFByb2Nlc3MucHJvdG90eXBlLCBcIl9zYW1wbGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgUG9zdFByb2Nlc3MucHJvdG90eXBlLCBcImFkYXB0U2NhbGVUb0N1cnJlbnRWaWV3cG9ydFwiLCB2b2lkIDApO1xuUmVnaXN0ZXJDbGFzcyhcIkJBQllMT04uUG9zdFByb2Nlc3NcIiwgUG9zdFByb2Nlc3MpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9zdFByb2Nlc3MuanMubWFwIiwiaW1wb3J0IHsgRWZmZWN0V3JhcHBlciB9IGZyb20gXCIuLi9NYXRlcmlhbHMvZWZmZWN0UmVuZGVyZXIuanNcIjtcbmltcG9ydCB7IEVuZ2luZSB9IGZyb20gXCIuLi9FbmdpbmVzL2VuZ2luZS5qc1wiO1xuLyoqXG4gKiBQYXNzUG9zdFByb2Nlc3Mgd2hpY2ggcHJvZHVjZXMgYW4gb3V0cHV0IHRoZSBzYW1lIGFzIGl0J3MgaW5wdXRcbiAqL1xuZXhwb3J0IGNsYXNzIFRoaW5QYXNzUG9zdFByb2Nlc3MgZXh0ZW5kcyBFZmZlY3RXcmFwcGVyIHtcbiAgICBfZ2F0aGVySW1wb3J0cyh1c2VXZWJHUFUsIGxpc3QpIHtcbiAgICAgICAgaWYgKHVzZVdlYkdQVSkge1xuICAgICAgICAgICAgdGhpcy5fd2ViR1BVUmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgbGlzdC5wdXNoKFByb21pc2UuYWxsKFtpbXBvcnQoXCIuLi9TaGFkZXJzV0dTTC9wYXNzLmZyYWdtZW50LmpzXCIpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5wdXNoKFByb21pc2UuYWxsKFtpbXBvcnQoXCIuLi9TaGFkZXJzL3Bhc3MuZnJhZ21lbnQuanNcIildKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX2dhdGhlckltcG9ydHModXNlV2ViR1BVLCBsaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBwYXNzIHBvc3QgcHJvY2Vzc1xuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGVmZmVjdFxuICAgICAqIEBwYXJhbSBlbmdpbmUgRW5naW5lIHRvIHVzZSB0byByZW5kZXIgdGhlIGVmZmVjdC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgbGFzdCBjcmVhdGVkIGVuZ2luZSB3aWxsIGJlIHVzZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgZWZmZWN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgZW5naW5lID0gbnVsbCwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGVuZ2luZTogZW5naW5lIHx8IEVuZ2luZS5MYXN0Q3JlYXRlZEVuZ2luZSxcbiAgICAgICAgICAgIHVzZVNoYWRlclN0b3JlOiB0cnVlLFxuICAgICAgICAgICAgdXNlQXNQb3N0UHJvY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBUaGluUGFzc1Bvc3RQcm9jZXNzLkZyYWdtZW50VXJsLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBmcmFnbWVudCBzaGFkZXIgdXJsXG4gKi9cblRoaW5QYXNzUG9zdFByb2Nlc3MuRnJhZ21lbnRVcmwgPSBcInBhc3NcIjtcbi8qKlxuICogUGFzc0N1YmVQb3N0UHJvY2VzcyB3aGljaCBwcm9kdWNlcyBhbiBvdXRwdXQgdGhlIHNhbWUgYXMgaXQncyBpbnB1dCAod2hpY2ggbXVzdCBiZSBhIGN1YmUgdGV4dHVyZSlcbiAqL1xuZXhwb3J0IGNsYXNzIFRoaW5QYXNzQ3ViZVBvc3RQcm9jZXNzIGV4dGVuZHMgRWZmZWN0V3JhcHBlciB7XG4gICAgX2dhdGhlckltcG9ydHModXNlV2ViR1BVLCBsaXN0KSB7XG4gICAgICAgIGlmICh1c2VXZWJHUFUpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlYkdQVVJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpc3QucHVzaChQcm9taXNlLmFsbChbaW1wb3J0KFwiLi4vU2hhZGVyc1dHU0wvcGFzc0N1YmUuZnJhZ21lbnQuanNcIildKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goUHJvbWlzZS5hbGwoW2ltcG9ydChcIi4uL1NoYWRlcnMvcGFzc0N1YmUuZnJhZ21lbnQuanNcIildKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX2dhdGhlckltcG9ydHModXNlV2ViR1BVLCBsaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgUGFzc0N1YmVQb3N0UHJvY2Vzc1xuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGVmZmVjdFxuICAgICAqIEBwYXJhbSBlbmdpbmUgRW5naW5lIHRvIHVzZSB0byByZW5kZXIgdGhlIGVmZmVjdC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgbGFzdCBjcmVhdGVkIGVuZ2luZSB3aWxsIGJlIHVzZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgZWZmZWN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgZW5naW5lID0gbnVsbCwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGVuZ2luZTogZW5naW5lIHx8IEVuZ2luZS5MYXN0Q3JlYXRlZEVuZ2luZSxcbiAgICAgICAgICAgIHVzZVNoYWRlclN0b3JlOiB0cnVlLFxuICAgICAgICAgICAgdXNlQXNQb3N0UHJvY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBUaGluUGFzc0N1YmVQb3N0UHJvY2Vzcy5GcmFnbWVudFVybCxcbiAgICAgICAgICAgIGRlZmluZXM6IFwiI2RlZmluZSBQT1NJVElWRVhcIixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ZhY2UgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1YmUgZmFjZSB0byBkaXNwbGF5LlxuICAgICAqICAqIDAgaXMgK1hcbiAgICAgKiAgKiAxIGlzIC1YXG4gICAgICogICogMiBpcyArWVxuICAgICAqICAqIDMgaXMgLVlcbiAgICAgKiAgKiA0IGlzICtaXG4gICAgICogICogNSBpcyAtWlxuICAgICAqL1xuICAgIGdldCBmYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFjZTtcbiAgICB9XG4gICAgc2V0IGZhY2UodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mYWNlID0gdmFsdWU7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fZmFjZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWZmZWN0KFwiI2RlZmluZSBQT1NJVElWRVhcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFZmZlY3QoXCIjZGVmaW5lIE5FR0FUSVZFWFwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVmZmVjdChcIiNkZWZpbmUgUE9TSVRJVkVZXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWZmZWN0KFwiI2RlZmluZSBORUdBVElWRVlcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFZmZlY3QoXCIjZGVmaW5lIFBPU0lUSVZFWlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVmZmVjdChcIiNkZWZpbmUgTkVHQVRJVkVaXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHVybFxuICovXG5UaGluUGFzc0N1YmVQb3N0UHJvY2Vzcy5GcmFnbWVudFVybCA9IFwicGFzc0N1YmVcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRoaW5QYXNzUG9zdFByb2Nlc3MuanMubWFwIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCIuLi9NaXNjL29ic2VydmFibGUuanNcIjtcbmltcG9ydCB7IFJlbmRlcmluZ01hbmFnZXIgfSBmcm9tIFwiLi4vUmVuZGVyaW5nL3JlbmRlcmluZ01hbmFnZXIuanNcIjtcblxuaW1wb3J0IHsgX09ic2VydmVBcnJheSB9IGZyb20gXCIuLi9NaXNjL2FycmF5VG9vbHMuanNcIjtcbi8qKlxuICogQSBjbGFzcyB0aGF0IHJlbmRlcnMgb2JqZWN0cyB0byB0aGUgY3VycmVudGx5IGJvdW5kIHJlbmRlciB0YXJnZXQuXG4gKiBUaGlzIGNsYXNzIG9ubHkgcmVuZGVycyBvYmplY3RzLCBhbmQgaXMgbm90IGNvbmNlcm5lZCB3aXRoIHRoZSBvdXRwdXQgdGV4dHVyZSBvciBwb3N0LXByb2Nlc3NpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBPYmplY3RSZW5kZXJlciB7XG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbGlzdCB0byBkZWZpbmUgdGhlIGxpc3Qgb2YgbWVzaCB5b3Ugd2FudCB0byByZW5kZXIuXG4gICAgICovXG4gICAgZ2V0IHJlbmRlckxpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJMaXN0O1xuICAgIH1cbiAgICBzZXQgcmVuZGVyTGlzdCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyTGlzdCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdW5PYnNlcnZlUmVuZGVyTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5fdW5PYnNlcnZlUmVuZGVyTGlzdCgpO1xuICAgICAgICAgICAgdGhpcy5fdW5PYnNlcnZlUmVuZGVyTGlzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl91bk9ic2VydmVSZW5kZXJMaXN0ID0gX09ic2VydmVBcnJheSh2YWx1ZSwgdGhpcy5fcmVuZGVyTGlzdEhhc0NoYW5nZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlckxpc3QgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIG9iamVjdCByZW5kZXJlciB3aWxsIHJlbmRlciBhbGwgb2JqZWN0cyB3aXRob3V0IGFueSBpbWFnZSBwcm9jZXNzaW5nIGFwcGxpZWQuXG4gICAgICogSWYgZmFsc2UgKGRlZmF1bHQgdmFsdWUpLCB0aGUgcmVuZGVyZXIgd2lsbCB1c2UgdGhlIGN1cnJlbnQgc2V0dGluZyBvZiB0aGUgc2NlbmUncyBpbWFnZSBwcm9jZXNzaW5nIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVJbWFnZVByb2Nlc3NpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlSW1hZ2VQcm9jZXNzaW5nO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZUltYWdlUHJvY2Vzc2luZyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHRoaXMuX2Rpc2FibGVJbWFnZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNhYmxlSW1hZ2VQcm9jZXNzaW5nID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3NjZW5lLm1hcmtBbGxNYXRlcmlhbHNBc0RpcnR5KDY0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnJpZW5kbHkgbmFtZSBvZiB0aGUgb2JqZWN0IHJlbmRlcmVyXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICBzZXQgbmFtZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fbmFtZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gICAgICAgIGlmICghdGhpcy5fc2NlbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9yZW5kZXJQYXNzSWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJQYXNzSWQgPSB0aGlzLl9yZW5kZXJQYXNzSWRzW2ldO1xuICAgICAgICAgICAgZW5naW5lLl9yZW5kZXJQYXNzTmFtZXNbcmVuZGVyUGFzc0lkXSA9IGAke3RoaXMuX25hbWV9IyR7aX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlbmRlciBwYXNzIGlkcyB1c2VkIGJ5IHRoZSBvYmplY3QgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZ2V0IHJlbmRlclBhc3NJZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQYXNzSWRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSByZWZyZXNoSWQgY291bnRlclxuICAgICAqL1xuICAgIGdldCBjdXJyZW50UmVmcmVzaElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFJlZnJlc2hJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHNwZWNpZmljIG1hdGVyaWFsIHRvIGJlIHVzZWQgdG8gcmVuZGVyIGEgbWVzaC9hIGxpc3Qgb2YgbWVzaGVzIHdpdGggdGhpcyBvYmplY3QgcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gbWVzaCBtZXNoIG9yIGFycmF5IG9mIG1lc2hlc1xuICAgICAqIEBwYXJhbSBtYXRlcmlhbCBtYXRlcmlhbCBvciBhcnJheSBvZiBtYXRlcmlhbHMgdG8gdXNlIGZvciB0aGlzIHJlbmRlciBwYXNzLiBJZiB1bmRlZmluZWQgaXMgcGFzc2VkLCBubyBzcGVjaWZpYyBtYXRlcmlhbCB3aWxsIGJlIHVzZWQgYnV0IHRoZSByZWd1bGFyIG1hdGVyaWFsIGluc3RlYWQgKG1lc2gubWF0ZXJpYWwpLiBJdCdzIHBvc3NpYmxlIHRvIHByb3ZpZGUgYW4gYXJyYXkgb2YgbWF0ZXJpYWxzIHRvIHVzZSBhIGRpZmZlcmVudCBtYXRlcmlhbCBmb3IgZWFjaCByZW5kZXJpbmcgcGFzcy5cbiAgICAgKi9cbiAgICBzZXRNYXRlcmlhbEZvclJlbmRlcmluZyhtZXNoLCBtYXRlcmlhbCkge1xuICAgICAgICBsZXQgbWVzaGVzO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzaCkpIHtcbiAgICAgICAgICAgIG1lc2hlcyA9IFttZXNoXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc2hlcyA9IG1lc2g7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtZXNoZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLm51bVBhc3NlczsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lc2ggPSBtZXNoZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKG1lc2hlc1tqXS5pc0FuSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzaCA9IG1lc2hlc1tqXS5zb3VyY2VNZXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXNoLnNldE1hdGVyaWFsRm9yUmVuZGVyUGFzcyh0aGlzLl9yZW5kZXJQYXNzSWRzW2ldLCBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpID8gbWF0ZXJpYWxbaV0gOiBtYXRlcmlhbCkgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBvYmplY3QgcmVuZGVyZXIuXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIGZyaWVuZGx5IG5hbWUgb2YgdGhlIG9iamVjdCByZW5kZXJlclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgc2NlbmUgdGhlIHJlbmRlcmVyIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGUgcmVuZGVyZXIgKG9wdGlvbmFsKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNjZW5lLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3VuT2JzZXJ2ZVJlbmRlckxpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW5kZXJMaXN0SGFzQ2hhbmdlZCA9IChfZnVuY3Rpb25OYW1lLCBwcmV2aW91c0xlbmd0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gdGhpcy5fcmVuZGVyTGlzdCA/IHRoaXMuX3JlbmRlckxpc3QubGVuZ3RoIDogMDtcbiAgICAgICAgICAgIGlmICgocHJldmlvdXNMZW5ndGggPT09IDAgJiYgbmV3TGVuZ3RoID4gMCkgfHwgbmV3TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZXNoIG9mIHRoaXMuX3NjZW5lLm1lc2hlcykge1xuICAgICAgICAgICAgICAgICAgICBtZXNoLl9tYXJrU3ViTWVzaGVzQXNMaWdodERpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIHRoZSBsaXN0IG9mIHBhcnRpY2xlIHN5c3RlbXMgdG8gcmVuZGVyLiBJZiBub3QgcHJvdmlkZWQsIHdpbGwgcmVuZGVyIGFsbCB0aGUgcGFydGljbGUgc3lzdGVtcyBvZiB0aGUgc2NlbmUuXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgcGFydGljbGUgc3lzdGVtcyBhcmUgcmVuZGVyZWQgb25seSBpZiByZW5kZXJQYXJ0aWNsZXMgaXMgc2V0IHRvIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtTGlzdCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgdGhpcyBmdW5jdGlvbiB0byBvdmVybG9hZCB0aGUgcmVuZGVyTGlzdCBhcnJheSBhdCByZW5kZXJpbmcgdGltZS5cbiAgICAgICAgICogUmV0dXJuIG51bGwgdG8gcmVuZGVyIHdpdGggdGhlIGN1cnJlbnQgcmVuZGVyTGlzdCwgZWxzZSByZXR1cm4gdGhlIGxpc3Qgb2YgbWVzaGVzIHRvIHVzZSBmb3IgcmVuZGVyaW5nLlxuICAgICAgICAgKiBGb3IgMkRBcnJheSwgbGF5ZXJPckZhY2UgaXMgdGhlIGluZGV4IG9mIHRoZSBsYXllciB0aGF0IGlzIGdvaW5nIHRvIGJlIHJlbmRlcmVkLCBlbHNlIGl0IGlzIHRoZSBmYWNlSW5kZXggb2ZcbiAgICAgICAgICogdGhlIGN1YmUgKGlmIHRoZSBSVFQgaXMgYSBjdWJlLCBlbHNlIGxheWVyT3JGYWNlPTApLlxuICAgICAgICAgKiBUaGUgcmVuZGVyTGlzdCBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGlzIHRoZSBjdXJyZW50IHJlbmRlciBsaXN0ICh0aGUgb25lIHRoYXQgd2lsbCBiZSB1c2VkIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5zIG51bGwpLlxuICAgICAgICAgKiBUaGUgbGVuZ3RoIG9mIHRoaXMgbGlzdCBpcyBwYXNzZWQgdGhyb3VnaCByZW5kZXJMaXN0TGVuZ3RoOiBkb24ndCB1c2UgcmVuZGVyTGlzdC5sZW5ndGggZGlyZWN0bHkgYmVjYXVzZSB0aGUgYXJyYXkgY2FuXG4gICAgICAgICAqIGhvbGQgZHVtbXkgZWxlbWVudHMhXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEN1c3RvbVJlbmRlckxpc3QgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIGlmIHBhcnRpY2xlcyBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlclBhcnRpY2xlcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgaWYgc3ByaXRlcyBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlclNwcml0ZXMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcmNlIGNoZWNraW5nIHRoZSBsYXllck1hc2sgcHJvcGVydHkgZXZlbiBpZiBhIGN1c3RvbSBsaXN0IG9mIG1lc2hlcyBpcyBwcm92aWRlZCAoaWUuIGlmIHJlbmRlckxpc3QgaXMgbm90IHVuZGVmaW5lZClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm9yY2VMYXllck1hc2tDaGVjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXNhYmxlSW1hZ2VQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgYmVmb3JlIHJlbmRlcmluZyB0aGUgb2JqZWN0c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJlZm9yZVJlbmRlck9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgdHJpZ2dlcmVkIGFmdGVyIHJlbmRlcmluZyB0aGUgb2JqZWN0c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkFmdGVyUmVuZGVyT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgYmVmb3JlIHRoZSByZW5kZXJpbmcgZ3JvdXAgaXMgcHJvY2Vzc2VkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmVmb3JlUmVuZGVyaW5nTWFuYWdlclJlbmRlck9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgdHJpZ2dlcmVkIGFmdGVyIHRoZSByZW5kZXJpbmcgZ3JvdXAgaXMgcHJvY2Vzc2VkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQWZ0ZXJSZW5kZXJpbmdNYW5hZ2VyUmVuZGVyT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBmYXN0IHBhdGggcmVuZGVyaW5nIGlzIHVzZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25GYXN0UGF0aFJlbmRlck9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50UmVmcmVzaElkID0gLTE7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hSYXRlID0gMTtcbiAgICAgICAgdGhpcy5fY3VycmVudEFwcGx5QnlQb3N0UHJvY2Vzc1NldHRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFNjZW5lQ2FtZXJhID0gbnVsbDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5yZW5kZXJMaXN0ID0gW107XG4gICAgICAgIHRoaXMuX3JlbmRlclBhc3NJZHMgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgbnVtUGFzc2VzOiAxLFxuICAgICAgICAgICAgZG9Ob3RDaGFuZ2VBc3BlY3RSYXRpbzogdHJ1ZSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NyZWF0ZVJlbmRlclBhc3NJZCgpO1xuICAgICAgICB0aGlzLnJlbmRlclBhc3NJZCA9IHRoaXMuX3JlbmRlclBhc3NJZHNbMF07XG4gICAgICAgIC8vIFJlbmRlcmluZyBncm91cHNcbiAgICAgICAgdGhpcy5fcmVuZGVyaW5nTWFuYWdlciA9IG5ldyBSZW5kZXJpbmdNYW5hZ2VyKHNjZW5lKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyaW5nTWFuYWdlci5fdXNlU2NlbmVBdXRvQ2xlYXJTZXR1cCA9IHRydWU7XG4gICAgfVxuICAgIF9yZWxlYXNlUmVuZGVyUGFzc0lkKCkge1xuICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMubnVtUGFzc2VzOyArK2kpIHtcbiAgICAgICAgICAgIGVuZ2luZS5yZWxlYXNlUmVuZGVyUGFzc0lkKHRoaXMuX3JlbmRlclBhc3NJZHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlclBhc3NJZHMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgX2NyZWF0ZVJlbmRlclBhc3NJZCgpIHtcbiAgICAgICAgdGhpcy5fcmVsZWFzZVJlbmRlclBhc3NJZCgpO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMubnVtUGFzc2VzOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclBhc3NJZHNbaV0gPSBlbmdpbmUuY3JlYXRlUmVuZGVyUGFzc0lkKGAke3RoaXMubmFtZX0jJHtpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgcmVmcmVzaCBjb3VudGVyIG9mIHRoZSByZW5kZXJlciBhbmQgc3RhcnQgYmFjayBmcm9tIHNjcmF0Y2guXG4gICAgICogQ291bGQgYmUgdXNlZnVsIHRvIHJlLXJlbmRlciBpZiBpdCBpcyBzZXR1cCB0byByZW5kZXIgb25seSBvbmNlLlxuICAgICAqL1xuICAgIHJlc2V0UmVmcmVzaENvdW50ZXIoKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRSZWZyZXNoSWQgPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgcmVmcmVzaCByYXRlIG9mIHRoZSByZW5kZXJpbmcgb3IgdGhlIHJlbmRlcmluZyBmcmVxdWVuY3kuXG4gICAgICogVXNlIDAgdG8gcmVuZGVyIGp1c3Qgb25jZSwgMSB0byByZW5kZXIgb24gZXZlcnkgZnJhbWUsIDIgdG8gcmVuZGVyIGV2ZXJ5IHR3byBmcmFtZXMgYW5kIHNvIG9uLi4uXG4gICAgICovXG4gICAgZ2V0IHJlZnJlc2hSYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmcmVzaFJhdGU7XG4gICAgfVxuICAgIHNldCByZWZyZXNoUmF0ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZWZyZXNoUmF0ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnJlc2V0UmVmcmVzaENvdW50ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSByZW5kZXJlciBzaG91bGQgcmVuZGVyIHRoZSBjdXJyZW50IGZyYW1lLlxuICAgICAqIFRoZSBvdXRwdXQgaXMgYmFzZWQgb24gdGhlIHNwZWNpZmllZCByZWZyZXNoIHJhdGUuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVuZGVyZXIgc2hvdWxkIHJlbmRlciB0aGUgY3VycmVudCBmcmFtZVxuICAgICAqL1xuICAgIHNob3VsZFJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRSZWZyZXNoSWQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBBdCBsZWFzdCByZW5kZXIgb25jZVxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJlZnJlc2hJZCA9IDE7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWZyZXNoUmF0ZSA9PT0gdGhpcy5fY3VycmVudFJlZnJlc2hJZCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJlZnJlc2hJZCA9IDE7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50UmVmcmVzaElkKys7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGNoZWNrIGlmIHRoZSByZW5kZXJlciBpcyByZWFkeSB0byByZW5kZXIgKHRleHR1cmVzIGFyZSBsb2FkZWQsIHNoYWRlcnMgYXJlIGNvbXBpbGVkKVxuICAgICAqIEBwYXJhbSB2aWV3cG9ydFdpZHRoIGRlZmluZXMgdGhlIHdpZHRoIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB2aWV3cG9ydEhlaWdodCBkZWZpbmVzIHRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBhbGwgcmVxdWlyZWQgcmVzb3VyY2VzIGFyZSByZWFkeVxuICAgICAqL1xuICAgIGlzUmVhZHlGb3JSZW5kZXJpbmcodmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlUmVuZGVyTGlzdCgpO1xuICAgICAgICB0aGlzLmluaXRSZW5kZXIodmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQpO1xuICAgICAgICBjb25zdCBpc1JlYWR5ID0gdGhpcy5fY2hlY2tSZWFkaW5lc3MoKTtcbiAgICAgICAgdGhpcy5maW5pc2hSZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIGlzUmVhZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHN1cmUgdGhlIGxpc3Qgb2YgbWVzaGVzIGlzIHJlYWR5IHRvIGJlIHJlbmRlcmVkXG4gICAgICogWW91IHNob3VsZCBjYWxsIHRoaXMgZnVuY3Rpb24gYmVmb3JlIFwiaW5pdFJlbmRlclwiLCBidXQgaWYgeW91IGtub3cgdGhlIHJlbmRlciBsaXN0IGlzIG9rLCB5b3UgbWF5IGNhbGwgXCJpbml0UmVuZGVyXCIgZGlyZWN0bHlcbiAgICAgKi9cbiAgICBwcmVwYXJlUmVuZGVyTGlzdCgpIHtcbiAgICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzLl9zY2VuZTtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmdSZW5kZXJMaXN0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVuZGVyTGlzdFByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl93YWl0aW5nUmVuZGVyTGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLl93YWl0aW5nUmVuZGVyTGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBzY2VuZS5nZXRNZXNoQnlJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxpc3QucHVzaChtZXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3dhaXRpbmdSZW5kZXJMaXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIElzIHByZWRpY2F0ZSBkZWZpbmVkP1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJMaXN0UHJlZGljYXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMaXN0Lmxlbmd0aCA9IDA7IC8vIENsZWFyIHByZXZpb3VzIHJlbmRlckxpc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGlzdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NlbmVNZXNoZXMgPSB0aGlzLl9zY2VuZS5tZXNoZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc2NlbmVNZXNoZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzaCA9IHNjZW5lTWVzaGVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJMaXN0UHJlZGljYXRlKG1lc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGlzdC5wdXNoKG1lc2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50QXBwbHlCeVBvc3RQcm9jZXNzU2V0dGluZyA9IHRoaXMuX3NjZW5lLmltYWdlUHJvY2Vzc2luZ0NvbmZpZ3VyYXRpb24uYXBwbHlCeVBvc3RQcm9jZXNzO1xuICAgICAgICBpZiAodGhpcy5fZGlzYWJsZUltYWdlUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHVzZSB0aGUgYXBwbHlCeVBvc3RQcm9jZXNzIHNldHRlciB0byBhdm9pZCBmbGFnZ2luZyBhbGwgdGhlIG1hdGVyaWFscyBhcyBcImltYWdlIHByb2Nlc3NpbmcgZGlydHlcIiFcbiAgICAgICAgICAgIHRoaXMuX3NjZW5lLmltYWdlUHJvY2Vzc2luZ0NvbmZpZ3VyYXRpb24uX2FwcGx5QnlQb3N0UHJvY2VzcyA9IHRoaXMuX2Rpc2FibGVJbWFnZVByb2Nlc3Npbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgbWFrZXMgc3VyZSBldmVyeXRoaW5nIGlzIHNldHVwIGJlZm9yZSBcInJlbmRlclwiIGNhbiBiZSBjYWxsZWRcbiAgICAgKiBAcGFyYW0gdmlld3BvcnRXaWR0aCBXaWR0aCBvZiB0aGUgdmlld3BvcnQgdG8gcmVuZGVyIHRvXG4gICAgICogQHBhcmFtIHZpZXdwb3J0SGVpZ2h0IEhlaWdodCBvZiB0aGUgdmlld3BvcnQgdG8gcmVuZGVyIHRvXG4gICAgICovXG4gICAgaW5pdFJlbmRlcih2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCkge1xuICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKTtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5hY3RpdmVDYW1lcmEgPz8gdGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhO1xuICAgICAgICB0aGlzLl9jdXJyZW50U2NlbmVDYW1lcmEgPSB0aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmE7XG4gICAgICAgIGlmIChjYW1lcmEpIHtcbiAgICAgICAgICAgIGlmIChjYW1lcmEgIT09IHRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjZW5lLnNldFRyYW5zZm9ybU1hdHJpeChjYW1lcmEuZ2V0Vmlld01hdHJpeCgpLCBjYW1lcmEuZ2V0UHJvamVjdGlvbk1hdHJpeCh0cnVlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhID0gY2FtZXJhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5naW5lLnNldFZpZXdwb3J0KGNhbWVyYS5yaWdQYXJlbnQgPyBjYW1lcmEucmlnUGFyZW50LnZpZXdwb3J0IDogY2FtZXJhLnZpZXdwb3J0LCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVmYXVsdFJlbmRlckxpc3RQcmVwYXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBhZnRlciB0aGUgXCJyZW5kZXJcIiBjYWxsKHMpLCB0byBjb21wbGV0ZSB0aGUgcmVuZGVyaW5nIHByb2Nlc3MuXG4gICAgICovXG4gICAgZmluaXNoUmVuZGVyKCkge1xuICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXMuX3NjZW5lO1xuICAgICAgICBpZiAodGhpcy5fZGlzYWJsZUltYWdlUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgc2NlbmUuaW1hZ2VQcm9jZXNzaW5nQ29uZmlndXJhdGlvbi5fYXBwbHlCeVBvc3RQcm9jZXNzID0gdGhpcy5fY3VycmVudEFwcGx5QnlQb3N0UHJvY2Vzc1NldHRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc2NlbmUuYWN0aXZlQ2FtZXJhID0gdGhpcy5fY3VycmVudFNjZW5lQ2FtZXJhO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudFNjZW5lQ2FtZXJhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVDYW1lcmEgJiYgdGhpcy5hY3RpdmVDYW1lcmEgIT09IHNjZW5lLmFjdGl2ZUNhbWVyYSkge1xuICAgICAgICAgICAgICAgIHNjZW5lLnNldFRyYW5zZm9ybU1hdHJpeCh0aGlzLl9jdXJyZW50U2NlbmVDYW1lcmEuZ2V0Vmlld01hdHJpeCgpLCB0aGlzLl9jdXJyZW50U2NlbmVDYW1lcmEuZ2V0UHJvamVjdGlvbk1hdHJpeCh0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2VuZS5nZXRFbmdpbmUoKS5zZXRWaWV3cG9ydCh0aGlzLl9jdXJyZW50U2NlbmVDYW1lcmEudmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHNjZW5lLnJlc2V0Q2FjaGVkTWF0ZXJpYWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbGwgdGhlIG9iamVjdHMgKG1lc2hlcywgcGFydGljbGVzIHN5c3RlbXMsIHNwcml0ZXMpIHRvIHRoZSBjdXJyZW50bHkgYm91bmQgcmVuZGVyIHRhcmdldCB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSBwYXNzSW5kZXggZGVmaW5lcyB0aGUgcGFzcyBpbmRleCB0byB1c2UgKGRlZmF1bHQ6IDApXG4gICAgICogQHBhcmFtIHNraXBPbkFmdGVyUmVuZGVyT2JzZXJ2YWJsZSBkZWZpbmVzIGEgZmxhZyB0byBza2lwIHJhaXNpbmcgdGhlIG9uQWZ0ZXJSZW5kZXJPYnNlcnZhYmxlXG4gICAgICovXG4gICAgcmVuZGVyKHBhc3NJbmRleCA9IDAsIHNraXBPbkFmdGVyUmVuZGVyT2JzZXJ2YWJsZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5fc2NlbmU7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IHNjZW5lLmdldEVuZ2luZSgpO1xuICAgICAgICBjb25zdCBjdXJyZW50UmVuZGVyUGFzc0lkID0gZW5naW5lLmN1cnJlbnRSZW5kZXJQYXNzSWQ7XG4gICAgICAgIGVuZ2luZS5jdXJyZW50UmVuZGVyUGFzc0lkID0gdGhpcy5fcmVuZGVyUGFzc0lkc1twYXNzSW5kZXhdO1xuICAgICAgICB0aGlzLm9uQmVmb3JlUmVuZGVyT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMocGFzc0luZGV4KTtcbiAgICAgICAgY29uc3QgZmFzdFBhdGggPSBlbmdpbmUuc25hcHNob3RSZW5kZXJpbmcgJiYgZW5naW5lLnNuYXBzaG90UmVuZGVyaW5nTW9kZSA9PT0gMTtcbiAgICAgICAgaWYgKCFmYXN0UGF0aCkge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsaXN0IG9mIG1lc2hlcyB0byByZW5kZXJcbiAgICAgICAgICAgIGxldCBjdXJyZW50UmVuZGVyTGlzdCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0UmVuZGVyTGlzdCA9IHRoaXMucmVuZGVyTGlzdCA/IHRoaXMucmVuZGVyTGlzdCA6IHNjZW5lLmdldEFjdGl2ZU1lc2hlcygpLmRhdGE7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0UmVuZGVyTGlzdExlbmd0aCA9IHRoaXMucmVuZGVyTGlzdCA/IHRoaXMucmVuZGVyTGlzdC5sZW5ndGggOiBzY2VuZS5nZXRBY3RpdmVNZXNoZXMoKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDdXN0b21SZW5kZXJMaXN0KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlbmRlckxpc3QgPSB0aGlzLmdldEN1c3RvbVJlbmRlckxpc3QocGFzc0luZGV4LCBkZWZhdWx0UmVuZGVyTGlzdCwgZGVmYXVsdFJlbmRlckxpc3RMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50UmVuZGVyTGlzdCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIGN1c3RvbSByZW5kZXIgbGlzdCBwcm92aWRlZCwgd2UgcHJlcGFyZSB0aGUgcmVuZGVyaW5nIGZvciB0aGUgZGVmYXVsdCBsaXN0LCBidXQgY2hlY2tcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBpZiB3ZSBkaWQgbm90IGFscmVhZHkgcGVyZm9ybWVkIHRoZSBwcmVwYXJhdGlvbiBiZWZvcmUgc28gYXMgdG8gYXZvaWQgcmUtZG9pbmcgaXQgc2V2ZXJhbCB0aW1lc1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGVmYXVsdFJlbmRlckxpc3RQcmVwYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVwYXJlUmVuZGVyaW5nTWFuYWdlcihkZWZhdWx0UmVuZGVyTGlzdCwgZGVmYXVsdFJlbmRlckxpc3RMZW5ndGgsICF0aGlzLnJlbmRlckxpc3QgfHwgdGhpcy5mb3JjZUxheWVyTWFza0NoZWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFJlbmRlckxpc3RQcmVwYXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJMaXN0ID0gZGVmYXVsdFJlbmRlckxpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSByZW5kZXJpbmcgZm9yIHRoZSBjdXN0b20gcmVuZGVyIGxpc3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVwYXJlUmVuZGVyaW5nTWFuYWdlcihjdXJyZW50UmVuZGVyTGlzdCwgY3VycmVudFJlbmRlckxpc3QubGVuZ3RoLCB0aGlzLmZvcmNlTGF5ZXJNYXNrQ2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbkJlZm9yZVJlbmRlcmluZ01hbmFnZXJSZW5kZXJPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhwYXNzSW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyaW5nTWFuYWdlci5yZW5kZXIodGhpcy5jdXN0b21SZW5kZXJGdW5jdGlvbiwgY3VycmVudFJlbmRlckxpc3QsIHRoaXMucmVuZGVyUGFydGljbGVzLCB0aGlzLnJlbmRlclNwcml0ZXMpO1xuICAgICAgICAgICAgdGhpcy5vbkFmdGVyUmVuZGVyaW5nTWFuYWdlclJlbmRlck9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHBhc3NJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uRmFzdFBhdGhSZW5kZXJPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhwYXNzSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2tpcE9uQWZ0ZXJSZW5kZXJPYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm9uQWZ0ZXJSZW5kZXJPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhwYXNzSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVuZ2luZS5jdXJyZW50UmVuZGVyUGFzc0lkID0gY3VycmVudFJlbmRlclBhc3NJZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jaGVja1JlYWRpbmVzcygpIHtcbiAgICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzLl9zY2VuZTtcbiAgICAgICAgY29uc3QgZW5naW5lID0gc2NlbmUuZ2V0RW5naW5lKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZW5kZXJQYXNzSWQgPSBlbmdpbmUuY3VycmVudFJlbmRlclBhc3NJZDtcbiAgICAgICAgbGV0IHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFzY2VuZS5nZXRWaWV3TWF0cml4KCkpIHtcbiAgICAgICAgICAgIC8vIFdlIHByb2JhYmx5IGRpZG4ndCBleGVjdXRlIHNjZW5lLnJlbmRlcigpIHlldCwgc28gbWFrZSBzdXJlIHdlIGhhdmUgYSB2aWV3L3Byb2plY3Rpb24gbWF0cml4IHNldHVwIGZvciB0aGUgc2NlbmVcbiAgICAgICAgICAgIHNjZW5lLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bVBhc3NlcyA9IHRoaXMub3B0aW9ucy5udW1QYXNzZXM7XG4gICAgICAgIGZvciAobGV0IHBhc3NJbmRleCA9IDA7IHBhc3NJbmRleCA8IG51bVBhc3NlcyAmJiByZXR1cm5WYWx1ZTsgcGFzc0luZGV4KyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50UmVuZGVyTGlzdCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0UmVuZGVyTGlzdCA9IHRoaXMucmVuZGVyTGlzdCA/IHRoaXMucmVuZGVyTGlzdCA6IHNjZW5lLmdldEFjdGl2ZU1lc2hlcygpLmRhdGE7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0UmVuZGVyTGlzdExlbmd0aCA9IHRoaXMucmVuZGVyTGlzdCA/IHRoaXMucmVuZGVyTGlzdC5sZW5ndGggOiBzY2VuZS5nZXRBY3RpdmVNZXNoZXMoKS5sZW5ndGg7XG4gICAgICAgICAgICBlbmdpbmUuY3VycmVudFJlbmRlclBhc3NJZCA9IHRoaXMuX3JlbmRlclBhc3NJZHNbcGFzc0luZGV4XTtcbiAgICAgICAgICAgIHRoaXMub25CZWZvcmVSZW5kZXJPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhwYXNzSW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VzdG9tUmVuZGVyTGlzdCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJMaXN0ID0gdGhpcy5nZXRDdXN0b21SZW5kZXJMaXN0KHBhc3NJbmRleCwgZGVmYXVsdFJlbmRlckxpc3QsIGRlZmF1bHRSZW5kZXJMaXN0TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3VycmVudFJlbmRlckxpc3QpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVuZGVyTGlzdCA9IGRlZmF1bHRSZW5kZXJMaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZG9Ob3RDaGFuZ2VBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIHNjZW5lLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudFJlbmRlckxpc3QubGVuZ3RoICYmIHJldHVyblZhbHVlOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNoID0gY3VycmVudFJlbmRlckxpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFtZXNoLmlzRW5hYmxlZCgpIHx8IG1lc2guaXNCbG9ja2VkIHx8ICFtZXNoLmlzVmlzaWJsZSB8fCAhbWVzaC5zdWJNZXNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbUlzUmVhZHlGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY3VzdG9tSXNSZWFkeUZ1bmN0aW9uKG1lc2gsIHRoaXMucmVmcmVzaFJhdGUsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW1lc2guaXNSZWFkeSh0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uQWZ0ZXJSZW5kZXJPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhwYXNzSW5kZXgpO1xuICAgICAgICAgICAgaWYgKG51bVBhc3NlcyA+IDEpIHtcbiAgICAgICAgICAgICAgICBzY2VuZS5pbmNyZW1lbnRSZW5kZXJJZCgpO1xuICAgICAgICAgICAgICAgIHNjZW5lLnJlc2V0Q2FjaGVkTWF0ZXJpYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0aWNsZVN5c3RlbXMgPSB0aGlzLnBhcnRpY2xlU3lzdGVtTGlzdCB8fCBzY2VuZS5wYXJ0aWNsZVN5c3RlbXM7XG4gICAgICAgIGZvciAoY29uc3QgcGFydGljbGVTeXN0ZW0gb2YgcGFydGljbGVTeXN0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoIXBhcnRpY2xlU3lzdGVtLmlzUmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW5naW5lLmN1cnJlbnRSZW5kZXJQYXNzSWQgPSBjdXJyZW50UmVuZGVyUGFzc0lkO1xuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIF9wcmVwYXJlUmVuZGVyaW5nTWFuYWdlcihjdXJyZW50UmVuZGVyTGlzdCwgY3VycmVudFJlbmRlckxpc3RMZW5ndGgsIGNoZWNrTGF5ZXJNYXNrKSB7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5fc2NlbmU7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IHNjZW5lLmFjdGl2ZUNhbWVyYTsgLy8gbm90ZSB0aGF0IGF0IHRoaXMgcG9pbnQsIHNjZW5lLmFjdGl2ZUNhbWVyYSA9PSB0aGlzLmFjdGl2ZUNhbWVyYSBpZiBkZWZpbmVkLCBiZWNhdXNlIGluaXRSZW5kZXIoKSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlXG4gICAgICAgIGNvbnN0IGNhbWVyYUZvckxPRCA9IHRoaXMuY2FtZXJhRm9yTE9EID8/IGNhbWVyYTtcbiAgICAgICAgdGhpcy5fcmVuZGVyaW5nTWFuYWdlci5yZXNldCgpO1xuICAgICAgICBjb25zdCBzY2VuZVJlbmRlcklkID0gc2NlbmUuZ2V0UmVuZGVySWQoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEZyYW1lSWQgPSBzY2VuZS5nZXRGcmFtZUlkKCk7XG4gICAgICAgIGZvciAobGV0IG1lc2hJbmRleCA9IDA7IG1lc2hJbmRleCA8IGN1cnJlbnRSZW5kZXJMaXN0TGVuZ3RoOyBtZXNoSW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgbWVzaCA9IGN1cnJlbnRSZW5kZXJMaXN0W21lc2hJbmRleF07XG4gICAgICAgICAgICBpZiAobWVzaCAmJiAhbWVzaC5pc0Jsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXN0b21Jc1JlYWR5RnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1c3RvbUlzUmVhZHlGdW5jdGlvbihtZXNoLCB0aGlzLnJlZnJlc2hSYXRlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRSZWZyZXNoQ291bnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW1lc2guaXNSZWFkeSh0aGlzLnJlZnJlc2hSYXRlID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0UmVmcmVzaENvdW50ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBtZXNoVG9SZW5kZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChjYW1lcmFGb3JMT0QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzaFRvUmVuZGVyQW5kRnJhbWVJZCA9IG1lc2guX2ludGVybmFsQWJzdHJhY3RNZXNoRGF0YUluZm8uX2N1cnJlbnRMT0QuZ2V0KGNhbWVyYUZvckxPRCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWVzaFRvUmVuZGVyQW5kRnJhbWVJZCB8fCBtZXNoVG9SZW5kZXJBbmRGcmFtZUlkWzFdICE9PSBjdXJyZW50RnJhbWVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaFRvUmVuZGVyID0gc2NlbmUuY3VzdG9tTE9EU2VsZWN0b3IgPyBzY2VuZS5jdXN0b21MT0RTZWxlY3RvcihtZXNoLCBjYW1lcmFGb3JMT0QpIDogbWVzaC5nZXRMT0QoY2FtZXJhRm9yTE9EKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVzaFRvUmVuZGVyQW5kRnJhbWVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc2guX2ludGVybmFsQWJzdHJhY3RNZXNoRGF0YUluZm8uX2N1cnJlbnRMT0Quc2V0KGNhbWVyYUZvckxPRCwgW21lc2hUb1JlbmRlciwgY3VycmVudEZyYW1lSWRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc2hUb1JlbmRlckFuZEZyYW1lSWRbMF0gPSBtZXNoVG9SZW5kZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzaFRvUmVuZGVyQW5kRnJhbWVJZFsxXSA9IGN1cnJlbnRGcmFtZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaFRvUmVuZGVyID0gbWVzaFRvUmVuZGVyQW5kRnJhbWVJZFswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzaFRvUmVuZGVyID0gbWVzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtZXNoVG9SZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNoVG9SZW5kZXIgIT09IG1lc2ggJiYgbWVzaFRvUmVuZGVyLmJpbGxib2FyZE1vZGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzaFRvUmVuZGVyLmNvbXB1dGVXb3JsZE1hdHJpeCgpOyAvLyBDb21wdXRlIHdvcmxkIG1hdHJpeCBpZiBMT0QgaXMgYmlsbGJvYXJkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lc2hUb1JlbmRlci5fcHJlQWN0aXZhdGVGb3JJbnRlcm1lZGlhdGVSZW5kZXJpbmcoc2NlbmVSZW5kZXJJZCk7XG4gICAgICAgICAgICAgICAgbGV0IGlzTWFza2VkO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0xheWVyTWFzayAmJiBjYW1lcmEpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNNYXNrZWQgPSAobWVzaC5sYXllck1hc2sgJiBjYW1lcmEubGF5ZXJNYXNrKSA9PT0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzTWFza2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNoLmlzRW5hYmxlZCgpICYmIG1lc2guaXNWaXNpYmxlICYmIG1lc2guc3ViTWVzaGVzICYmICFpc01hc2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzaFRvUmVuZGVyICE9PSBtZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoVG9SZW5kZXIuX2FjdGl2YXRlKHNjZW5lUmVuZGVySWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNoLl9hY3RpdmF0ZShzY2VuZVJlbmRlcklkLCB0cnVlKSAmJiBtZXNoLnN1Yk1lc2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVzaC5pc0FuSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNoVG9SZW5kZXIuX2ludGVybmFsQWJzdHJhY3RNZXNoRGF0YUluZm8uX29ubHlGb3JJbnN0YW5jZXNJbnRlcm1lZGlhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNoLl9pbnRlcm5hbEFic3RyYWN0TWVzaERhdGFJbmZvLl9hY3RBc1JlZ3VsYXJNZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc2hUb1JlbmRlciA9IG1lc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzaFRvUmVuZGVyLl9pbnRlcm5hbEFic3RyYWN0TWVzaERhdGFJbmZvLl9pc0FjdGl2ZUludGVybWVkaWF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2VuZS5fcHJlcGFyZVNrZWxldG9uKG1lc2hUb1JlbmRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWJJbmRleCA9IDA7IHN1YkluZGV4IDwgbWVzaFRvUmVuZGVyLnN1Yk1lc2hlcy5sZW5ndGg7IHN1YkluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJNZXNoID0gbWVzaFRvUmVuZGVyLnN1Yk1lc2hlc1tzdWJJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyaW5nTWFuYWdlci5kaXNwYXRjaChzdWJNZXNoLCBtZXNoVG9SZW5kZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc2guX3Bvc3RBY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0aWNsZVN5c3RlbXMgPSB0aGlzLnBhcnRpY2xlU3lzdGVtTGlzdCB8fCBzY2VuZS5wYXJ0aWNsZVN5c3RlbXM7XG4gICAgICAgIGZvciAobGV0IHBhcnRpY2xlSW5kZXggPSAwOyBwYXJ0aWNsZUluZGV4IDwgcGFydGljbGVTeXN0ZW1zLmxlbmd0aDsgcGFydGljbGVJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNsZVN5c3RlbSA9IHBhcnRpY2xlU3lzdGVtc1twYXJ0aWNsZUluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBwYXJ0aWNsZVN5c3RlbS5lbWl0dGVyO1xuICAgICAgICAgICAgaWYgKCFwYXJ0aWNsZVN5c3RlbS5pc1N0YXJ0ZWQoKSB8fCAhZW1pdHRlciB8fCAoZW1pdHRlci5wb3NpdGlvbiAmJiAhZW1pdHRlci5pc0VuYWJsZWQoKSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmluZ01hbmFnZXIuZGlzcGF0Y2hQYXJ0aWNsZXMocGFydGljbGVTeXN0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBzb3J0IGZ1bmN0aW9uIGFwcGxpZWQgaW4gdGhlIHJlbmRlcmluZyBncm91cCB0byBwcmVwYXJlIHRoZSBtZXNoZXMuXG4gICAgICogVGhpcyBhbGxvd2VkIGNvbnRyb2wgZm9yIGZyb250IHRvIGJhY2sgcmVuZGVyaW5nIG9yIHJldmVyc2VseSBkZXBlbmRpbmcgb2YgdGhlIHNwZWNpYWwgbmVlZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVuZGVyaW5nR3JvdXBJZCBUaGUgcmVuZGVyaW5nIGdyb3VwIGlkIGNvcnJlc3BvbmRpbmcgdG8gaXRzIGluZGV4XG4gICAgICogQHBhcmFtIG9wYXF1ZVNvcnRDb21wYXJlRm4gVGhlIG9wYXF1ZSBxdWV1ZSBjb21wYXJpc29uIGZ1bmN0aW9uIHVzZSB0byBzb3J0LlxuICAgICAqIEBwYXJhbSBhbHBoYVRlc3RTb3J0Q29tcGFyZUZuIFRoZSBhbHBoYSB0ZXN0IHF1ZXVlIGNvbXBhcmlzb24gZnVuY3Rpb24gdXNlIHRvIHNvcnQuXG4gICAgICogQHBhcmFtIHRyYW5zcGFyZW50U29ydENvbXBhcmVGbiBUaGUgdHJhbnNwYXJlbnQgcXVldWUgY29tcGFyaXNvbiBmdW5jdGlvbiB1c2UgdG8gc29ydC5cbiAgICAgKi9cbiAgICBzZXRSZW5kZXJpbmdPcmRlcihyZW5kZXJpbmdHcm91cElkLCBvcGFxdWVTb3J0Q29tcGFyZUZuID0gbnVsbCwgYWxwaGFUZXN0U29ydENvbXBhcmVGbiA9IG51bGwsIHRyYW5zcGFyZW50U29ydENvbXBhcmVGbiA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyaW5nTWFuYWdlci5zZXRSZW5kZXJpbmdPcmRlcihyZW5kZXJpbmdHcm91cElkLCBvcGFxdWVTb3J0Q29tcGFyZUZuLCBhbHBoYVRlc3RTb3J0Q29tcGFyZUZuLCB0cmFuc3BhcmVudFNvcnRDb21wYXJlRm4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhlIHN0ZW5jaWwgYW5kIGRlcHRoIGJ1ZmZlciBhcmUgY2xlYXJlZCBiZXR3ZWVuIHR3byByZW5kZXJpbmcgZ3JvdXBzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbmRlcmluZ0dyb3VwSWQgVGhlIHJlbmRlcmluZyBncm91cCBpZCBjb3JyZXNwb25kaW5nIHRvIGl0cyBpbmRleFxuICAgICAqIEBwYXJhbSBhdXRvQ2xlYXJEZXB0aFN0ZW5jaWwgQXV0b21hdGljYWxseSBjbGVhcnMgZGVwdGggYW5kIHN0ZW5jaWwgYmV0d2VlbiBncm91cHMgaWYgdHJ1ZS5cbiAgICAgKiBAcGFyYW0gZGVwdGggQXV0b21hdGljYWxseSBjbGVhcnMgZGVwdGggYmV0d2VlbiBncm91cHMgaWYgdHJ1ZSBhbmQgYXV0b0NsZWFyIGlzIHRydWUuXG4gICAgICogQHBhcmFtIHN0ZW5jaWwgQXV0b21hdGljYWxseSBjbGVhcnMgc3RlbmNpbCBiZXR3ZWVuIGdyb3VwcyBpZiB0cnVlIGFuZCBhdXRvQ2xlYXIgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICBzZXRSZW5kZXJpbmdBdXRvQ2xlYXJEZXB0aFN0ZW5jaWwocmVuZGVyaW5nR3JvdXBJZCwgYXV0b0NsZWFyRGVwdGhTdGVuY2lsLCBkZXB0aCA9IHRydWUsIHN0ZW5jaWwgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmluZ01hbmFnZXIuc2V0UmVuZGVyaW5nQXV0b0NsZWFyRGVwdGhTdGVuY2lsKHJlbmRlcmluZ0dyb3VwSWQsIGF1dG9DbGVhckRlcHRoU3RlbmNpbCwgZGVwdGgsIHN0ZW5jaWwpO1xuICAgICAgICB0aGlzLl9yZW5kZXJpbmdNYW5hZ2VyLl91c2VTY2VuZUF1dG9DbGVhclNldHVwID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgcmVuZGVyZXIuXG4gICAgICogQHJldHVybnMgdGhlIGNsb25lZCByZW5kZXJlclxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBuZXdSZW5kZXJlciA9IG5ldyBPYmplY3RSZW5kZXJlcih0aGlzLm5hbWUsIHRoaXMuX3NjZW5lLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJMaXN0KSB7XG4gICAgICAgICAgICBuZXdSZW5kZXJlci5yZW5kZXJMaXN0ID0gdGhpcy5yZW5kZXJMaXN0LnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdSZW5kZXJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB0aGUgcmVuZGVyZXIgYW5kIHJlbGVhc2UgaXRzIGFzc29jaWF0ZWQgcmVzb3VyY2VzLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlckxpc3QgPSB0aGlzLnJlbmRlckxpc3QgPyB0aGlzLnJlbmRlckxpc3QgOiB0aGlzLl9zY2VuZS5nZXRBY3RpdmVNZXNoZXMoKS5kYXRhO1xuICAgICAgICBjb25zdCByZW5kZXJMaXN0TGVuZ3RoID0gdGhpcy5yZW5kZXJMaXN0ID8gdGhpcy5yZW5kZXJMaXN0Lmxlbmd0aCA6IHRoaXMuX3NjZW5lLmdldEFjdGl2ZU1lc2hlcygpLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJMaXN0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc2ggPSByZW5kZXJMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKG1lc2guZ2V0TWF0ZXJpYWxGb3JSZW5kZXJQYXNzKHRoaXMucmVuZGVyUGFzc0lkKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzaC5zZXRNYXRlcmlhbEZvclJlbmRlclBhc3ModGhpcy5yZW5kZXJQYXNzSWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkJlZm9yZVJlbmRlck9ic2VydmFibGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5vbkFmdGVyUmVuZGVyT2JzZXJ2YWJsZS5jbGVhcigpO1xuICAgICAgICB0aGlzLm9uQmVmb3JlUmVuZGVyaW5nTWFuYWdlclJlbmRlck9ic2VydmFibGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5vbkFmdGVyUmVuZGVyaW5nTWFuYWdlclJlbmRlck9ic2VydmFibGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5vbkZhc3RQYXRoUmVuZGVyT2JzZXJ2YWJsZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9yZWxlYXNlUmVuZGVyUGFzc0lkKCk7XG4gICAgICAgIHRoaXMucmVuZGVyTGlzdCA9IG51bGw7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVidWlsZCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaFJhdGUgPT09IE9iamVjdFJlbmRlcmVyLlJFRlJFU0hSQVRFX1JFTkRFUl9PTkNFKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hSYXRlID0gT2JqZWN0UmVuZGVyZXIuUkVGUkVTSFJBVEVfUkVOREVSX09OQ0U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGluZm8gcmVsYXRlZCB0byByZW5kZXJpbmcgZ3JvdXBzIHByZXZlbnRpbmcgcmV0ZW50aW9uIHBvaW50IGluIG1hdGVyaWFsIGRpc3Bvc2UuXG4gICAgICovXG4gICAgZnJlZVJlbmRlcmluZ0dyb3VwcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmluZ01hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmluZ01hbmFnZXIuZnJlZVJlbmRlcmluZ0dyb3VwcygpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBPYmplY3RzIHdpbGwgb25seSBiZSByZW5kZXJlZCBvbmNlIHdoaWNoIGNhbiBiZSB1c2VmdWwgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSBpZiBldmVyeXRoaW5nIGluIHlvdXIgcmVuZGVyIGlzIHN0YXRpYyBmb3IgaW5zdGFuY2UuXG4gKi9cbk9iamVjdFJlbmRlcmVyLlJFRlJFU0hSQVRFX1JFTkRFUl9PTkNFID0gMDtcbi8qKlxuICogT2JqZWN0cyB3aWxsIGJlIHJlbmRlcmVkIGV2ZXJ5IGZyYW1lIGFuZCBpcyByZWNvbW1lbmRlZCBmb3IgZHluYW1pYyBjb250ZW50cy5cbiAqL1xuT2JqZWN0UmVuZGVyZXIuUkVGUkVTSFJBVEVfUkVOREVSX09ORVZFUllGUkFNRSA9IDE7XG4vKipcbiAqIE9iamVjdHMgd2lsbCBiZSByZW5kZXJlZCBldmVyeSAyIGZyYW1lcyB3aGljaCBjb3VsZCBiZSBlbm91Z2ggaWYgeW91ciBkeW5hbWljIG9iamVjdHMgYXJlIG5vdFxuICogdGhlIGNlbnRyYWwgcG9pbnQgb2YgeW91ciBlZmZlY3QgYW5kIGNhbiBzYXZlIGEgbG90IG9mIHBlcmZvcm1hbmNlcy5cbiAqL1xuT2JqZWN0UmVuZGVyZXIuUkVGUkVTSFJBVEVfUkVOREVSX09ORVZFUllUV09GUkFNRVMgPSAyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0UmVuZGVyZXIuanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJwb3N0cHJvY2Vzc1ZlcnRleFNoYWRlclwiO1xuY29uc3Qgc2hhZGVyID0gYGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO3VuaWZvcm0gdmVjMiBzY2FsZTt2YXJ5aW5nIHZlYzIgdlVWO2NvbnN0IHZlYzIgbWFkZD12ZWMyKDAuNSwwLjUpO1xuI2RlZmluZSBDVVNUT01fVkVSVEVYX0RFRklOSVRJT05TXG52b2lkIG1haW4odm9pZCkge1xuI2RlZmluZSBDVVNUT01fVkVSVEVYX01BSU5fQkVHSU5cbnZVVj0ocG9zaXRpb24qbWFkZCttYWRkKSpzY2FsZTtnbF9Qb3NpdGlvbj12ZWM0KHBvc2l0aW9uLDAuMCwxLjApO1xuI2RlZmluZSBDVVNUT01fVkVSVEVYX01BSU5fRU5EXG59YDtcbi8vIFNpZGVlZmZlY3RcbmlmICghU2hhZGVyU3RvcmUuU2hhZGVyc1N0b3JlW25hbWVdKSB7XG4gICAgU2hhZGVyU3RvcmUuU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHBvc3Rwcm9jZXNzVmVydGV4U2hhZGVyID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvc3Rwcm9jZXNzLnZlcnRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=