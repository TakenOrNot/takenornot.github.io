"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["node_modules_babylonjs_core_Shaders_rgbdDecode_fragment_js"],{

/***/ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   helperFunctions: () => (/* binding */ helperFunctions)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "helperFunctions";
const shader = `const float PI=3.1415926535897932384626433832795;const float TWO_PI=6.283185307179586;const float HALF_PI=1.5707963267948966;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float RECIPROCAL_PI4=0.07957747154594767;const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
mat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}
#if USE_EXACT_SRGB_CONVERSIONS
vec3 toLinearSpaceExact(vec3 color)
{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));
#else
return
vec3(
color.r<=0.04045 ? nearZeroSection.r : remainingSection.r,
color.g<=0.04045 ? nearZeroSection.g : remainingSection.g,
color.b<=0.04045 ? nearZeroSection.b : remainingSection.b);
#endif
}
vec3 toGammaSpaceExact(vec3 color)
{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));
#else
return
vec3(
color.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,
color.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,
color.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);
#endif
}
#endif
float toLinearSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
vec3 toLinearSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3(LinearEncodePowerApprox));
#endif
}
vec4 toLinearSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
#endif
}
float toGammaSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;
#else
return pow(color,GammaEncodePowerApprox);
#endif
}
vec3 toGammaSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3(GammaEncodePowerApprox));
#endif
}
vec4 toGammaSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
#endif
}
float square(float value)
{return value*value;}
vec3 square(vec3 value)
{return value*value;}
float pow5(float value) {float sq=value*value;return sq*sq*value;}
float getLuminance(vec3 color)
{return saturate(dot(color,LuminanceEncodeApprox));}
float getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}
float dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}
const float rgbdMaxRange=255.;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =saturate(floor(D)/255.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(saturate(rgb),D);}
vec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
vec3 equirectangularToCubemapDirection(vec2 uv) {float longitude=uv.x*TWO_PI-PI;float latitude=HALF_PI-uv.y*PI;vec3 direction;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}
float sqrtClamped(float value) {return sqrt(max(value,0.));}
float avg(vec3 value) {return dot(value,vec3(0.333333333));}`;
// Sideeffect
if (!_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name]) {
    _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStore[name] = shader;
}
/** @internal */
const helperFunctions = { name, shader };
//# sourceMappingURL=helperFunctions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rgbdDecodePixelShader: () => (/* binding */ rgbdDecodePixelShader)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
/* harmony import */ var _ShadersInclude_helperFunctions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShadersInclude/helperFunctions.js */ "./node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js");
// Do not edit.


const name = "rgbdDecodePixelShader";
const shader = `varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;
// Sideeffect
if (!_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.ShadersStore[name]) {
    _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.ShadersStore[name] = shader;
}
/** @internal */
const rgbdDecodePixelShader = { name, shader };
//# sourceMappingURL=rgbdDecode.fragment.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2JhYnlsb25qc19jb3JlX1NoYWRlcnNfcmdiZERlY29kZV9mcmFnbWVudF9qcy5icm93c2VyLXBhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMyRDtBQUMzRDtBQUNBLGlFQUFpRSxxQ0FBcUMsdUNBQXVDLDZDQUE2QywrQ0FBK0MsK0NBQStDO0FBQ3hSLHdDQUF3QywrREFBK0QsNERBQTREO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9CQUFvQixvQkFBb0Isb0JBQW9CO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixpQ0FBaUMsK0RBQStELCtEQUErRCwrREFBK0QsMEJBQTBCLDJCQUEyQiwwQkFBMEIsa0NBQWtDO0FBQy9VO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUNBQWlDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQTBEO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQXNEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRCx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0EsQ0FBQztBQUNELDBCQUEwQjtBQUMxQiw4Q0FBOEMseUJBQXlCLHdDQUF3QyxrREFBa0Q7QUFDakssOEJBQThCLHlCQUF5Qix1REFBdUQscUNBQXFDLDJCQUEyQixxQkFBcUIsc0JBQXNCO0FBQ3pOLDBCQUEwQixpQ0FBaUM7QUFDM0Qsc0ZBQXNGLGlDQUFpQywyQkFBMkIsZ0VBQWdFLGdFQUFnRSxnRUFBZ0UsK0VBQStFLG9EQUFvRDtBQUNyZCxpREFBaUQsK0JBQStCLCtCQUErQixlQUFlLHlDQUF5QywwQkFBMEIseUNBQXlDO0FBQzFPLGdDQUFnQztBQUNoQyx1QkFBdUIscUNBQXFDO0FBQzVEO0FBQ0EsS0FBSyxnRUFBVztBQUNoQixJQUFJLGdFQUFXO0FBQ2Y7QUFDQTtBQUNPLDBCQUEwQjtBQUNqQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hIQTtBQUN3RDtBQUNYO0FBQzdDO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0VBQWdFO0FBQ2pFO0FBQ0EsS0FBSyxnRUFBVztBQUNoQixJQUFJLGdFQUFXO0FBQ2Y7QUFDQTtBQUNPLGdDQUFnQztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzL1NoYWRlcnNJbmNsdWRlL2hlbHBlckZ1bmN0aW9ucy5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVycy9yZ2JkRGVjb2RlLmZyYWdtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERvIG5vdCBlZGl0LlxuaW1wb3J0IHsgU2hhZGVyU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9zaGFkZXJTdG9yZS5qc1wiO1xuY29uc3QgbmFtZSA9IFwiaGVscGVyRnVuY3Rpb25zXCI7XG5jb25zdCBzaGFkZXIgPSBgY29uc3QgZmxvYXQgUEk9My4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1O2NvbnN0IGZsb2F0IFRXT19QST02LjI4MzE4NTMwNzE3OTU4Njtjb25zdCBmbG9hdCBIQUxGX1BJPTEuNTcwNzk2MzI2Nzk0ODk2Njtjb25zdCBmbG9hdCBSRUNJUFJPQ0FMX1BJPTAuMzE4MzA5ODg2MTgzNzkwNztjb25zdCBmbG9hdCBSRUNJUFJPQ0FMX1BJMj0wLjE1OTE1NDk0MzA5MTg5NTM1O2NvbnN0IGZsb2F0IFJFQ0lQUk9DQUxfUEk0PTAuMDc5NTc3NDcxNTQ1OTQ3Njc7Y29uc3QgZmxvYXQgSEFMRl9NSU49NS45NjA0NjQ0OGUtMDg7IFxuY29uc3QgZmxvYXQgTGluZWFyRW5jb2RlUG93ZXJBcHByb3g9Mi4yO2NvbnN0IGZsb2F0IEdhbW1hRW5jb2RlUG93ZXJBcHByb3g9MS4wL0xpbmVhckVuY29kZVBvd2VyQXBwcm94O2NvbnN0IHZlYzMgTHVtaW5hbmNlRW5jb2RlQXBwcm94PXZlYzMoMC4yMTI2LDAuNzE1MiwwLjA3MjIpO2NvbnN0IGZsb2F0IEVwc2lsb249MC4wMDAwMDAxO1xuI2RlZmluZSBzYXR1cmF0ZSh4KSBjbGFtcCh4LDAuMCwxLjApXG4jZGVmaW5lIGFic0Vwcyh4KSBhYnMoeCkrRXBzaWxvblxuI2RlZmluZSBtYXhFcHMoeCkgbWF4KHgsRXBzaWxvbilcbiNkZWZpbmUgc2F0dXJhdGVFcHMoeCkgY2xhbXAoeCxFcHNpbG9uLDEuMClcbm1hdDMgdHJhbnNwb3NlTWF0MyhtYXQzIGluTWF0cml4KSB7dmVjMyBpMD1pbk1hdHJpeFswXTt2ZWMzIGkxPWluTWF0cml4WzFdO3ZlYzMgaTI9aW5NYXRyaXhbMl07bWF0MyBvdXRNYXRyaXg9bWF0MyhcbnZlYzMoaTAueCxpMS54LGkyLngpLFxudmVjMyhpMC55LGkxLnksaTIueSksXG52ZWMzKGkwLnosaTEueixpMi56KVxuKTtyZXR1cm4gb3V0TWF0cml4O31cbm1hdDMgaW52ZXJzZU1hdDMobWF0MyBpbk1hdHJpeCkge2Zsb2F0IGEwMD1pbk1hdHJpeFswXVswXSxhMDE9aW5NYXRyaXhbMF1bMV0sYTAyPWluTWF0cml4WzBdWzJdO2Zsb2F0IGExMD1pbk1hdHJpeFsxXVswXSxhMTE9aW5NYXRyaXhbMV1bMV0sYTEyPWluTWF0cml4WzFdWzJdO2Zsb2F0IGEyMD1pbk1hdHJpeFsyXVswXSxhMjE9aW5NYXRyaXhbMl1bMV0sYTIyPWluTWF0cml4WzJdWzJdO2Zsb2F0IGIwMT1hMjIqYTExLWExMiphMjE7ZmxvYXQgYjExPS1hMjIqYTEwK2ExMiphMjA7ZmxvYXQgYjIxPWEyMSphMTAtYTExKmEyMDtmbG9hdCBkZXQ9YTAwKmIwMSthMDEqYjExK2EwMipiMjE7cmV0dXJuIG1hdDMoYjAxLCgtYTIyKmEwMSthMDIqYTIxKSwoYTEyKmEwMS1hMDIqYTExKSxcbmIxMSwoYTIyKmEwMC1hMDIqYTIwKSwoLWExMiphMDArYTAyKmExMCksXG5iMjEsKC1hMjEqYTAwK2EwMSphMjApLChhMTEqYTAwLWEwMSphMTApKS9kZXQ7fVxuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG52ZWMzIHRvTGluZWFyU3BhY2VFeGFjdCh2ZWMzIGNvbG9yKVxue3ZlYzMgbmVhclplcm9TZWN0aW9uPTAuMDc3Mzk5MzgwOCpjb2xvcjt2ZWMzIHJlbWFpbmluZ1NlY3Rpb249cG93KDAuOTQ3ODY3Mjk5Kihjb2xvcit2ZWMzKDAuMDU1KSksdmVjMygyLjQpKTtcbiNpZiBkZWZpbmVkKFdFQkdMMikgfHwgZGVmaW5lZChXRUJHUFUpIHx8IGRlZmluZWQoTkFUSVZFKVxucmV0dXJuIG1peChyZW1haW5pbmdTZWN0aW9uLG5lYXJaZXJvU2VjdGlvbixsZXNzVGhhbkVxdWFsKGNvbG9yLHZlYzMoMC4wNDA0NSkpKTtcbiNlbHNlXG5yZXR1cm5cbnZlYzMoXG5jb2xvci5yPD0wLjA0MDQ1ID8gbmVhclplcm9TZWN0aW9uLnIgOiByZW1haW5pbmdTZWN0aW9uLnIsXG5jb2xvci5nPD0wLjA0MDQ1ID8gbmVhclplcm9TZWN0aW9uLmcgOiByZW1haW5pbmdTZWN0aW9uLmcsXG5jb2xvci5iPD0wLjA0MDQ1ID8gbmVhclplcm9TZWN0aW9uLmIgOiByZW1haW5pbmdTZWN0aW9uLmIpO1xuI2VuZGlmXG59XG52ZWMzIHRvR2FtbWFTcGFjZUV4YWN0KHZlYzMgY29sb3IpXG57dmVjMyBuZWFyWmVyb1NlY3Rpb249MTIuOTIqY29sb3I7dmVjMyByZW1haW5pbmdTZWN0aW9uPTEuMDU1KnBvdyhjb2xvcix2ZWMzKDAuNDE2NjYpKS12ZWMzKDAuMDU1KTtcbiNpZiBkZWZpbmVkKFdFQkdMMikgfHwgZGVmaW5lZChXRUJHUFUpIHx8IGRlZmluZWQoTkFUSVZFKVxucmV0dXJuIG1peChyZW1haW5pbmdTZWN0aW9uLG5lYXJaZXJvU2VjdGlvbixsZXNzVGhhbkVxdWFsKGNvbG9yLHZlYzMoMC4wMDMxMzA4KSkpO1xuI2Vsc2VcbnJldHVyblxudmVjMyhcbmNvbG9yLnI8PTAuMDAzMTMwOCA/IG5lYXJaZXJvU2VjdGlvbi5yIDogcmVtYWluaW5nU2VjdGlvbi5yLFxuY29sb3IuZzw9MC4wMDMxMzA4ID8gbmVhclplcm9TZWN0aW9uLmcgOiByZW1haW5pbmdTZWN0aW9uLmcsXG5jb2xvci5iPD0wLjAwMzEzMDggPyBuZWFyWmVyb1NlY3Rpb24uYiA6IHJlbWFpbmluZ1NlY3Rpb24uYik7XG4jZW5kaWZcbn1cbiNlbmRpZlxuZmxvYXQgdG9MaW5lYXJTcGFjZShmbG9hdCBjb2xvcilcbntcbiNpZiBVU0VfRVhBQ1RfU1JHQl9DT05WRVJTSU9OU1xuZmxvYXQgbmVhclplcm9TZWN0aW9uPTAuMDc3Mzk5MzgwOCpjb2xvcjtmbG9hdCByZW1haW5pbmdTZWN0aW9uPXBvdygwLjk0Nzg2NzI5OSooY29sb3IrMC4wNTUpLDIuNCk7cmV0dXJuIGNvbG9yPD0wLjA0MDQ1ID8gbmVhclplcm9TZWN0aW9uIDogcmVtYWluaW5nU2VjdGlvbjtcbiNlbHNlXG5yZXR1cm4gcG93KGNvbG9yLExpbmVhckVuY29kZVBvd2VyQXBwcm94KTtcbiNlbmRpZlxufVxudmVjMyB0b0xpbmVhclNwYWNlKHZlYzMgY29sb3IpXG57XG4jaWYgVVNFX0VYQUNUX1NSR0JfQ09OVkVSU0lPTlNcbnJldHVybiB0b0xpbmVhclNwYWNlRXhhY3QoY29sb3IpO1xuI2Vsc2VcbnJldHVybiBwb3coY29sb3IsdmVjMyhMaW5lYXJFbmNvZGVQb3dlckFwcHJveCkpO1xuI2VuZGlmXG59XG52ZWM0IHRvTGluZWFyU3BhY2UodmVjNCBjb2xvcilcbntcbiNpZiBVU0VfRVhBQ1RfU1JHQl9DT05WRVJTSU9OU1xucmV0dXJuIHZlYzQodG9MaW5lYXJTcGFjZUV4YWN0KGNvbG9yLnJnYiksY29sb3IuYSk7XG4jZWxzZVxucmV0dXJuIHZlYzQocG93KGNvbG9yLnJnYix2ZWMzKExpbmVhckVuY29kZVBvd2VyQXBwcm94KSksY29sb3IuYSk7XG4jZW5kaWZcbn1cbmZsb2F0IHRvR2FtbWFTcGFjZShmbG9hdCBjb2xvcilcbntcbiNpZiBVU0VfRVhBQ1RfU1JHQl9DT05WRVJTSU9OU1xuZmxvYXQgbmVhclplcm9TZWN0aW9uPTEyLjkyKmNvbG9yO2Zsb2F0IHJlbWFpbmluZ1NlY3Rpb249MS4wNTUqcG93KGNvbG9yLDAuNDE2NjYpLTAuMDU1O3JldHVybiBjb2xvcjw9MC4wMDMxMzA4ID8gbmVhclplcm9TZWN0aW9uIDogcmVtYWluaW5nU2VjdGlvbjtcbiNlbHNlXG5yZXR1cm4gcG93KGNvbG9yLEdhbW1hRW5jb2RlUG93ZXJBcHByb3gpO1xuI2VuZGlmXG59XG52ZWMzIHRvR2FtbWFTcGFjZSh2ZWMzIGNvbG9yKVxue1xuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG5yZXR1cm4gdG9HYW1tYVNwYWNlRXhhY3QoY29sb3IpO1xuI2Vsc2VcbnJldHVybiBwb3coY29sb3IsdmVjMyhHYW1tYUVuY29kZVBvd2VyQXBwcm94KSk7XG4jZW5kaWZcbn1cbnZlYzQgdG9HYW1tYVNwYWNlKHZlYzQgY29sb3IpXG57XG4jaWYgVVNFX0VYQUNUX1NSR0JfQ09OVkVSU0lPTlNcbnJldHVybiB2ZWM0KHRvR2FtbWFTcGFjZUV4YWN0KGNvbG9yLnJnYiksY29sb3IuYSk7XG4jZWxzZVxucmV0dXJuIHZlYzQocG93KGNvbG9yLnJnYix2ZWMzKEdhbW1hRW5jb2RlUG93ZXJBcHByb3gpKSxjb2xvci5hKTtcbiNlbmRpZlxufVxuZmxvYXQgc3F1YXJlKGZsb2F0IHZhbHVlKVxue3JldHVybiB2YWx1ZSp2YWx1ZTt9XG52ZWMzIHNxdWFyZSh2ZWMzIHZhbHVlKVxue3JldHVybiB2YWx1ZSp2YWx1ZTt9XG5mbG9hdCBwb3c1KGZsb2F0IHZhbHVlKSB7ZmxvYXQgc3E9dmFsdWUqdmFsdWU7cmV0dXJuIHNxKnNxKnZhbHVlO31cbmZsb2F0IGdldEx1bWluYW5jZSh2ZWMzIGNvbG9yKVxue3JldHVybiBzYXR1cmF0ZShkb3QoY29sb3IsTHVtaW5hbmNlRW5jb2RlQXBwcm94KSk7fVxuZmxvYXQgZ2V0UmFuZCh2ZWMyIHNlZWQpIHtyZXR1cm4gZnJhY3Qoc2luKGRvdChzZWVkLnh5ICx2ZWMyKDEyLjk4OTgsNzguMjMzKSkpKjQzNzU4LjU0NTMpO31cbmZsb2F0IGRpdGhlcih2ZWMyIHNlZWQsZmxvYXQgdmFyaWFuY2VBbW91bnQpIHtmbG9hdCByYW5kPWdldFJhbmQoc2VlZCk7ZmxvYXQgbm9ybVZhcmlhbmNlPXZhcmlhbmNlQW1vdW50LzI1NS4wO2Zsb2F0IGRpdGhlcj1taXgoLW5vcm1WYXJpYW5jZSxub3JtVmFyaWFuY2UscmFuZCk7cmV0dXJuIGRpdGhlcjt9XG5jb25zdCBmbG9hdCByZ2JkTWF4UmFuZ2U9MjU1Ljt2ZWM0IHRvUkdCRCh2ZWMzIGNvbG9yKSB7ZmxvYXQgbWF4UkdCPW1heEVwcyhtYXgoY29sb3IucixtYXgoY29sb3IuZyxjb2xvci5iKSkpO2Zsb2F0IEQgPW1heChyZ2JkTWF4UmFuZ2UvbWF4UkdCLDEuKTtEID1zYXR1cmF0ZShmbG9vcihEKS8yNTUuKTt2ZWMzIHJnYj1jb2xvci5yZ2IqRDtyZ2I9dG9HYW1tYVNwYWNlKHJnYik7cmV0dXJuIHZlYzQoc2F0dXJhdGUocmdiKSxEKTt9XG52ZWMzIGZyb21SR0JEKHZlYzQgcmdiZCkge3JnYmQucmdiPXRvTGluZWFyU3BhY2UocmdiZC5yZ2IpO3JldHVybiByZ2JkLnJnYi9yZ2JkLmE7fVxudmVjMyBwYXJhbGxheENvcnJlY3ROb3JtYWwoIHZlYzMgdmVydGV4UG9zLHZlYzMgb3JpZ1ZlYyx2ZWMzIGN1YmVTaXplLHZlYzMgY3ViZVBvcyApIHt2ZWMzIGludk9yaWdWZWM9dmVjMygxLikvb3JpZ1ZlYzt2ZWMzIGhhbGZTaXplPWN1YmVTaXplKjAuNTt2ZWMzIGludGVyc2VjQXRNYXhQbGFuZT0oY3ViZVBvcytoYWxmU2l6ZS12ZXJ0ZXhQb3MpKmludk9yaWdWZWM7dmVjMyBpbnRlcnNlY0F0TWluUGxhbmU9KGN1YmVQb3MtaGFsZlNpemUtdmVydGV4UG9zKSppbnZPcmlnVmVjO3ZlYzMgbGFyZ2VzdEludGVyc2VjPW1heChpbnRlcnNlY0F0TWF4UGxhbmUsaW50ZXJzZWNBdE1pblBsYW5lKTtmbG9hdCBkaXN0YW5jZT1taW4obWluKGxhcmdlc3RJbnRlcnNlYy54LGxhcmdlc3RJbnRlcnNlYy55KSxsYXJnZXN0SW50ZXJzZWMueik7dmVjMyBpbnRlcnNlY3RQb3NpdGlvbldTPXZlcnRleFBvcytvcmlnVmVjKmRpc3RhbmNlO3JldHVybiBpbnRlcnNlY3RQb3NpdGlvbldTLWN1YmVQb3M7fVxudmVjMyBlcXVpcmVjdGFuZ3VsYXJUb0N1YmVtYXBEaXJlY3Rpb24odmVjMiB1dikge2Zsb2F0IGxvbmdpdHVkZT11di54KlRXT19QSS1QSTtmbG9hdCBsYXRpdHVkZT1IQUxGX1BJLXV2LnkqUEk7dmVjMyBkaXJlY3Rpb247ZGlyZWN0aW9uLng9Y29zKGxhdGl0dWRlKSpzaW4obG9uZ2l0dWRlKTtkaXJlY3Rpb24ueT1zaW4obGF0aXR1ZGUpO2RpcmVjdGlvbi56PWNvcyhsYXRpdHVkZSkqY29zKGxvbmdpdHVkZSk7cmV0dXJuIGRpcmVjdGlvbjt9XG5mbG9hdCBzcXJ0Q2xhbXBlZChmbG9hdCB2YWx1ZSkge3JldHVybiBzcXJ0KG1heCh2YWx1ZSwwLikpO31cbmZsb2F0IGF2Zyh2ZWMzIHZhbHVlKSB7cmV0dXJuIGRvdCh2YWx1ZSx2ZWMzKDAuMzMzMzMzMzMzKSk7fWA7XG4vLyBTaWRlZWZmZWN0XG5pZiAoIVNoYWRlclN0b3JlLkluY2x1ZGVzU2hhZGVyc1N0b3JlW25hbWVdKSB7XG4gICAgU2hhZGVyU3RvcmUuSW5jbHVkZXNTaGFkZXJzU3RvcmVbbmFtZV0gPSBzaGFkZXI7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaGVscGVyRnVuY3Rpb25zID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlckZ1bmN0aW9ucy5qcy5tYXAiLCIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmltcG9ydCBcIi4vU2hhZGVyc0luY2x1ZGUvaGVscGVyRnVuY3Rpb25zLmpzXCI7XG5jb25zdCBuYW1lID0gXCJyZ2JkRGVjb2RlUGl4ZWxTaGFkZXJcIjtcbmNvbnN0IHNoYWRlciA9IGB2YXJ5aW5nIHZlYzIgdlVWO3VuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyO1xuI2luY2x1ZGU8aGVscGVyRnVuY3Rpb25zPlxuI2RlZmluZSBDVVNUT01fRlJBR01FTlRfREVGSU5JVElPTlNcbnZvaWQgbWFpbih2b2lkKSBcbntnbF9GcmFnQ29sb3I9dmVjNChmcm9tUkdCRCh0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsdlVWKSksMS4wKTt9YDtcbi8vIFNpZGVlZmZlY3RcbmlmICghU2hhZGVyU3RvcmUuU2hhZGVyc1N0b3JlW25hbWVdKSB7XG4gICAgU2hhZGVyU3RvcmUuU2hhZGVyc1N0b3JlW25hbWVdID0gc2hhZGVyO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHJnYmREZWNvZGVQaXhlbFNoYWRlciA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZ2JkRGVjb2RlLmZyYWdtZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==