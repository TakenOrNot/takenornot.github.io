"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["vendors-node_modules_babylonjs_core_Materials_Textures_Loaders_envTextureLoader_js"],{

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/envTextureLoader.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/envTextureLoader.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _ENVTextureLoader: () => (/* binding */ _ENVTextureLoader)
/* harmony export */ });
/* harmony import */ var _Misc_environmentTextureTools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Misc/environmentTextureTools.js */ "./node_modules/@babylonjs/core/Misc/environmentTextureTools.js");

/**
 * Implementation of the ENV Texture Loader.
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class _ENVTextureLoader {
    constructor() {
        /**
         * Defines whether the loader supports cascade loading the different faces.
         */
        this.supportCascades = false;
    }
    /**
     * Uploads the cube texture data to the WebGL texture. It has already been bound.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param createPolynomials will be true if polynomials have been requested
     * @param onLoad defines the callback to trigger once the texture is ready
     * @param onError defines the callback to trigger in case of error
     */
    loadCubeData(data, texture, createPolynomials, onLoad, onError) {
        if (Array.isArray(data)) {
            return;
        }
        const info = (0,_Misc_environmentTextureTools_js__WEBPACK_IMPORTED_MODULE_0__.GetEnvInfo)(data);
        if (info) {
            texture.width = info.width;
            texture.height = info.width;
            try {
                (0,_Misc_environmentTextureTools_js__WEBPACK_IMPORTED_MODULE_0__.UploadEnvSpherical)(texture, info);
                (0,_Misc_environmentTextureTools_js__WEBPACK_IMPORTED_MODULE_0__.UploadEnvLevelsAsync)(texture, data, info).then(() => {
                    texture.isReady = true;
                    texture.onLoadedObservable.notifyObservers(texture);
                    texture.onLoadedObservable.clear();
                    if (onLoad) {
                        onLoad();
                    }
                }, (reason) => {
                    onError?.("Can not upload environment levels", reason);
                });
            }
            catch (e) {
                onError?.("Can not upload environment file", e);
            }
        }
        else if (onError) {
            onError("Can not parse the environment file", null);
        }
    }
    /**
     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
     */
    loadData() {
        // eslint-disable-next-line no-throw-literal
        throw ".env not supported in 2d.";
    }
}
//# sourceMappingURL=envTextureLoader.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Misc_HighDynamicRange_cubemapToSphericalPolynomial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Misc/HighDynamicRange/cubemapToSphericalPolynomial.js */ "./node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js");
/* harmony import */ var _baseTexture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./baseTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/baseTexture.js");


_baseTexture_js__WEBPACK_IMPORTED_MODULE_1__.BaseTexture.prototype.forceSphericalPolynomialsRecompute = function () {
    if (this._texture) {
        this._texture._sphericalPolynomial = null;
        this._texture._sphericalPolynomialPromise = null;
        this._texture._sphericalPolynomialComputed = false;
    }
};
Object.defineProperty(_baseTexture_js__WEBPACK_IMPORTED_MODULE_1__.BaseTexture.prototype, "sphericalPolynomial", {
    get: function () {
        if (this._texture) {
            if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {
                return this._texture._sphericalPolynomial;
            }
            if (this._texture.isReady) {
                if (!this._texture._sphericalPolynomialPromise) {
                    this._texture._sphericalPolynomialPromise = _Misc_HighDynamicRange_cubemapToSphericalPolynomial_js__WEBPACK_IMPORTED_MODULE_0__.CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);
                    if (this._texture._sphericalPolynomialPromise === null) {
                        this._texture._sphericalPolynomialComputed = true;
                    }
                    else {
                        this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {
                            this._texture._sphericalPolynomial = sphericalPolynomial;
                            this._texture._sphericalPolynomialComputed = true;
                        });
                    }
                }
                return null;
            }
        }
        return null;
    },
    set: function (value) {
        if (this._texture) {
            this._texture._sphericalPolynomial = value;
        }
    },
    enumerable: true,
    configurable: true,
});
//# sourceMappingURL=baseTexture.polynomial.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/dumpTools.js":
/*!********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/dumpTools.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dispose: () => (/* binding */ Dispose),
/* harmony export */   DumpData: () => (/* binding */ DumpData),
/* harmony export */   DumpDataAsync: () => (/* binding */ DumpDataAsync),
/* harmony export */   DumpFramebuffer: () => (/* binding */ DumpFramebuffer),
/* harmony export */   DumpTools: () => (/* binding */ DumpTools)
/* harmony export */ });
/* harmony import */ var _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Materials/effectRenderer.js */ "./node_modules/@babylonjs/core/Materials/effectRenderer.js");
/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools.js */ "./node_modules/@babylonjs/core/Misc/tools.js");
/* harmony import */ var _Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Maths/math.scalar.functions.js */ "./node_modules/@babylonjs/core/Maths/math.scalar.functions.js");
/* harmony import */ var _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Engines/engineStore.js */ "./node_modules/@babylonjs/core/Engines/engineStore.js");





let DumpToolsEngine;
let EnginePromise = null;
async function _CreateDumpRendererAsync() {
    if (!EnginePromise) {
        EnginePromise = new Promise((resolve, reject) => {
            let canvas;
            let engine = null;
            const options = {
                preserveDrawingBuffer: true,
                depth: false,
                stencil: false,
                alpha: true,
                premultipliedAlpha: false,
                antialias: false,
                failIfMajorPerformanceCaveat: false,
            };
            Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../Engines/thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js"))
                .then(({ ThinEngine: thinEngineClass }) => {
                const engineInstanceCount = _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.Instances.length;
                try {
                    canvas = new OffscreenCanvas(100, 100); // will be resized later
                    engine = new thinEngineClass(canvas, false, options);
                }
                catch (e) {
                    if (engineInstanceCount < _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.Instances.length) {
                        // The engine was created by another instance, let's use it
                        _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.Instances.pop()?.dispose();
                    }
                    // The browser either does not support OffscreenCanvas or WebGL context in OffscreenCanvas, fallback on a regular canvas
                    canvas = document.createElement("canvas");
                    engine = new thinEngineClass(canvas, false, options);
                }
                // remove this engine from the list of instances to avoid using it for other purposes
                _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.Instances.pop();
                // However, make sure to dispose it when no other engines are left
                _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.OnEnginesDisposedObservable.add((e) => {
                    // guaranteed to run when no other instances are left
                    // only dispose if it's not the current engine
                    if (engine && e !== engine && !engine.isDisposed && _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.Instances.length === 0) {
                        // Dump the engine and the associated resources
                        Dispose();
                    }
                });
                engine.getCaps().parallelShaderCompile = undefined;
                const renderer = new _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_0__.EffectRenderer(engine);
                __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_Shaders_pass_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../Shaders/pass.fragment.js */ "./node_modules/@babylonjs/core/Shaders/pass.fragment.js")).then(({ passPixelShader }) => {
                    if (!engine) {
                        reject("Engine is not defined");
                        return;
                    }
                    const wrapper = new _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_0__.EffectWrapper({
                        engine,
                        name: passPixelShader.name,
                        fragmentShader: passPixelShader.shader,
                        samplerNames: ["textureSampler"],
                    });
                    DumpToolsEngine = {
                        canvas,
                        engine,
                        renderer,
                        wrapper,
                    };
                    resolve(DumpToolsEngine);
                });
            })
                .catch(reject);
        });
    }
    return await EnginePromise;
}
/**
 * Dumps the current bound framebuffer
 * @param width defines the rendering width
 * @param height defines the rendering height
 * @param engine defines the hosting engine
 * @param successCallback defines the callback triggered once the data are available
 * @param mimeType defines the mime type of the result
 * @param fileName defines the filename to download. If present, the result will automatically be downloaded
 * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
 * @returns a void promise
 */
// Should have "Async" in the name but this is a public API and we can't break it now
// eslint-disable-next-line no-restricted-syntax
async function DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName, quality) {
    // Read the contents of the framebuffer
    const bufferView = await engine.readPixels(0, 0, width, height);
    const data = new Uint8Array(bufferView.buffer);
    DumpData(width, height, data, successCallback, mimeType, fileName, true, undefined, quality);
}
/**
 * Dumps an array buffer
 * @param width defines the rendering width
 * @param height defines the rendering height
 * @param data the data array
 * @param mimeType defines the mime type of the result
 * @param fileName defines the filename to download. If present, the result will automatically be downloaded
 * @param invertY true to invert the picture in the Y dimension
 * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string
 * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
 * @returns a promise that resolve to the final data
 */
async function DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    return new Promise((resolve) => {
        DumpData(width, height, data, (result) => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);
    });
}
/**
 * Dumps an array buffer
 * @param width defines the rendering width
 * @param height defines the rendering height
 * @param data the data array
 * @param successCallback defines the callback triggered once the data are available
 * @param mimeType defines the mime type of the result
 * @param fileName defines the filename to download. If present, the result will automatically be downloaded
 * @param invertY true to invert the picture in the Y dimension
 * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string
 * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
 */
function DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    _CreateDumpRendererAsync().then((renderer) => {
        renderer.engine.setSize(width, height, true);
        // Convert if data are float32
        if (data instanceof Float32Array) {
            const data2 = new Uint8Array(data.length);
            let n = data.length;
            while (n--) {
                const v = data[n];
                data2[n] = Math.round((0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_2__.Clamp)(v) * 255);
            }
            data = data2;
        }
        // Create the image
        const texture = renderer.engine.createRawTexture(data, width, height, 5, false, !invertY, 1);
        renderer.renderer.setViewport();
        renderer.renderer.applyEffectWrapper(renderer.wrapper);
        renderer.wrapper.effect._bindTexture("textureSampler", texture);
        renderer.renderer.draw();
        if (toArrayBuffer) {
            _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.ToBlob(renderer.canvas, (blob) => {
                const fileReader = new FileReader();
                fileReader.onload = (event) => {
                    const arrayBuffer = event.target.result;
                    if (successCallback) {
                        successCallback(arrayBuffer);
                    }
                };
                fileReader.readAsArrayBuffer(blob);
            }, mimeType, quality);
        }
        else {
            _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);
        }
        texture.dispose();
    });
}
/**
 * Dispose the dump tools associated resources
 */
function Dispose() {
    if (DumpToolsEngine) {
        DumpToolsEngine.wrapper.dispose();
        DumpToolsEngine.renderer.dispose();
        DumpToolsEngine.engine.dispose();
    }
    else {
        // in cases where the engine is not yet created, we need to wait for it to dispose it
        EnginePromise?.then((dumpToolsEngine) => {
            dumpToolsEngine.wrapper.dispose();
            dumpToolsEngine.renderer.dispose();
            dumpToolsEngine.engine.dispose();
        });
    }
    EnginePromise = null;
    DumpToolsEngine = null;
}
/**
 * Object containing a set of static utilities functions to dump data from a canvas
 * @deprecated use functions
 */
const DumpTools = {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    DumpData,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    DumpDataAsync,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    DumpFramebuffer,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    Dispose,
};
/**
 * This will be executed automatically for UMD and es5.
 * If esm dev wants the side effects to execute they will have to run it manually
 * Once we build native modules those need to be exported.
 * @internal
 */
const InitSideEffects = () => {
    // References the dependencies.
    _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.DumpData = DumpData;
    _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.DumpDataAsync = DumpDataAsync;
    _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.DumpFramebuffer = DumpFramebuffer;
};
InitSideEffects();
//# sourceMappingURL=dumpTools.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/environmentTextureTools.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/environmentTextureTools.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateEnvTextureAsync: () => (/* binding */ CreateEnvTextureAsync),
/* harmony export */   CreateIrradianceImageDataArrayBufferViews: () => (/* binding */ CreateIrradianceImageDataArrayBufferViews),
/* harmony export */   CreateRadianceImageDataArrayBufferViews: () => (/* binding */ CreateRadianceImageDataArrayBufferViews),
/* harmony export */   EnvironmentTextureTools: () => (/* binding */ EnvironmentTextureTools),
/* harmony export */   GetEnvInfo: () => (/* binding */ GetEnvInfo),
/* harmony export */   UploadEnvLevelsAsync: () => (/* binding */ UploadEnvLevelsAsync),
/* harmony export */   UploadEnvSpherical: () => (/* binding */ UploadEnvSpherical),
/* harmony export */   UploadIrradianceLevelsAsync: () => (/* binding */ UploadIrradianceLevelsAsync),
/* harmony export */   UploadRadianceLevelsAsync: () => (/* binding */ UploadRadianceLevelsAsync),
/* harmony export */   _UpdateRGBDAsync: () => (/* binding */ _UpdateRGBDAsync),
/* harmony export */   normalizeEnvInfo: () => (/* binding */ normalizeEnvInfo)
/* harmony export */ });
/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools.js */ "./node_modules/@babylonjs/core/Misc/tools.js");
/* harmony import */ var _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Maths/math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");
/* harmony import */ var _Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Maths/math.scalar.functions.js */ "./node_modules/@babylonjs/core/Maths/math.scalar.functions.js");
/* harmony import */ var _Maths_sphericalPolynomial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Maths/sphericalPolynomial.js */ "./node_modules/@babylonjs/core/Maths/sphericalPolynomial.js");
/* harmony import */ var _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Materials/Textures/internalTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/internalTexture.js");
/* harmony import */ var _Materials_Textures_baseTexture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Materials/Textures/baseTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/baseTexture.js");
/* harmony import */ var _scene_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../scene.js */ "./node_modules/@babylonjs/core/scene.js");
/* harmony import */ var _PostProcesses_postProcess_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../PostProcesses/postProcess.js */ "./node_modules/@babylonjs/core/PostProcesses/postProcess.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _rgbdTextureTools_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rgbdTextureTools.js */ "./node_modules/@babylonjs/core/Misc/rgbdTextureTools.js");
/* harmony import */ var _Misc_dumpTools_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Misc/dumpTools.js */ "./node_modules/@babylonjs/core/Misc/dumpTools.js");
/* harmony import */ var _Materials_Textures_baseTexture_polynomial_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Materials/Textures/baseTexture.polynomial.js */ "./node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js");













const DefaultEnvironmentTextureImageType = "image/png";
const CurrentVersion = 2;
/**
 * Magic number identifying the env file.
 */
const MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];
/**
 * Gets the environment info from an env file.
 * @param data The array buffer containing the .env bytes.
 * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.
 */
function GetEnvInfo(data) {
    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
    let pos = 0;
    for (let i = 0; i < MagicBytes.length; i++) {
        if (dataView.getUint8(pos++) !== MagicBytes[i]) {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_8__.Logger.Error("Not a babylon environment map");
            return null;
        }
    }
    // Read json manifest - collect characters up to null terminator
    let manifestString = "";
    let charCode = 0x00;
    while ((charCode = dataView.getUint8(pos++))) {
        manifestString += String.fromCharCode(charCode);
    }
    let manifest = JSON.parse(manifestString);
    manifest = normalizeEnvInfo(manifest);
    // Extend the header with the position of the payload.
    manifest.binaryDataPosition = pos;
    if (manifest.specular) {
        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.
        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;
    }
    return manifest;
}
/**
 * Normalizes any supported version of the environment file info to the latest version
 * @param info environment file info on any supported version
 * @returns environment file info in the latest supported version
 * @private
 */
function normalizeEnvInfo(info) {
    if (info.version > CurrentVersion) {
        throw new Error(`Unsupported babylon environment map version "${info.version}". Latest supported version is "${CurrentVersion}".`);
    }
    if (info.version === 2) {
        return info;
    }
    // Migrate a v1 info to v2
    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };
    return info;
}
/**
 * Creates an environment texture from a loaded cube texture.
 * @param texture defines the cube texture to convert in env file
 * @param options options for the conversion process
 * @param options.imageType the mime type for the encoded images, with support for "image/png" (default) and "image/webp"
 * @param options.imageQuality the image quality of encoded WebP images.
 * @returns a promise containing the environment data if successful.
 */
async function CreateEnvTextureAsync(texture, options = {}) {
    const internalTexture = texture.getInternalTexture();
    if (!internalTexture) {
        return Promise.reject("The cube texture is invalid.");
    }
    const engine = internalTexture.getEngine();
    if (texture.textureType !== 2 &&
        texture.textureType !== 1 &&
        texture.textureType !== 0 &&
        texture.textureType !== 0 &&
        texture.textureType !== 7 &&
        texture.textureType !== -1) {
        return Promise.reject("The cube texture should allow HDR (Full Float or Half Float).");
    }
    let textureType = 1;
    if (!engine.getCaps().textureFloatRender) {
        textureType = 2;
        if (!engine.getCaps().textureHalfFloatRender) {
            return Promise.reject("Env texture can only be created when the browser supports half float or full float rendering.");
        }
    }
    // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions
    texture.sphericalPolynomial;
    // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.
    const sphericalPolynomialPromise = texture.getInternalTexture()?._sphericalPolynomialPromise;
    const cubeWidth = internalTexture.width;
    const hostingScene = new _scene_js__WEBPACK_IMPORTED_MODULE_6__.Scene(engine);
    const specularTextures = {};
    const diffuseTextures = {};
    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!
    engine.flushFramebuffer();
    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;
    // Read and collect all mipmaps data from the cube.
    const mipmapsCount = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_2__.ILog2)(internalTexture.width);
    for (let i = 0; i <= mipmapsCount; i++) {
        const faceWidth = Math.pow(2, mipmapsCount - i);
        // All faces of the cube.
        for (let face = 0; face < 6; face++) {
            specularTextures[i * 6 + face] = await _GetTextureEncodedDataAsync(hostingScene, texture, textureType, face, i, faceWidth, imageType, options.imageQuality);
        }
    }
    // Read and collect all irradiance data from the cube.
    const irradianceTexture = options.disableIrradianceTexture ? null : texture.irradianceTexture;
    if (irradianceTexture) {
        const faceWidth = irradianceTexture.getSize().width;
        // All faces of the cube.
        for (let face = 0; face < 6; face++) {
            diffuseTextures[face] = await _GetTextureEncodedDataAsync(hostingScene, irradianceTexture, textureType, face, 0, faceWidth, imageType, options.imageQuality);
        }
    }
    // We can delete the hosting scene keeping track of all the creation objects
    hostingScene.dispose();
    // Ensure completion of the polynomial creation promise.
    if (sphericalPolynomialPromise) {
        await sphericalPolynomialPromise;
    }
    // Creates the json header for the env texture
    const info = {
        version: CurrentVersion,
        width: cubeWidth,
        imageType,
        irradiance: CreateEnvTextureIrradiance(texture),
        specular: {
            mipmaps: [],
            lodGenerationScale: texture.lodGenerationScale,
        },
    };
    // Sets the specular image data information
    let position = 0;
    for (let i = 0; i <= mipmapsCount; i++) {
        for (let face = 0; face < 6; face++) {
            const byteLength = specularTextures[i * 6 + face].byteLength;
            info.specular.mipmaps.push({
                length: byteLength,
                position: position,
            });
            position += byteLength;
        }
    }
    // Sets the irradiance image data information
    if (irradianceTexture) {
        info.irradiance = info.irradiance || {
            x: [0, 0, 0],
            xx: [0, 0, 0],
            y: [0, 0, 0],
            yy: [0, 0, 0],
            z: [0, 0, 0],
            zz: [0, 0, 0],
            yz: [0, 0, 0],
            zx: [0, 0, 0],
            xy: [0, 0, 0],
        };
        info.irradiance.irradianceTexture = {
            size: irradianceTexture.getSize().width,
            faces: [],
        };
        for (let face = 0; face < 6; face++) {
            const byteLength = diffuseTextures[face].byteLength;
            info.irradiance.irradianceTexture.faces.push({
                length: byteLength,
                position: position,
            });
            position += byteLength;
        }
    }
    // Encode the JSON as an array buffer
    const infoString = JSON.stringify(info);
    const infoBuffer = new ArrayBuffer(infoString.length + 1);
    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.
    for (let i = 0, strLen = infoString.length; i < strLen; i++) {
        infoView[i] = infoString.charCodeAt(i);
    }
    // Ends up with a null terminator for easier parsing
    infoView[infoString.length] = 0x00;
    // Computes the final required size and creates the storage
    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;
    const finalBuffer = new ArrayBuffer(totalSize);
    const finalBufferView = new Uint8Array(finalBuffer);
    const dataView = new DataView(finalBuffer);
    // Copy the magic bytes identifying the file in
    let pos = 0;
    for (let i = 0; i < MagicBytes.length; i++) {
        dataView.setUint8(pos++, MagicBytes[i]);
    }
    // Add the json info
    finalBufferView.set(new Uint8Array(infoBuffer), pos);
    pos += infoBuffer.byteLength;
    // Finally inserts the radiance texture data
    for (let i = 0; i <= mipmapsCount; i++) {
        for (let face = 0; face < 6; face++) {
            const dataBuffer = specularTextures[i * 6 + face];
            finalBufferView.set(new Uint8Array(dataBuffer), pos);
            pos += dataBuffer.byteLength;
        }
    }
    // Finally inserts the irradiance texture data
    if (irradianceTexture) {
        for (let face = 0; face < 6; face++) {
            const dataBuffer = diffuseTextures[face];
            finalBufferView.set(new Uint8Array(dataBuffer), pos);
            pos += dataBuffer.byteLength;
        }
    }
    // Voila
    return finalBuffer;
}
/**
 * Get the texture encoded data from the current texture
 * @internal
 */
async function _GetTextureEncodedDataAsync(hostingScene, texture, textureType, face, i, size, imageType, imageQuality) {
    let faceData = await texture.readPixels(face, i, undefined, false);
    if (faceData && faceData.byteLength === faceData.length) {
        const faceDataFloat = new Float32Array(faceData.byteLength * 4);
        for (let i = 0; i < faceData.byteLength; i++) {
            faceDataFloat[i] = faceData[i] / 255;
            // Gamma to linear
            faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);
        }
        faceData = faceDataFloat;
    }
    else if (faceData && texture.gammaSpace) {
        const floatData = faceData;
        for (let i = 0; i < floatData.length; i++) {
            // Gamma to linear
            floatData[i] = Math.pow(floatData[i], 2.2);
        }
    }
    const engine = hostingScene.getEngine();
    const tempTexture = engine.createRawTexture(faceData, size, size, 5, false, true, 1, null, textureType);
    await _rgbdTextureTools_js__WEBPACK_IMPORTED_MODULE_9__.RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);
    const rgbdEncodedData = await engine._readTexturePixels(tempTexture, size, size);
    const imageEncodedData = await (0,_Misc_dumpTools_js__WEBPACK_IMPORTED_MODULE_10__.DumpDataAsync)(size, size, rgbdEncodedData, imageType, undefined, false, true, imageQuality);
    tempTexture.dispose();
    return imageEncodedData;
}
/**
 * Creates a JSON representation of the spherical data.
 * @param texture defines the texture containing the polynomials
 * @returns the JSON representation of the spherical info
 */
function CreateEnvTextureIrradiance(texture) {
    const polynmials = texture.sphericalPolynomial;
    if (polynmials == null) {
        return null;
    }
    return {
        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],
        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],
        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],
        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],
        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],
        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],
        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],
        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],
        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],
    };
}
/**
 * Creates the ArrayBufferViews used for initializing environment texture image data.
 * @param data the image data
 * @param info parameters that determine what views will be created for accessing the underlying buffer
 * @returns the views described by info providing access to the underlying buffer
 */
function CreateRadianceImageDataArrayBufferViews(data, info) {
    info = normalizeEnvInfo(info);
    const specularInfo = info.specular;
    // Double checks the enclosed info
    let mipmapsCount = Math.log2(info.width);
    mipmapsCount = Math.round(mipmapsCount) + 1;
    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {
        throw new Error(`Unsupported specular mipmaps number "${specularInfo.mipmaps.length}"`);
    }
    const imageData = new Array(mipmapsCount);
    for (let i = 0; i < mipmapsCount; i++) {
        imageData[i] = new Array(6);
        for (let face = 0; face < 6; face++) {
            const imageInfo = specularInfo.mipmaps[i * 6 + face];
            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition + imageInfo.position, imageInfo.length);
        }
    }
    return imageData;
}
/**
 * Creates the ArrayBufferViews used for initializing environment texture image data.
 * @param data the image data
 * @param info parameters that determine what views will be created for accessing the underlying buffer
 * @returns the views described by info providing access to the underlying buffer
 */
function CreateIrradianceImageDataArrayBufferViews(data, info) {
    info = normalizeEnvInfo(info);
    const imageData = new Array(6);
    const irradianceTexture = info.irradiance?.irradianceTexture;
    if (irradianceTexture) {
        if (irradianceTexture.faces.length !== 6) {
            throw new Error(`Incorrect irradiance texture faces number "${irradianceTexture.faces.length}"`);
        }
        for (let face = 0; face < 6; face++) {
            const imageInfo = irradianceTexture.faces[face];
            imageData[face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition + imageInfo.position, imageInfo.length);
        }
    }
    return imageData;
}
/**
 * Uploads the texture info contained in the env file to the GPU.
 * @param texture defines the internal texture to upload to
 * @param data defines the data to load
 * @param info defines the texture info retrieved through the GetEnvInfo method
 * @returns a promise
 */
function UploadEnvLevelsAsync(texture, data, info) {
    info = normalizeEnvInfo(info);
    const specularInfo = info.specular;
    if (!specularInfo) {
        // Nothing else parsed so far
        return Promise.resolve([]);
    }
    texture._lodGenerationScale = specularInfo.lodGenerationScale;
    const promises = [];
    const radianceImageData = CreateRadianceImageDataArrayBufferViews(data, info);
    promises.push(UploadRadianceLevelsAsync(texture, radianceImageData, info.imageType));
    const irradianceTexture = info.irradiance?.irradianceTexture;
    if (irradianceTexture) {
        const irradianceImageData = CreateIrradianceImageDataArrayBufferViews(data, info);
        promises.push(UploadIrradianceLevelsAsync(texture, irradianceImageData, irradianceTexture.size, info.imageType));
    }
    return Promise.all(promises);
}
async function _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {
    return new Promise((resolve, reject) => {
        if (expandTexture) {
            const tempTexture = engine.createTexture(null, true, true, null, 1, null, (message) => {
                reject(message);
            }, image);
            rgbdPostProcess?.onEffectCreatedObservable.addOnce((effect) => {
                effect.executeWhenCompiled(() => {
                    // Uncompress the data to a RTT
                    rgbdPostProcess.externalTextureSamplerBinding = true;
                    rgbdPostProcess.onApply = (effect) => {
                        effect._bindTexture("textureSampler", tempTexture);
                        effect.setFloat2("scale", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);
                    };
                    if (!engine.scenes.length) {
                        return;
                    }
                    engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);
                    // Cleanup
                    engine.restoreDefaultFramebuffer();
                    tempTexture.dispose();
                    URL.revokeObjectURL(url);
                    resolve();
                });
            });
        }
        else {
            engine._uploadImageToTexture(texture, image, face, i);
            // Upload the face to the non lod texture support
            if (generateNonLODTextures) {
                const lodTexture = lodTextures[i];
                if (lodTexture) {
                    engine._uploadImageToTexture(lodTexture._texture, image, face, 0);
                }
            }
            resolve();
        }
    });
}
/**
 * Uploads the levels of image data to the GPU.
 * @param texture defines the internal texture to upload to
 * @param imageData defines the array buffer views of image data [mipmap][face]
 * @param imageType the mime type of the image data
 * @returns a promise
 */
async function UploadRadianceLevelsAsync(texture, imageData, imageType = DefaultEnvironmentTextureImageType) {
    const engine = texture.getEngine();
    texture.format = 5;
    texture.type = 0;
    texture.generateMipMaps = true;
    texture._cachedAnisotropicFilteringLevel = null;
    engine.updateTextureSamplingMode(3, texture);
    await _UploadLevelsAsync(texture, imageData, true, imageType);
    // Flag internal texture as ready in case they are in use.
    texture.isReady = true;
}
/**
 * Uploads the levels of image data to the GPU.
 * @param mainTexture defines the internal texture to upload to
 * @param imageData defines the array buffer views of image data [mipmap][face]
 * @param size defines the size of the texture faces
 * @param imageType the mime type of the image data
 * @returns a promise
 */
async function UploadIrradianceLevelsAsync(mainTexture, imageData, size, imageType = DefaultEnvironmentTextureImageType) {
    // Gets everything ready.
    const engine = mainTexture.getEngine();
    const texture = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_4__.InternalTexture(engine, 5 /* InternalTextureSource.RenderTarget */);
    const baseTexture = new _Materials_Textures_baseTexture_js__WEBPACK_IMPORTED_MODULE_5__.BaseTexture(engine, texture);
    mainTexture._irradianceTexture = baseTexture;
    texture.isCube = true;
    texture.format = 5;
    texture.type = 0;
    texture.generateMipMaps = true;
    texture._cachedAnisotropicFilteringLevel = null;
    texture.generateMipMaps = true;
    texture.width = size;
    texture.height = size;
    engine.updateTextureSamplingMode(3, texture);
    await _UploadLevelsAsync(texture, [imageData], false, imageType);
    engine.generateMipMapsForCubemap(texture);
    // Flag internal texture as ready in case they are in use.
    texture.isReady = true;
}
/**
 * Uploads the levels of image data to the GPU.
 * @param texture defines the internal texture to upload to
 * @param imageData defines the array buffer views of image data [mipmap][face]
 * @param canGenerateNonLODTextures defines whether or not to generate non lod textures
 * @param imageType the mime type of the image data
 * @returns a promise
 */
async function _UploadLevelsAsync(texture, imageData, canGenerateNonLODTextures, imageType = DefaultEnvironmentTextureImageType) {
    if (!_tools_js__WEBPACK_IMPORTED_MODULE_0__.Tools.IsExponentOfTwo(texture.width)) {
        throw new Error("Texture size must be a power of two");
    }
    const mipmapsCount = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_2__.ILog2)(texture.width) + 1;
    // Gets everything ready.
    const engine = texture.getEngine();
    let expandTexture = false;
    let generateNonLODTextures = false;
    let rgbdPostProcess = null;
    let cubeRtt = null;
    let lodTextures = null;
    const caps = engine.getCaps();
    if (!caps.textureLOD) {
        expandTexture = false;
        generateNonLODTextures = canGenerateNonLODTextures;
    }
    else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {
        expandTexture = false;
    }
    // If half float available we can uncompress the texture
    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        expandTexture = true;
        texture.type = 2;
    }
    // If full float available we can uncompress the texture
    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        expandTexture = true;
        texture.type = 1;
    }
    // Expand the texture if possible
    let shaderLanguage = 0 /* ShaderLanguage.GLSL */;
    if (expandTexture) {
        if (engine.isWebGPU) {
            shaderLanguage = 1 /* ShaderLanguage.WGSL */;
            await __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_ShadersWGSL_rgbdDecode_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../ShadersWGSL/rgbdDecode.fragment.js */ "./node_modules/@babylonjs/core/ShadersWGSL/rgbdDecode.fragment.js"));
        }
        else {
            await __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_Shaders_rgbdDecode_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../Shaders/rgbdDecode.fragment.js */ "./node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js"));
        }
        // Simply run through the decode PP
        rgbdPostProcess = new _PostProcesses_postProcess_js__WEBPACK_IMPORTED_MODULE_7__.PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, undefined, texture.type, undefined, null, false, undefined, shaderLanguage);
        texture._isRGBD = false;
        texture.invertY = false;
        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {
            generateDepthBuffer: false,
            generateMipMaps: true,
            generateStencilBuffer: false,
            samplingMode: 3,
            type: texture.type,
            format: 5,
        });
    }
    else {
        texture._isRGBD = true;
        texture.invertY = true;
        // In case of missing support, applies the same patch than DDS files.
        if (generateNonLODTextures) {
            const mipSlices = 3;
            lodTextures = {};
            const scale = texture._lodGenerationScale;
            const offset = texture._lodGenerationOffset;
            for (let i = 0; i < mipSlices; i++) {
                //compute LOD from even spacing in smoothness (matching shader calculation)
                const smoothness = i / (mipSlices - 1);
                const roughness = 1 - smoothness;
                const minLODIndex = offset; // roughness = 0
                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)
                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
                //compute LOD from even spacing in smoothness (matching shader calculation)
                const glTextureFromLod = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_4__.InternalTexture(engine, 2 /* InternalTextureSource.Temp */);
                glTextureFromLod.isCube = true;
                glTextureFromLod.invertY = true;
                glTextureFromLod.generateMipMaps = false;
                engine.updateTextureSamplingMode(2, glTextureFromLod);
                // Wrap in a base texture for easy binding.
                const lodTexture = new _Materials_Textures_baseTexture_js__WEBPACK_IMPORTED_MODULE_5__.BaseTexture(null);
                lodTexture._isCube = true;
                lodTexture._texture = glTextureFromLod;
                lodTextures[mipmapIndex] = lodTexture;
                switch (i) {
                    case 0:
                        texture._lodTextureLow = lodTexture;
                        break;
                    case 1:
                        texture._lodTextureMid = lodTexture;
                        break;
                    case 2:
                        texture._lodTextureHigh = lodTexture;
                        break;
                }
            }
        }
    }
    const promises = [];
    // All mipmaps up to provided number of images
    for (let i = 0; i < imageData.length; i++) {
        // All faces
        for (let face = 0; face < 6; face++) {
            // Constructs an image element from image data
            const bytes = imageData[i][face];
            const blob = new Blob([bytes], { type: imageType });
            const url = URL.createObjectURL(blob);
            let promise;
            if (engine._features.forceBitmapOverHTMLImageElement) {
                promise = engine.createImageBitmap(blob, { premultiplyAlpha: "none" }).then(async (img) => {
                    return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);
                });
            }
            else {
                const image = new Image();
                image.src = url;
                // Enqueue promise to upload to the texture.
                promise = new Promise((resolve, reject) => {
                    image.onload = () => {
                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)
                            .then(() => resolve())
                            .catch((reason) => {
                            reject(reason);
                        });
                    };
                    image.onerror = (error) => {
                        reject(error);
                    };
                });
            }
            promises.push(promise);
        }
    }
    await Promise.all(promises);
    // Fill remaining mipmaps with black textures.
    if (imageData.length < mipmapsCount) {
        let data;
        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);
        const dataLength = size * size * 4;
        switch (texture.type) {
            case 0: {
                data = new Uint8Array(dataLength);
                break;
            }
            case 2: {
                data = new Uint16Array(dataLength);
                break;
            }
            case 1: {
                data = new Float32Array(dataLength);
                break;
            }
        }
        for (let i = imageData.length; i < mipmapsCount; i++) {
            for (let face = 0; face < 6; face++) {
                engine._uploadArrayBufferViewToTexture(cubeRtt?.texture || texture, data, face, i);
            }
        }
    }
    // Release temp RTT.
    if (cubeRtt) {
        const irradiance = texture._irradianceTexture;
        texture._irradianceTexture = null;
        engine._releaseTexture(texture);
        cubeRtt._swapAndDie(texture);
        texture._irradianceTexture = irradiance;
    }
    // Release temp Post Process.
    if (rgbdPostProcess) {
        rgbdPostProcess.dispose();
    }
    // Flag internal texture as ready in case they are in use.
    if (generateNonLODTextures) {
        if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {
            texture._lodTextureHigh._texture.isReady = true;
        }
        if (texture._lodTextureMid && texture._lodTextureMid._texture) {
            texture._lodTextureMid._texture.isReady = true;
        }
        if (texture._lodTextureLow && texture._lodTextureLow._texture) {
            texture._lodTextureLow._texture.isReady = true;
        }
    }
}
/**
 * Uploads spherical polynomials information to the texture.
 * @param texture defines the texture we are trying to upload the information to
 * @param info defines the environment texture info retrieved through the GetEnvInfo method
 */
function UploadEnvSpherical(texture, info) {
    info = normalizeEnvInfo(info);
    const irradianceInfo = info.irradiance;
    if (!irradianceInfo) {
        return;
    }
    const sp = new _Maths_sphericalPolynomial_js__WEBPACK_IMPORTED_MODULE_3__.SphericalPolynomial();
    _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);
    _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);
    _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);
    _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);
    _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);
    _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);
    _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);
    _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);
    _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);
    texture._sphericalPolynomial = sp;
}
/**
 * @internal
 */
function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {
    const proxy = internalTexture
        .getEngine()
        .createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);
    const proxyPromise = UploadRadianceLevelsAsync(proxy, data).then(() => internalTexture);
    internalTexture.onRebuildCallback = (_internalTexture) => {
        return {
            proxy: proxyPromise,
            isReady: true,
            isAsync: true,
        };
    };
    internalTexture._source = 13 /* InternalTextureSource.CubeRawRGBD */;
    internalTexture._bufferViewArrayArray = data;
    internalTexture._lodGenerationScale = lodScale;
    internalTexture._lodGenerationOffset = lodOffset;
    internalTexture._sphericalPolynomial = sphericalPolynomial;
    return UploadRadianceLevelsAsync(internalTexture, data).then(() => {
        internalTexture.isReady = true;
        return internalTexture;
    });
}
/**
 * Sets of helpers addressing the serialization and deserialization of environment texture
 * stored in a BabylonJS env file.
 * Those files are usually stored as .env files.
 */
const EnvironmentTextureTools = {
    /**
     * Gets the environment info from an env file.
     * @param data The array buffer containing the .env bytes.
     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.
     */
    GetEnvInfo,
    /**
     * Creates an environment texture from a loaded cube texture.
     * @param texture defines the cube texture to convert in env file
     * @param options options for the conversion process
     * @param options.imageType the mime type for the encoded images, with support for "image/png" (default) and "image/webp"
     * @param options.imageQuality the image quality of encoded WebP images.
     * @returns a promise containing the environment data if successful.
     */
    CreateEnvTextureAsync,
    /**
     * Creates the ArrayBufferViews used for initializing environment texture image data.
     * @param data the image data
     * @param info parameters that determine what views will be created for accessing the underlying buffer
     * @returns the views described by info providing access to the underlying buffer
     */
    CreateRadianceImageDataArrayBufferViews,
    /**
     * Creates the ArrayBufferViews used for initializing environment texture image data.
     * @param data the image data
     * @param info parameters that determine what views will be created for accessing the underlying buffer
     * @returns the views described by info providing access to the underlying buffer
     */
    CreateIrradianceImageDataArrayBufferViews,
    /**
     * Uploads the texture info contained in the env file to the GPU.
     * @param texture defines the internal texture to upload to
     * @param data defines the data to load
     * @param info defines the texture info retrieved through the GetEnvInfo method
     * @returns a promise
     */
    UploadEnvLevelsAsync,
    /**
     * Uploads the levels of image data to the GPU.
     * @param texture defines the internal texture to upload to
     * @param imageData defines the array buffer views of image data [mipmap][face]
     * @param imageType the mime type of the image data
     * @returns a promise
     */
    UploadRadianceLevelsAsync,
    /**
     * Uploads the levels of image data to the GPU.
     * @param texture defines the internal texture to upload to
     * @param imageData defines the array buffer views of image data [mipmap][face]
     * @param imageType the mime type of the image data
     * @returns a promise
     */
    UploadIrradianceLevelsAsync,
    /**
     * Uploads spherical polynomials information to the texture.
     * @param texture defines the texture we are trying to upload the information to
     * @param info defines the environment texture info retrieved through the GetEnvInfo method
     */
    UploadEnvSpherical,
};
//# sourceMappingURL=environmentTextureTools.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/rgbdTextureTools.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/rgbdTextureTools.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RGBDTextureTools: () => (/* binding */ RGBDTextureTools)
/* harmony export */ });
/* harmony import */ var _PostProcesses_postProcess_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PostProcesses/postProcess.js */ "./node_modules/@babylonjs/core/PostProcesses/postProcess.js");
/* harmony import */ var _textureTools_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./textureTools.js */ "./node_modules/@babylonjs/core/Misc/textureTools.js");



/**
 * Class used to host RGBD texture specific utilities
 */
class RGBDTextureTools {
    /**
     * Expand the RGBD Texture from RGBD to Half Float if possible.
     * @param texture the texture to expand.
     */
    static ExpandRGBDTexture(texture) {
        const internalTexture = texture._texture;
        if (!internalTexture || !texture.isRGBD) {
            return;
        }
        // Gets everything ready.
        const engine = internalTexture.getEngine();
        const caps = engine.getCaps();
        const isReady = internalTexture.isReady;
        let expandTexture = false;
        // If half float available we can uncompress the texture
        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
            expandTexture = true;
            internalTexture.type = 2;
        }
        // If full float available we can uncompress the texture
        else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
            expandTexture = true;
            internalTexture.type = 1;
        }
        if (expandTexture) {
            // Do not use during decode.
            internalTexture.isReady = false;
            internalTexture._isRGBD = false;
            internalTexture.invertY = false;
        }
        const expandRgbdTextureAsync = async () => {
            const isWebGpu = engine.isWebGPU;
            const shaderLanguage = isWebGpu ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */;
            internalTexture.isReady = false;
            if (isWebGpu) {
                await __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_ShadersWGSL_rgbdDecode_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../ShadersWGSL/rgbdDecode.fragment.js */ "./node_modules/@babylonjs/core/ShadersWGSL/rgbdDecode.fragment.js"));
            }
            else {
                await __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_Shaders_rgbdDecode_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../Shaders/rgbdDecode.fragment.js */ "./node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js"));
            }
            // Expand the texture if possible
            // Simply run through the decode PP.
            const rgbdPostProcess = new _PostProcesses_postProcess_js__WEBPACK_IMPORTED_MODULE_0__.PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, undefined, internalTexture.type, undefined, null, false, undefined, shaderLanguage);
            rgbdPostProcess.externalTextureSamplerBinding = true;
            // Hold the output of the decoding.
            const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {
                generateDepthBuffer: false,
                generateMipMaps: false,
                generateStencilBuffer: false,
                samplingMode: internalTexture.samplingMode,
                type: internalTexture.type,
                format: 5,
            });
            rgbdPostProcess.onEffectCreatedObservable.addOnce((e) => {
                e.executeWhenCompiled(() => {
                    // PP Render Pass
                    rgbdPostProcess.onApply = (effect) => {
                        effect._bindTexture("textureSampler", internalTexture);
                        effect.setFloat2("scale", 1, 1);
                    };
                    texture.getScene().postProcessManager.directRender([rgbdPostProcess], expandedTexture, true);
                    // Cleanup
                    engine.restoreDefaultFramebuffer();
                    engine._releaseTexture(internalTexture);
                    if (rgbdPostProcess) {
                        rgbdPostProcess.dispose();
                    }
                    // Internal Swap
                    expandedTexture._swapAndDie(internalTexture);
                    // Ready to get rolling again.
                    internalTexture.isReady = true;
                });
            });
        };
        if (expandTexture) {
            if (isReady) {
                expandRgbdTextureAsync();
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                texture.onLoadObservable.addOnce(expandRgbdTextureAsync);
            }
        }
    }
    /**
     * Encode the texture to RGBD if possible.
     * @param internalTexture the texture to encode
     * @param scene the scene hosting the texture
     * @param outputTextureType type of the texture in which the encoding is performed
     * @returns a promise with the internalTexture having its texture replaced by the result of the processing
     */
    // Should have "Async" in the name but this is a breaking change.
    // eslint-disable-next-line no-restricted-syntax
    static async EncodeTextureToRGBD(internalTexture, scene, outputTextureType = 0) {
        if (!scene.getEngine().isWebGPU) {
            await __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_Shaders_rgbdEncode_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../Shaders/rgbdEncode.fragment.js */ "./node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js"));
        }
        else {
            await __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_ShadersWGSL_rgbdEncode_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../ShadersWGSL/rgbdEncode.fragment.js */ "./node_modules/@babylonjs/core/ShadersWGSL/rgbdEncode.fragment.js"));
        }
        return (0,_textureTools_js__WEBPACK_IMPORTED_MODULE_1__.ApplyPostProcess)("rgbdEncode", internalTexture, scene, outputTextureType, 1, 5);
    }
}
//# sourceMappingURL=rgbdTextureTools.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfTWF0ZXJpYWxzX1RleHR1cmVzX0xvYWRlcnNfZW52VGV4dHVyZUxvYWRlcl9qcy5icm93c2VyLXBhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0g7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRFQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9GQUFrQjtBQUNsQyxnQkFBZ0Isc0ZBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxRGdIO0FBQ2pFO0FBQy9DLHdEQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHFIQUFpQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QytFO0FBQzVDO0FBQ3VCO0FBQ0Y7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaVFBQTJDO0FBQzdEO0FBQ0E7QUFDQSxrQkFBa0IsNlFBQStDO0FBQ2pFO0FBQ0EsZUFBZSxrRUFBZ0I7QUFDL0I7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGVyaWFscy9UZXh0dXJlcy9Mb2FkZXJzL2VudlRleHR1cmVMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGVyaWFscy9UZXh0dXJlcy9iYXNlVGV4dHVyZS5wb2x5bm9taWFsLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NaXNjL2R1bXBUb29scy5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWlzYy9lbnZpcm9ubWVudFRleHR1cmVUb29scy5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWlzYy9yZ2JkVGV4dHVyZVRvb2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdldEVudkluZm8sIFVwbG9hZEVudkxldmVsc0FzeW5jLCBVcGxvYWRFbnZTcGhlcmljYWwgfSBmcm9tIFwiLi4vLi4vLi4vTWlzYy9lbnZpcm9ubWVudFRleHR1cmVUb29scy5qc1wiO1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgRU5WIFRleHR1cmUgTG9hZGVyLlxuICogQGludGVybmFsXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjbGFzcyBfRU5WVGV4dHVyZUxvYWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhlIGxvYWRlciBzdXBwb3J0cyBjYXNjYWRlIGxvYWRpbmcgdGhlIGRpZmZlcmVudCBmYWNlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcG9ydENhc2NhZGVzID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIGN1YmUgdGV4dHVyZSBkYXRhIHRvIHRoZSBXZWJHTCB0ZXh0dXJlLiBJdCBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kLlxuICAgICAqIEBwYXJhbSBkYXRhIGNvbnRhaW5zIHRoZSB0ZXh0dXJlIGRhdGFcbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSBCYWJ5bG9uSlMgaW50ZXJuYWwgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBjcmVhdGVQb2x5bm9taWFscyB3aWxsIGJlIHRydWUgaWYgcG9seW5vbWlhbHMgaGF2ZSBiZWVuIHJlcXVlc3RlZFxuICAgICAqIEBwYXJhbSBvbkxvYWQgZGVmaW5lcyB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBvbmNlIHRoZSB0ZXh0dXJlIGlzIHJlYWR5XG4gICAgICogQHBhcmFtIG9uRXJyb3IgZGVmaW5lcyB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBpbiBjYXNlIG9mIGVycm9yXG4gICAgICovXG4gICAgbG9hZEN1YmVEYXRhKGRhdGEsIHRleHR1cmUsIGNyZWF0ZVBvbHlub21pYWxzLCBvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmZvID0gR2V0RW52SW5mbyhkYXRhKTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIHRleHR1cmUud2lkdGggPSBpbmZvLndpZHRoO1xuICAgICAgICAgICAgdGV4dHVyZS5oZWlnaHQgPSBpbmZvLndpZHRoO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBVcGxvYWRFbnZTcGhlcmljYWwodGV4dHVyZSwgaW5mbyk7XG4gICAgICAgICAgICAgICAgVXBsb2FkRW52TGV2ZWxzQXN5bmModGV4dHVyZSwgZGF0YSwgaW5mbykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUub25Mb2FkZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyh0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5vbkxvYWRlZE9ic2VydmFibGUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Mb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I/LihcIkNhbiBub3QgdXBsb2FkIGVudmlyb25tZW50IGxldmVsc1wiLCByZWFzb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yPy4oXCJDYW4gbm90IHVwbG9hZCBlbnZpcm9ubWVudCBmaWxlXCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoXCJDYW4gbm90IHBhcnNlIHRoZSBlbnZpcm9ubWVudCBmaWxlXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIDJEIHRleHR1cmUgZGF0YSB0byB0aGUgV2ViR0wgdGV4dHVyZS4gSXQgaGFzIGFscmVhZHkgYmVlbiBib3VuZCBvbmNlIGluIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBsb2FkRGF0YSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgdGhyb3cgXCIuZW52IG5vdCBzdXBwb3J0ZWQgaW4gMmQuXCI7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52VGV4dHVyZUxvYWRlci5qcy5tYXAiLCJpbXBvcnQgeyBDdWJlTWFwVG9TcGhlcmljYWxQb2x5bm9taWFsVG9vbHMgfSBmcm9tIFwiLi4vLi4vTWlzYy9IaWdoRHluYW1pY1JhbmdlL2N1YmVtYXBUb1NwaGVyaWNhbFBvbHlub21pYWwuanNcIjtcbmltcG9ydCB7IEJhc2VUZXh0dXJlIH0gZnJvbSBcIi4vYmFzZVRleHR1cmUuanNcIjtcbkJhc2VUZXh0dXJlLnByb3RvdHlwZS5mb3JjZVNwaGVyaWNhbFBvbHlub21pYWxzUmVjb21wdXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX3RleHR1cmUuX3NwaGVyaWNhbFBvbHlub21pYWwgPSBudWxsO1xuICAgICAgICB0aGlzLl90ZXh0dXJlLl9zcGhlcmljYWxQb2x5bm9taWFsUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RleHR1cmUuX3NwaGVyaWNhbFBvbHlub21pYWxDb21wdXRlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVRleHR1cmUucHJvdG90eXBlLCBcInNwaGVyaWNhbFBvbHlub21pYWxcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUuX3NwaGVyaWNhbFBvbHlub21pYWwgfHwgdGhpcy5fdGV4dHVyZS5fc3BoZXJpY2FsUG9seW5vbWlhbENvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmUuX3NwaGVyaWNhbFBvbHlub21pYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZS5pc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlLl9zcGhlcmljYWxQb2x5bm9taWFsUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlLl9zcGhlcmljYWxQb2x5bm9taWFsUHJvbWlzZSA9IEN1YmVNYXBUb1NwaGVyaWNhbFBvbHlub21pYWxUb29scy5Db252ZXJ0Q3ViZU1hcFRleHR1cmVUb1NwaGVyaWNhbFBvbHlub21pYWwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0dXJlLl9zcGhlcmljYWxQb2x5bm9taWFsUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5fc3BoZXJpY2FsUG9seW5vbWlhbENvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmUuX3NwaGVyaWNhbFBvbHlub21pYWxQcm9taXNlLnRoZW4oKHNwaGVyaWNhbFBvbHlub21pYWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlLl9zcGhlcmljYWxQb2x5bm9taWFsID0gc3BoZXJpY2FsUG9seW5vbWlhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlLl9zcGhlcmljYWxQb2x5bm9taWFsQ29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5fc3BoZXJpY2FsUG9seW5vbWlhbCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZVRleHR1cmUucG9seW5vbWlhbC5qcy5tYXAiLCJcbmltcG9ydCB7IEVmZmVjdFJlbmRlcmVyLCBFZmZlY3RXcmFwcGVyIH0gZnJvbSBcIi4uL01hdGVyaWFscy9lZmZlY3RSZW5kZXJlci5qc1wiO1xuaW1wb3J0IHsgVG9vbHMgfSBmcm9tIFwiLi90b29scy5qc1wiO1xuaW1wb3J0IHsgQ2xhbXAgfSBmcm9tIFwiLi4vTWF0aHMvbWF0aC5zY2FsYXIuZnVuY3Rpb25zLmpzXCI7XG5pbXBvcnQgeyBFbmdpbmVTdG9yZSB9IGZyb20gXCIuLi9FbmdpbmVzL2VuZ2luZVN0b3JlLmpzXCI7XG5sZXQgRHVtcFRvb2xzRW5naW5lO1xubGV0IEVuZ2luZVByb21pc2UgPSBudWxsO1xuYXN5bmMgZnVuY3Rpb24gX0NyZWF0ZUR1bXBSZW5kZXJlckFzeW5jKCkge1xuICAgIGlmICghRW5naW5lUHJvbWlzZSkge1xuICAgICAgICBFbmdpbmVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNhbnZhcztcbiAgICAgICAgICAgIGxldCBlbmdpbmUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbXBvcnQoXCIuLi9FbmdpbmVzL3RoaW5FbmdpbmUuanNcIilcbiAgICAgICAgICAgICAgICAudGhlbigoeyBUaGluRW5naW5lOiB0aGluRW5naW5lQ2xhc3MgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZ2luZUluc3RhbmNlQ291bnQgPSBFbmdpbmVTdG9yZS5JbnN0YW5jZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMTAwLCAxMDApOyAvLyB3aWxsIGJlIHJlc2l6ZWQgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgZW5naW5lID0gbmV3IHRoaW5FbmdpbmVDbGFzcyhjYW52YXMsIGZhbHNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZ2luZUluc3RhbmNlQ291bnQgPCBFbmdpbmVTdG9yZS5JbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW5naW5lIHdhcyBjcmVhdGVkIGJ5IGFub3RoZXIgaW5zdGFuY2UsIGxldCdzIHVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgRW5naW5lU3RvcmUuSW5zdGFuY2VzLnBvcCgpPy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJyb3dzZXIgZWl0aGVyIGRvZXMgbm90IHN1cHBvcnQgT2Zmc2NyZWVuQ2FudmFzIG9yIFdlYkdMIGNvbnRleHQgaW4gT2Zmc2NyZWVuQ2FudmFzLCBmYWxsYmFjayBvbiBhIHJlZ3VsYXIgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgIGVuZ2luZSA9IG5ldyB0aGluRW5naW5lQ2xhc3MoY2FudmFzLCBmYWxzZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGlzIGVuZ2luZSBmcm9tIHRoZSBsaXN0IG9mIGluc3RhbmNlcyB0byBhdm9pZCB1c2luZyBpdCBmb3Igb3RoZXIgcHVycG9zZXNcbiAgICAgICAgICAgICAgICBFbmdpbmVTdG9yZS5JbnN0YW5jZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgbWFrZSBzdXJlIHRvIGRpc3Bvc2UgaXQgd2hlbiBubyBvdGhlciBlbmdpbmVzIGFyZSBsZWZ0XG4gICAgICAgICAgICAgICAgRW5naW5lU3RvcmUuT25FbmdpbmVzRGlzcG9zZWRPYnNlcnZhYmxlLmFkZCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBndWFyYW50ZWVkIHRvIHJ1biB3aGVuIG5vIG90aGVyIGluc3RhbmNlcyBhcmUgbGVmdFxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGRpc3Bvc2UgaWYgaXQncyBub3QgdGhlIGN1cnJlbnQgZW5naW5lXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmdpbmUgJiYgZSAhPT0gZW5naW5lICYmICFlbmdpbmUuaXNEaXNwb3NlZCAmJiBFbmdpbmVTdG9yZS5JbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEdW1wIHRoZSBlbmdpbmUgYW5kIHRoZSBhc3NvY2lhdGVkIHJlc291cmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgRGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZW5naW5lLmdldENhcHMoKS5wYXJhbGxlbFNoYWRlckNvbXBpbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgRWZmZWN0UmVuZGVyZXIoZW5naW5lKTtcbiAgICAgICAgICAgICAgICBpbXBvcnQoXCIuLi9TaGFkZXJzL3Bhc3MuZnJhZ21lbnQuanNcIikudGhlbigoeyBwYXNzUGl4ZWxTaGFkZXIgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZ2luZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiRW5naW5lIGlzIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgRWZmZWN0V3JhcHBlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmdpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXNzUGl4ZWxTaGFkZXIubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBwYXNzUGl4ZWxTaGFkZXIuc2hhZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlck5hbWVzOiBbXCJ0ZXh0dXJlU2FtcGxlclwiXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIER1bXBUb29sc0VuZ2luZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZ2luZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShEdW1wVG9vbHNFbmdpbmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBFbmdpbmVQcm9taXNlO1xufVxuLyoqXG4gKiBEdW1wcyB0aGUgY3VycmVudCBib3VuZCBmcmFtZWJ1ZmZlclxuICogQHBhcmFtIHdpZHRoIGRlZmluZXMgdGhlIHJlbmRlcmluZyB3aWR0aFxuICogQHBhcmFtIGhlaWdodCBkZWZpbmVzIHRoZSByZW5kZXJpbmcgaGVpZ2h0XG4gKiBAcGFyYW0gZW5naW5lIGRlZmluZXMgdGhlIGhvc3RpbmcgZW5naW5lXG4gKiBAcGFyYW0gc3VjY2Vzc0NhbGxiYWNrIGRlZmluZXMgdGhlIGNhbGxiYWNrIHRyaWdnZXJlZCBvbmNlIHRoZSBkYXRhIGFyZSBhdmFpbGFibGVcbiAqIEBwYXJhbSBtaW1lVHlwZSBkZWZpbmVzIHRoZSBtaW1lIHR5cGUgb2YgdGhlIHJlc3VsdFxuICogQHBhcmFtIGZpbGVOYW1lIGRlZmluZXMgdGhlIGZpbGVuYW1lIHRvIGRvd25sb2FkLiBJZiBwcmVzZW50LCB0aGUgcmVzdWx0IHdpbGwgYXV0b21hdGljYWxseSBiZSBkb3dubG9hZGVkXG4gKiBAcGFyYW0gcXVhbGl0eSBUaGUgcXVhbGl0eSBvZiB0aGUgaW1hZ2UgaWYgbG9zc3kgbWltZVR5cGUgaXMgdXNlZCAoZS5nLiBpbWFnZS9qcGVnLCBpbWFnZS93ZWJwKS4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvdG9CbG9iIHwgSFRNTENhbnZhc0VsZW1lbnQudG9CbG9iKCl9J3MgYHF1YWxpdHlgIHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIGEgdm9pZCBwcm9taXNlXG4gKi9cbi8vIFNob3VsZCBoYXZlIFwiQXN5bmNcIiBpbiB0aGUgbmFtZSBidXQgdGhpcyBpcyBhIHB1YmxpYyBBUEkgYW5kIHdlIGNhbid0IGJyZWFrIGl0IG5vd1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gRHVtcEZyYW1lYnVmZmVyKHdpZHRoLCBoZWlnaHQsIGVuZ2luZSwgc3VjY2Vzc0NhbGxiYWNrLCBtaW1lVHlwZSA9IFwiaW1hZ2UvcG5nXCIsIGZpbGVOYW1lLCBxdWFsaXR5KSB7XG4gICAgLy8gUmVhZCB0aGUgY29udGVudHMgb2YgdGhlIGZyYW1lYnVmZmVyXG4gICAgY29uc3QgYnVmZmVyVmlldyA9IGF3YWl0IGVuZ2luZS5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXJWaWV3LmJ1ZmZlcik7XG4gICAgRHVtcERhdGEod2lkdGgsIGhlaWdodCwgZGF0YSwgc3VjY2Vzc0NhbGxiYWNrLCBtaW1lVHlwZSwgZmlsZU5hbWUsIHRydWUsIHVuZGVmaW5lZCwgcXVhbGl0eSk7XG59XG4vKipcbiAqIER1bXBzIGFuIGFycmF5IGJ1ZmZlclxuICogQHBhcmFtIHdpZHRoIGRlZmluZXMgdGhlIHJlbmRlcmluZyB3aWR0aFxuICogQHBhcmFtIGhlaWdodCBkZWZpbmVzIHRoZSByZW5kZXJpbmcgaGVpZ2h0XG4gKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBhcnJheVxuICogQHBhcmFtIG1pbWVUeXBlIGRlZmluZXMgdGhlIG1pbWUgdHlwZSBvZiB0aGUgcmVzdWx0XG4gKiBAcGFyYW0gZmlsZU5hbWUgZGVmaW5lcyB0aGUgZmlsZW5hbWUgdG8gZG93bmxvYWQuIElmIHByZXNlbnQsIHRoZSByZXN1bHQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRvd25sb2FkZWRcbiAqIEBwYXJhbSBpbnZlcnRZIHRydWUgdG8gaW52ZXJ0IHRoZSBwaWN0dXJlIGluIHRoZSBZIGRpbWVuc2lvblxuICogQHBhcmFtIHRvQXJyYXlCdWZmZXIgdHJ1ZSB0byBjb252ZXJ0IHRoZSBkYXRhIHRvIGFuIEFycmF5QnVmZmVyIChlbmNvZGVkIGFzIGBtaW1lVHlwZWApIGluc3RlYWQgb2YgYSBiYXNlNjQgc3RyaW5nXG4gKiBAcGFyYW0gcXVhbGl0eSBUaGUgcXVhbGl0eSBvZiB0aGUgaW1hZ2UgaWYgbG9zc3kgbWltZVR5cGUgaXMgdXNlZCAoZS5nLiBpbWFnZS9qcGVnLCBpbWFnZS93ZWJwKS4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvdG9CbG9iIHwgSFRNTENhbnZhc0VsZW1lbnQudG9CbG9iKCl9J3MgYHF1YWxpdHlgIHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmUgdG8gdGhlIGZpbmFsIGRhdGFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIER1bXBEYXRhQXN5bmMod2lkdGgsIGhlaWdodCwgZGF0YSwgbWltZVR5cGUgPSBcImltYWdlL3BuZ1wiLCBmaWxlTmFtZSwgaW52ZXJ0WSA9IGZhbHNlLCB0b0FycmF5QnVmZmVyID0gZmFsc2UsIHF1YWxpdHkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgRHVtcERhdGEod2lkdGgsIGhlaWdodCwgZGF0YSwgKHJlc3VsdCkgPT4gcmVzb2x2ZShyZXN1bHQpLCBtaW1lVHlwZSwgZmlsZU5hbWUsIGludmVydFksIHRvQXJyYXlCdWZmZXIsIHF1YWxpdHkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBEdW1wcyBhbiBhcnJheSBidWZmZXJcbiAqIEBwYXJhbSB3aWR0aCBkZWZpbmVzIHRoZSByZW5kZXJpbmcgd2lkdGhcbiAqIEBwYXJhbSBoZWlnaHQgZGVmaW5lcyB0aGUgcmVuZGVyaW5nIGhlaWdodFxuICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgYXJyYXlcbiAqIEBwYXJhbSBzdWNjZXNzQ2FsbGJhY2sgZGVmaW5lcyB0aGUgY2FsbGJhY2sgdHJpZ2dlcmVkIG9uY2UgdGhlIGRhdGEgYXJlIGF2YWlsYWJsZVxuICogQHBhcmFtIG1pbWVUeXBlIGRlZmluZXMgdGhlIG1pbWUgdHlwZSBvZiB0aGUgcmVzdWx0XG4gKiBAcGFyYW0gZmlsZU5hbWUgZGVmaW5lcyB0aGUgZmlsZW5hbWUgdG8gZG93bmxvYWQuIElmIHByZXNlbnQsIHRoZSByZXN1bHQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRvd25sb2FkZWRcbiAqIEBwYXJhbSBpbnZlcnRZIHRydWUgdG8gaW52ZXJ0IHRoZSBwaWN0dXJlIGluIHRoZSBZIGRpbWVuc2lvblxuICogQHBhcmFtIHRvQXJyYXlCdWZmZXIgdHJ1ZSB0byBjb252ZXJ0IHRoZSBkYXRhIHRvIGFuIEFycmF5QnVmZmVyIChlbmNvZGVkIGFzIGBtaW1lVHlwZWApIGluc3RlYWQgb2YgYSBiYXNlNjQgc3RyaW5nXG4gKiBAcGFyYW0gcXVhbGl0eSBUaGUgcXVhbGl0eSBvZiB0aGUgaW1hZ2UgaWYgbG9zc3kgbWltZVR5cGUgaXMgdXNlZCAoZS5nLiBpbWFnZS9qcGVnLCBpbWFnZS93ZWJwKS4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvdG9CbG9iIHwgSFRNTENhbnZhc0VsZW1lbnQudG9CbG9iKCl9J3MgYHF1YWxpdHlgIHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIER1bXBEYXRhKHdpZHRoLCBoZWlnaHQsIGRhdGEsIHN1Y2Nlc3NDYWxsYmFjaywgbWltZVR5cGUgPSBcImltYWdlL3BuZ1wiLCBmaWxlTmFtZSwgaW52ZXJ0WSA9IGZhbHNlLCB0b0FycmF5QnVmZmVyID0gZmFsc2UsIHF1YWxpdHkpIHtcbiAgICBfQ3JlYXRlRHVtcFJlbmRlcmVyQXN5bmMoKS50aGVuKChyZW5kZXJlcikgPT4ge1xuICAgICAgICByZW5kZXJlci5lbmdpbmUuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgLy8gQ29udmVydCBpZiBkYXRhIGFyZSBmbG9hdDMyXG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhMiA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IGRhdGFbbl07XG4gICAgICAgICAgICAgICAgZGF0YTJbbl0gPSBNYXRoLnJvdW5kKENsYW1wKHYpICogMjU1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBkYXRhMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIGltYWdlXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSByZW5kZXJlci5lbmdpbmUuY3JlYXRlUmF3VGV4dHVyZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCA1LCBmYWxzZSwgIWludmVydFksIDEpO1xuICAgICAgICByZW5kZXJlci5yZW5kZXJlci5zZXRWaWV3cG9ydCgpO1xuICAgICAgICByZW5kZXJlci5yZW5kZXJlci5hcHBseUVmZmVjdFdyYXBwZXIocmVuZGVyZXIud3JhcHBlcik7XG4gICAgICAgIHJlbmRlcmVyLndyYXBwZXIuZWZmZWN0Ll9iaW5kVGV4dHVyZShcInRleHR1cmVTYW1wbGVyXCIsIHRleHR1cmUpO1xuICAgICAgICByZW5kZXJlci5yZW5kZXJlci5kcmF3KCk7XG4gICAgICAgIGlmICh0b0FycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBUb29scy5Ub0Jsb2IocmVuZGVyZXIuY2FudmFzLCAoYmxvYikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICAgICAgICAgIH0sIG1pbWVUeXBlLCBxdWFsaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFRvb2xzLkVuY29kZVNjcmVlbnNob3RDYW52YXNEYXRhKHJlbmRlcmVyLmNhbnZhcywgc3VjY2Vzc0NhbGxiYWNrLCBtaW1lVHlwZSwgZmlsZU5hbWUsIHF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBEaXNwb3NlIHRoZSBkdW1wIHRvb2xzIGFzc29jaWF0ZWQgcmVzb3VyY2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBEaXNwb3NlKCkge1xuICAgIGlmIChEdW1wVG9vbHNFbmdpbmUpIHtcbiAgICAgICAgRHVtcFRvb2xzRW5naW5lLndyYXBwZXIuZGlzcG9zZSgpO1xuICAgICAgICBEdW1wVG9vbHNFbmdpbmUucmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICBEdW1wVG9vbHNFbmdpbmUuZW5naW5lLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGluIGNhc2VzIHdoZXJlIHRoZSBlbmdpbmUgaXMgbm90IHlldCBjcmVhdGVkLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0IHRvIGRpc3Bvc2UgaXRcbiAgICAgICAgRW5naW5lUHJvbWlzZT8udGhlbigoZHVtcFRvb2xzRW5naW5lKSA9PiB7XG4gICAgICAgICAgICBkdW1wVG9vbHNFbmdpbmUud3JhcHBlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICBkdW1wVG9vbHNFbmdpbmUucmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgZHVtcFRvb2xzRW5naW5lLmVuZ2luZS5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBFbmdpbmVQcm9taXNlID0gbnVsbDtcbiAgICBEdW1wVG9vbHNFbmdpbmUgPSBudWxsO1xufVxuLyoqXG4gKiBPYmplY3QgY29udGFpbmluZyBhIHNldCBvZiBzdGF0aWMgdXRpbGl0aWVzIGZ1bmN0aW9ucyB0byBkdW1wIGRhdGEgZnJvbSBhIGNhbnZhc1xuICogQGRlcHJlY2F0ZWQgdXNlIGZ1bmN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgRHVtcFRvb2xzID0ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBEdW1wRGF0YSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgRHVtcERhdGFBc3luYyxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgRHVtcEZyYW1lYnVmZmVyLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBEaXNwb3NlLFxufTtcbi8qKlxuICogVGhpcyB3aWxsIGJlIGV4ZWN1dGVkIGF1dG9tYXRpY2FsbHkgZm9yIFVNRCBhbmQgZXM1LlxuICogSWYgZXNtIGRldiB3YW50cyB0aGUgc2lkZSBlZmZlY3RzIHRvIGV4ZWN1dGUgdGhleSB3aWxsIGhhdmUgdG8gcnVuIGl0IG1hbnVhbGx5XG4gKiBPbmNlIHdlIGJ1aWxkIG5hdGl2ZSBtb2R1bGVzIHRob3NlIG5lZWQgdG8gYmUgZXhwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgSW5pdFNpZGVFZmZlY3RzID0gKCkgPT4ge1xuICAgIC8vIFJlZmVyZW5jZXMgdGhlIGRlcGVuZGVuY2llcy5cbiAgICBUb29scy5EdW1wRGF0YSA9IER1bXBEYXRhO1xuICAgIFRvb2xzLkR1bXBEYXRhQXN5bmMgPSBEdW1wRGF0YUFzeW5jO1xuICAgIFRvb2xzLkR1bXBGcmFtZWJ1ZmZlciA9IER1bXBGcmFtZWJ1ZmZlcjtcbn07XG5Jbml0U2lkZUVmZmVjdHMoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR1bXBUb29scy5qcy5tYXAiLCJpbXBvcnQgeyBUb29scyB9IGZyb20gXCIuL3Rvb2xzLmpzXCI7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSBcIi4uL01hdGhzL21hdGgudmVjdG9yLmpzXCI7XG5pbXBvcnQgeyBJTG9nMiB9IGZyb20gXCIuLi9NYXRocy9tYXRoLnNjYWxhci5mdW5jdGlvbnMuanNcIjtcbmltcG9ydCB7IFNwaGVyaWNhbFBvbHlub21pYWwgfSBmcm9tIFwiLi4vTWF0aHMvc3BoZXJpY2FsUG9seW5vbWlhbC5qc1wiO1xuaW1wb3J0IHsgSW50ZXJuYWxUZXh0dXJlIH0gZnJvbSBcIi4uL01hdGVyaWFscy9UZXh0dXJlcy9pbnRlcm5hbFRleHR1cmUuanNcIjtcbmltcG9ydCB7IEJhc2VUZXh0dXJlIH0gZnJvbSBcIi4uL01hdGVyaWFscy9UZXh0dXJlcy9iYXNlVGV4dHVyZS5qc1wiO1xuXG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gXCIuLi9zY2VuZS5qc1wiO1xuaW1wb3J0IHsgUG9zdFByb2Nlc3MgfSBmcm9tIFwiLi4vUG9zdFByb2Nlc3Nlcy9wb3N0UHJvY2Vzcy5qc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL01pc2MvbG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyBSR0JEVGV4dHVyZVRvb2xzIH0gZnJvbSBcIi4vcmdiZFRleHR1cmVUb29scy5qc1wiO1xuaW1wb3J0IHsgRHVtcERhdGFBc3luYyB9IGZyb20gXCIuLi9NaXNjL2R1bXBUb29scy5qc1wiO1xuaW1wb3J0IFwiLi4vTWF0ZXJpYWxzL1RleHR1cmVzL2Jhc2VUZXh0dXJlLnBvbHlub21pYWwuanNcIjtcbmNvbnN0IERlZmF1bHRFbnZpcm9ubWVudFRleHR1cmVJbWFnZVR5cGUgPSBcImltYWdlL3BuZ1wiO1xuY29uc3QgQ3VycmVudFZlcnNpb24gPSAyO1xuLyoqXG4gKiBNYWdpYyBudW1iZXIgaWRlbnRpZnlpbmcgdGhlIGVudiBmaWxlLlxuICovXG5jb25zdCBNYWdpY0J5dGVzID0gWzB4ODYsIDB4MTYsIDB4ODcsIDB4OTYsIDB4ZjYsIDB4ZDYsIDB4OTYsIDB4MzZdO1xuLyoqXG4gKiBHZXRzIHRoZSBlbnZpcm9ubWVudCBpbmZvIGZyb20gYW4gZW52IGZpbGUuXG4gKiBAcGFyYW0gZGF0YSBUaGUgYXJyYXkgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIC5lbnYgYnl0ZXMuXG4gKiBAcmV0dXJucyB0aGUgZW52aXJvbm1lbnQgZmlsZSBpbmZvICh0aGUganNvbiBoZWFkZXIpIGlmIHN1Y2Nlc3NmdWxseSBwYXJzZWQsIG5vcm1hbGl6ZWQgdG8gdGhlIGxhdGVzdCBzdXBwb3J0ZWQgdmVyc2lvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEdldEVudkluZm8oZGF0YSkge1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYWdpY0J5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50OChwb3MrKykgIT09IE1hZ2ljQnl0ZXNbaV0pIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihcIk5vdCBhIGJhYnlsb24gZW52aXJvbm1lbnQgbWFwXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVhZCBqc29uIG1hbmlmZXN0IC0gY29sbGVjdCBjaGFyYWN0ZXJzIHVwIHRvIG51bGwgdGVybWluYXRvclxuICAgIGxldCBtYW5pZmVzdFN0cmluZyA9IFwiXCI7XG4gICAgbGV0IGNoYXJDb2RlID0gMHgwMDtcbiAgICB3aGlsZSAoKGNoYXJDb2RlID0gZGF0YVZpZXcuZ2V0VWludDgocG9zKyspKSkge1xuICAgICAgICBtYW5pZmVzdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICB9XG4gICAgbGV0IG1hbmlmZXN0ID0gSlNPTi5wYXJzZShtYW5pZmVzdFN0cmluZyk7XG4gICAgbWFuaWZlc3QgPSBub3JtYWxpemVFbnZJbmZvKG1hbmlmZXN0KTtcbiAgICAvLyBFeHRlbmQgdGhlIGhlYWRlciB3aXRoIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGF5bG9hZC5cbiAgICBtYW5pZmVzdC5iaW5hcnlEYXRhUG9zaXRpb24gPSBwb3M7XG4gICAgaWYgKG1hbmlmZXN0LnNwZWN1bGFyKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIDAuOCBleGFjdGx5IGlmIGxvZEdlbmVyYXRpb25TY2FsZSBpcyBub3QgZGVmaW5lZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgbWFuaWZlc3Quc3BlY3VsYXIubG9kR2VuZXJhdGlvblNjYWxlID0gbWFuaWZlc3Quc3BlY3VsYXIubG9kR2VuZXJhdGlvblNjYWxlIHx8IDAuODtcbiAgICB9XG4gICAgcmV0dXJuIG1hbmlmZXN0O1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIGFueSBzdXBwb3J0ZWQgdmVyc2lvbiBvZiB0aGUgZW52aXJvbm1lbnQgZmlsZSBpbmZvIHRvIHRoZSBsYXRlc3QgdmVyc2lvblxuICogQHBhcmFtIGluZm8gZW52aXJvbm1lbnQgZmlsZSBpbmZvIG9uIGFueSBzdXBwb3J0ZWQgdmVyc2lvblxuICogQHJldHVybnMgZW52aXJvbm1lbnQgZmlsZSBpbmZvIGluIHRoZSBsYXRlc3Qgc3VwcG9ydGVkIHZlcnNpb25cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVFbnZJbmZvKGluZm8pIHtcbiAgICBpZiAoaW5mby52ZXJzaW9uID4gQ3VycmVudFZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBiYWJ5bG9uIGVudmlyb25tZW50IG1hcCB2ZXJzaW9uIFwiJHtpbmZvLnZlcnNpb259XCIuIExhdGVzdCBzdXBwb3J0ZWQgdmVyc2lvbiBpcyBcIiR7Q3VycmVudFZlcnNpb259XCIuYCk7XG4gICAgfVxuICAgIGlmIChpbmZvLnZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICAgIC8vIE1pZ3JhdGUgYSB2MSBpbmZvIHRvIHYyXG4gICAgaW5mbyA9IHsgLi4uaW5mbywgdmVyc2lvbjogMiwgaW1hZ2VUeXBlOiBEZWZhdWx0RW52aXJvbm1lbnRUZXh0dXJlSW1hZ2VUeXBlIH07XG4gICAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gZW52aXJvbm1lbnQgdGV4dHVyZSBmcm9tIGEgbG9hZGVkIGN1YmUgdGV4dHVyZS5cbiAqIEBwYXJhbSB0ZXh0dXJlIGRlZmluZXMgdGhlIGN1YmUgdGV4dHVyZSB0byBjb252ZXJ0IGluIGVudiBmaWxlXG4gKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGUgY29udmVyc2lvbiBwcm9jZXNzXG4gKiBAcGFyYW0gb3B0aW9ucy5pbWFnZVR5cGUgdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGVuY29kZWQgaW1hZ2VzLCB3aXRoIHN1cHBvcnQgZm9yIFwiaW1hZ2UvcG5nXCIgKGRlZmF1bHQpIGFuZCBcImltYWdlL3dlYnBcIlxuICogQHBhcmFtIG9wdGlvbnMuaW1hZ2VRdWFsaXR5IHRoZSBpbWFnZSBxdWFsaXR5IG9mIGVuY29kZWQgV2ViUCBpbWFnZXMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgY29udGFpbmluZyB0aGUgZW52aXJvbm1lbnQgZGF0YSBpZiBzdWNjZXNzZnVsLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gQ3JlYXRlRW52VGV4dHVyZUFzeW5jKHRleHR1cmUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGludGVybmFsVGV4dHVyZSA9IHRleHR1cmUuZ2V0SW50ZXJuYWxUZXh0dXJlKCk7XG4gICAgaWYgKCFpbnRlcm5hbFRleHR1cmUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiVGhlIGN1YmUgdGV4dHVyZSBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgZW5naW5lID0gaW50ZXJuYWxUZXh0dXJlLmdldEVuZ2luZSgpO1xuICAgIGlmICh0ZXh0dXJlLnRleHR1cmVUeXBlICE9PSAyICYmXG4gICAgICAgIHRleHR1cmUudGV4dHVyZVR5cGUgIT09IDEgJiZcbiAgICAgICAgdGV4dHVyZS50ZXh0dXJlVHlwZSAhPT0gMCAmJlxuICAgICAgICB0ZXh0dXJlLnRleHR1cmVUeXBlICE9PSAwICYmXG4gICAgICAgIHRleHR1cmUudGV4dHVyZVR5cGUgIT09IDcgJiZcbiAgICAgICAgdGV4dHVyZS50ZXh0dXJlVHlwZSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiVGhlIGN1YmUgdGV4dHVyZSBzaG91bGQgYWxsb3cgSERSIChGdWxsIEZsb2F0IG9yIEhhbGYgRmxvYXQpLlwiKTtcbiAgICB9XG4gICAgbGV0IHRleHR1cmVUeXBlID0gMTtcbiAgICBpZiAoIWVuZ2luZS5nZXRDYXBzKCkudGV4dHVyZUZsb2F0UmVuZGVyKSB7XG4gICAgICAgIHRleHR1cmVUeXBlID0gMjtcbiAgICAgICAgaWYgKCFlbmdpbmUuZ2V0Q2FwcygpLnRleHR1cmVIYWxmRmxvYXRSZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIkVudiB0ZXh0dXJlIGNhbiBvbmx5IGJlIGNyZWF0ZWQgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBoYWxmIGZsb2F0IG9yIGZ1bGwgZmxvYXQgcmVuZGVyaW5nLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzcGhlcmljYWxQb2x5bm9taWFsIGlzIGxhenkgbG9hZGVkIHNvIHNpbXBseSBhY2Nlc3NpbmcgaXQgc2hvdWxkIHRyaWdnZXIgdGhlIGNvbXB1dGF0aW9uLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgdGV4dHVyZS5zcGhlcmljYWxQb2x5bm9taWFsO1xuICAgIC8vIExldHMga2VlcCB0cmFjayBvZiB0aGUgcG9seW5vbWlhbCBwcm9taXNlIHNvIHdlIGNhbiB3YWl0IGZvciBpdCB0byBiZSByZWFkeSBiZWZvcmUgZ2VuZXJhdGluZyB0aGUgcGl4ZWxzLlxuICAgIGNvbnN0IHNwaGVyaWNhbFBvbHlub21pYWxQcm9taXNlID0gdGV4dHVyZS5nZXRJbnRlcm5hbFRleHR1cmUoKT8uX3NwaGVyaWNhbFBvbHlub21pYWxQcm9taXNlO1xuICAgIGNvbnN0IGN1YmVXaWR0aCA9IGludGVybmFsVGV4dHVyZS53aWR0aDtcbiAgICBjb25zdCBob3N0aW5nU2NlbmUgPSBuZXcgU2NlbmUoZW5naW5lKTtcbiAgICBjb25zdCBzcGVjdWxhclRleHR1cmVzID0ge307XG4gICAgY29uc3QgZGlmZnVzZVRleHR1cmVzID0ge307XG4gICAgLy8gQXMgd2UgYXJlIGdvaW5nIHRvIHJlYWRQaXhlbHMgdGhlIGZhY2VzIG9mIHRoZSBjdWJlLCBtYWtlIHN1cmUgdGhlIGRyYXdpbmcvdXBkYXRlIGNvbW1hbmRzIGZvciB0aGUgY3ViZSB0ZXh0dXJlIGFyZSBmdWxseSBzZW50IHRvIHRoZSBHUFUgaW4gY2FzZSBpdCBpcyBkcmF3biBmb3IgdGhlIGZpcnN0IHRpbWUgaW4gdGhpcyB2ZXJ5IGZyYW1lIVxuICAgIGVuZ2luZS5mbHVzaEZyYW1lYnVmZmVyKCk7XG4gICAgY29uc3QgaW1hZ2VUeXBlID0gb3B0aW9ucy5pbWFnZVR5cGUgPz8gRGVmYXVsdEVudmlyb25tZW50VGV4dHVyZUltYWdlVHlwZTtcbiAgICAvLyBSZWFkIGFuZCBjb2xsZWN0IGFsbCBtaXBtYXBzIGRhdGEgZnJvbSB0aGUgY3ViZS5cbiAgICBjb25zdCBtaXBtYXBzQ291bnQgPSBJTG9nMihpbnRlcm5hbFRleHR1cmUud2lkdGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1pcG1hcHNDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZhY2VXaWR0aCA9IE1hdGgucG93KDIsIG1pcG1hcHNDb3VudCAtIGkpO1xuICAgICAgICAvLyBBbGwgZmFjZXMgb2YgdGhlIGN1YmUuXG4gICAgICAgIGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgNjsgZmFjZSsrKSB7XG4gICAgICAgICAgICBzcGVjdWxhclRleHR1cmVzW2kgKiA2ICsgZmFjZV0gPSBhd2FpdCBfR2V0VGV4dHVyZUVuY29kZWREYXRhQXN5bmMoaG9zdGluZ1NjZW5lLCB0ZXh0dXJlLCB0ZXh0dXJlVHlwZSwgZmFjZSwgaSwgZmFjZVdpZHRoLCBpbWFnZVR5cGUsIG9wdGlvbnMuaW1hZ2VRdWFsaXR5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZWFkIGFuZCBjb2xsZWN0IGFsbCBpcnJhZGlhbmNlIGRhdGEgZnJvbSB0aGUgY3ViZS5cbiAgICBjb25zdCBpcnJhZGlhbmNlVGV4dHVyZSA9IG9wdGlvbnMuZGlzYWJsZUlycmFkaWFuY2VUZXh0dXJlID8gbnVsbCA6IHRleHR1cmUuaXJyYWRpYW5jZVRleHR1cmU7XG4gICAgaWYgKGlycmFkaWFuY2VUZXh0dXJlKSB7XG4gICAgICAgIGNvbnN0IGZhY2VXaWR0aCA9IGlycmFkaWFuY2VUZXh0dXJlLmdldFNpemUoKS53aWR0aDtcbiAgICAgICAgLy8gQWxsIGZhY2VzIG9mIHRoZSBjdWJlLlxuICAgICAgICBmb3IgKGxldCBmYWNlID0gMDsgZmFjZSA8IDY7IGZhY2UrKykge1xuICAgICAgICAgICAgZGlmZnVzZVRleHR1cmVzW2ZhY2VdID0gYXdhaXQgX0dldFRleHR1cmVFbmNvZGVkRGF0YUFzeW5jKGhvc3RpbmdTY2VuZSwgaXJyYWRpYW5jZVRleHR1cmUsIHRleHR1cmVUeXBlLCBmYWNlLCAwLCBmYWNlV2lkdGgsIGltYWdlVHlwZSwgb3B0aW9ucy5pbWFnZVF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFdlIGNhbiBkZWxldGUgdGhlIGhvc3Rpbmcgc2NlbmUga2VlcGluZyB0cmFjayBvZiBhbGwgdGhlIGNyZWF0aW9uIG9iamVjdHNcbiAgICBob3N0aW5nU2NlbmUuZGlzcG9zZSgpO1xuICAgIC8vIEVuc3VyZSBjb21wbGV0aW9uIG9mIHRoZSBwb2x5bm9taWFsIGNyZWF0aW9uIHByb21pc2UuXG4gICAgaWYgKHNwaGVyaWNhbFBvbHlub21pYWxQcm9taXNlKSB7XG4gICAgICAgIGF3YWl0IHNwaGVyaWNhbFBvbHlub21pYWxQcm9taXNlO1xuICAgIH1cbiAgICAvLyBDcmVhdGVzIHRoZSBqc29uIGhlYWRlciBmb3IgdGhlIGVudiB0ZXh0dXJlXG4gICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgdmVyc2lvbjogQ3VycmVudFZlcnNpb24sXG4gICAgICAgIHdpZHRoOiBjdWJlV2lkdGgsXG4gICAgICAgIGltYWdlVHlwZSxcbiAgICAgICAgaXJyYWRpYW5jZTogQ3JlYXRlRW52VGV4dHVyZUlycmFkaWFuY2UodGV4dHVyZSksXG4gICAgICAgIHNwZWN1bGFyOiB7XG4gICAgICAgICAgICBtaXBtYXBzOiBbXSxcbiAgICAgICAgICAgIGxvZEdlbmVyYXRpb25TY2FsZTogdGV4dHVyZS5sb2RHZW5lcmF0aW9uU2NhbGUsXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvLyBTZXRzIHRoZSBzcGVjdWxhciBpbWFnZSBkYXRhIGluZm9ybWF0aW9uXG4gICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtaXBtYXBzQ291bnQ7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBmYWNlID0gMDsgZmFjZSA8IDY7IGZhY2UrKykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IHNwZWN1bGFyVGV4dHVyZXNbaSAqIDYgKyBmYWNlXS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaW5mby5zcGVjdWxhci5taXBtYXBzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxlbmd0aDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IGJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU2V0cyB0aGUgaXJyYWRpYW5jZSBpbWFnZSBkYXRhIGluZm9ybWF0aW9uXG4gICAgaWYgKGlycmFkaWFuY2VUZXh0dXJlKSB7XG4gICAgICAgIGluZm8uaXJyYWRpYW5jZSA9IGluZm8uaXJyYWRpYW5jZSB8fCB7XG4gICAgICAgICAgICB4OiBbMCwgMCwgMF0sXG4gICAgICAgICAgICB4eDogWzAsIDAsIDBdLFxuICAgICAgICAgICAgeTogWzAsIDAsIDBdLFxuICAgICAgICAgICAgeXk6IFswLCAwLCAwXSxcbiAgICAgICAgICAgIHo6IFswLCAwLCAwXSxcbiAgICAgICAgICAgIHp6OiBbMCwgMCwgMF0sXG4gICAgICAgICAgICB5ejogWzAsIDAsIDBdLFxuICAgICAgICAgICAgeng6IFswLCAwLCAwXSxcbiAgICAgICAgICAgIHh5OiBbMCwgMCwgMF0sXG4gICAgICAgIH07XG4gICAgICAgIGluZm8uaXJyYWRpYW5jZS5pcnJhZGlhbmNlVGV4dHVyZSA9IHtcbiAgICAgICAgICAgIHNpemU6IGlycmFkaWFuY2VUZXh0dXJlLmdldFNpemUoKS53aWR0aCxcbiAgICAgICAgICAgIGZhY2VzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCA2OyBmYWNlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBkaWZmdXNlVGV4dHVyZXNbZmFjZV0uYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGluZm8uaXJyYWRpYW5jZS5pcnJhZGlhbmNlVGV4dHVyZS5mYWNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb3NpdGlvbiArPSBieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEVuY29kZSB0aGUgSlNPTiBhcyBhbiBhcnJheSBidWZmZXJcbiAgICBjb25zdCBpbmZvU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoaW5mbyk7XG4gICAgY29uc3QgaW5mb0J1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihpbmZvU3RyaW5nLmxlbmd0aCArIDEpO1xuICAgIGNvbnN0IGluZm9WaWV3ID0gbmV3IFVpbnQ4QXJyYXkoaW5mb0J1ZmZlcik7IC8vIExpbWl0ZWQgdG8gYXNjaWkgc3Vic2V0IG1hdGNoaW5nIHVuaWNvZGUuXG4gICAgZm9yIChsZXQgaSA9IDAsIHN0ckxlbiA9IGluZm9TdHJpbmcubGVuZ3RoOyBpIDwgc3RyTGVuOyBpKyspIHtcbiAgICAgICAgaW5mb1ZpZXdbaV0gPSBpbmZvU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIC8vIEVuZHMgdXAgd2l0aCBhIG51bGwgdGVybWluYXRvciBmb3IgZWFzaWVyIHBhcnNpbmdcbiAgICBpbmZvVmlld1tpbmZvU3RyaW5nLmxlbmd0aF0gPSAweDAwO1xuICAgIC8vIENvbXB1dGVzIHRoZSBmaW5hbCByZXF1aXJlZCBzaXplIGFuZCBjcmVhdGVzIHRoZSBzdG9yYWdlXG4gICAgY29uc3QgdG90YWxTaXplID0gTWFnaWNCeXRlcy5sZW5ndGggKyBwb3NpdGlvbiArIGluZm9CdWZmZXIuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBmaW5hbEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0b3RhbFNpemUpO1xuICAgIGNvbnN0IGZpbmFsQnVmZmVyVmlldyA9IG5ldyBVaW50OEFycmF5KGZpbmFsQnVmZmVyKTtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhmaW5hbEJ1ZmZlcik7XG4gICAgLy8gQ29weSB0aGUgbWFnaWMgYnl0ZXMgaWRlbnRpZnlpbmcgdGhlIGZpbGUgaW5cbiAgICBsZXQgcG9zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hZ2ljQnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVZpZXcuc2V0VWludDgocG9zKyssIE1hZ2ljQnl0ZXNbaV0pO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGpzb24gaW5mb1xuICAgIGZpbmFsQnVmZmVyVmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoaW5mb0J1ZmZlciksIHBvcyk7XG4gICAgcG9zICs9IGluZm9CdWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAvLyBGaW5hbGx5IGluc2VydHMgdGhlIHJhZGlhbmNlIHRleHR1cmUgZGF0YVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1pcG1hcHNDb3VudDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgNjsgZmFjZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhQnVmZmVyID0gc3BlY3VsYXJUZXh0dXJlc1tpICogNiArIGZhY2VdO1xuICAgICAgICAgICAgZmluYWxCdWZmZXJWaWV3LnNldChuZXcgVWludDhBcnJheShkYXRhQnVmZmVyKSwgcG9zKTtcbiAgICAgICAgICAgIHBvcyArPSBkYXRhQnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluYWxseSBpbnNlcnRzIHRoZSBpcnJhZGlhbmNlIHRleHR1cmUgZGF0YVxuICAgIGlmIChpcnJhZGlhbmNlVGV4dHVyZSkge1xuICAgICAgICBmb3IgKGxldCBmYWNlID0gMDsgZmFjZSA8IDY7IGZhY2UrKykge1xuICAgICAgICAgICAgY29uc3QgZGF0YUJ1ZmZlciA9IGRpZmZ1c2VUZXh0dXJlc1tmYWNlXTtcbiAgICAgICAgICAgIGZpbmFsQnVmZmVyVmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoZGF0YUJ1ZmZlciksIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gZGF0YUJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFZvaWxhXG4gICAgcmV0dXJuIGZpbmFsQnVmZmVyO1xufVxuLyoqXG4gKiBHZXQgdGhlIHRleHR1cmUgZW5jb2RlZCBkYXRhIGZyb20gdGhlIGN1cnJlbnQgdGV4dHVyZVxuICogQGludGVybmFsXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9HZXRUZXh0dXJlRW5jb2RlZERhdGFBc3luYyhob3N0aW5nU2NlbmUsIHRleHR1cmUsIHRleHR1cmVUeXBlLCBmYWNlLCBpLCBzaXplLCBpbWFnZVR5cGUsIGltYWdlUXVhbGl0eSkge1xuICAgIGxldCBmYWNlRGF0YSA9IGF3YWl0IHRleHR1cmUucmVhZFBpeGVscyhmYWNlLCBpLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICBpZiAoZmFjZURhdGEgJiYgZmFjZURhdGEuYnl0ZUxlbmd0aCA9PT0gZmFjZURhdGEubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZhY2VEYXRhRmxvYXQgPSBuZXcgRmxvYXQzMkFycmF5KGZhY2VEYXRhLmJ5dGVMZW5ndGggKiA0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNlRGF0YS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZhY2VEYXRhRmxvYXRbaV0gPSBmYWNlRGF0YVtpXSAvIDI1NTtcbiAgICAgICAgICAgIC8vIEdhbW1hIHRvIGxpbmVhclxuICAgICAgICAgICAgZmFjZURhdGFGbG9hdFtpXSA9IE1hdGgucG93KGZhY2VEYXRhRmxvYXRbaV0sIDIuMik7XG4gICAgICAgIH1cbiAgICAgICAgZmFjZURhdGEgPSBmYWNlRGF0YUZsb2F0O1xuICAgIH1cbiAgICBlbHNlIGlmIChmYWNlRGF0YSAmJiB0ZXh0dXJlLmdhbW1hU3BhY2UpIHtcbiAgICAgICAgY29uc3QgZmxvYXREYXRhID0gZmFjZURhdGE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmxvYXREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBHYW1tYSB0byBsaW5lYXJcbiAgICAgICAgICAgIGZsb2F0RGF0YVtpXSA9IE1hdGgucG93KGZsb2F0RGF0YVtpXSwgMi4yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbmdpbmUgPSBob3N0aW5nU2NlbmUuZ2V0RW5naW5lKCk7XG4gICAgY29uc3QgdGVtcFRleHR1cmUgPSBlbmdpbmUuY3JlYXRlUmF3VGV4dHVyZShmYWNlRGF0YSwgc2l6ZSwgc2l6ZSwgNSwgZmFsc2UsIHRydWUsIDEsIG51bGwsIHRleHR1cmVUeXBlKTtcbiAgICBhd2FpdCBSR0JEVGV4dHVyZVRvb2xzLkVuY29kZVRleHR1cmVUb1JHQkQodGVtcFRleHR1cmUsIGhvc3RpbmdTY2VuZSwgdGV4dHVyZVR5cGUpO1xuICAgIGNvbnN0IHJnYmRFbmNvZGVkRGF0YSA9IGF3YWl0IGVuZ2luZS5fcmVhZFRleHR1cmVQaXhlbHModGVtcFRleHR1cmUsIHNpemUsIHNpemUpO1xuICAgIGNvbnN0IGltYWdlRW5jb2RlZERhdGEgPSBhd2FpdCBEdW1wRGF0YUFzeW5jKHNpemUsIHNpemUsIHJnYmRFbmNvZGVkRGF0YSwgaW1hZ2VUeXBlLCB1bmRlZmluZWQsIGZhbHNlLCB0cnVlLCBpbWFnZVF1YWxpdHkpO1xuICAgIHRlbXBUZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICByZXR1cm4gaW1hZ2VFbmNvZGVkRGF0YTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwaGVyaWNhbCBkYXRhLlxuICogQHBhcmFtIHRleHR1cmUgZGVmaW5lcyB0aGUgdGV4dHVyZSBjb250YWluaW5nIHRoZSBwb2x5bm9taWFsc1xuICogQHJldHVybnMgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwaGVyaWNhbCBpbmZvXG4gKi9cbmZ1bmN0aW9uIENyZWF0ZUVudlRleHR1cmVJcnJhZGlhbmNlKHRleHR1cmUpIHtcbiAgICBjb25zdCBwb2x5bm1pYWxzID0gdGV4dHVyZS5zcGhlcmljYWxQb2x5bm9taWFsO1xuICAgIGlmIChwb2x5bm1pYWxzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IFtwb2x5bm1pYWxzLngueCwgcG9seW5taWFscy54LnksIHBvbHlubWlhbHMueC56XSxcbiAgICAgICAgeTogW3BvbHlubWlhbHMueS54LCBwb2x5bm1pYWxzLnkueSwgcG9seW5taWFscy55LnpdLFxuICAgICAgICB6OiBbcG9seW5taWFscy56LngsIHBvbHlubWlhbHMuei55LCBwb2x5bm1pYWxzLnouel0sXG4gICAgICAgIHh4OiBbcG9seW5taWFscy54eC54LCBwb2x5bm1pYWxzLnh4LnksIHBvbHlubWlhbHMueHguel0sXG4gICAgICAgIHl5OiBbcG9seW5taWFscy55eS54LCBwb2x5bm1pYWxzLnl5LnksIHBvbHlubWlhbHMueXkuel0sXG4gICAgICAgIHp6OiBbcG9seW5taWFscy56ei54LCBwb2x5bm1pYWxzLnp6LnksIHBvbHlubWlhbHMuenouel0sXG4gICAgICAgIHl6OiBbcG9seW5taWFscy55ei54LCBwb2x5bm1pYWxzLnl6LnksIHBvbHlubWlhbHMueXouel0sXG4gICAgICAgIHp4OiBbcG9seW5taWFscy56eC54LCBwb2x5bm1pYWxzLnp4LnksIHBvbHlubWlhbHMuenguel0sXG4gICAgICAgIHh5OiBbcG9seW5taWFscy54eS54LCBwb2x5bm1pYWxzLnh5LnksIHBvbHlubWlhbHMueHkuel0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyB0aGUgQXJyYXlCdWZmZXJWaWV3cyB1c2VkIGZvciBpbml0aWFsaXppbmcgZW52aXJvbm1lbnQgdGV4dHVyZSBpbWFnZSBkYXRhLlxuICogQHBhcmFtIGRhdGEgdGhlIGltYWdlIGRhdGFcbiAqIEBwYXJhbSBpbmZvIHBhcmFtZXRlcnMgdGhhdCBkZXRlcm1pbmUgd2hhdCB2aWV3cyB3aWxsIGJlIGNyZWF0ZWQgZm9yIGFjY2Vzc2luZyB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAqIEByZXR1cm5zIHRoZSB2aWV3cyBkZXNjcmliZWQgYnkgaW5mbyBwcm92aWRpbmcgYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlUmFkaWFuY2VJbWFnZURhdGFBcnJheUJ1ZmZlclZpZXdzKGRhdGEsIGluZm8pIHtcbiAgICBpbmZvID0gbm9ybWFsaXplRW52SW5mbyhpbmZvKTtcbiAgICBjb25zdCBzcGVjdWxhckluZm8gPSBpbmZvLnNwZWN1bGFyO1xuICAgIC8vIERvdWJsZSBjaGVja3MgdGhlIGVuY2xvc2VkIGluZm9cbiAgICBsZXQgbWlwbWFwc0NvdW50ID0gTWF0aC5sb2cyKGluZm8ud2lkdGgpO1xuICAgIG1pcG1hcHNDb3VudCA9IE1hdGgucm91bmQobWlwbWFwc0NvdW50KSArIDE7XG4gICAgaWYgKHNwZWN1bGFySW5mby5taXBtYXBzLmxlbmd0aCAhPT0gNiAqIG1pcG1hcHNDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNwZWN1bGFyIG1pcG1hcHMgbnVtYmVyIFwiJHtzcGVjdWxhckluZm8ubWlwbWFwcy5sZW5ndGh9XCJgKTtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IEFycmF5KG1pcG1hcHNDb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaXBtYXBzQ291bnQ7IGkrKykge1xuICAgICAgICBpbWFnZURhdGFbaV0gPSBuZXcgQXJyYXkoNik7XG4gICAgICAgIGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgNjsgZmFjZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZUluZm8gPSBzcGVjdWxhckluZm8ubWlwbWFwc1tpICogNiArIGZhY2VdO1xuICAgICAgICAgICAgaW1hZ2VEYXRhW2ldW2ZhY2VdID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCArIGluZm8uYmluYXJ5RGF0YVBvc2l0aW9uICsgaW1hZ2VJbmZvLnBvc2l0aW9uLCBpbWFnZUluZm8ubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VEYXRhO1xufVxuLyoqXG4gKiBDcmVhdGVzIHRoZSBBcnJheUJ1ZmZlclZpZXdzIHVzZWQgZm9yIGluaXRpYWxpemluZyBlbnZpcm9ubWVudCB0ZXh0dXJlIGltYWdlIGRhdGEuXG4gKiBAcGFyYW0gZGF0YSB0aGUgaW1hZ2UgZGF0YVxuICogQHBhcmFtIGluZm8gcGFyYW1ldGVycyB0aGF0IGRldGVybWluZSB3aGF0IHZpZXdzIHdpbGwgYmUgY3JlYXRlZCBmb3IgYWNjZXNzaW5nIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICogQHJldHVybnMgdGhlIHZpZXdzIGRlc2NyaWJlZCBieSBpbmZvIHByb3ZpZGluZyBhY2Nlc3MgdG8gdGhlIHVuZGVybHlpbmcgYnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDcmVhdGVJcnJhZGlhbmNlSW1hZ2VEYXRhQXJyYXlCdWZmZXJWaWV3cyhkYXRhLCBpbmZvKSB7XG4gICAgaW5mbyA9IG5vcm1hbGl6ZUVudkluZm8oaW5mbyk7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IEFycmF5KDYpO1xuICAgIGNvbnN0IGlycmFkaWFuY2VUZXh0dXJlID0gaW5mby5pcnJhZGlhbmNlPy5pcnJhZGlhbmNlVGV4dHVyZTtcbiAgICBpZiAoaXJyYWRpYW5jZVRleHR1cmUpIHtcbiAgICAgICAgaWYgKGlycmFkaWFuY2VUZXh0dXJlLmZhY2VzLmxlbmd0aCAhPT0gNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvcnJlY3QgaXJyYWRpYW5jZSB0ZXh0dXJlIGZhY2VzIG51bWJlciBcIiR7aXJyYWRpYW5jZVRleHR1cmUuZmFjZXMubGVuZ3RofVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCA2OyBmYWNlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlSW5mbyA9IGlycmFkaWFuY2VUZXh0dXJlLmZhY2VzW2ZhY2VdO1xuICAgICAgICAgICAgaW1hZ2VEYXRhW2ZhY2VdID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCArIGluZm8uYmluYXJ5RGF0YVBvc2l0aW9uICsgaW1hZ2VJbmZvLnBvc2l0aW9uLCBpbWFnZUluZm8ubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VEYXRhO1xufVxuLyoqXG4gKiBVcGxvYWRzIHRoZSB0ZXh0dXJlIGluZm8gY29udGFpbmVkIGluIHRoZSBlbnYgZmlsZSB0byB0aGUgR1BVLlxuICogQHBhcmFtIHRleHR1cmUgZGVmaW5lcyB0aGUgaW50ZXJuYWwgdGV4dHVyZSB0byB1cGxvYWQgdG9cbiAqIEBwYXJhbSBkYXRhIGRlZmluZXMgdGhlIGRhdGEgdG8gbG9hZFxuICogQHBhcmFtIGluZm8gZGVmaW5lcyB0aGUgdGV4dHVyZSBpbmZvIHJldHJpZXZlZCB0aHJvdWdoIHRoZSBHZXRFbnZJbmZvIG1ldGhvZFxuICogQHJldHVybnMgYSBwcm9taXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBVcGxvYWRFbnZMZXZlbHNBc3luYyh0ZXh0dXJlLCBkYXRhLCBpbmZvKSB7XG4gICAgaW5mbyA9IG5vcm1hbGl6ZUVudkluZm8oaW5mbyk7XG4gICAgY29uc3Qgc3BlY3VsYXJJbmZvID0gaW5mby5zcGVjdWxhcjtcbiAgICBpZiAoIXNwZWN1bGFySW5mbykge1xuICAgICAgICAvLyBOb3RoaW5nIGVsc2UgcGFyc2VkIHNvIGZhclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gICAgdGV4dHVyZS5fbG9kR2VuZXJhdGlvblNjYWxlID0gc3BlY3VsYXJJbmZvLmxvZEdlbmVyYXRpb25TY2FsZTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IHJhZGlhbmNlSW1hZ2VEYXRhID0gQ3JlYXRlUmFkaWFuY2VJbWFnZURhdGFBcnJheUJ1ZmZlclZpZXdzKGRhdGEsIGluZm8pO1xuICAgIHByb21pc2VzLnB1c2goVXBsb2FkUmFkaWFuY2VMZXZlbHNBc3luYyh0ZXh0dXJlLCByYWRpYW5jZUltYWdlRGF0YSwgaW5mby5pbWFnZVR5cGUpKTtcbiAgICBjb25zdCBpcnJhZGlhbmNlVGV4dHVyZSA9IGluZm8uaXJyYWRpYW5jZT8uaXJyYWRpYW5jZVRleHR1cmU7XG4gICAgaWYgKGlycmFkaWFuY2VUZXh0dXJlKSB7XG4gICAgICAgIGNvbnN0IGlycmFkaWFuY2VJbWFnZURhdGEgPSBDcmVhdGVJcnJhZGlhbmNlSW1hZ2VEYXRhQXJyYXlCdWZmZXJWaWV3cyhkYXRhLCBpbmZvKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChVcGxvYWRJcnJhZGlhbmNlTGV2ZWxzQXN5bmModGV4dHVyZSwgaXJyYWRpYW5jZUltYWdlRGF0YSwgaXJyYWRpYW5jZVRleHR1cmUuc2l6ZSwgaW5mby5pbWFnZVR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9PbkltYWdlUmVhZHlBc3luYyhpbWFnZSwgZW5naW5lLCBleHBhbmRUZXh0dXJlLCByZ2JkUG9zdFByb2Nlc3MsIHVybCwgZmFjZSwgaSwgZ2VuZXJhdGVOb25MT0RUZXh0dXJlcywgbG9kVGV4dHVyZXMsIGN1YmVSdHQsIHRleHR1cmUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAoZXhwYW5kVGV4dHVyZSkge1xuICAgICAgICAgICAgY29uc3QgdGVtcFRleHR1cmUgPSBlbmdpbmUuY3JlYXRlVGV4dHVyZShudWxsLCB0cnVlLCB0cnVlLCBudWxsLCAxLCBudWxsLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sIGltYWdlKTtcbiAgICAgICAgICAgIHJnYmRQb3N0UHJvY2Vzcz8ub25FZmZlY3RDcmVhdGVkT2JzZXJ2YWJsZS5hZGRPbmNlKChlZmZlY3QpID0+IHtcbiAgICAgICAgICAgICAgICBlZmZlY3QuZXhlY3V0ZVdoZW5Db21waWxlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuY29tcHJlc3MgdGhlIGRhdGEgdG8gYSBSVFRcbiAgICAgICAgICAgICAgICAgICAgcmdiZFBvc3RQcm9jZXNzLmV4dGVybmFsVGV4dHVyZVNhbXBsZXJCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmdiZFBvc3RQcm9jZXNzLm9uQXBwbHkgPSAoZWZmZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3QuX2JpbmRUZXh0dXJlKFwidGV4dHVyZVNhbXBsZXJcIiwgdGVtcFRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0LnNldEZsb2F0MihcInNjYWxlXCIsIDEsIGVuZ2luZS5fZmVhdHVyZXMubmVlZHNJbnZlcnRpbmdCaXRtYXAgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5naW5lLnNjZW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbmdpbmUuc2NlbmVzWzBdLnBvc3RQcm9jZXNzTWFuYWdlci5kaXJlY3RSZW5kZXIoW3JnYmRQb3N0UHJvY2Vzc10sIGN1YmVSdHQsIHRydWUsIGZhY2UsIGkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhbnVwXG4gICAgICAgICAgICAgICAgICAgIGVuZ2luZS5yZXN0b3JlRGVmYXVsdEZyYW1lYnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBUZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZ2luZS5fdXBsb2FkSW1hZ2VUb1RleHR1cmUodGV4dHVyZSwgaW1hZ2UsIGZhY2UsIGkpO1xuICAgICAgICAgICAgLy8gVXBsb2FkIHRoZSBmYWNlIHRvIHRoZSBub24gbG9kIHRleHR1cmUgc3VwcG9ydFxuICAgICAgICAgICAgaWYgKGdlbmVyYXRlTm9uTE9EVGV4dHVyZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2RUZXh0dXJlID0gbG9kVGV4dHVyZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGxvZFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5naW5lLl91cGxvYWRJbWFnZVRvVGV4dHVyZShsb2RUZXh0dXJlLl90ZXh0dXJlLCBpbWFnZSwgZmFjZSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFVwbG9hZHMgdGhlIGxldmVscyBvZiBpbWFnZSBkYXRhIHRvIHRoZSBHUFUuXG4gKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSBpbnRlcm5hbCB0ZXh0dXJlIHRvIHVwbG9hZCB0b1xuICogQHBhcmFtIGltYWdlRGF0YSBkZWZpbmVzIHRoZSBhcnJheSBidWZmZXIgdmlld3Mgb2YgaW1hZ2UgZGF0YSBbbWlwbWFwXVtmYWNlXVxuICogQHBhcmFtIGltYWdlVHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBkYXRhXG4gKiBAcmV0dXJucyBhIHByb21pc2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFVwbG9hZFJhZGlhbmNlTGV2ZWxzQXN5bmModGV4dHVyZSwgaW1hZ2VEYXRhLCBpbWFnZVR5cGUgPSBEZWZhdWx0RW52aXJvbm1lbnRUZXh0dXJlSW1hZ2VUeXBlKSB7XG4gICAgY29uc3QgZW5naW5lID0gdGV4dHVyZS5nZXRFbmdpbmUoKTtcbiAgICB0ZXh0dXJlLmZvcm1hdCA9IDU7XG4gICAgdGV4dHVyZS50eXBlID0gMDtcbiAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwTWFwcyA9IHRydWU7XG4gICAgdGV4dHVyZS5fY2FjaGVkQW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCA9IG51bGw7XG4gICAgZW5naW5lLnVwZGF0ZVRleHR1cmVTYW1wbGluZ01vZGUoMywgdGV4dHVyZSk7XG4gICAgYXdhaXQgX1VwbG9hZExldmVsc0FzeW5jKHRleHR1cmUsIGltYWdlRGF0YSwgdHJ1ZSwgaW1hZ2VUeXBlKTtcbiAgICAvLyBGbGFnIGludGVybmFsIHRleHR1cmUgYXMgcmVhZHkgaW4gY2FzZSB0aGV5IGFyZSBpbiB1c2UuXG4gICAgdGV4dHVyZS5pc1JlYWR5ID0gdHJ1ZTtcbn1cbi8qKlxuICogVXBsb2FkcyB0aGUgbGV2ZWxzIG9mIGltYWdlIGRhdGEgdG8gdGhlIEdQVS5cbiAqIEBwYXJhbSBtYWluVGV4dHVyZSBkZWZpbmVzIHRoZSBpbnRlcm5hbCB0ZXh0dXJlIHRvIHVwbG9hZCB0b1xuICogQHBhcmFtIGltYWdlRGF0YSBkZWZpbmVzIHRoZSBhcnJheSBidWZmZXIgdmlld3Mgb2YgaW1hZ2UgZGF0YSBbbWlwbWFwXVtmYWNlXVxuICogQHBhcmFtIHNpemUgZGVmaW5lcyB0aGUgc2l6ZSBvZiB0aGUgdGV4dHVyZSBmYWNlc1xuICogQHBhcmFtIGltYWdlVHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBkYXRhXG4gKiBAcmV0dXJucyBhIHByb21pc2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFVwbG9hZElycmFkaWFuY2VMZXZlbHNBc3luYyhtYWluVGV4dHVyZSwgaW1hZ2VEYXRhLCBzaXplLCBpbWFnZVR5cGUgPSBEZWZhdWx0RW52aXJvbm1lbnRUZXh0dXJlSW1hZ2VUeXBlKSB7XG4gICAgLy8gR2V0cyBldmVyeXRoaW5nIHJlYWR5LlxuICAgIGNvbnN0IGVuZ2luZSA9IG1haW5UZXh0dXJlLmdldEVuZ2luZSgpO1xuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgSW50ZXJuYWxUZXh0dXJlKGVuZ2luZSwgNSAvKiBJbnRlcm5hbFRleHR1cmVTb3VyY2UuUmVuZGVyVGFyZ2V0ICovKTtcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShlbmdpbmUsIHRleHR1cmUpO1xuICAgIG1haW5UZXh0dXJlLl9pcnJhZGlhbmNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlO1xuICAgIHRleHR1cmUuaXNDdWJlID0gdHJ1ZTtcbiAgICB0ZXh0dXJlLmZvcm1hdCA9IDU7XG4gICAgdGV4dHVyZS50eXBlID0gMDtcbiAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwTWFwcyA9IHRydWU7XG4gICAgdGV4dHVyZS5fY2FjaGVkQW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCA9IG51bGw7XG4gICAgdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMgPSB0cnVlO1xuICAgIHRleHR1cmUud2lkdGggPSBzaXplO1xuICAgIHRleHR1cmUuaGVpZ2h0ID0gc2l6ZTtcbiAgICBlbmdpbmUudXBkYXRlVGV4dHVyZVNhbXBsaW5nTW9kZSgzLCB0ZXh0dXJlKTtcbiAgICBhd2FpdCBfVXBsb2FkTGV2ZWxzQXN5bmModGV4dHVyZSwgW2ltYWdlRGF0YV0sIGZhbHNlLCBpbWFnZVR5cGUpO1xuICAgIGVuZ2luZS5nZW5lcmF0ZU1pcE1hcHNGb3JDdWJlbWFwKHRleHR1cmUpO1xuICAgIC8vIEZsYWcgaW50ZXJuYWwgdGV4dHVyZSBhcyByZWFkeSBpbiBjYXNlIHRoZXkgYXJlIGluIHVzZS5cbiAgICB0ZXh0dXJlLmlzUmVhZHkgPSB0cnVlO1xufVxuLyoqXG4gKiBVcGxvYWRzIHRoZSBsZXZlbHMgb2YgaW1hZ2UgZGF0YSB0byB0aGUgR1BVLlxuICogQHBhcmFtIHRleHR1cmUgZGVmaW5lcyB0aGUgaW50ZXJuYWwgdGV4dHVyZSB0byB1cGxvYWQgdG9cbiAqIEBwYXJhbSBpbWFnZURhdGEgZGVmaW5lcyB0aGUgYXJyYXkgYnVmZmVyIHZpZXdzIG9mIGltYWdlIGRhdGEgW21pcG1hcF1bZmFjZV1cbiAqIEBwYXJhbSBjYW5HZW5lcmF0ZU5vbkxPRFRleHR1cmVzIGRlZmluZXMgd2hldGhlciBvciBub3QgdG8gZ2VuZXJhdGUgbm9uIGxvZCB0ZXh0dXJlc1xuICogQHBhcmFtIGltYWdlVHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBkYXRhXG4gKiBAcmV0dXJucyBhIHByb21pc2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX1VwbG9hZExldmVsc0FzeW5jKHRleHR1cmUsIGltYWdlRGF0YSwgY2FuR2VuZXJhdGVOb25MT0RUZXh0dXJlcywgaW1hZ2VUeXBlID0gRGVmYXVsdEVudmlyb25tZW50VGV4dHVyZUltYWdlVHlwZSkge1xuICAgIGlmICghVG9vbHMuSXNFeHBvbmVudE9mVHdvKHRleHR1cmUud2lkdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRleHR1cmUgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvXCIpO1xuICAgIH1cbiAgICBjb25zdCBtaXBtYXBzQ291bnQgPSBJTG9nMih0ZXh0dXJlLndpZHRoKSArIDE7XG4gICAgLy8gR2V0cyBldmVyeXRoaW5nIHJlYWR5LlxuICAgIGNvbnN0IGVuZ2luZSA9IHRleHR1cmUuZ2V0RW5naW5lKCk7XG4gICAgbGV0IGV4cGFuZFRleHR1cmUgPSBmYWxzZTtcbiAgICBsZXQgZ2VuZXJhdGVOb25MT0RUZXh0dXJlcyA9IGZhbHNlO1xuICAgIGxldCByZ2JkUG9zdFByb2Nlc3MgPSBudWxsO1xuICAgIGxldCBjdWJlUnR0ID0gbnVsbDtcbiAgICBsZXQgbG9kVGV4dHVyZXMgPSBudWxsO1xuICAgIGNvbnN0IGNhcHMgPSBlbmdpbmUuZ2V0Q2FwcygpO1xuICAgIGlmICghY2Fwcy50ZXh0dXJlTE9EKSB7XG4gICAgICAgIGV4cGFuZFRleHR1cmUgPSBmYWxzZTtcbiAgICAgICAgZ2VuZXJhdGVOb25MT0RUZXh0dXJlcyA9IGNhbkdlbmVyYXRlTm9uTE9EVGV4dHVyZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFlbmdpbmUuX2ZlYXR1cmVzLnN1cHBvcnRSZW5kZXJBbmRDb3B5VG9Mb2RGb3JGbG9hdFRleHR1cmVzKSB7XG4gICAgICAgIGV4cGFuZFRleHR1cmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgaGFsZiBmbG9hdCBhdmFpbGFibGUgd2UgY2FuIHVuY29tcHJlc3MgdGhlIHRleHR1cmVcbiAgICBlbHNlIGlmIChjYXBzLnRleHR1cmVIYWxmRmxvYXRSZW5kZXIgJiYgY2Fwcy50ZXh0dXJlSGFsZkZsb2F0TGluZWFyRmlsdGVyaW5nKSB7XG4gICAgICAgIGV4cGFuZFRleHR1cmUgPSB0cnVlO1xuICAgICAgICB0ZXh0dXJlLnR5cGUgPSAyO1xuICAgIH1cbiAgICAvLyBJZiBmdWxsIGZsb2F0IGF2YWlsYWJsZSB3ZSBjYW4gdW5jb21wcmVzcyB0aGUgdGV4dHVyZVxuICAgIGVsc2UgaWYgKGNhcHMudGV4dHVyZUZsb2F0UmVuZGVyICYmIGNhcHMudGV4dHVyZUZsb2F0TGluZWFyRmlsdGVyaW5nKSB7XG4gICAgICAgIGV4cGFuZFRleHR1cmUgPSB0cnVlO1xuICAgICAgICB0ZXh0dXJlLnR5cGUgPSAxO1xuICAgIH1cbiAgICAvLyBFeHBhbmQgdGhlIHRleHR1cmUgaWYgcG9zc2libGVcbiAgICBsZXQgc2hhZGVyTGFuZ3VhZ2UgPSAwIC8qIFNoYWRlckxhbmd1YWdlLkdMU0wgKi87XG4gICAgaWYgKGV4cGFuZFRleHR1cmUpIHtcbiAgICAgICAgaWYgKGVuZ2luZS5pc1dlYkdQVSkge1xuICAgICAgICAgICAgc2hhZGVyTGFuZ3VhZ2UgPSAxIC8qIFNoYWRlckxhbmd1YWdlLldHU0wgKi87XG4gICAgICAgICAgICBhd2FpdCBpbXBvcnQoXCIuLi9TaGFkZXJzV0dTTC9yZ2JkRGVjb2RlLmZyYWdtZW50LmpzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgaW1wb3J0KFwiLi4vU2hhZGVycy9yZ2JkRGVjb2RlLmZyYWdtZW50LmpzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbXBseSBydW4gdGhyb3VnaCB0aGUgZGVjb2RlIFBQXG4gICAgICAgIHJnYmRQb3N0UHJvY2VzcyA9IG5ldyBQb3N0UHJvY2VzcyhcInJnYmREZWNvZGVcIiwgXCJyZ2JkRGVjb2RlXCIsIG51bGwsIG51bGwsIDEsIG51bGwsIDMsIGVuZ2luZSwgZmFsc2UsIHVuZGVmaW5lZCwgdGV4dHVyZS50eXBlLCB1bmRlZmluZWQsIG51bGwsIGZhbHNlLCB1bmRlZmluZWQsIHNoYWRlckxhbmd1YWdlKTtcbiAgICAgICAgdGV4dHVyZS5faXNSR0JEID0gZmFsc2U7XG4gICAgICAgIHRleHR1cmUuaW52ZXJ0WSA9IGZhbHNlO1xuICAgICAgICBjdWJlUnR0ID0gZW5naW5lLmNyZWF0ZVJlbmRlclRhcmdldEN1YmVUZXh0dXJlKHRleHR1cmUud2lkdGgsIHtcbiAgICAgICAgICAgIGdlbmVyYXRlRGVwdGhCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgZ2VuZXJhdGVNaXBNYXBzOiB0cnVlLFxuICAgICAgICAgICAgZ2VuZXJhdGVTdGVuY2lsQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIHNhbXBsaW5nTW9kZTogMyxcbiAgICAgICAgICAgIHR5cGU6IHRleHR1cmUudHlwZSxcbiAgICAgICAgICAgIGZvcm1hdDogNSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0ZXh0dXJlLl9pc1JHQkQgPSB0cnVlO1xuICAgICAgICB0ZXh0dXJlLmludmVydFkgPSB0cnVlO1xuICAgICAgICAvLyBJbiBjYXNlIG9mIG1pc3Npbmcgc3VwcG9ydCwgYXBwbGllcyB0aGUgc2FtZSBwYXRjaCB0aGFuIEREUyBmaWxlcy5cbiAgICAgICAgaWYgKGdlbmVyYXRlTm9uTE9EVGV4dHVyZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pcFNsaWNlcyA9IDM7XG4gICAgICAgICAgICBsb2RUZXh0dXJlcyA9IHt9O1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0ZXh0dXJlLl9sb2RHZW5lcmF0aW9uU2NhbGU7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0ZXh0dXJlLl9sb2RHZW5lcmF0aW9uT2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaXBTbGljZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBMT0QgZnJvbSBldmVuIHNwYWNpbmcgaW4gc21vb3RobmVzcyAobWF0Y2hpbmcgc2hhZGVyIGNhbGN1bGF0aW9uKVxuICAgICAgICAgICAgICAgIGNvbnN0IHNtb290aG5lc3MgPSBpIC8gKG1pcFNsaWNlcyAtIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdWdobmVzcyA9IDEgLSBzbW9vdGhuZXNzO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbkxPREluZGV4ID0gb2Zmc2V0OyAvLyByb3VnaG5lc3MgPSAwXG4gICAgICAgICAgICAgICAgY29uc3QgbWF4TE9ESW5kZXggPSAobWlwbWFwc0NvdW50IC0gMSkgKiBzY2FsZSArIG9mZnNldDsgLy8gcm91Z2huZXNzID0gMSAobWlwbWFwcyBzdGFydCBmcm9tIDApXG4gICAgICAgICAgICAgICAgY29uc3QgbG9kSW5kZXggPSBtaW5MT0RJbmRleCArIChtYXhMT0RJbmRleCAtIG1pbkxPREluZGV4KSAqIHJvdWdobmVzcztcbiAgICAgICAgICAgICAgICBjb25zdCBtaXBtYXBJbmRleCA9IE1hdGgucm91bmQoTWF0aC5taW4oTWF0aC5tYXgobG9kSW5kZXgsIDApLCBtYXhMT0RJbmRleCkpO1xuICAgICAgICAgICAgICAgIC8vY29tcHV0ZSBMT0QgZnJvbSBldmVuIHNwYWNpbmcgaW4gc21vb3RobmVzcyAobWF0Y2hpbmcgc2hhZGVyIGNhbGN1bGF0aW9uKVxuICAgICAgICAgICAgICAgIGNvbnN0IGdsVGV4dHVyZUZyb21Mb2QgPSBuZXcgSW50ZXJuYWxUZXh0dXJlKGVuZ2luZSwgMiAvKiBJbnRlcm5hbFRleHR1cmVTb3VyY2UuVGVtcCAqLyk7XG4gICAgICAgICAgICAgICAgZ2xUZXh0dXJlRnJvbUxvZC5pc0N1YmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZUZyb21Mb2QuaW52ZXJ0WSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZ2xUZXh0dXJlRnJvbUxvZC5nZW5lcmF0ZU1pcE1hcHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbmdpbmUudXBkYXRlVGV4dHVyZVNhbXBsaW5nTW9kZSgyLCBnbFRleHR1cmVGcm9tTG9kKTtcbiAgICAgICAgICAgICAgICAvLyBXcmFwIGluIGEgYmFzZSB0ZXh0dXJlIGZvciBlYXN5IGJpbmRpbmcuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9kVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShudWxsKTtcbiAgICAgICAgICAgICAgICBsb2RUZXh0dXJlLl9pc0N1YmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxvZFRleHR1cmUuX3RleHR1cmUgPSBnbFRleHR1cmVGcm9tTG9kO1xuICAgICAgICAgICAgICAgIGxvZFRleHR1cmVzW21pcG1hcEluZGV4XSA9IGxvZFRleHR1cmU7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuX2xvZFRleHR1cmVMb3cgPSBsb2RUZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuX2xvZFRleHR1cmVNaWQgPSBsb2RUZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuX2xvZFRleHR1cmVIaWdoID0gbG9kVGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIC8vIEFsbCBtaXBtYXBzIHVwIHRvIHByb3ZpZGVkIG51bWJlciBvZiBpbWFnZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBBbGwgZmFjZXNcbiAgICAgICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCA2OyBmYWNlKyspIHtcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdHMgYW4gaW1hZ2UgZWxlbWVudCBmcm9tIGltYWdlIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gaW1hZ2VEYXRhW2ldW2ZhY2VdO1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtieXRlc10sIHsgdHlwZTogaW1hZ2VUeXBlIH0pO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgIGxldCBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKGVuZ2luZS5fZmVhdHVyZXMuZm9yY2VCaXRtYXBPdmVySFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHByb21pc2UgPSBlbmdpbmUuY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYiwgeyBwcmVtdWx0aXBseUFscGhhOiBcIm5vbmVcIiB9KS50aGVuKGFzeW5jIChpbWcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9PbkltYWdlUmVhZHlBc3luYyhpbWcsIGVuZ2luZSwgZXhwYW5kVGV4dHVyZSwgcmdiZFBvc3RQcm9jZXNzLCB1cmwsIGZhY2UsIGksIGdlbmVyYXRlTm9uTE9EVGV4dHVyZXMsIGxvZFRleHR1cmVzLCBjdWJlUnR0LCB0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gdXJsO1xuICAgICAgICAgICAgICAgIC8vIEVucXVldWUgcHJvbWlzZSB0byB1cGxvYWQgdG8gdGhlIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgX09uSW1hZ2VSZWFkeUFzeW5jKGltYWdlLCBlbmdpbmUsIGV4cGFuZFRleHR1cmUsIHJnYmRQb3N0UHJvY2VzcywgdXJsLCBmYWNlLCBpLCBnZW5lcmF0ZU5vbkxPRFRleHR1cmVzLCBsb2RUZXh0dXJlcywgY3ViZVJ0dCwgdGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiByZXNvbHZlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgLy8gRmlsbCByZW1haW5pbmcgbWlwbWFwcyB3aXRoIGJsYWNrIHRleHR1cmVzLlxuICAgIGlmIChpbWFnZURhdGEubGVuZ3RoIDwgbWlwbWFwc0NvdW50KSB7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBjb25zdCBzaXplID0gTWF0aC5wb3coMiwgbWlwbWFwc0NvdW50IC0gMSAtIGltYWdlRGF0YS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gc2l6ZSAqIHNpemUgKiA0O1xuICAgICAgICBzd2l0Y2ggKHRleHR1cmUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50MTZBcnJheShkYXRhTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGFMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBpbWFnZURhdGEubGVuZ3RoOyBpIDwgbWlwbWFwc0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgNjsgZmFjZSsrKSB7XG4gICAgICAgICAgICAgICAgZW5naW5lLl91cGxvYWRBcnJheUJ1ZmZlclZpZXdUb1RleHR1cmUoY3ViZVJ0dD8udGV4dHVyZSB8fCB0ZXh0dXJlLCBkYXRhLCBmYWNlLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZWxlYXNlIHRlbXAgUlRULlxuICAgIGlmIChjdWJlUnR0KSB7XG4gICAgICAgIGNvbnN0IGlycmFkaWFuY2UgPSB0ZXh0dXJlLl9pcnJhZGlhbmNlVGV4dHVyZTtcbiAgICAgICAgdGV4dHVyZS5faXJyYWRpYW5jZVRleHR1cmUgPSBudWxsO1xuICAgICAgICBlbmdpbmUuX3JlbGVhc2VUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgICBjdWJlUnR0Ll9zd2FwQW5kRGllKHRleHR1cmUpO1xuICAgICAgICB0ZXh0dXJlLl9pcnJhZGlhbmNlVGV4dHVyZSA9IGlycmFkaWFuY2U7XG4gICAgfVxuICAgIC8vIFJlbGVhc2UgdGVtcCBQb3N0IFByb2Nlc3MuXG4gICAgaWYgKHJnYmRQb3N0UHJvY2Vzcykge1xuICAgICAgICByZ2JkUG9zdFByb2Nlc3MuZGlzcG9zZSgpO1xuICAgIH1cbiAgICAvLyBGbGFnIGludGVybmFsIHRleHR1cmUgYXMgcmVhZHkgaW4gY2FzZSB0aGV5IGFyZSBpbiB1c2UuXG4gICAgaWYgKGdlbmVyYXRlTm9uTE9EVGV4dHVyZXMpIHtcbiAgICAgICAgaWYgKHRleHR1cmUuX2xvZFRleHR1cmVIaWdoICYmIHRleHR1cmUuX2xvZFRleHR1cmVIaWdoLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLl9sb2RUZXh0dXJlSGlnaC5fdGV4dHVyZS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dHVyZS5fbG9kVGV4dHVyZU1pZCAmJiB0ZXh0dXJlLl9sb2RUZXh0dXJlTWlkLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLl9sb2RUZXh0dXJlTWlkLl90ZXh0dXJlLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0dXJlLl9sb2RUZXh0dXJlTG93ICYmIHRleHR1cmUuX2xvZFRleHR1cmVMb3cuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRleHR1cmUuX2xvZFRleHR1cmVMb3cuX3RleHR1cmUuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFVwbG9hZHMgc3BoZXJpY2FsIHBvbHlub21pYWxzIGluZm9ybWF0aW9uIHRvIHRoZSB0ZXh0dXJlLlxuICogQHBhcmFtIHRleHR1cmUgZGVmaW5lcyB0aGUgdGV4dHVyZSB3ZSBhcmUgdHJ5aW5nIHRvIHVwbG9hZCB0aGUgaW5mb3JtYXRpb24gdG9cbiAqIEBwYXJhbSBpbmZvIGRlZmluZXMgdGhlIGVudmlyb25tZW50IHRleHR1cmUgaW5mbyByZXRyaWV2ZWQgdGhyb3VnaCB0aGUgR2V0RW52SW5mbyBtZXRob2RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFVwbG9hZEVudlNwaGVyaWNhbCh0ZXh0dXJlLCBpbmZvKSB7XG4gICAgaW5mbyA9IG5vcm1hbGl6ZUVudkluZm8oaW5mbyk7XG4gICAgY29uc3QgaXJyYWRpYW5jZUluZm8gPSBpbmZvLmlycmFkaWFuY2U7XG4gICAgaWYgKCFpcnJhZGlhbmNlSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNwID0gbmV3IFNwaGVyaWNhbFBvbHlub21pYWwoKTtcbiAgICBWZWN0b3IzLkZyb21BcnJheVRvUmVmKGlycmFkaWFuY2VJbmZvLngsIDAsIHNwLngpO1xuICAgIFZlY3RvcjMuRnJvbUFycmF5VG9SZWYoaXJyYWRpYW5jZUluZm8ueSwgMCwgc3AueSk7XG4gICAgVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZihpcnJhZGlhbmNlSW5mby56LCAwLCBzcC56KTtcbiAgICBWZWN0b3IzLkZyb21BcnJheVRvUmVmKGlycmFkaWFuY2VJbmZvLnh4LCAwLCBzcC54eCk7XG4gICAgVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZihpcnJhZGlhbmNlSW5mby55eSwgMCwgc3AueXkpO1xuICAgIFZlY3RvcjMuRnJvbUFycmF5VG9SZWYoaXJyYWRpYW5jZUluZm8uenosIDAsIHNwLnp6KTtcbiAgICBWZWN0b3IzLkZyb21BcnJheVRvUmVmKGlycmFkaWFuY2VJbmZvLnl6LCAwLCBzcC55eik7XG4gICAgVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZihpcnJhZGlhbmNlSW5mby56eCwgMCwgc3AuengpO1xuICAgIFZlY3RvcjMuRnJvbUFycmF5VG9SZWYoaXJyYWRpYW5jZUluZm8ueHksIDAsIHNwLnh5KTtcbiAgICB0ZXh0dXJlLl9zcGhlcmljYWxQb2x5bm9taWFsID0gc3A7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gX1VwZGF0ZVJHQkRBc3luYyhpbnRlcm5hbFRleHR1cmUsIGRhdGEsIHNwaGVyaWNhbFBvbHlub21pYWwsIGxvZFNjYWxlLCBsb2RPZmZzZXQpIHtcbiAgICBjb25zdCBwcm94eSA9IGludGVybmFsVGV4dHVyZVxuICAgICAgICAuZ2V0RW5naW5lKClcbiAgICAgICAgLmNyZWF0ZVJhd0N1YmVUZXh0dXJlKG51bGwsIGludGVybmFsVGV4dHVyZS53aWR0aCwgaW50ZXJuYWxUZXh0dXJlLmZvcm1hdCwgaW50ZXJuYWxUZXh0dXJlLnR5cGUsIGludGVybmFsVGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMsIGludGVybmFsVGV4dHVyZS5pbnZlcnRZLCBpbnRlcm5hbFRleHR1cmUuc2FtcGxpbmdNb2RlLCBpbnRlcm5hbFRleHR1cmUuX2NvbXByZXNzaW9uKTtcbiAgICBjb25zdCBwcm94eVByb21pc2UgPSBVcGxvYWRSYWRpYW5jZUxldmVsc0FzeW5jKHByb3h5LCBkYXRhKS50aGVuKCgpID0+IGludGVybmFsVGV4dHVyZSk7XG4gICAgaW50ZXJuYWxUZXh0dXJlLm9uUmVidWlsZENhbGxiYWNrID0gKF9pbnRlcm5hbFRleHR1cmUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3h5OiBwcm94eVByb21pc2UsXG4gICAgICAgICAgICBpc1JlYWR5OiB0cnVlLFxuICAgICAgICAgICAgaXNBc3luYzogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGludGVybmFsVGV4dHVyZS5fc291cmNlID0gMTMgLyogSW50ZXJuYWxUZXh0dXJlU291cmNlLkN1YmVSYXdSR0JEICovO1xuICAgIGludGVybmFsVGV4dHVyZS5fYnVmZmVyVmlld0FycmF5QXJyYXkgPSBkYXRhO1xuICAgIGludGVybmFsVGV4dHVyZS5fbG9kR2VuZXJhdGlvblNjYWxlID0gbG9kU2NhbGU7XG4gICAgaW50ZXJuYWxUZXh0dXJlLl9sb2RHZW5lcmF0aW9uT2Zmc2V0ID0gbG9kT2Zmc2V0O1xuICAgIGludGVybmFsVGV4dHVyZS5fc3BoZXJpY2FsUG9seW5vbWlhbCA9IHNwaGVyaWNhbFBvbHlub21pYWw7XG4gICAgcmV0dXJuIFVwbG9hZFJhZGlhbmNlTGV2ZWxzQXN5bmMoaW50ZXJuYWxUZXh0dXJlLCBkYXRhKS50aGVuKCgpID0+IHtcbiAgICAgICAgaW50ZXJuYWxUZXh0dXJlLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxUZXh0dXJlO1xuICAgIH0pO1xufVxuLyoqXG4gKiBTZXRzIG9mIGhlbHBlcnMgYWRkcmVzc2luZyB0aGUgc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJpYWxpemF0aW9uIG9mIGVudmlyb25tZW50IHRleHR1cmVcbiAqIHN0b3JlZCBpbiBhIEJhYnlsb25KUyBlbnYgZmlsZS5cbiAqIFRob3NlIGZpbGVzIGFyZSB1c3VhbGx5IHN0b3JlZCBhcyAuZW52IGZpbGVzLlxuICovXG5leHBvcnQgY29uc3QgRW52aXJvbm1lbnRUZXh0dXJlVG9vbHMgPSB7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZW52aXJvbm1lbnQgaW5mbyBmcm9tIGFuIGVudiBmaWxlLlxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBhcnJheSBidWZmZXIgY29udGFpbmluZyB0aGUgLmVudiBieXRlcy5cbiAgICAgKiBAcmV0dXJucyB0aGUgZW52aXJvbm1lbnQgZmlsZSBpbmZvICh0aGUganNvbiBoZWFkZXIpIGlmIHN1Y2Nlc3NmdWxseSBwYXJzZWQsIG5vcm1hbGl6ZWQgdG8gdGhlIGxhdGVzdCBzdXBwb3J0ZWQgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBHZXRFbnZJbmZvLFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZW52aXJvbm1lbnQgdGV4dHVyZSBmcm9tIGEgbG9hZGVkIGN1YmUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSBjdWJlIHRleHR1cmUgdG8gY29udmVydCBpbiBlbnYgZmlsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgZm9yIHRoZSBjb252ZXJzaW9uIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbWFnZVR5cGUgdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGVuY29kZWQgaW1hZ2VzLCB3aXRoIHN1cHBvcnQgZm9yIFwiaW1hZ2UvcG5nXCIgKGRlZmF1bHQpIGFuZCBcImltYWdlL3dlYnBcIlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmltYWdlUXVhbGl0eSB0aGUgaW1hZ2UgcXVhbGl0eSBvZiBlbmNvZGVkIFdlYlAgaW1hZ2VzLlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSBjb250YWluaW5nIHRoZSBlbnZpcm9ubWVudCBkYXRhIGlmIHN1Y2Nlc3NmdWwuXG4gICAgICovXG4gICAgQ3JlYXRlRW52VGV4dHVyZUFzeW5jLFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIEFycmF5QnVmZmVyVmlld3MgdXNlZCBmb3IgaW5pdGlhbGl6aW5nIGVudmlyb25tZW50IHRleHR1cmUgaW1hZ2UgZGF0YS5cbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgaW1hZ2UgZGF0YVxuICAgICAqIEBwYXJhbSBpbmZvIHBhcmFtZXRlcnMgdGhhdCBkZXRlcm1pbmUgd2hhdCB2aWV3cyB3aWxsIGJlIGNyZWF0ZWQgZm9yIGFjY2Vzc2luZyB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAgICAgKiBAcmV0dXJucyB0aGUgdmlld3MgZGVzY3JpYmVkIGJ5IGluZm8gcHJvdmlkaW5nIGFjY2VzcyB0byB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAgICAgKi9cbiAgICBDcmVhdGVSYWRpYW5jZUltYWdlRGF0YUFycmF5QnVmZmVyVmlld3MsXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgQXJyYXlCdWZmZXJWaWV3cyB1c2VkIGZvciBpbml0aWFsaXppbmcgZW52aXJvbm1lbnQgdGV4dHVyZSBpbWFnZSBkYXRhLlxuICAgICAqIEBwYXJhbSBkYXRhIHRoZSBpbWFnZSBkYXRhXG4gICAgICogQHBhcmFtIGluZm8gcGFyYW1ldGVycyB0aGF0IGRldGVybWluZSB3aGF0IHZpZXdzIHdpbGwgYmUgY3JlYXRlZCBmb3IgYWNjZXNzaW5nIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAqIEByZXR1cm5zIHRoZSB2aWV3cyBkZXNjcmliZWQgYnkgaW5mbyBwcm92aWRpbmcgYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAqL1xuICAgIENyZWF0ZUlycmFkaWFuY2VJbWFnZURhdGFBcnJheUJ1ZmZlclZpZXdzLFxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIHRleHR1cmUgaW5mbyBjb250YWluZWQgaW4gdGhlIGVudiBmaWxlIHRvIHRoZSBHUFUuXG4gICAgICogQHBhcmFtIHRleHR1cmUgZGVmaW5lcyB0aGUgaW50ZXJuYWwgdGV4dHVyZSB0byB1cGxvYWQgdG9cbiAgICAgKiBAcGFyYW0gZGF0YSBkZWZpbmVzIHRoZSBkYXRhIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gaW5mbyBkZWZpbmVzIHRoZSB0ZXh0dXJlIGluZm8gcmV0cmlldmVkIHRocm91Z2ggdGhlIEdldEVudkluZm8gbWV0aG9kXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlXG4gICAgICovXG4gICAgVXBsb2FkRW52TGV2ZWxzQXN5bmMsXG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgbGV2ZWxzIG9mIGltYWdlIGRhdGEgdG8gdGhlIEdQVS5cbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSBpbnRlcm5hbCB0ZXh0dXJlIHRvIHVwbG9hZCB0b1xuICAgICAqIEBwYXJhbSBpbWFnZURhdGEgZGVmaW5lcyB0aGUgYXJyYXkgYnVmZmVyIHZpZXdzIG9mIGltYWdlIGRhdGEgW21pcG1hcF1bZmFjZV1cbiAgICAgKiBAcGFyYW0gaW1hZ2VUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGltYWdlIGRhdGFcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2VcbiAgICAgKi9cbiAgICBVcGxvYWRSYWRpYW5jZUxldmVsc0FzeW5jLFxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIGxldmVscyBvZiBpbWFnZSBkYXRhIHRvIHRoZSBHUFUuXG4gICAgICogQHBhcmFtIHRleHR1cmUgZGVmaW5lcyB0aGUgaW50ZXJuYWwgdGV4dHVyZSB0byB1cGxvYWQgdG9cbiAgICAgKiBAcGFyYW0gaW1hZ2VEYXRhIGRlZmluZXMgdGhlIGFycmF5IGJ1ZmZlciB2aWV3cyBvZiBpbWFnZSBkYXRhIFttaXBtYXBdW2ZhY2VdXG4gICAgICogQHBhcmFtIGltYWdlVHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBkYXRhXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlXG4gICAgICovXG4gICAgVXBsb2FkSXJyYWRpYW5jZUxldmVsc0FzeW5jLFxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgc3BoZXJpY2FsIHBvbHlub21pYWxzIGluZm9ybWF0aW9uIHRvIHRoZSB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIGRlZmluZXMgdGhlIHRleHR1cmUgd2UgYXJlIHRyeWluZyB0byB1cGxvYWQgdGhlIGluZm9ybWF0aW9uIHRvXG4gICAgICogQHBhcmFtIGluZm8gZGVmaW5lcyB0aGUgZW52aXJvbm1lbnQgdGV4dHVyZSBpbmZvIHJldHJpZXZlZCB0aHJvdWdoIHRoZSBHZXRFbnZJbmZvIG1ldGhvZFxuICAgICAqL1xuICAgIFVwbG9hZEVudlNwaGVyaWNhbCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnZpcm9ubWVudFRleHR1cmVUb29scy5qcy5tYXAiLCJcbmltcG9ydCB7IFBvc3RQcm9jZXNzIH0gZnJvbSBcIi4uL1Bvc3RQcm9jZXNzZXMvcG9zdFByb2Nlc3MuanNcIjtcbmltcG9ydCB7IEFwcGx5UG9zdFByb2Nlc3MgfSBmcm9tIFwiLi90ZXh0dXJlVG9vbHMuanNcIjtcbi8qKlxuICogQ2xhc3MgdXNlZCB0byBob3N0IFJHQkQgdGV4dHVyZSBzcGVjaWZpYyB1dGlsaXRpZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFJHQkRUZXh0dXJlVG9vbHMge1xuICAgIC8qKlxuICAgICAqIEV4cGFuZCB0aGUgUkdCRCBUZXh0dXJlIGZyb20gUkdCRCB0byBIYWxmIEZsb2F0IGlmIHBvc3NpYmxlLlxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIHRoZSB0ZXh0dXJlIHRvIGV4cGFuZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgRXhwYW5kUkdCRFRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICBjb25zdCBpbnRlcm5hbFRleHR1cmUgPSB0ZXh0dXJlLl90ZXh0dXJlO1xuICAgICAgICBpZiAoIWludGVybmFsVGV4dHVyZSB8fCAhdGV4dHVyZS5pc1JHQkQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXRzIGV2ZXJ5dGhpbmcgcmVhZHkuXG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IGludGVybmFsVGV4dHVyZS5nZXRFbmdpbmUoKTtcbiAgICAgICAgY29uc3QgY2FwcyA9IGVuZ2luZS5nZXRDYXBzKCk7XG4gICAgICAgIGNvbnN0IGlzUmVhZHkgPSBpbnRlcm5hbFRleHR1cmUuaXNSZWFkeTtcbiAgICAgICAgbGV0IGV4cGFuZFRleHR1cmUgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgaGFsZiBmbG9hdCBhdmFpbGFibGUgd2UgY2FuIHVuY29tcHJlc3MgdGhlIHRleHR1cmVcbiAgICAgICAgaWYgKGNhcHMudGV4dHVyZUhhbGZGbG9hdFJlbmRlciAmJiBjYXBzLnRleHR1cmVIYWxmRmxvYXRMaW5lYXJGaWx0ZXJpbmcpIHtcbiAgICAgICAgICAgIGV4cGFuZFRleHR1cmUgPSB0cnVlO1xuICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlLnR5cGUgPSAyO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGZ1bGwgZmxvYXQgYXZhaWxhYmxlIHdlIGNhbiB1bmNvbXByZXNzIHRoZSB0ZXh0dXJlXG4gICAgICAgIGVsc2UgaWYgKGNhcHMudGV4dHVyZUZsb2F0UmVuZGVyICYmIGNhcHMudGV4dHVyZUZsb2F0TGluZWFyRmlsdGVyaW5nKSB7XG4gICAgICAgICAgICBleHBhbmRUZXh0dXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludGVybmFsVGV4dHVyZS50eXBlID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwYW5kVGV4dHVyZSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IHVzZSBkdXJpbmcgZGVjb2RlLlxuICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlLmlzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgICAgIGludGVybmFsVGV4dHVyZS5faXNSR0JEID0gZmFsc2U7XG4gICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUuaW52ZXJ0WSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cGFuZFJnYmRUZXh0dXJlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1dlYkdwdSA9IGVuZ2luZS5pc1dlYkdQVTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlckxhbmd1YWdlID0gaXNXZWJHcHUgPyAxIC8qIFNoYWRlckxhbmd1YWdlLldHU0wgKi8gOiAwIC8qIFNoYWRlckxhbmd1YWdlLkdMU0wgKi87XG4gICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUuaXNSZWFkeSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlzV2ViR3B1KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaW1wb3J0KFwiLi4vU2hhZGVyc1dHU0wvcmdiZERlY29kZS5mcmFnbWVudC5qc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IGltcG9ydChcIi4uL1NoYWRlcnMvcmdiZERlY29kZS5mcmFnbWVudC5qc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cGFuZCB0aGUgdGV4dHVyZSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgLy8gU2ltcGx5IHJ1biB0aHJvdWdoIHRoZSBkZWNvZGUgUFAuXG4gICAgICAgICAgICBjb25zdCByZ2JkUG9zdFByb2Nlc3MgPSBuZXcgUG9zdFByb2Nlc3MoXCJyZ2JkRGVjb2RlXCIsIFwicmdiZERlY29kZVwiLCBudWxsLCBudWxsLCAxLCBudWxsLCAzLCBlbmdpbmUsIGZhbHNlLCB1bmRlZmluZWQsIGludGVybmFsVGV4dHVyZS50eXBlLCB1bmRlZmluZWQsIG51bGwsIGZhbHNlLCB1bmRlZmluZWQsIHNoYWRlckxhbmd1YWdlKTtcbiAgICAgICAgICAgIHJnYmRQb3N0UHJvY2Vzcy5leHRlcm5hbFRleHR1cmVTYW1wbGVyQmluZGluZyA9IHRydWU7XG4gICAgICAgICAgICAvLyBIb2xkIHRoZSBvdXRwdXQgb2YgdGhlIGRlY29kaW5nLlxuICAgICAgICAgICAgY29uc3QgZXhwYW5kZWRUZXh0dXJlID0gZW5naW5lLmNyZWF0ZVJlbmRlclRhcmdldFRleHR1cmUoaW50ZXJuYWxUZXh0dXJlLndpZHRoLCB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVEZXB0aEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVNaXBNYXBzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZVN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNhbXBsaW5nTW9kZTogaW50ZXJuYWxUZXh0dXJlLnNhbXBsaW5nTW9kZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBpbnRlcm5hbFRleHR1cmUudHlwZSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IDUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJnYmRQb3N0UHJvY2Vzcy5vbkVmZmVjdENyZWF0ZWRPYnNlcnZhYmxlLmFkZE9uY2UoKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLmV4ZWN1dGVXaGVuQ29tcGlsZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBQUCBSZW5kZXIgUGFzc1xuICAgICAgICAgICAgICAgICAgICByZ2JkUG9zdFByb2Nlc3Mub25BcHBseSA9IChlZmZlY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdC5fYmluZFRleHR1cmUoXCJ0ZXh0dXJlU2FtcGxlclwiLCBpbnRlcm5hbFRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0LnNldEZsb2F0MihcInNjYWxlXCIsIDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmdldFNjZW5lKCkucG9zdFByb2Nlc3NNYW5hZ2VyLmRpcmVjdFJlbmRlcihbcmdiZFBvc3RQcm9jZXNzXSwgZXhwYW5kZWRUZXh0dXJlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW51cFxuICAgICAgICAgICAgICAgICAgICBlbmdpbmUucmVzdG9yZURlZmF1bHRGcmFtZWJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICBlbmdpbmUuX3JlbGVhc2VUZXh0dXJlKGludGVybmFsVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZ2JkUG9zdFByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJnYmRQb3N0UHJvY2Vzcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJuYWwgU3dhcFxuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZFRleHR1cmUuX3N3YXBBbmREaWUoaW50ZXJuYWxUZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZHkgdG8gZ2V0IHJvbGxpbmcgYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsVGV4dHVyZS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZXhwYW5kVGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKGlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICBleHBhbmRSZ2JkVGV4dHVyZUFzeW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLm9uTG9hZE9ic2VydmFibGUuYWRkT25jZShleHBhbmRSZ2JkVGV4dHVyZUFzeW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgdGhlIHRleHR1cmUgdG8gUkdCRCBpZiBwb3NzaWJsZS5cbiAgICAgKiBAcGFyYW0gaW50ZXJuYWxUZXh0dXJlIHRoZSB0ZXh0dXJlIHRvIGVuY29kZVxuICAgICAqIEBwYXJhbSBzY2VuZSB0aGUgc2NlbmUgaG9zdGluZyB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBvdXRwdXRUZXh0dXJlVHlwZSB0eXBlIG9mIHRoZSB0ZXh0dXJlIGluIHdoaWNoIHRoZSBlbmNvZGluZyBpcyBwZXJmb3JtZWRcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2Ugd2l0aCB0aGUgaW50ZXJuYWxUZXh0dXJlIGhhdmluZyBpdHMgdGV4dHVyZSByZXBsYWNlZCBieSB0aGUgcmVzdWx0IG9mIHRoZSBwcm9jZXNzaW5nXG4gICAgICovXG4gICAgLy8gU2hvdWxkIGhhdmUgXCJBc3luY1wiIGluIHRoZSBuYW1lIGJ1dCB0aGlzIGlzIGEgYnJlYWtpbmcgY2hhbmdlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIHN0YXRpYyBhc3luYyBFbmNvZGVUZXh0dXJlVG9SR0JEKGludGVybmFsVGV4dHVyZSwgc2NlbmUsIG91dHB1dFRleHR1cmVUeXBlID0gMCkge1xuICAgICAgICBpZiAoIXNjZW5lLmdldEVuZ2luZSgpLmlzV2ViR1BVKSB7XG4gICAgICAgICAgICBhd2FpdCBpbXBvcnQoXCIuLi9TaGFkZXJzL3JnYmRFbmNvZGUuZnJhZ21lbnQuanNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBpbXBvcnQoXCIuLi9TaGFkZXJzV0dTTC9yZ2JkRW5jb2RlLmZyYWdtZW50LmpzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcHBseVBvc3RQcm9jZXNzKFwicmdiZEVuY29kZVwiLCBpbnRlcm5hbFRleHR1cmUsIHNjZW5lLCBvdXRwdXRUZXh0dXJlVHlwZSwgMSwgNSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmdiZFRleHR1cmVUb29scy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=