"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["vendors-node_modules_babylonjs_core_Materials_Textures_Loaders_basisTextureLoader_js"],{

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/basisTextureLoader.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/basisTextureLoader.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _BasisTextureLoader: () => (/* binding */ _BasisTextureLoader)
/* harmony export */ });
/* harmony import */ var _Misc_basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Misc/basis.js */ "./node_modules/@babylonjs/core/Misc/basis.js");
/* harmony import */ var _Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Misc/tools.js */ "./node_modules/@babylonjs/core/Misc/tools.js");


/**
 * Loader for .basis file format
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class _BasisTextureLoader {
    constructor() {
        /**
         * Defines whether the loader supports cascade loading the different faces.
         */
        this.supportCascades = false;
    }
    /**
     * Uploads the cube texture data to the WebGL texture. It has already been bound.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param createPolynomials will be true if polynomials have been requested
     * @param onLoad defines the callback to trigger once the texture is ready
     * @param onError defines the callback to trigger in case of error
     */
    loadCubeData(data, texture, createPolynomials, onLoad, onError) {
        if (Array.isArray(data)) {
            return;
        }
        const caps = texture.getEngine().getCaps();
        const transcodeConfig = {
            supportedCompressionFormats: {
                etc1: caps.etc1 ? true : false,
                s3tc: caps.s3tc ? true : false,
                pvrtc: caps.pvrtc ? true : false,
                etc2: caps.etc2 ? true : false,
                astc: caps.astc ? true : false,
                bc7: caps.bptc ? true : false,
            },
        };
        (0,_Misc_basis_js__WEBPACK_IMPORTED_MODULE_0__.TranscodeAsync)(data, transcodeConfig)
            .then((result) => {
            const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;
            (0,_Misc_basis_js__WEBPACK_IMPORTED_MODULE_0__.LoadTextureFromTranscodeResult)(texture, result);
            texture.getEngine()._setCubeMapTextureParams(texture, hasMipmap);
            texture.isReady = true;
            texture.onLoadedObservable.notifyObservers(texture);
            texture.onLoadedObservable.clear();
            if (onLoad) {
                onLoad();
            }
        })
            .catch((err) => {
            const errorMessage = "Failed to transcode Basis file, transcoding may not be supported on this device";
            _Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn(errorMessage);
            texture.isReady = true;
            if (onError) {
                onError(err);
            }
        });
    }
    /**
     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param callback defines the method to call once ready to upload
     */
    loadData(data, texture, callback) {
        const caps = texture.getEngine().getCaps();
        const transcodeConfig = {
            supportedCompressionFormats: {
                etc1: caps.etc1 ? true : false,
                s3tc: caps.s3tc ? true : false,
                pvrtc: caps.pvrtc ? true : false,
                etc2: caps.etc2 ? true : false,
                astc: caps.astc ? true : false,
                bc7: caps.bptc ? true : false,
            },
        };
        (0,_Misc_basis_js__WEBPACK_IMPORTED_MODULE_0__.TranscodeAsync)(data, transcodeConfig)
            .then((result) => {
            const rootImage = result.fileInfo.images[0].levels[0];
            const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;
            callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, () => {
                (0,_Misc_basis_js__WEBPACK_IMPORTED_MODULE_0__.LoadTextureFromTranscodeResult)(texture, result);
            });
        })
            .catch((err) => {
            _Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device");
            _Misc_tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn(`Failed to transcode Basis file: ${err}`);
            callback(0, 0, false, false, () => { }, true);
        });
    }
}
//# sourceMappingURL=basisTextureLoader.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/basis.js":
/*!****************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/basis.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasisFileInfo: () => (/* binding */ BasisFileInfo),
/* harmony export */   BasisTools: () => (/* binding */ BasisTools),
/* harmony export */   BasisToolsOptions: () => (/* binding */ BasisToolsOptions),
/* harmony export */   BasisTranscodeConfiguration: () => (/* binding */ BasisTranscodeConfiguration),
/* harmony export */   GetInternalFormatFromBasisFormat: () => (/* binding */ GetInternalFormatFromBasisFormat),
/* harmony export */   LoadTextureFromTranscodeResult: () => (/* binding */ LoadTextureFromTranscodeResult),
/* harmony export */   SetBasisTranscoderWorker: () => (/* binding */ SetBasisTranscoderWorker),
/* harmony export */   TranscodeAsync: () => (/* binding */ TranscodeAsync)
/* harmony export */ });
/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools.js */ "./node_modules/@babylonjs/core/Misc/tools.js");
/* harmony import */ var _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Materials/Textures/texture.js */ "./node_modules/@babylonjs/core/Materials/Textures/texture.js");
/* harmony import */ var _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Materials/Textures/internalTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/internalTexture.js");
/* harmony import */ var _basisWorker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisWorker.js */ "./node_modules/@babylonjs/core/Misc/basisWorker.js");





/**
 * Info about the .basis files
 */
class BasisFileInfo {
}
/**
 * Result of transcoding a basis file
 */
class TranscodeResult {
}
/**
 * Configuration options for the Basis transcoder
 */
class BasisTranscodeConfiguration {
}
/**
 * @internal
 * Enum of basis transcoder formats
 */
var BASIS_FORMATS;
(function (BASIS_FORMATS) {
    BASIS_FORMATS[BASIS_FORMATS["cTFETC1"] = 0] = "cTFETC1";
    BASIS_FORMATS[BASIS_FORMATS["cTFETC2"] = 1] = "cTFETC2";
    BASIS_FORMATS[BASIS_FORMATS["cTFBC1"] = 2] = "cTFBC1";
    BASIS_FORMATS[BASIS_FORMATS["cTFBC3"] = 3] = "cTFBC3";
    BASIS_FORMATS[BASIS_FORMATS["cTFBC4"] = 4] = "cTFBC4";
    BASIS_FORMATS[BASIS_FORMATS["cTFBC5"] = 5] = "cTFBC5";
    BASIS_FORMATS[BASIS_FORMATS["cTFBC7"] = 6] = "cTFBC7";
    BASIS_FORMATS[BASIS_FORMATS["cTFPVRTC1_4_RGB"] = 8] = "cTFPVRTC1_4_RGB";
    BASIS_FORMATS[BASIS_FORMATS["cTFPVRTC1_4_RGBA"] = 9] = "cTFPVRTC1_4_RGBA";
    BASIS_FORMATS[BASIS_FORMATS["cTFASTC_4x4"] = 10] = "cTFASTC_4x4";
    BASIS_FORMATS[BASIS_FORMATS["cTFATC_RGB"] = 11] = "cTFATC_RGB";
    BASIS_FORMATS[BASIS_FORMATS["cTFATC_RGBA_INTERPOLATED_ALPHA"] = 12] = "cTFATC_RGBA_INTERPOLATED_ALPHA";
    BASIS_FORMATS[BASIS_FORMATS["cTFRGBA32"] = 13] = "cTFRGBA32";
    BASIS_FORMATS[BASIS_FORMATS["cTFRGB565"] = 14] = "cTFRGB565";
    BASIS_FORMATS[BASIS_FORMATS["cTFBGR565"] = 15] = "cTFBGR565";
    BASIS_FORMATS[BASIS_FORMATS["cTFRGBA4444"] = 16] = "cTFRGBA4444";
    BASIS_FORMATS[BASIS_FORMATS["cTFFXT1_RGB"] = 17] = "cTFFXT1_RGB";
    BASIS_FORMATS[BASIS_FORMATS["cTFPVRTC2_4_RGB"] = 18] = "cTFPVRTC2_4_RGB";
    BASIS_FORMATS[BASIS_FORMATS["cTFPVRTC2_4_RGBA"] = 19] = "cTFPVRTC2_4_RGBA";
    BASIS_FORMATS[BASIS_FORMATS["cTFETC2_EAC_R11"] = 20] = "cTFETC2_EAC_R11";
    BASIS_FORMATS[BASIS_FORMATS["cTFETC2_EAC_RG11"] = 21] = "cTFETC2_EAC_RG11";
})(BASIS_FORMATS || (BASIS_FORMATS = {}));
/**
 * Used to load .Basis files
 * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl
 */
const BasisToolsOptions = {
    /**
     * URL to use when loading the basis transcoder
     */
    JSModuleURL: `${_tools_js__WEBPACK_IMPORTED_MODULE_0__.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,
    /**
     * URL to use when loading the wasm module for the transcoder
     */
    WasmModuleURL: `${_tools_js__WEBPACK_IMPORTED_MODULE_0__.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`,
};
/**
 * Get the internal format to be passed to texImage2D corresponding to the .basis format value
 * @param basisFormat format chosen from GetSupportedTranscodeFormat
 * @param engine
 * @returns internal format corresponding to the Basis format
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const GetInternalFormatFromBasisFormat = (basisFormat, engine) => {
    let format;
    switch (basisFormat) {
        case BASIS_FORMATS.cTFETC1:
            format = 36196;
            break;
        case BASIS_FORMATS.cTFBC1:
            format = 33776;
            break;
        case BASIS_FORMATS.cTFBC4:
            format = 33779;
            break;
        case BASIS_FORMATS.cTFASTC_4x4:
            format = 37808;
            break;
        case BASIS_FORMATS.cTFETC2:
            format = 37496;
            break;
        case BASIS_FORMATS.cTFBC7:
            format = 36492;
            break;
    }
    if (format === undefined) {
        // eslint-disable-next-line no-throw-literal
        throw "The chosen Basis transcoder format is not currently supported";
    }
    return format;
};
let WorkerPromise = null;
let LocalWorker = null;
let ActionId = 0;
const IgnoreSupportedFormats = false;
const CreateWorkerAsync = async () => {
    if (!WorkerPromise) {
        WorkerPromise = new Promise((res, reject) => {
            if (LocalWorker) {
                res(LocalWorker);
            }
            else {
                _tools_js__WEBPACK_IMPORTED_MODULE_0__.Tools.LoadFileAsync(_tools_js__WEBPACK_IMPORTED_MODULE_0__.Tools.GetBabylonScriptURL(BasisToolsOptions.WasmModuleURL))
                    .then((wasmBinary) => {
                    if (typeof URL !== "function") {
                        return reject("Basis transcoder requires an environment with a URL constructor");
                    }
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    const workerBlobUrl = URL.createObjectURL(new Blob([`(${_basisWorker_js__WEBPACK_IMPORTED_MODULE_3__.workerFunction})()`], { type: "application/javascript" }));
                    LocalWorker = new Worker(workerBlobUrl);
                    (0,_basisWorker_js__WEBPACK_IMPORTED_MODULE_3__.initializeWebWorker)(LocalWorker, wasmBinary, BasisToolsOptions.JSModuleURL).then(res, reject);
                })
                    .catch(reject);
            }
        });
    }
    return WorkerPromise;
};
/**
 * Set the worker to use for transcoding
 * @param worker The worker that will be used for transcoding
 */
const SetBasisTranscoderWorker = (worker) => {
    LocalWorker = worker;
};
/**
 * Transcodes a loaded image file to compressed pixel data
 * @param data image data to transcode
 * @param config configuration options for the transcoding
 * @returns a promise resulting in the transcoded image
 */
const TranscodeAsync = async (data, config) => {
    const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
    return new Promise((res, rej) => {
        CreateWorkerAsync().then(() => {
            const actionId = ActionId++;
            const messageHandler = (msg) => {
                if (msg.data.action === "transcode" && msg.data.id === actionId) {
                    LocalWorker.removeEventListener("message", messageHandler);
                    if (!msg.data.success) {
                        rej("Transcode is not supported on this device");
                    }
                    else {
                        res(msg.data);
                    }
                }
            };
            LocalWorker.addEventListener("message", messageHandler);
            const dataViewCopy = new Uint8Array(dataView.byteLength);
            dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));
            LocalWorker.postMessage({ action: "transcode", id: actionId, imageData: dataViewCopy, config: config, ignoreSupportedFormats: IgnoreSupportedFormats }, [
                dataViewCopy.buffer,
            ]);
        }, (error) => {
            rej(error);
        });
    });
};
/**
 * Binds a texture according to its underlying target.
 * @param texture texture to bind
 * @param engine the engine to bind the texture in
 */
const BindTexture = (texture, engine) => {
    let target = engine._gl?.TEXTURE_2D;
    if (texture.isCube) {
        target = engine._gl?.TEXTURE_CUBE_MAP;
    }
    engine._bindTextureDirectly(target, texture, true);
};
/**
 * Loads a texture from the transcode result
 * @param texture texture load to
 * @param transcodeResult the result of transcoding the basis file to load from
 */
const LoadTextureFromTranscodeResult = (texture, transcodeResult) => {
    const engine = texture.getEngine();
    for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {
        const rootImage = transcodeResult.fileInfo.images[i].levels[0];
        texture._invertVScale = texture.invertY;
        if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {
            // No compatable compressed format found, fallback to RGB
            texture.type = 10;
            texture.format = 4;
            if (engine._features.basisNeedsPOT && (Math.log2(rootImage.width) % 1 !== 0 || Math.log2(rootImage.height) % 1 !== 0)) {
                // Create non power of two texture
                const source = new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_2__.InternalTexture(engine, 2 /* InternalTextureSource.Temp */);
                texture._invertVScale = texture.invertY;
                source.type = 10;
                source.format = 4;
                // Fallback requires aligned width/height
                source.width = (rootImage.width + 3) & ~3;
                source.height = (rootImage.height + 3) & ~3;
                BindTexture(source, engine);
                engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);
                // Resize to power of two
                engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(4), () => {
                    engine._releaseTexture(source);
                    BindTexture(texture, engine);
                });
            }
            else {
                // Fallback is already inverted
                texture._invertVScale = !texture.invertY;
                // Upload directly
                texture.width = (rootImage.width + 3) & ~3;
                texture.height = (rootImage.height + 3) & ~3;
                texture.samplingMode = 2;
                BindTexture(texture, engine);
                engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);
            }
        }
        else {
            texture.width = rootImage.width;
            texture.height = rootImage.height;
            texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;
            const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format, engine);
            texture.format = format;
            BindTexture(texture, engine);
            // Upload all mip levels in the file
            const levels = transcodeResult.fileInfo.images[i].levels;
            for (let index = 0; index < levels.length; index++) {
                const level = levels[index];
                engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);
            }
            if (engine._features.basisNeedsPOT && (Math.log2(texture.width) % 1 !== 0 || Math.log2(texture.height) % 1 !== 0)) {
                _tools_js__WEBPACK_IMPORTED_MODULE_0__.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.");
                texture._cachedWrapU = _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.CLAMP_ADDRESSMODE;
                texture._cachedWrapV = _Materials_Textures_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.CLAMP_ADDRESSMODE;
            }
        }
    }
};
/**
 * Used to load .Basis files
 * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl
 */
const BasisTools = {
    /**
     * URL to use when loading the basis transcoder
     */
    JSModuleURL: BasisToolsOptions.JSModuleURL,
    /**
     * URL to use when loading the wasm module for the transcoder
     */
    WasmModuleURL: BasisToolsOptions.WasmModuleURL,
    /**
     * Get the internal format to be passed to texImage2D corresponding to the .basis format value
     * @param basisFormat format chosen from GetSupportedTranscodeFormat
     * @returns internal format corresponding to the Basis format
     */
    GetInternalFormatFromBasisFormat,
    /**
     * Transcodes a loaded image file to compressed pixel data
     * @param data image data to transcode
     * @param config configuration options for the transcoding
     * @returns a promise resulting in the transcoded image
     */
    TranscodeAsync,
    /**
     * Loads a texture from the transcode result
     * @param texture texture load to
     * @param transcodeResult the result of transcoding the basis file to load from
     */
    LoadTextureFromTranscodeResult,
};
Object.defineProperty(BasisTools, "JSModuleURL", {
    get: function () {
        return BasisToolsOptions.JSModuleURL;
    },
    set: function (value) {
        BasisToolsOptions.JSModuleURL = value;
    },
});
Object.defineProperty(BasisTools, "WasmModuleURL", {
    get: function () {
        return BasisToolsOptions.WasmModuleURL;
    },
    set: function (value) {
        BasisToolsOptions.WasmModuleURL = value;
    },
});
//# sourceMappingURL=basis.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/basisWorker.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/basisWorker.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initializeWebWorker: () => (/* binding */ initializeWebWorker),
/* harmony export */   workerFunction: () => (/* binding */ workerFunction)
/* harmony export */ });
/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools.js */ "./node_modules/@babylonjs/core/Misc/tools.js");

/**
 * The worker function that gets converted to a blob url to pass into a worker.
 * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.
 */
function workerFunction() {
    const _BASIS_FORMAT = {
        cTFETC1: 0,
        cTFETC2: 1,
        cTFBC1: 2,
        cTFBC3: 3,
        cTFBC4: 4,
        cTFBC5: 5,
        cTFBC7: 6,
        cTFPVRTC1_4_RGB: 8,
        cTFPVRTC1_4_RGBA: 9,
        cTFASTC_4x4: 10,
        cTFATC_RGB: 11,
        cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
        cTFRGBA32: 13,
        cTFRGB565: 14,
        cTFBGR565: 15,
        cTFRGBA4444: 16,
        cTFFXT1_RGB: 17,
        cTFPVRTC2_4_RGB: 18,
        cTFPVRTC2_4_RGBA: 19,
        cTFETC2_EAC_R11: 20,
        cTFETC2_EAC_RG11: 21,
    };
    let transcoderModulePromise = null;
    onmessage = (event) => {
        if (event.data.action === "init") {
            // Load the transcoder if it hasn't been yet
            if (event.data.url) {
                // make sure we loaded the script correctly
                try {
                    importScripts(event.data.url);
                }
                catch (e) {
                    postMessage({ action: "error", error: e });
                }
            }
            if (!transcoderModulePromise) {
                transcoderModulePromise = BASIS({
                    // Override wasm binary
                    wasmBinary: event.data.wasmBinary,
                });
            }
            if (transcoderModulePromise !== null) {
                transcoderModulePromise.then((m) => {
                    BASIS = m;
                    m.initializeBasis();
                    postMessage({ action: "init" });
                });
            }
        }
        else if (event.data.action === "transcode") {
            // Transcode the basis image and return the resulting pixels
            const config = event.data.config;
            const imgData = event.data.imageData;
            const loadedFile = new BASIS.BasisFile(imgData);
            const fileInfo = GetFileInfo(loadedFile);
            let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);
            let needsConversion = false;
            if (format === null) {
                needsConversion = true;
                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;
            }
            // Begin transcode
            let success = true;
            if (!loadedFile.startTranscoding()) {
                success = false;
            }
            const buffers = [];
            for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {
                if (!success) {
                    break;
                }
                const image = fileInfo.images[imageIndex];
                if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {
                    let mipCount = image.levels.length;
                    if (config.loadMipmapLevels === false) {
                        mipCount = 1;
                    }
                    for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {
                        const levelInfo = image.levels[levelIndex];
                        const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format, needsConversion);
                        if (!pixels) {
                            success = false;
                            break;
                        }
                        levelInfo.transcodedPixels = pixels;
                        buffers.push(levelInfo.transcodedPixels.buffer);
                    }
                }
            }
            // Close file
            loadedFile.close();
            loadedFile.delete();
            if (needsConversion) {
                format = -1;
            }
            if (!success) {
                postMessage({ action: "transcode", success: success, id: event.data.id });
            }
            else {
                postMessage({ action: "transcode", success: success, id: event.data.id, fileInfo: fileInfo, format: format }, buffers);
            }
        }
    };
    /**
     * Detects the supported transcode format for the file
     * @param config transcode config
     * @param fileInfo info about the file
     * @returns the chosed format or null if none are supported
     */
    function GetSupportedTranscodeFormat(config, fileInfo) {
        let format = null;
        if (config.supportedCompressionFormats) {
            if (config.supportedCompressionFormats.astc) {
                format = _BASIS_FORMAT.cTFASTC_4x4;
            }
            else if (config.supportedCompressionFormats.bc7) {
                format = _BASIS_FORMAT.cTFBC7;
            }
            else if (config.supportedCompressionFormats.s3tc) {
                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;
            }
            else if (config.supportedCompressionFormats.pvrtc) {
                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;
            }
            else if (config.supportedCompressionFormats.etc2) {
                format = _BASIS_FORMAT.cTFETC2;
            }
            else if (config.supportedCompressionFormats.etc1) {
                format = _BASIS_FORMAT.cTFETC1;
            }
            else {
                format = _BASIS_FORMAT.cTFRGB565;
            }
        }
        return format;
    }
    /**
     * Retrieves information about the basis file eg. dimensions
     * @param basisFile the basis file to get the info from
     * @returns information about the basis file
     */
    function GetFileInfo(basisFile) {
        const hasAlpha = basisFile.getHasAlpha();
        const imageCount = basisFile.getNumImages();
        const images = [];
        for (let i = 0; i < imageCount; i++) {
            const imageInfo = {
                levels: [],
            };
            const levelCount = basisFile.getNumLevels(i);
            for (let level = 0; level < levelCount; level++) {
                const levelInfo = {
                    width: basisFile.getImageWidth(i, level),
                    height: basisFile.getImageHeight(i, level),
                };
                imageInfo.levels.push(levelInfo);
            }
            images.push(imageInfo);
        }
        const info = { hasAlpha, images };
        return info;
    }
    function TranscodeLevel(loadedFile, imageIndex, levelIndex, format, convertToRgb565) {
        const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);
        let dst = new Uint8Array(dstSize);
        if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {
            return null;
        }
        // If no supported format is found, load as dxt and convert to rgb565
        if (convertToRgb565) {
            const alignedWidth = (loadedFile.getImageWidth(imageIndex, levelIndex) + 3) & ~3;
            const alignedHeight = (loadedFile.getImageHeight(imageIndex, levelIndex) + 3) & ~3;
            dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);
        }
        return dst;
    }
    /**
     * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js
     * An unoptimized version of dxtToRgb565.  Also, the floating
     * point math used to compute the colors actually results in
     * slightly different colors compared to hardware DXT decoders.
     * @param src dxt src pixels
     * @param srcByteOffset offset for the start of src
     * @param  width aligned width of the image
     * @param  height aligned height of the image
     * @returns the converted pixels
     */
    function ConvertDxtToRgb565(src, srcByteOffset, width, height) {
        const c = new Uint16Array(4);
        const dst = new Uint16Array(width * height);
        const blockWidth = width / 4;
        const blockHeight = height / 4;
        for (let blockY = 0; blockY < blockHeight; blockY++) {
            for (let blockX = 0; blockX < blockWidth; blockX++) {
                const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);
                c[0] = src[i] | (src[i + 1] << 8);
                c[1] = src[i + 2] | (src[i + 3] << 8);
                c[2] =
                    ((2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3) |
                        (((2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3) & 0x7e0) |
                        (((2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3) & 0xf800);
                c[3] =
                    ((2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3) |
                        (((2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3) & 0x7e0) |
                        (((2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3) & 0xf800);
                for (let row = 0; row < 4; row++) {
                    const m = src[i + 4 + row];
                    let dstI = (blockY * 4 + row) * width + blockX * 4;
                    dst[dstI++] = c[m & 0x3];
                    dst[dstI++] = c[(m >> 2) & 0x3];
                    dst[dstI++] = c[(m >> 4) & 0x3];
                    dst[dstI++] = c[(m >> 6) & 0x3];
                }
            }
        }
        return dst;
    }
}
/**
 * Initialize a web worker with the basis transcoder
 * @param worker the worker to initialize
 * @param wasmBinary the wasm binary to load into the worker
 * @param moduleUrl the url to the basis transcoder module
 * @returns a promise that resolves when the worker is initialized
 */
// eslint-disable-next-line no-restricted-syntax
async function initializeWebWorker(worker, wasmBinary, moduleUrl) {
    return new Promise((res, reject) => {
        const initHandler = (msg) => {
            if (msg.data.action === "init") {
                worker.removeEventListener("message", initHandler);
                res(worker);
            }
            else if (msg.data.action === "error") {
                reject(msg.data.error || "error initializing worker");
            }
        };
        worker.addEventListener("message", initHandler);
        // we can use transferable objects here because the worker will own the ArrayBuffer
        worker.postMessage({ action: "init", url: moduleUrl ? _tools_js__WEBPACK_IMPORTED_MODULE_0__.Tools.GetBabylonScriptURL(moduleUrl) : undefined, wasmBinary }, [wasmBinary]);
    });
}
//# sourceMappingURL=basisWorker.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfTWF0ZXJpYWxzX1RleHR1cmVzX0xvYWRlcnNfYmFzaXNUZXh0dXJlTG9hZGVyX2pzLmJyb3dzZXItcGFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBd0Y7QUFDekM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsUUFBUSw4REFBYztBQUN0QjtBQUNBO0FBQ0EsWUFBWSw4RUFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksaURBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFFBQVEsOERBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEVBQThCO0FBQzlDLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxZQUFZLGlEQUFLO0FBQ2pCLFlBQVksaURBQUsseUNBQXlDLElBQUk7QUFDOUQsa0RBQWtEO0FBQ2xELFNBQVM7QUFDVDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzRm1DO0FBQ3dCO0FBQ2dCOztBQUVKO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRCxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUNBQWlDLDRDQUFLLHlEQUF5RDtBQUM1SCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvTG9hZGVycy9iYXNpc1RleHR1cmVMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01pc2MvYmFzaXMuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01pc2MvYmFzaXNXb3JrZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZFRleHR1cmVGcm9tVHJhbnNjb2RlUmVzdWx0LCBUcmFuc2NvZGVBc3luYyB9IGZyb20gXCIuLi8uLi8uLi9NaXNjL2Jhc2lzLmpzXCI7XG5pbXBvcnQgeyBUb29scyB9IGZyb20gXCIuLi8uLi8uLi9NaXNjL3Rvb2xzLmpzXCI7XG4vKipcbiAqIExvYWRlciBmb3IgLmJhc2lzIGZpbGUgZm9ybWF0XG4gKiBAaW50ZXJuYWxcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNsYXNzIF9CYXNpc1RleHR1cmVMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBsb2FkZXIgc3VwcG9ydHMgY2FzY2FkZSBsb2FkaW5nIHRoZSBkaWZmZXJlbnQgZmFjZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRDYXNjYWRlcyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSBjdWJlIHRleHR1cmUgZGF0YSB0byB0aGUgV2ViR0wgdGV4dHVyZS4gSXQgaGFzIGFscmVhZHkgYmVlbiBib3VuZC5cbiAgICAgKiBAcGFyYW0gZGF0YSBjb250YWlucyB0aGUgdGV4dHVyZSBkYXRhXG4gICAgICogQHBhcmFtIHRleHR1cmUgZGVmaW5lcyB0aGUgQmFieWxvbkpTIGludGVybmFsIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gY3JlYXRlUG9seW5vbWlhbHMgd2lsbCBiZSB0cnVlIGlmIHBvbHlub21pYWxzIGhhdmUgYmVlbiByZXF1ZXN0ZWRcbiAgICAgKiBAcGFyYW0gb25Mb2FkIGRlZmluZXMgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgb25jZSB0aGUgdGV4dHVyZSBpcyByZWFkeVxuICAgICAqIEBwYXJhbSBvbkVycm9yIGRlZmluZXMgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgaW4gY2FzZSBvZiBlcnJvclxuICAgICAqL1xuICAgIGxvYWRDdWJlRGF0YShkYXRhLCB0ZXh0dXJlLCBjcmVhdGVQb2x5bm9taWFscywgb25Mb2FkLCBvbkVycm9yKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FwcyA9IHRleHR1cmUuZ2V0RW5naW5lKCkuZ2V0Q2FwcygpO1xuICAgICAgICBjb25zdCB0cmFuc2NvZGVDb25maWcgPSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWRDb21wcmVzc2lvbkZvcm1hdHM6IHtcbiAgICAgICAgICAgICAgICBldGMxOiBjYXBzLmV0YzEgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgczN0YzogY2Fwcy5zM3RjID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHB2cnRjOiBjYXBzLnB2cnRjID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGV0YzI6IGNhcHMuZXRjMiA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc3RjOiBjYXBzLmFzdGMgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYmM3OiBjYXBzLmJwdGMgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBUcmFuc2NvZGVBc3luYyhkYXRhLCB0cmFuc2NvZGVDb25maWcpXG4gICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYXNNaXBtYXAgPSByZXN1bHQuZmlsZUluZm8uaW1hZ2VzWzBdLmxldmVscy5sZW5ndGggPiAxICYmIHRleHR1cmUuZ2VuZXJhdGVNaXBNYXBzO1xuICAgICAgICAgICAgTG9hZFRleHR1cmVGcm9tVHJhbnNjb2RlUmVzdWx0KHRleHR1cmUsIHJlc3VsdCk7XG4gICAgICAgICAgICB0ZXh0dXJlLmdldEVuZ2luZSgpLl9zZXRDdWJlTWFwVGV4dHVyZVBhcmFtcyh0ZXh0dXJlLCBoYXNNaXBtYXApO1xuICAgICAgICAgICAgdGV4dHVyZS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRleHR1cmUub25Mb2FkZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyh0ZXh0dXJlKTtcbiAgICAgICAgICAgIHRleHR1cmUub25Mb2FkZWRPYnNlcnZhYmxlLmNsZWFyKCk7XG4gICAgICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgb25Mb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gXCJGYWlsZWQgdG8gdHJhbnNjb2RlIEJhc2lzIGZpbGUsIHRyYW5zY29kaW5nIG1heSBub3QgYmUgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlXCI7XG4gICAgICAgICAgICBUb29scy5XYXJuKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB0ZXh0dXJlLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSAyRCB0ZXh0dXJlIGRhdGEgdG8gdGhlIFdlYkdMIHRleHR1cmUuIEl0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmQgb25jZSBpbiB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIGRhdGEgY29udGFpbnMgdGhlIHRleHR1cmUgZGF0YVxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIGRlZmluZXMgdGhlIEJhYnlsb25KUyBpbnRlcm5hbCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIGRlZmluZXMgdGhlIG1ldGhvZCB0byBjYWxsIG9uY2UgcmVhZHkgdG8gdXBsb2FkXG4gICAgICovXG4gICAgbG9hZERhdGEoZGF0YSwgdGV4dHVyZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY2FwcyA9IHRleHR1cmUuZ2V0RW5naW5lKCkuZ2V0Q2FwcygpO1xuICAgICAgICBjb25zdCB0cmFuc2NvZGVDb25maWcgPSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWRDb21wcmVzc2lvbkZvcm1hdHM6IHtcbiAgICAgICAgICAgICAgICBldGMxOiBjYXBzLmV0YzEgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgczN0YzogY2Fwcy5zM3RjID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHB2cnRjOiBjYXBzLnB2cnRjID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGV0YzI6IGNhcHMuZXRjMiA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc3RjOiBjYXBzLmFzdGMgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYmM3OiBjYXBzLmJwdGMgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBUcmFuc2NvZGVBc3luYyhkYXRhLCB0cmFuc2NvZGVDb25maWcpXG4gICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb290SW1hZ2UgPSByZXN1bHQuZmlsZUluZm8uaW1hZ2VzWzBdLmxldmVsc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGhhc01pcG1hcCA9IHJlc3VsdC5maWxlSW5mby5pbWFnZXNbMF0ubGV2ZWxzLmxlbmd0aCA+IDEgJiYgdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHM7XG4gICAgICAgICAgICBjYWxsYmFjayhyb290SW1hZ2Uud2lkdGgsIHJvb3RJbWFnZS5oZWlnaHQsIGhhc01pcG1hcCwgcmVzdWx0LmZvcm1hdCAhPT0gLTEsICgpID0+IHtcbiAgICAgICAgICAgICAgICBMb2FkVGV4dHVyZUZyb21UcmFuc2NvZGVSZXN1bHQodGV4dHVyZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIFRvb2xzLldhcm4oXCJGYWlsZWQgdG8gdHJhbnNjb2RlIEJhc2lzIGZpbGUsIHRyYW5zY29kaW5nIG1heSBub3QgYmUgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlXCIpO1xuICAgICAgICAgICAgVG9vbHMuV2FybihgRmFpbGVkIHRvIHRyYW5zY29kZSBCYXNpcyBmaWxlOiAke2Vycn1gKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKDAsIDAsIGZhbHNlLCBmYWxzZSwgKCkgPT4geyB9LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzaXNUZXh0dXJlTG9hZGVyLmpzLm1hcCIsImltcG9ydCB7IFRvb2xzIH0gZnJvbSBcIi4vdG9vbHMuanNcIjtcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tIFwiLi4vTWF0ZXJpYWxzL1RleHR1cmVzL3RleHR1cmUuanNcIjtcbmltcG9ydCB7IEludGVybmFsVGV4dHVyZSB9IGZyb20gXCIuLi9NYXRlcmlhbHMvVGV4dHVyZXMvaW50ZXJuYWxUZXh0dXJlLmpzXCI7XG5cbmltcG9ydCB7IGluaXRpYWxpemVXZWJXb3JrZXIsIHdvcmtlckZ1bmN0aW9uIH0gZnJvbSBcIi4vYmFzaXNXb3JrZXIuanNcIjtcbi8qKlxuICogSW5mbyBhYm91dCB0aGUgLmJhc2lzIGZpbGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNpc0ZpbGVJbmZvIHtcbn1cbi8qKlxuICogUmVzdWx0IG9mIHRyYW5zY29kaW5nIGEgYmFzaXMgZmlsZVxuICovXG5jbGFzcyBUcmFuc2NvZGVSZXN1bHQge1xufVxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBCYXNpcyB0cmFuc2NvZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNpc1RyYW5zY29kZUNvbmZpZ3VyYXRpb24ge1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEVudW0gb2YgYmFzaXMgdHJhbnNjb2RlciBmb3JtYXRzXG4gKi9cbnZhciBCQVNJU19GT1JNQVRTO1xuKGZ1bmN0aW9uIChCQVNJU19GT1JNQVRTKSB7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGRVRDMVwiXSA9IDBdID0gXCJjVEZFVEMxXCI7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGRVRDMlwiXSA9IDFdID0gXCJjVEZFVEMyXCI7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGQkMxXCJdID0gMl0gPSBcImNURkJDMVwiO1xuICAgIEJBU0lTX0ZPUk1BVFNbQkFTSVNfRk9STUFUU1tcImNURkJDM1wiXSA9IDNdID0gXCJjVEZCQzNcIjtcbiAgICBCQVNJU19GT1JNQVRTW0JBU0lTX0ZPUk1BVFNbXCJjVEZCQzRcIl0gPSA0XSA9IFwiY1RGQkM0XCI7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGQkM1XCJdID0gNV0gPSBcImNURkJDNVwiO1xuICAgIEJBU0lTX0ZPUk1BVFNbQkFTSVNfRk9STUFUU1tcImNURkJDN1wiXSA9IDZdID0gXCJjVEZCQzdcIjtcbiAgICBCQVNJU19GT1JNQVRTW0JBU0lTX0ZPUk1BVFNbXCJjVEZQVlJUQzFfNF9SR0JcIl0gPSA4XSA9IFwiY1RGUFZSVEMxXzRfUkdCXCI7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGUFZSVEMxXzRfUkdCQVwiXSA9IDldID0gXCJjVEZQVlJUQzFfNF9SR0JBXCI7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGQVNUQ180eDRcIl0gPSAxMF0gPSBcImNURkFTVENfNHg0XCI7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGQVRDX1JHQlwiXSA9IDExXSA9IFwiY1RGQVRDX1JHQlwiO1xuICAgIEJBU0lTX0ZPUk1BVFNbQkFTSVNfRk9STUFUU1tcImNURkFUQ19SR0JBX0lOVEVSUE9MQVRFRF9BTFBIQVwiXSA9IDEyXSA9IFwiY1RGQVRDX1JHQkFfSU5URVJQT0xBVEVEX0FMUEhBXCI7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGUkdCQTMyXCJdID0gMTNdID0gXCJjVEZSR0JBMzJcIjtcbiAgICBCQVNJU19GT1JNQVRTW0JBU0lTX0ZPUk1BVFNbXCJjVEZSR0I1NjVcIl0gPSAxNF0gPSBcImNURlJHQjU2NVwiO1xuICAgIEJBU0lTX0ZPUk1BVFNbQkFTSVNfRk9STUFUU1tcImNURkJHUjU2NVwiXSA9IDE1XSA9IFwiY1RGQkdSNTY1XCI7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGUkdCQTQ0NDRcIl0gPSAxNl0gPSBcImNURlJHQkE0NDQ0XCI7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGRlhUMV9SR0JcIl0gPSAxN10gPSBcImNURkZYVDFfUkdCXCI7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGUFZSVEMyXzRfUkdCXCJdID0gMThdID0gXCJjVEZQVlJUQzJfNF9SR0JcIjtcbiAgICBCQVNJU19GT1JNQVRTW0JBU0lTX0ZPUk1BVFNbXCJjVEZQVlJUQzJfNF9SR0JBXCJdID0gMTldID0gXCJjVEZQVlJUQzJfNF9SR0JBXCI7XG4gICAgQkFTSVNfRk9STUFUU1tCQVNJU19GT1JNQVRTW1wiY1RGRVRDMl9FQUNfUjExXCJdID0gMjBdID0gXCJjVEZFVEMyX0VBQ19SMTFcIjtcbiAgICBCQVNJU19GT1JNQVRTW0JBU0lTX0ZPUk1BVFNbXCJjVEZFVEMyX0VBQ19SRzExXCJdID0gMjFdID0gXCJjVEZFVEMyX0VBQ19SRzExXCI7XG59KShCQVNJU19GT1JNQVRTIHx8IChCQVNJU19GT1JNQVRTID0ge30pKTtcbi8qKlxuICogVXNlZCB0byBsb2FkIC5CYXNpcyBmaWxlc1xuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9CaW5vbWlhbExMQy9iYXNpc191bml2ZXJzYWwvdHJlZS9tYXN0ZXIvd2ViZ2xcbiAqL1xuZXhwb3J0IGNvbnN0IEJhc2lzVG9vbHNPcHRpb25zID0ge1xuICAgIC8qKlxuICAgICAqIFVSTCB0byB1c2Ugd2hlbiBsb2FkaW5nIHRoZSBiYXNpcyB0cmFuc2NvZGVyXG4gICAgICovXG4gICAgSlNNb2R1bGVVUkw6IGAke1Rvb2xzLl9EZWZhdWx0Q2RuVXJsfS9iYXNpc1RyYW5zY29kZXIvMS9iYXNpc190cmFuc2NvZGVyLmpzYCxcbiAgICAvKipcbiAgICAgKiBVUkwgdG8gdXNlIHdoZW4gbG9hZGluZyB0aGUgd2FzbSBtb2R1bGUgZm9yIHRoZSB0cmFuc2NvZGVyXG4gICAgICovXG4gICAgV2FzbU1vZHVsZVVSTDogYCR7VG9vbHMuX0RlZmF1bHRDZG5Vcmx9L2Jhc2lzVHJhbnNjb2Rlci8xL2Jhc2lzX3RyYW5zY29kZXIud2FzbWAsXG59O1xuLyoqXG4gKiBHZXQgdGhlIGludGVybmFsIGZvcm1hdCB0byBiZSBwYXNzZWQgdG8gdGV4SW1hZ2UyRCBjb3JyZXNwb25kaW5nIHRvIHRoZSAuYmFzaXMgZm9ybWF0IHZhbHVlXG4gKiBAcGFyYW0gYmFzaXNGb3JtYXQgZm9ybWF0IGNob3NlbiBmcm9tIEdldFN1cHBvcnRlZFRyYW5zY29kZUZvcm1hdFxuICogQHBhcmFtIGVuZ2luZVxuICogQHJldHVybnMgaW50ZXJuYWwgZm9ybWF0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIEJhc2lzIGZvcm1hdFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgY29uc3QgR2V0SW50ZXJuYWxGb3JtYXRGcm9tQmFzaXNGb3JtYXQgPSAoYmFzaXNGb3JtYXQsIGVuZ2luZSkgPT4ge1xuICAgIGxldCBmb3JtYXQ7XG4gICAgc3dpdGNoIChiYXNpc0Zvcm1hdCkge1xuICAgICAgICBjYXNlIEJBU0lTX0ZPUk1BVFMuY1RGRVRDMTpcbiAgICAgICAgICAgIGZvcm1hdCA9IDM2MTk2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQkFTSVNfRk9STUFUUy5jVEZCQzE6XG4gICAgICAgICAgICBmb3JtYXQgPSAzMzc3NjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJBU0lTX0ZPUk1BVFMuY1RGQkM0OlxuICAgICAgICAgICAgZm9ybWF0ID0gMzM3Nzk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCQVNJU19GT1JNQVRTLmNURkFTVENfNHg0OlxuICAgICAgICAgICAgZm9ybWF0ID0gMzc4MDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCQVNJU19GT1JNQVRTLmNURkVUQzI6XG4gICAgICAgICAgICBmb3JtYXQgPSAzNzQ5NjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJBU0lTX0ZPUk1BVFMuY1RGQkM3OlxuICAgICAgICAgICAgZm9ybWF0ID0gMzY0OTI7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gICAgICAgIHRocm93IFwiVGhlIGNob3NlbiBCYXNpcyB0cmFuc2NvZGVyIGZvcm1hdCBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZFwiO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0O1xufTtcbmxldCBXb3JrZXJQcm9taXNlID0gbnVsbDtcbmxldCBMb2NhbFdvcmtlciA9IG51bGw7XG5sZXQgQWN0aW9uSWQgPSAwO1xuY29uc3QgSWdub3JlU3VwcG9ydGVkRm9ybWF0cyA9IGZhbHNlO1xuY29uc3QgQ3JlYXRlV29ya2VyQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFXb3JrZXJQcm9taXNlKSB7XG4gICAgICAgIFdvcmtlclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmIChMb2NhbFdvcmtlcikge1xuICAgICAgICAgICAgICAgIHJlcyhMb2NhbFdvcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBUb29scy5Mb2FkRmlsZUFzeW5jKFRvb2xzLkdldEJhYnlsb25TY3JpcHRVUkwoQmFzaXNUb29sc09wdGlvbnMuV2FzbU1vZHVsZVVSTCkpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh3YXNtQmluYXJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVVJMICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoXCJCYXNpcyB0cmFuc2NvZGVyIHJlcXVpcmVzIGFuIGVudmlyb25tZW50IHdpdGggYSBVUkwgY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3b3JrZXJCbG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbYCgke3dvcmtlckZ1bmN0aW9ufSkoKWBdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxXb3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlckJsb2JVcmwpO1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplV2ViV29ya2VyKExvY2FsV29ya2VyLCB3YXNtQmluYXJ5LCBCYXNpc1Rvb2xzT3B0aW9ucy5KU01vZHVsZVVSTCkudGhlbihyZXMsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gV29ya2VyUHJvbWlzZTtcbn07XG4vKipcbiAqIFNldCB0aGUgd29ya2VyIHRvIHVzZSBmb3IgdHJhbnNjb2RpbmdcbiAqIEBwYXJhbSB3b3JrZXIgVGhlIHdvcmtlciB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdHJhbnNjb2RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFNldEJhc2lzVHJhbnNjb2RlcldvcmtlciA9ICh3b3JrZXIpID0+IHtcbiAgICBMb2NhbFdvcmtlciA9IHdvcmtlcjtcbn07XG4vKipcbiAqIFRyYW5zY29kZXMgYSBsb2FkZWQgaW1hZ2UgZmlsZSB0byBjb21wcmVzc2VkIHBpeGVsIGRhdGFcbiAqIEBwYXJhbSBkYXRhIGltYWdlIGRhdGEgdG8gdHJhbnNjb2RlXG4gKiBAcGFyYW0gY29uZmlnIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHRyYW5zY29kaW5nXG4gKiBAcmV0dXJucyBhIHByb21pc2UgcmVzdWx0aW5nIGluIHRoZSB0cmFuc2NvZGVkIGltYWdlXG4gKi9cbmV4cG9ydCBjb25zdCBUcmFuc2NvZGVBc3luYyA9IGFzeW5jIChkYXRhLCBjb25maWcpID0+IHtcbiAgICBjb25zdCBkYXRhVmlldyA9IGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KGRhdGEpIDogZGF0YTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIENyZWF0ZVdvcmtlckFzeW5jKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25JZCA9IEFjdGlvbklkKys7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobXNnLmRhdGEuYWN0aW9uID09PSBcInRyYW5zY29kZVwiICYmIG1zZy5kYXRhLmlkID09PSBhY3Rpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICBMb2NhbFdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBtZXNzYWdlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXNnLmRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqKFwiVHJhbnNjb2RlIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMobXNnLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIExvY2FsV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3Q29weSA9IG5ldyBVaW50OEFycmF5KGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgZGF0YVZpZXdDb3B5LnNldChuZXcgVWludDhBcnJheShkYXRhVmlldy5idWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgICAgIExvY2FsV29ya2VyLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiBcInRyYW5zY29kZVwiLCBpZDogYWN0aW9uSWQsIGltYWdlRGF0YTogZGF0YVZpZXdDb3B5LCBjb25maWc6IGNvbmZpZywgaWdub3JlU3VwcG9ydGVkRm9ybWF0czogSWdub3JlU3VwcG9ydGVkRm9ybWF0cyB9LCBbXG4gICAgICAgICAgICAgICAgZGF0YVZpZXdDb3B5LmJ1ZmZlcixcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJlaihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8qKlxuICogQmluZHMgYSB0ZXh0dXJlIGFjY29yZGluZyB0byBpdHMgdW5kZXJseWluZyB0YXJnZXQuXG4gKiBAcGFyYW0gdGV4dHVyZSB0ZXh0dXJlIHRvIGJpbmRcbiAqIEBwYXJhbSBlbmdpbmUgdGhlIGVuZ2luZSB0byBiaW5kIHRoZSB0ZXh0dXJlIGluXG4gKi9cbmNvbnN0IEJpbmRUZXh0dXJlID0gKHRleHR1cmUsIGVuZ2luZSkgPT4ge1xuICAgIGxldCB0YXJnZXQgPSBlbmdpbmUuX2dsPy5URVhUVVJFXzJEO1xuICAgIGlmICh0ZXh0dXJlLmlzQ3ViZSkge1xuICAgICAgICB0YXJnZXQgPSBlbmdpbmUuX2dsPy5URVhUVVJFX0NVQkVfTUFQO1xuICAgIH1cbiAgICBlbmdpbmUuX2JpbmRUZXh0dXJlRGlyZWN0bHkodGFyZ2V0LCB0ZXh0dXJlLCB0cnVlKTtcbn07XG4vKipcbiAqIExvYWRzIGEgdGV4dHVyZSBmcm9tIHRoZSB0cmFuc2NvZGUgcmVzdWx0XG4gKiBAcGFyYW0gdGV4dHVyZSB0ZXh0dXJlIGxvYWQgdG9cbiAqIEBwYXJhbSB0cmFuc2NvZGVSZXN1bHQgdGhlIHJlc3VsdCBvZiB0cmFuc2NvZGluZyB0aGUgYmFzaXMgZmlsZSB0byBsb2FkIGZyb21cbiAqL1xuZXhwb3J0IGNvbnN0IExvYWRUZXh0dXJlRnJvbVRyYW5zY29kZVJlc3VsdCA9ICh0ZXh0dXJlLCB0cmFuc2NvZGVSZXN1bHQpID0+IHtcbiAgICBjb25zdCBlbmdpbmUgPSB0ZXh0dXJlLmdldEVuZ2luZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNjb2RlUmVzdWx0LmZpbGVJbmZvLmltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByb290SW1hZ2UgPSB0cmFuc2NvZGVSZXN1bHQuZmlsZUluZm8uaW1hZ2VzW2ldLmxldmVsc1swXTtcbiAgICAgICAgdGV4dHVyZS5faW52ZXJ0VlNjYWxlID0gdGV4dHVyZS5pbnZlcnRZO1xuICAgICAgICBpZiAodHJhbnNjb2RlUmVzdWx0LmZvcm1hdCA9PT0gLTEgfHwgdHJhbnNjb2RlUmVzdWx0LmZvcm1hdCA9PT0gQkFTSVNfRk9STUFUUy5jVEZSR0I1NjUpIHtcbiAgICAgICAgICAgIC8vIE5vIGNvbXBhdGFibGUgY29tcHJlc3NlZCBmb3JtYXQgZm91bmQsIGZhbGxiYWNrIHRvIFJHQlxuICAgICAgICAgICAgdGV4dHVyZS50eXBlID0gMTA7XG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IDQ7XG4gICAgICAgICAgICBpZiAoZW5naW5lLl9mZWF0dXJlcy5iYXNpc05lZWRzUE9UICYmIChNYXRoLmxvZzIocm9vdEltYWdlLndpZHRoKSAlIDEgIT09IDAgfHwgTWF0aC5sb2cyKHJvb3RJbWFnZS5oZWlnaHQpICUgMSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbm9uIHBvd2VyIG9mIHR3byB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IEludGVybmFsVGV4dHVyZShlbmdpbmUsIDIgLyogSW50ZXJuYWxUZXh0dXJlU291cmNlLlRlbXAgKi8pO1xuICAgICAgICAgICAgICAgIHRleHR1cmUuX2ludmVydFZTY2FsZSA9IHRleHR1cmUuaW52ZXJ0WTtcbiAgICAgICAgICAgICAgICBzb3VyY2UudHlwZSA9IDEwO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5mb3JtYXQgPSA0O1xuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHJlcXVpcmVzIGFsaWduZWQgd2lkdGgvaGVpZ2h0XG4gICAgICAgICAgICAgICAgc291cmNlLndpZHRoID0gKHJvb3RJbWFnZS53aWR0aCArIDMpICYgfjM7XG4gICAgICAgICAgICAgICAgc291cmNlLmhlaWdodCA9IChyb290SW1hZ2UuaGVpZ2h0ICsgMykgJiB+MztcbiAgICAgICAgICAgICAgICBCaW5kVGV4dHVyZShzb3VyY2UsIGVuZ2luZSk7XG4gICAgICAgICAgICAgICAgZW5naW5lLl91cGxvYWREYXRhVG9UZXh0dXJlRGlyZWN0bHkoc291cmNlLCBuZXcgVWludDE2QXJyYXkocm9vdEltYWdlLnRyYW5zY29kZWRQaXhlbHMuYnVmZmVyKSwgaSwgMCwgNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gUmVzaXplIHRvIHBvd2VyIG9mIHR3b1xuICAgICAgICAgICAgICAgIGVuZ2luZS5fcmVzY2FsZVRleHR1cmUoc291cmNlLCB0ZXh0dXJlLCBlbmdpbmUuc2NlbmVzWzBdLCBlbmdpbmUuX2dldEludGVybmFsRm9ybWF0KDQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVuZ2luZS5fcmVsZWFzZVRleHR1cmUoc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgQmluZFRleHR1cmUodGV4dHVyZSwgZW5naW5lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGlzIGFscmVhZHkgaW52ZXJ0ZWRcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLl9pbnZlcnRWU2NhbGUgPSAhdGV4dHVyZS5pbnZlcnRZO1xuICAgICAgICAgICAgICAgIC8vIFVwbG9hZCBkaXJlY3RseVxuICAgICAgICAgICAgICAgIHRleHR1cmUud2lkdGggPSAocm9vdEltYWdlLndpZHRoICsgMykgJiB+MztcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmhlaWdodCA9IChyb290SW1hZ2UuaGVpZ2h0ICsgMykgJiB+MztcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnNhbXBsaW5nTW9kZSA9IDI7XG4gICAgICAgICAgICAgICAgQmluZFRleHR1cmUodGV4dHVyZSwgZW5naW5lKTtcbiAgICAgICAgICAgICAgICBlbmdpbmUuX3VwbG9hZERhdGFUb1RleHR1cmVEaXJlY3RseSh0ZXh0dXJlLCBuZXcgVWludDE2QXJyYXkocm9vdEltYWdlLnRyYW5zY29kZWRQaXhlbHMuYnVmZmVyKSwgaSwgMCwgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZXh0dXJlLndpZHRoID0gcm9vdEltYWdlLndpZHRoO1xuICAgICAgICAgICAgdGV4dHVyZS5oZWlnaHQgPSByb290SW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMgPSB0cmFuc2NvZGVSZXN1bHQuZmlsZUluZm8uaW1hZ2VzW2ldLmxldmVscy5sZW5ndGggPiAxO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gQmFzaXNUb29scy5HZXRJbnRlcm5hbEZvcm1hdEZyb21CYXNpc0Zvcm1hdCh0cmFuc2NvZGVSZXN1bHQuZm9ybWF0LCBlbmdpbmUpO1xuICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgICAgICBCaW5kVGV4dHVyZSh0ZXh0dXJlLCBlbmdpbmUpO1xuICAgICAgICAgICAgLy8gVXBsb2FkIGFsbCBtaXAgbGV2ZWxzIGluIHRoZSBmaWxlXG4gICAgICAgICAgICBjb25zdCBsZXZlbHMgPSB0cmFuc2NvZGVSZXN1bHQuZmlsZUluZm8uaW1hZ2VzW2ldLmxldmVscztcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZXZlbHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGVuZ2luZS5fdXBsb2FkQ29tcHJlc3NlZERhdGFUb1RleHR1cmVEaXJlY3RseSh0ZXh0dXJlLCBmb3JtYXQsIGxldmVsLndpZHRoLCBsZXZlbC5oZWlnaHQsIGxldmVsLnRyYW5zY29kZWRQaXhlbHMsIGksIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmdpbmUuX2ZlYXR1cmVzLmJhc2lzTmVlZHNQT1QgJiYgKE1hdGgubG9nMih0ZXh0dXJlLndpZHRoKSAlIDEgIT09IDAgfHwgTWF0aC5sb2cyKHRleHR1cmUuaGVpZ2h0KSAlIDEgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgVG9vbHMuV2FybihcIkxvYWRlZCAuYmFzaXMgdGV4dHVyZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgYSBwb3dlciBvZiB0d28uIFRleHR1cmUgd3JhcHBpbmcgd2lsbCBiZSBzZXQgdG8gVGV4dHVyZS5DTEFNUF9BRERSRVNTTU9ERSBhcyBvdGhlciBtb2RlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG5vbiBwb3dlciBvZiB0d28gZGltZW5zaW9ucyBpbiB3ZWJHTCAxLlwiKTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLl9jYWNoZWRXcmFwVSA9IFRleHR1cmUuQ0xBTVBfQUREUkVTU01PREU7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5fY2FjaGVkV3JhcFYgPSBUZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogVXNlZCB0byBsb2FkIC5CYXNpcyBmaWxlc1xuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9CaW5vbWlhbExMQy9iYXNpc191bml2ZXJzYWwvdHJlZS9tYXN0ZXIvd2ViZ2xcbiAqL1xuZXhwb3J0IGNvbnN0IEJhc2lzVG9vbHMgPSB7XG4gICAgLyoqXG4gICAgICogVVJMIHRvIHVzZSB3aGVuIGxvYWRpbmcgdGhlIGJhc2lzIHRyYW5zY29kZXJcbiAgICAgKi9cbiAgICBKU01vZHVsZVVSTDogQmFzaXNUb29sc09wdGlvbnMuSlNNb2R1bGVVUkwsXG4gICAgLyoqXG4gICAgICogVVJMIHRvIHVzZSB3aGVuIGxvYWRpbmcgdGhlIHdhc20gbW9kdWxlIGZvciB0aGUgdHJhbnNjb2RlclxuICAgICAqL1xuICAgIFdhc21Nb2R1bGVVUkw6IEJhc2lzVG9vbHNPcHRpb25zLldhc21Nb2R1bGVVUkwsXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbnRlcm5hbCBmb3JtYXQgdG8gYmUgcGFzc2VkIHRvIHRleEltYWdlMkQgY29ycmVzcG9uZGluZyB0byB0aGUgLmJhc2lzIGZvcm1hdCB2YWx1ZVxuICAgICAqIEBwYXJhbSBiYXNpc0Zvcm1hdCBmb3JtYXQgY2hvc2VuIGZyb20gR2V0U3VwcG9ydGVkVHJhbnNjb2RlRm9ybWF0XG4gICAgICogQHJldHVybnMgaW50ZXJuYWwgZm9ybWF0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIEJhc2lzIGZvcm1hdFxuICAgICAqL1xuICAgIEdldEludGVybmFsRm9ybWF0RnJvbUJhc2lzRm9ybWF0LFxuICAgIC8qKlxuICAgICAqIFRyYW5zY29kZXMgYSBsb2FkZWQgaW1hZ2UgZmlsZSB0byBjb21wcmVzc2VkIHBpeGVsIGRhdGFcbiAgICAgKiBAcGFyYW0gZGF0YSBpbWFnZSBkYXRhIHRvIHRyYW5zY29kZVxuICAgICAqIEBwYXJhbSBjb25maWcgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgdHJhbnNjb2RpbmdcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgcmVzdWx0aW5nIGluIHRoZSB0cmFuc2NvZGVkIGltYWdlXG4gICAgICovXG4gICAgVHJhbnNjb2RlQXN5bmMsXG4gICAgLyoqXG4gICAgICogTG9hZHMgYSB0ZXh0dXJlIGZyb20gdGhlIHRyYW5zY29kZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gdGV4dHVyZSB0ZXh0dXJlIGxvYWQgdG9cbiAgICAgKiBAcGFyYW0gdHJhbnNjb2RlUmVzdWx0IHRoZSByZXN1bHQgb2YgdHJhbnNjb2RpbmcgdGhlIGJhc2lzIGZpbGUgdG8gbG9hZCBmcm9tXG4gICAgICovXG4gICAgTG9hZFRleHR1cmVGcm9tVHJhbnNjb2RlUmVzdWx0LFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpc1Rvb2xzLCBcIkpTTW9kdWxlVVJMXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJhc2lzVG9vbHNPcHRpb25zLkpTTW9kdWxlVVJMO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgQmFzaXNUb29sc09wdGlvbnMuSlNNb2R1bGVVUkwgPSB2YWx1ZTtcbiAgICB9LFxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaXNUb29scywgXCJXYXNtTW9kdWxlVVJMXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJhc2lzVG9vbHNPcHRpb25zLldhc21Nb2R1bGVVUkw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBCYXNpc1Rvb2xzT3B0aW9ucy5XYXNtTW9kdWxlVVJMID0gdmFsdWU7XG4gICAgfSxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzaXMuanMubWFwIiwiaW1wb3J0IHsgVG9vbHMgfSBmcm9tIFwiLi90b29scy5qc1wiO1xuLyoqXG4gKiBUaGUgd29ya2VyIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjb252ZXJ0ZWQgdG8gYSBibG9iIHVybCB0byBwYXNzIGludG8gYSB3b3JrZXIuXG4gKiBUbyBiZSB1c2VkIGlmIGEgZGV2ZWxvcGVyIHdhbnRzIHRvIGNyZWF0ZSB0aGVpciBvd24gd29ya2VyIGluc3RhbmNlIGFuZCBpbmplY3QgaXQgaW5zdGVhZCBvZiB1c2luZyB0aGUgZGVmYXVsdCB3b3JrZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3b3JrZXJGdW5jdGlvbigpIHtcbiAgICBjb25zdCBfQkFTSVNfRk9STUFUID0ge1xuICAgICAgICBjVEZFVEMxOiAwLFxuICAgICAgICBjVEZFVEMyOiAxLFxuICAgICAgICBjVEZCQzE6IDIsXG4gICAgICAgIGNURkJDMzogMyxcbiAgICAgICAgY1RGQkM0OiA0LFxuICAgICAgICBjVEZCQzU6IDUsXG4gICAgICAgIGNURkJDNzogNixcbiAgICAgICAgY1RGUFZSVEMxXzRfUkdCOiA4LFxuICAgICAgICBjVEZQVlJUQzFfNF9SR0JBOiA5LFxuICAgICAgICBjVEZBU1RDXzR4NDogMTAsXG4gICAgICAgIGNURkFUQ19SR0I6IDExLFxuICAgICAgICBjVEZBVENfUkdCQV9JTlRFUlBPTEFURURfQUxQSEE6IDEyLFxuICAgICAgICBjVEZSR0JBMzI6IDEzLFxuICAgICAgICBjVEZSR0I1NjU6IDE0LFxuICAgICAgICBjVEZCR1I1NjU6IDE1LFxuICAgICAgICBjVEZSR0JBNDQ0NDogMTYsXG4gICAgICAgIGNURkZYVDFfUkdCOiAxNyxcbiAgICAgICAgY1RGUFZSVEMyXzRfUkdCOiAxOCxcbiAgICAgICAgY1RGUFZSVEMyXzRfUkdCQTogMTksXG4gICAgICAgIGNURkVUQzJfRUFDX1IxMTogMjAsXG4gICAgICAgIGNURkVUQzJfRUFDX1JHMTE6IDIxLFxuICAgIH07XG4gICAgbGV0IHRyYW5zY29kZXJNb2R1bGVQcm9taXNlID0gbnVsbDtcbiAgICBvbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuYWN0aW9uID09PSBcImluaXRcIikge1xuICAgICAgICAgICAgLy8gTG9hZCB0aGUgdHJhbnNjb2RlciBpZiBpdCBoYXNuJ3QgYmVlbiB5ZXRcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLnVybCkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBsb2FkZWQgdGhlIHNjcmlwdCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRTY3JpcHRzKGV2ZW50LmRhdGEudXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyBhY3Rpb246IFwiZXJyb3JcIiwgZXJyb3I6IGUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0cmFuc2NvZGVyTW9kdWxlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zY29kZXJNb2R1bGVQcm9taXNlID0gQkFTSVMoe1xuICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZSB3YXNtIGJpbmFyeVxuICAgICAgICAgICAgICAgICAgICB3YXNtQmluYXJ5OiBldmVudC5kYXRhLndhc21CaW5hcnksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNjb2Rlck1vZHVsZVByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2NvZGVyTW9kdWxlUHJvbWlzZS50aGVuKChtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIEJBU0lTID0gbTtcbiAgICAgICAgICAgICAgICAgICAgbS5pbml0aWFsaXplQmFzaXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyBhY3Rpb246IFwiaW5pdFwiIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmRhdGEuYWN0aW9uID09PSBcInRyYW5zY29kZVwiKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2NvZGUgdGhlIGJhc2lzIGltYWdlIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBwaXhlbHNcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGV2ZW50LmRhdGEuY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgaW1nRGF0YSA9IGV2ZW50LmRhdGEuaW1hZ2VEYXRhO1xuICAgICAgICAgICAgY29uc3QgbG9hZGVkRmlsZSA9IG5ldyBCQVNJUy5CYXNpc0ZpbGUoaW1nRGF0YSk7XG4gICAgICAgICAgICBjb25zdCBmaWxlSW5mbyA9IEdldEZpbGVJbmZvKGxvYWRlZEZpbGUpO1xuICAgICAgICAgICAgbGV0IGZvcm1hdCA9IGV2ZW50LmRhdGEuaWdub3JlU3VwcG9ydGVkRm9ybWF0cyA/IG51bGwgOiBHZXRTdXBwb3J0ZWRUcmFuc2NvZGVGb3JtYXQoZXZlbnQuZGF0YS5jb25maWcsIGZpbGVJbmZvKTtcbiAgICAgICAgICAgIGxldCBuZWVkc0NvbnZlcnNpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZWVkc0NvbnZlcnNpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZpbGVJbmZvLmhhc0FscGhhID8gX0JBU0lTX0ZPUk1BVC5jVEZCQzMgOiBfQkFTSVNfRk9STUFULmNURkJDMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJlZ2luIHRyYW5zY29kZVxuICAgICAgICAgICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFsb2FkZWRGaWxlLnN0YXJ0VHJhbnNjb2RpbmcoKSkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGltYWdlSW5kZXggPSAwOyBpbWFnZUluZGV4IDwgZmlsZUluZm8uaW1hZ2VzLmxlbmd0aDsgaW1hZ2VJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IGZpbGVJbmZvLmltYWdlc1tpbWFnZUluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvYWRTaW5nbGVJbWFnZSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5sb2FkU2luZ2xlSW1hZ2UgPT09IGltYWdlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pcENvdW50ID0gaW1hZ2UubGV2ZWxzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2FkTWlwbWFwTGV2ZWxzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlwQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGxldmVsSW5kZXggPSAwOyBsZXZlbEluZGV4IDwgbWlwQ291bnQ7IGxldmVsSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGV2ZWxJbmZvID0gaW1hZ2UubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxzID0gVHJhbnNjb2RlTGV2ZWwobG9hZGVkRmlsZSwgaW1hZ2VJbmRleCwgbGV2ZWxJbmRleCwgZm9ybWF0LCBuZWVkc0NvbnZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwaXhlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbEluZm8udHJhbnNjb2RlZFBpeGVscyA9IHBpeGVscztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChsZXZlbEluZm8udHJhbnNjb2RlZFBpeGVscy5idWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xvc2UgZmlsZVxuICAgICAgICAgICAgbG9hZGVkRmlsZS5jbG9zZSgpO1xuICAgICAgICAgICAgbG9hZGVkRmlsZS5kZWxldGUoKTtcbiAgICAgICAgICAgIGlmIChuZWVkc0NvbnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgYWN0aW9uOiBcInRyYW5zY29kZVwiLCBzdWNjZXNzOiBzdWNjZXNzLCBpZDogZXZlbnQuZGF0YS5pZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgYWN0aW9uOiBcInRyYW5zY29kZVwiLCBzdWNjZXNzOiBzdWNjZXNzLCBpZDogZXZlbnQuZGF0YS5pZCwgZmlsZUluZm86IGZpbGVJbmZvLCBmb3JtYXQ6IGZvcm1hdCB9LCBidWZmZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyB0aGUgc3VwcG9ydGVkIHRyYW5zY29kZSBmb3JtYXQgZm9yIHRoZSBmaWxlXG4gICAgICogQHBhcmFtIGNvbmZpZyB0cmFuc2NvZGUgY29uZmlnXG4gICAgICogQHBhcmFtIGZpbGVJbmZvIGluZm8gYWJvdXQgdGhlIGZpbGVcbiAgICAgKiBAcmV0dXJucyB0aGUgY2hvc2VkIGZvcm1hdCBvciBudWxsIGlmIG5vbmUgYXJlIHN1cHBvcnRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdldFN1cHBvcnRlZFRyYW5zY29kZUZvcm1hdChjb25maWcsIGZpbGVJbmZvKSB7XG4gICAgICAgIGxldCBmb3JtYXQgPSBudWxsO1xuICAgICAgICBpZiAoY29uZmlnLnN1cHBvcnRlZENvbXByZXNzaW9uRm9ybWF0cykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5zdXBwb3J0ZWRDb21wcmVzc2lvbkZvcm1hdHMuYXN0Yykge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IF9CQVNJU19GT1JNQVQuY1RGQVNUQ180eDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuc3VwcG9ydGVkQ29tcHJlc3Npb25Gb3JtYXRzLmJjNykge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IF9CQVNJU19GT1JNQVQuY1RGQkM3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLnN1cHBvcnRlZENvbXByZXNzaW9uRm9ybWF0cy5zM3RjKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZmlsZUluZm8uaGFzQWxwaGEgPyBfQkFTSVNfRk9STUFULmNURkJDMyA6IF9CQVNJU19GT1JNQVQuY1RGQkMxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLnN1cHBvcnRlZENvbXByZXNzaW9uRm9ybWF0cy5wdnJ0Yykge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZpbGVJbmZvLmhhc0FscGhhID8gX0JBU0lTX0ZPUk1BVC5jVEZQVlJUQzFfNF9SR0JBIDogX0JBU0lTX0ZPUk1BVC5jVEZQVlJUQzFfNF9SR0I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuc3VwcG9ydGVkQ29tcHJlc3Npb25Gb3JtYXRzLmV0YzIpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBfQkFTSVNfRk9STUFULmNURkVUQzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuc3VwcG9ydGVkQ29tcHJlc3Npb25Gb3JtYXRzLmV0YzEpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBfQkFTSVNfRk9STUFULmNURkVUQzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBfQkFTSVNfRk9STUFULmNURlJHQjU2NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGJhc2lzIGZpbGUgZWcuIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gYmFzaXNGaWxlIHRoZSBiYXNpcyBmaWxlIHRvIGdldCB0aGUgaW5mbyBmcm9tXG4gICAgICogQHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGJhc2lzIGZpbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHZXRGaWxlSW5mbyhiYXNpc0ZpbGUpIHtcbiAgICAgICAgY29uc3QgaGFzQWxwaGEgPSBiYXNpc0ZpbGUuZ2V0SGFzQWxwaGEoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VDb3VudCA9IGJhc2lzRmlsZS5nZXROdW1JbWFnZXMoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBsZXZlbENvdW50ID0gYmFzaXNGaWxlLmdldE51bUxldmVscyhpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCBsZXZlbENvdW50OyBsZXZlbCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGV2ZWxJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYmFzaXNGaWxlLmdldEltYWdlV2lkdGgoaSwgbGV2ZWwpLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJhc2lzRmlsZS5nZXRJbWFnZUhlaWdodChpLCBsZXZlbCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbWFnZUluZm8ubGV2ZWxzLnB1c2gobGV2ZWxJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltYWdlcy5wdXNoKGltYWdlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5mbyA9IHsgaGFzQWxwaGEsIGltYWdlcyB9O1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNjb2RlTGV2ZWwobG9hZGVkRmlsZSwgaW1hZ2VJbmRleCwgbGV2ZWxJbmRleCwgZm9ybWF0LCBjb252ZXJ0VG9SZ2I1NjUpIHtcbiAgICAgICAgY29uc3QgZHN0U2l6ZSA9IGxvYWRlZEZpbGUuZ2V0SW1hZ2VUcmFuc2NvZGVkU2l6ZUluQnl0ZXMoaW1hZ2VJbmRleCwgbGV2ZWxJbmRleCwgZm9ybWF0KTtcbiAgICAgICAgbGV0IGRzdCA9IG5ldyBVaW50OEFycmF5KGRzdFNpemUpO1xuICAgICAgICBpZiAoIWxvYWRlZEZpbGUudHJhbnNjb2RlSW1hZ2UoZHN0LCBpbWFnZUluZGV4LCBsZXZlbEluZGV4LCBmb3JtYXQsIDEsIDApKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBzdXBwb3J0ZWQgZm9ybWF0IGlzIGZvdW5kLCBsb2FkIGFzIGR4dCBhbmQgY29udmVydCB0byByZ2I1NjVcbiAgICAgICAgaWYgKGNvbnZlcnRUb1JnYjU2NSkge1xuICAgICAgICAgICAgY29uc3QgYWxpZ25lZFdpZHRoID0gKGxvYWRlZEZpbGUuZ2V0SW1hZ2VXaWR0aChpbWFnZUluZGV4LCBsZXZlbEluZGV4KSArIDMpICYgfjM7XG4gICAgICAgICAgICBjb25zdCBhbGlnbmVkSGVpZ2h0ID0gKGxvYWRlZEZpbGUuZ2V0SW1hZ2VIZWlnaHQoaW1hZ2VJbmRleCwgbGV2ZWxJbmRleCkgKyAzKSAmIH4zO1xuICAgICAgICAgICAgZHN0ID0gQ29udmVydER4dFRvUmdiNTY1KGRzdCwgMCwgYWxpZ25lZFdpZHRoLCBhbGlnbmVkSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9CaW5vbWlhbExMQy9iYXNpc191bml2ZXJzYWwvYmxvYi9tYXN0ZXIvd2ViZ2wvdGV4dHVyZS9keHQtdG8tcmdiNTY1LmpzXG4gICAgICogQW4gdW5vcHRpbWl6ZWQgdmVyc2lvbiBvZiBkeHRUb1JnYjU2NS4gIEFsc28sIHRoZSBmbG9hdGluZ1xuICAgICAqIHBvaW50IG1hdGggdXNlZCB0byBjb21wdXRlIHRoZSBjb2xvcnMgYWN0dWFsbHkgcmVzdWx0cyBpblxuICAgICAqIHNsaWdodGx5IGRpZmZlcmVudCBjb2xvcnMgY29tcGFyZWQgdG8gaGFyZHdhcmUgRFhUIGRlY29kZXJzLlxuICAgICAqIEBwYXJhbSBzcmMgZHh0IHNyYyBwaXhlbHNcbiAgICAgKiBAcGFyYW0gc3JjQnl0ZU9mZnNldCBvZmZzZXQgZm9yIHRoZSBzdGFydCBvZiBzcmNcbiAgICAgKiBAcGFyYW0gIHdpZHRoIGFsaWduZWQgd2lkdGggb2YgdGhlIGltYWdlXG4gICAgICogQHBhcmFtICBoZWlnaHQgYWxpZ25lZCBoZWlnaHQgb2YgdGhlIGltYWdlXG4gICAgICogQHJldHVybnMgdGhlIGNvbnZlcnRlZCBwaXhlbHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb252ZXJ0RHh0VG9SZ2I1NjUoc3JjLCBzcmNCeXRlT2Zmc2V0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgVWludDE2QXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IGRzdCA9IG5ldyBVaW50MTZBcnJheSh3aWR0aCAqIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGJsb2NrV2lkdGggPSB3aWR0aCAvIDQ7XG4gICAgICAgIGNvbnN0IGJsb2NrSGVpZ2h0ID0gaGVpZ2h0IC8gNDtcbiAgICAgICAgZm9yIChsZXQgYmxvY2tZID0gMDsgYmxvY2tZIDwgYmxvY2tIZWlnaHQ7IGJsb2NrWSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBibG9ja1ggPSAwOyBibG9ja1ggPCBibG9ja1dpZHRoOyBibG9ja1grKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBzcmNCeXRlT2Zmc2V0ICsgOCAqIChibG9ja1kgKiBibG9ja1dpZHRoICsgYmxvY2tYKTtcbiAgICAgICAgICAgICAgICBjWzBdID0gc3JjW2ldIHwgKHNyY1tpICsgMV0gPDwgOCk7XG4gICAgICAgICAgICAgICAgY1sxXSA9IHNyY1tpICsgMl0gfCAoc3JjW2kgKyAzXSA8PCA4KTtcbiAgICAgICAgICAgICAgICBjWzJdID1cbiAgICAgICAgICAgICAgICAgICAgKCgyICogKGNbMF0gJiAweDFmKSArIDEgKiAoY1sxXSAmIDB4MWYpKSAvIDMpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICgoKDIgKiAoY1swXSAmIDB4N2UwKSArIDEgKiAoY1sxXSAmIDB4N2UwKSkgLyAzKSAmIDB4N2UwKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoKCgyICogKGNbMF0gJiAweGY4MDApICsgMSAqIChjWzFdICYgMHhmODAwKSkgLyAzKSAmIDB4ZjgwMCk7XG4gICAgICAgICAgICAgICAgY1szXSA9XG4gICAgICAgICAgICAgICAgICAgICgoMiAqIChjWzFdICYgMHgxZikgKyAxICogKGNbMF0gJiAweDFmKSkgLyAzKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoKCgyICogKGNbMV0gJiAweDdlMCkgKyAxICogKGNbMF0gJiAweDdlMCkpIC8gMykgJiAweDdlMCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKCgoMiAqIChjWzFdICYgMHhmODAwKSArIDEgKiAoY1swXSAmIDB4ZjgwMCkpIC8gMykgJiAweGY4MDApO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IDQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBzcmNbaSArIDQgKyByb3ddO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZHN0SSA9IChibG9ja1kgKiA0ICsgcm93KSAqIHdpZHRoICsgYmxvY2tYICogNDtcbiAgICAgICAgICAgICAgICAgICAgZHN0W2RzdEkrK10gPSBjW20gJiAweDNdO1xuICAgICAgICAgICAgICAgICAgICBkc3RbZHN0SSsrXSA9IGNbKG0gPj4gMikgJiAweDNdO1xuICAgICAgICAgICAgICAgICAgICBkc3RbZHN0SSsrXSA9IGNbKG0gPj4gNCkgJiAweDNdO1xuICAgICAgICAgICAgICAgICAgICBkc3RbZHN0SSsrXSA9IGNbKG0gPj4gNikgJiAweDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhbGl6ZSBhIHdlYiB3b3JrZXIgd2l0aCB0aGUgYmFzaXMgdHJhbnNjb2RlclxuICogQHBhcmFtIHdvcmtlciB0aGUgd29ya2VyIHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB3YXNtQmluYXJ5IHRoZSB3YXNtIGJpbmFyeSB0byBsb2FkIGludG8gdGhlIHdvcmtlclxuICogQHBhcmFtIG1vZHVsZVVybCB0aGUgdXJsIHRvIHRoZSBiYXNpcyB0cmFuc2NvZGVyIG1vZHVsZVxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgd29ya2VyIGlzIGluaXRpYWxpemVkXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVXZWJXb3JrZXIod29ya2VyLCB3YXNtQmluYXJ5LCBtb2R1bGVVcmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluaXRIYW5kbGVyID0gKG1zZykgPT4ge1xuICAgICAgICAgICAgaWYgKG1zZy5kYXRhLmFjdGlvbiA9PT0gXCJpbml0XCIpIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaW5pdEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJlcyh3b3JrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobXNnLmRhdGEuYWN0aW9uID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobXNnLmRhdGEuZXJyb3IgfHwgXCJlcnJvciBpbml0aWFsaXppbmcgd29ya2VyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaW5pdEhhbmRsZXIpO1xuICAgICAgICAvLyB3ZSBjYW4gdXNlIHRyYW5zZmVyYWJsZSBvYmplY3RzIGhlcmUgYmVjYXVzZSB0aGUgd29ya2VyIHdpbGwgb3duIHRoZSBBcnJheUJ1ZmZlclxuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyBhY3Rpb246IFwiaW5pdFwiLCB1cmw6IG1vZHVsZVVybCA/IFRvb2xzLkdldEJhYnlsb25TY3JpcHRVUkwobW9kdWxlVXJsKSA6IHVuZGVmaW5lZCwgd2FzbUJpbmFyeSB9LCBbd2FzbUJpbmFyeV0pO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzaXNXb3JrZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9