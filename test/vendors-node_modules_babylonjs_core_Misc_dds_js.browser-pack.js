"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["vendors-node_modules_babylonjs_core_Misc_dds_js"],{

/***/ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.cubeTexture.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.cubeTexture.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Materials/Textures/internalTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/internalTexture.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _Misc_fileTools_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Misc/fileTools.js */ "./node_modules/@babylonjs/core/Misc/fileTools.js");
/* harmony import */ var _Misc_guid_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Misc/guid.js */ "./node_modules/@babylonjs/core/Misc/guid.js");
/* harmony import */ var _abstractEngine_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../abstractEngine.js */ "./node_modules/@babylonjs/core/Engines/abstractEngine.js");
/* harmony import */ var _Materials_Textures_Loaders_textureLoaderManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Materials/Textures/Loaders/textureLoaderManager.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/textureLoaderManager.js");
/* harmony import */ var _Misc_urlTools_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Misc/urlTools.js */ "./node_modules/@babylonjs/core/Misc/urlTools.js");







_abstractEngine_js__WEBPACK_IMPORTED_MODULE_4__.AbstractEngine.prototype._partialLoadFile = function (url, index, loadedFiles, onfinish, onErrorCallBack = null) {
    const onload = (data) => {
        loadedFiles[index] = data;
        loadedFiles._internalCount++;
        if (loadedFiles._internalCount === 6) {
            onfinish(loadedFiles);
        }
    };
    const onerror = (request, exception) => {
        if (onErrorCallBack && request) {
            onErrorCallBack(request.status + " " + request.statusText, exception);
        }
    };
    this._loadFile(url, onload, undefined, undefined, true, onerror);
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_4__.AbstractEngine.prototype._cascadeLoadFiles = function (scene, onfinish, files, onError = null) {
    const loadedFiles = [];
    loadedFiles._internalCount = 0;
    for (let index = 0; index < 6; index++) {
        this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);
    }
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_4__.AbstractEngine.prototype._cascadeLoadImgs = function (scene, texture, onfinish, files, onError = null, mimeType) {
    const loadedImages = [];
    loadedImages._internalCount = 0;
    for (let index = 0; index < 6; index++) {
        this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);
    }
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_4__.AbstractEngine.prototype._partialLoadImg = function (url, index, loadedImages, scene, texture, onfinish, onErrorCallBack = null, mimeType) {
    const tokenPendingData = (0,_Misc_guid_js__WEBPACK_IMPORTED_MODULE_3__.RandomGUID)();
    const onload = (img) => {
        loadedImages[index] = img;
        loadedImages._internalCount++;
        if (scene) {
            scene.removePendingData(tokenPendingData);
        }
        if (loadedImages._internalCount === 6 && onfinish) {
            onfinish(texture, loadedImages);
        }
    };
    const onerror = (message, exception) => {
        if (scene) {
            scene.removePendingData(tokenPendingData);
        }
        if (onErrorCallBack) {
            onErrorCallBack(message, exception);
        }
    };
    (0,_Misc_fileTools_js__WEBPACK_IMPORTED_MODULE_2__.LoadImage)(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);
    if (scene) {
        scene.addPendingData(tokenPendingData);
    }
};
_abstractEngine_js__WEBPACK_IMPORTED_MODULE_4__.AbstractEngine.prototype.createCubeTextureBase = function (rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, beforeLoadCubeDataCallback = null, imageHandler = null, useSRGBBuffer = false, buffer = null) {
    const texture = fallback ? fallback : new _Materials_Textures_internalTexture_js__WEBPACK_IMPORTED_MODULE_0__.InternalTexture(this, 7 /* InternalTextureSource.Cube */);
    texture.isCube = true;
    texture.url = rootUrl;
    texture.generateMipMaps = !noMipmap;
    texture._lodGenerationScale = lodScale;
    texture._lodGenerationOffset = lodOffset;
    texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.version > 1 || this.isWebGPU || !!noMipmap);
    if (texture !== fallback) {
        texture.label = rootUrl.substring(0, 60); // default label, can be overriden by the caller
    }
    if (!this._doNotHandleContextLost) {
        texture._extension = forcedExtension;
        texture._files = files;
        texture._buffer = buffer;
    }
    const originalRootUrl = rootUrl;
    if (this._transformTextureUrl && !fallback) {
        rootUrl = this._transformTextureUrl(rootUrl);
    }
    const extension = forcedExtension ?? (0,_Misc_urlTools_js__WEBPACK_IMPORTED_MODULE_6__.GetExtensionFromUrl)(rootUrl);
    const loaderPromise = (0,_Materials_Textures_Loaders_textureLoaderManager_js__WEBPACK_IMPORTED_MODULE_5__._GetCompatibleTextureLoader)(extension);
    const onInternalError = (request, exception) => {
        if (rootUrl === originalRootUrl) {
            if (onError && request) {
                onError(request.status + " " + request.statusText, exception);
            }
        }
        else {
            // fall back to the original url if the transformed url fails to load
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);
            this.createCubeTextureBase(originalRootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, beforeLoadCubeDataCallback, imageHandler, useSRGBBuffer, buffer);
        }
    };
    if (loaderPromise) {
        loaderPromise.then((loader) => {
            const onloaddata = (data) => {
                if (beforeLoadCubeDataCallback) {
                    beforeLoadCubeDataCallback(texture, data);
                }
                loader.loadCubeData(data, texture, createPolynomials, onLoad, onError);
            };
            if (buffer) {
                onloaddata(buffer);
            }
            else if (files && files.length === 6) {
                if (loader.supportCascades) {
                    this._cascadeLoadFiles(scene, (images) => onloaddata(images.map((image) => new Uint8Array(image))), files, onError);
                }
                else {
                    if (onError) {
                        onError("Textures type does not support cascades.");
                    }
                    else {
                        _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn("Texture loader does not support cascades.");
                    }
                }
            }
            else {
                this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data)), undefined, undefined, true, onInternalError);
            }
        });
    }
    else {
        if (!files || files.length === 0) {
            throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");
        }
        this._cascadeLoadImgs(scene, texture, (texture, imgs) => {
            if (imageHandler) {
                imageHandler(texture, imgs);
            }
        }, files, onError);
    }
    this._internalTexturesCache.push(texture);
    return texture;
};
//# sourceMappingURL=abstractEngine.cubeTexture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/dds.js":
/*!**************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/dds.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DDSTools: () => (/* binding */ DDSTools)
/* harmony export */ });
/* harmony import */ var _Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Maths/math.scalar.functions.js */ "./node_modules/@babylonjs/core/Maths/math.scalar.functions.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _Misc_HighDynamicRange_cubemapToSphericalPolynomial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Misc/HighDynamicRange/cubemapToSphericalPolynomial.js */ "./node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js");
/* harmony import */ var _textureTools_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./textureTools.js */ "./node_modules/@babylonjs/core/Misc/textureTools.js");
/* harmony import */ var _Engines_AbstractEngine_abstractEngine_cubeTexture_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Engines/AbstractEngine/abstractEngine.cubeTexture.js */ "./node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.cubeTexture.js");
/* eslint-disable @typescript-eslint/naming-convention */






// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html
// All values and structures referenced from:
// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
const DDS_MAGIC = 0x20534444;
const //DDSD_CAPS = 0x1,
//DDSD_HEIGHT = 0x2,
//DDSD_WIDTH = 0x4,
//DDSD_PITCH = 0x8,
//DDSD_PIXELFORMAT = 0x1000,
DDSD_MIPMAPCOUNT = 0x20000;
//DDSD_LINEARSIZE = 0x80000,
//DDSD_DEPTH = 0x800000;
// var DDSCAPS_COMPLEX = 0x8,
//     DDSCAPS_MIPMAP = 0x400000,
//     DDSCAPS_TEXTURE = 0x1000;
const DDSCAPS2_CUBEMAP = 0x200;
// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
// DDSCAPS2_VOLUME = 0x200000;
const //DDPF_ALPHAPIXELS = 0x1,
//DDPF_ALPHA = 0x2,
DDPF_FOURCC = 0x4, DDPF_RGB = 0x40, 
//DDPF_YUV = 0x200,
DDPF_LUMINANCE = 0x20000;
function FourCCToInt32(value) {
    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
}
function Int32ToFourCC(value) {
    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);
}
const FOURCC_DXT1 = FourCCToInt32("DXT1");
const FOURCC_DXT3 = FourCCToInt32("DXT3");
const FOURCC_DXT5 = FourCCToInt32("DXT5");
const FOURCC_DX10 = FourCCToInt32("DX10");
const FOURCC_D3DFMT_R16G16B16A16F = 113;
const FOURCC_D3DFMT_R32G32B32A32F = 116;
const DXGI_FORMAT_R32G32B32A32_FLOAT = 2;
const DXGI_FORMAT_R16G16B16A16_FLOAT = 10;
const DXGI_FORMAT_B8G8R8X8_UNORM = 88;
const headerLengthInt = 31; // The header length in 32 bit ints
// Offsets into the header array
const off_magic = 0;
const off_size = 1;
const off_flags = 2;
const off_height = 3;
const off_width = 4;
const off_mipmapCount = 7;
const off_pfFlags = 20;
const off_pfFourCC = 21;
const off_RGBbpp = 22;
const off_RMask = 23;
const off_GMask = 24;
const off_BMask = 25;
const off_AMask = 26;
// var off_caps1 = 27;
const off_caps2 = 28;
// var off_caps3 = 29;
// var off_caps4 = 30;
const off_dxgiFormat = 32;
/**
 * Class used to provide DDS decompression tools
 */
class DDSTools {
    /**
     * Gets DDS information from an array buffer
     * @param data defines the array buffer view to read data from
     * @returns the DDS information
     */
    static GetDDSInfo(data) {
        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
        const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);
        let mipmapCount = 1;
        if (header[off_flags] & DDSD_MIPMAPCOUNT) {
            mipmapCount = Math.max(1, header[off_mipmapCount]);
        }
        const fourCC = header[off_pfFourCC];
        const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;
        let textureType = 0;
        switch (fourCC) {
            case FOURCC_D3DFMT_R16G16B16A16F:
                textureType = 2;
                break;
            case FOURCC_D3DFMT_R32G32B32A32F:
                textureType = 1;
                break;
            case FOURCC_DX10:
                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {
                    textureType = 2;
                    break;
                }
                if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {
                    textureType = 1;
                    break;
                }
        }
        return {
            width: header[off_width],
            height: header[off_height],
            mipmapCount: mipmapCount,
            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,
            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,
            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,
            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,
            isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,
            dxgiFormat: dxgiFormat,
            textureType: textureType,
        };
    }
    static _GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        const destArray = new Float32Array(dataLength);
        const srcData = new Uint16Array(arrayBuffer, dataOffset);
        let index = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const srcPos = (x + y * width) * 4;
                destArray[index] = (0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.FromHalfFloat)(srcData[srcPos]);
                destArray[index + 1] = (0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.FromHalfFloat)(srcData[srcPos + 1]);
                destArray[index + 2] = (0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.FromHalfFloat)(srcData[srcPos + 2]);
                if (DDSTools.StoreLODInAlphaChannel) {
                    destArray[index + 3] = lod;
                }
                else {
                    destArray[index + 3] = (0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.FromHalfFloat)(srcData[srcPos + 3]);
                }
                index += 4;
            }
        }
        return destArray;
    }
    static _GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        if (DDSTools.StoreLODInAlphaChannel) {
            const destArray = new Uint16Array(dataLength);
            const srcData = new Uint16Array(arrayBuffer, dataOffset);
            let index = 0;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const srcPos = (x + y * width) * 4;
                    destArray[index] = srcData[srcPos];
                    destArray[index + 1] = srcData[srcPos + 1];
                    destArray[index + 2] = srcData[srcPos + 2];
                    destArray[index + 3] = (0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.ToHalfFloat)(lod);
                    index += 4;
                }
            }
            return destArray;
        }
        return new Uint16Array(arrayBuffer, dataOffset, dataLength);
    }
    static _GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        if (DDSTools.StoreLODInAlphaChannel) {
            const destArray = new Float32Array(dataLength);
            const srcData = new Float32Array(arrayBuffer, dataOffset);
            let index = 0;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const srcPos = (x + y * width) * 4;
                    destArray[index] = srcData[srcPos];
                    destArray[index + 1] = srcData[srcPos + 1];
                    destArray[index + 2] = srcData[srcPos + 2];
                    destArray[index + 3] = lod;
                    index += 4;
                }
            }
            return destArray;
        }
        return new Float32Array(arrayBuffer, dataOffset, dataLength);
    }
    static _GetFloatAsHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        const destArray = new Uint16Array(dataLength);
        const srcData = new Float32Array(arrayBuffer, dataOffset);
        let index = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                destArray[index] = (0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.ToHalfFloat)(srcData[index]);
                destArray[index + 1] = (0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.ToHalfFloat)(srcData[index + 1]);
                destArray[index + 2] = (0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.ToHalfFloat)(srcData[index + 2]);
                if (DDSTools.StoreLODInAlphaChannel) {
                    destArray[index + 3] = (0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.ToHalfFloat)(lod);
                }
                else {
                    destArray[index + 3] = (0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.ToHalfFloat)(srcData[index + 3]);
                }
                index += 4;
            }
        }
        return destArray;
    }
    static _GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        const destArray = new Uint8Array(dataLength);
        const srcData = new Float32Array(arrayBuffer, dataOffset);
        let index = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const srcPos = (x + y * width) * 4;
                destArray[index] = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.Clamp)(srcData[srcPos]) * 255;
                destArray[index + 1] = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.Clamp)(srcData[srcPos + 1]) * 255;
                destArray[index + 2] = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.Clamp)(srcData[srcPos + 2]) * 255;
                if (DDSTools.StoreLODInAlphaChannel) {
                    destArray[index + 3] = lod;
                }
                else {
                    destArray[index + 3] = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.Clamp)(srcData[srcPos + 3]) * 255;
                }
                index += 4;
            }
        }
        return destArray;
    }
    static _GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        const destArray = new Uint8Array(dataLength);
        const srcData = new Uint16Array(arrayBuffer, dataOffset);
        let index = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const srcPos = (x + y * width) * 4;
                destArray[index] = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.Clamp)((0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.FromHalfFloat)(srcData[srcPos])) * 255;
                destArray[index + 1] = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.Clamp)((0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.FromHalfFloat)(srcData[srcPos + 1])) * 255;
                destArray[index + 2] = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.Clamp)((0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.FromHalfFloat)(srcData[srcPos + 2])) * 255;
                if (DDSTools.StoreLODInAlphaChannel) {
                    destArray[index + 3] = lod;
                }
                else {
                    destArray[index + 3] = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.Clamp)((0,_textureTools_js__WEBPACK_IMPORTED_MODULE_3__.FromHalfFloat)(srcData[srcPos + 3])) * 255;
                }
                index += 4;
            }
        }
        return destArray;
    }
    static _GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {
        const byteArray = new Uint8Array(dataLength);
        const srcData = new Uint8Array(arrayBuffer, dataOffset);
        let index = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const srcPos = (x + y * width) * 4;
                byteArray[index] = srcData[srcPos + rOffset];
                byteArray[index + 1] = srcData[srcPos + gOffset];
                byteArray[index + 2] = srcData[srcPos + bOffset];
                byteArray[index + 3] = srcData[srcPos + aOffset];
                index += 4;
            }
        }
        return byteArray;
    }
    static _ExtractLongWordOrder(value) {
        if (value === 0 || value === 255 || value === -16777216) {
            return 0;
        }
        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);
    }
    static _GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {
        const byteArray = new Uint8Array(dataLength);
        const srcData = new Uint8Array(arrayBuffer, dataOffset);
        let index = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const srcPos = (x + y * width) * 3;
                byteArray[index] = srcData[srcPos + rOffset];
                byteArray[index + 1] = srcData[srcPos + gOffset];
                byteArray[index + 2] = srcData[srcPos + bOffset];
                index += 3;
            }
        }
        return byteArray;
    }
    static _GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer) {
        const byteArray = new Uint8Array(dataLength);
        const srcData = new Uint8Array(arrayBuffer, dataOffset);
        let index = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const srcPos = x + y * width;
                byteArray[index] = srcData[srcPos];
                index++;
            }
        }
        return byteArray;
    }
    /**
     * Uploads DDS Levels to a Babylon Texture
     * @internal
     */
    static UploadDDSLevels(engine, texture, data, info, loadMipmaps, faces, lodIndex = -1, currentFace, destTypeMustBeFilterable = true) {
        let sphericalPolynomialFaces = null;
        if (info.sphericalPolynomial) {
            sphericalPolynomialFaces = [];
        }
        const ext = !!engine.getCaps().s3tc;
        // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed
        texture.generateMipMaps = loadMipmaps;
        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
        let fourCC, width, height, dataLength = 0, dataOffset;
        let byteArray, mipmapCount, mip;
        let internalCompressedFormat = 0;
        let blockBytes = 1;
        if (header[off_magic] !== DDS_MAGIC) {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Error("Invalid magic number in DDS header");
            return;
        }
        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");
            return;
        }
        if (info.isCompressed && !ext) {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Error("Compressed textures are not supported on this platform.");
            return;
        }
        let bpp = header[off_RGBbpp];
        dataOffset = header[off_size] + 4;
        let computeFormats = false;
        if (info.isFourCC) {
            fourCC = header[off_pfFourCC];
            switch (fourCC) {
                case FOURCC_DXT1:
                    blockBytes = 8;
                    internalCompressedFormat = 33777;
                    break;
                case FOURCC_DXT3:
                    blockBytes = 16;
                    internalCompressedFormat = 33778;
                    break;
                case FOURCC_DXT5:
                    blockBytes = 16;
                    internalCompressedFormat = 33779;
                    break;
                case FOURCC_D3DFMT_R16G16B16A16F:
                    computeFormats = true;
                    bpp = 64;
                    break;
                case FOURCC_D3DFMT_R32G32B32A32F:
                    computeFormats = true;
                    bpp = 128;
                    break;
                case FOURCC_DX10: {
                    // There is an additionnal header so dataOffset need to be changed
                    dataOffset += 5 * 4; // 5 uints
                    let supported = false;
                    switch (info.dxgiFormat) {
                        case DXGI_FORMAT_R16G16B16A16_FLOAT:
                            computeFormats = true;
                            bpp = 64;
                            supported = true;
                            break;
                        case DXGI_FORMAT_R32G32B32A32_FLOAT:
                            computeFormats = true;
                            bpp = 128;
                            supported = true;
                            break;
                        case DXGI_FORMAT_B8G8R8X8_UNORM:
                            info.isRGB = true;
                            info.isFourCC = false;
                            bpp = 32;
                            supported = true;
                            break;
                    }
                    if (supported) {
                        break;
                    }
                }
                // eslint-disable-next-line no-fallthrough
                default:
                    _Misc_logger_js__WEBPACK_IMPORTED_MODULE_1__.Logger.Error(["Unsupported FourCC code:", Int32ToFourCC(fourCC)]);
                    return;
            }
        }
        const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);
        const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);
        const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);
        const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);
        if (computeFormats) {
            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);
        }
        mipmapCount = 1;
        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
            mipmapCount = Math.max(1, header[off_mipmapCount]);
        }
        const startFace = currentFace || 0;
        const caps = engine.getCaps();
        for (let face = startFace; face < faces; face++) {
            width = header[off_width];
            height = header[off_height];
            for (mip = 0; mip < mipmapCount; ++mip) {
                if (lodIndex === -1 || lodIndex === mip) {
                    // In case of fixed LOD, if the lod has just been uploaded, early exit.
                    const i = lodIndex === -1 ? mip : 0;
                    if (!info.isCompressed && info.isFourCC) {
                        texture.format = 5;
                        dataLength = width * height * 4;
                        let floatArray = null;
                        if (engine._badOS || engine._badDesktopOS || (!caps.textureHalfFloat && !caps.textureFloat)) {
                            // Required because iOS has many issues with float and half float generation
                            if (bpp === 128) {
                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                                if (sphericalPolynomialFaces && i == 0) {
                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                                }
                            }
                            else if (bpp === 64) {
                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                                if (sphericalPolynomialFaces && i == 0) {
                                    sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                                }
                            }
                            texture.type = 0;
                        }
                        else {
                            const floatAvailable = caps.textureFloat && ((destTypeMustBeFilterable && caps.textureFloatLinearFiltering) || !destTypeMustBeFilterable);
                            const halfFloatAvailable = caps.textureHalfFloat && ((destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering) || !destTypeMustBeFilterable);
                            const destType = (bpp === 128 || (bpp === 64 && !halfFloatAvailable)) && floatAvailable
                                ? 1
                                : (bpp === 64 || (bpp === 128 && !floatAvailable)) && halfFloatAvailable
                                    ? 2
                                    : 0;
                            let dataGetter;
                            let dataGetterPolynomial = null;
                            switch (bpp) {
                                case 128: {
                                    switch (destType) {
                                        case 1:
                                            dataGetter = DDSTools._GetFloatRGBAArrayBuffer;
                                            dataGetterPolynomial = null;
                                            break;
                                        case 2:
                                            dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;
                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;
                                            break;
                                        case 0:
                                            dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;
                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;
                                            break;
                                    }
                                    break;
                                }
                                default: {
                                    // 64 bpp
                                    switch (destType) {
                                        case 1:
                                            dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                                            dataGetterPolynomial = null;
                                            break;
                                        case 2:
                                            dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;
                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                                            break;
                                        case 0:
                                            dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;
                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                                            break;
                                    }
                                    break;
                                }
                            }
                            texture.type = destType;
                            floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                            if (sphericalPolynomialFaces && i == 0) {
                                sphericalPolynomialFaces.push(dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray);
                            }
                        }
                        if (floatArray) {
                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);
                        }
                    }
                    else if (info.isRGB) {
                        texture.type = 0;
                        if (bpp === 24) {
                            texture.format = 4;
                            dataLength = width * height * 3;
                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);
                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
                        }
                        else {
                            // 32
                            texture.format = 5;
                            dataLength = width * height * 4;
                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);
                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
                        }
                    }
                    else if (info.isLuminance) {
                        const unpackAlignment = engine._getUnpackAlignement();
                        const unpaddedRowSize = width;
                        const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;
                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;
                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);
                        texture.format = 1;
                        texture.type = 0;
                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
                    }
                    else {
                        dataLength = (((Math.max(4, width) / 4) * Math.max(4, height)) / 4) * blockBytes;
                        byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);
                        texture.type = 0;
                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);
                    }
                }
                dataOffset += bpp ? width * height * (bpp / 8) : dataLength;
                width *= 0.5;
                height *= 0.5;
                width = Math.max(1.0, width);
                height = Math.max(1.0, height);
            }
            if (currentFace !== undefined) {
                // Loading a single face
                break;
            }
        }
        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {
            info.sphericalPolynomial = _Misc_HighDynamicRange_cubemapToSphericalPolynomial_js__WEBPACK_IMPORTED_MODULE_2__.CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({
                size: header[off_width],
                right: sphericalPolynomialFaces[0],
                left: sphericalPolynomialFaces[1],
                up: sphericalPolynomialFaces[2],
                down: sphericalPolynomialFaces[3],
                front: sphericalPolynomialFaces[4],
                back: sphericalPolynomialFaces[5],
                format: 5,
                type: 1,
                gammaSpace: false,
            });
        }
        else {
            info.sphericalPolynomial = undefined;
        }
    }
}
/**
 * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)
 */
DDSTools.StoreLODInAlphaChannel = false;
//# sourceMappingURL=dds.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/urlTools.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/urlTools.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GetExtensionFromUrl: () => (/* binding */ GetExtensionFromUrl)
/* harmony export */ });
/**
 * Gets the file extension from a URL.
 * @param url The URL to get the file extension from.
 * @returns The file extension, or an empty string if no extension is found.
 */
function GetExtensionFromUrl(url) {
    const urlWithoutUriParams = url.split("?")[0];
    const lastDot = urlWithoutUriParams.lastIndexOf(".");
    const extension = lastDot > -1 ? urlWithoutUriParams.substring(lastDot).toLowerCase() : "";
    return extension;
}
//# sourceMappingURL=urlTools.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfTWlzY19kZHNfanMuYnJvd3Nlci1wYWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThFO0FBQ2hDO0FBQ007QUFDSjtBQUNNO0FBQ2lEO0FBQzFDO0FBQzdELDhEQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUFjO0FBQ2Q7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDhEQUFjO0FBQ2Q7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDhEQUFjO0FBQ2QsNkJBQTZCLHlEQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkRBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUFjO0FBQ2QsOENBQThDLG1GQUFlO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNFQUFtQjtBQUM1RCwwQkFBMEIsZ0hBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFNLHdCQUF3QixRQUFRLHdCQUF3QixnQkFBZ0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtREFBTTtBQUM5QjtBQUNBO0FBQ0E7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Ynlsb25qcy9jb3JlL0VuZ2luZXMvQWJzdHJhY3RFbmdpbmUvYWJzdHJhY3RFbmdpbmUuY3ViZVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01pc2MvZGRzLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NaXNjL3VybFRvb2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEludGVybmFsVGV4dHVyZSB9IGZyb20gXCIuLi8uLi9NYXRlcmlhbHMvVGV4dHVyZXMvaW50ZXJuYWxUZXh0dXJlLmpzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vLi4vTWlzYy9sb2dnZXIuanNcIjtcbmltcG9ydCB7IExvYWRJbWFnZSB9IGZyb20gXCIuLi8uLi9NaXNjL2ZpbGVUb29scy5qc1wiO1xuaW1wb3J0IHsgUmFuZG9tR1VJRCB9IGZyb20gXCIuLi8uLi9NaXNjL2d1aWQuanNcIjtcbmltcG9ydCB7IEFic3RyYWN0RW5naW5lIH0gZnJvbSBcIi4uL2Fic3RyYWN0RW5naW5lLmpzXCI7XG5pbXBvcnQgeyBfR2V0Q29tcGF0aWJsZVRleHR1cmVMb2FkZXIgfSBmcm9tIFwiLi4vLi4vTWF0ZXJpYWxzL1RleHR1cmVzL0xvYWRlcnMvdGV4dHVyZUxvYWRlck1hbmFnZXIuanNcIjtcbmltcG9ydCB7IEdldEV4dGVuc2lvbkZyb21VcmwgfSBmcm9tIFwiLi4vLi4vTWlzYy91cmxUb29scy5qc1wiO1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLl9wYXJ0aWFsTG9hZEZpbGUgPSBmdW5jdGlvbiAodXJsLCBpbmRleCwgbG9hZGVkRmlsZXMsIG9uZmluaXNoLCBvbkVycm9yQ2FsbEJhY2sgPSBudWxsKSB7XG4gICAgY29uc3Qgb25sb2FkID0gKGRhdGEpID0+IHtcbiAgICAgICAgbG9hZGVkRmlsZXNbaW5kZXhdID0gZGF0YTtcbiAgICAgICAgbG9hZGVkRmlsZXMuX2ludGVybmFsQ291bnQrKztcbiAgICAgICAgaWYgKGxvYWRlZEZpbGVzLl9pbnRlcm5hbENvdW50ID09PSA2KSB7XG4gICAgICAgICAgICBvbmZpbmlzaChsb2FkZWRGaWxlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uZXJyb3IgPSAocmVxdWVzdCwgZXhjZXB0aW9uKSA9PiB7XG4gICAgICAgIGlmIChvbkVycm9yQ2FsbEJhY2sgJiYgcmVxdWVzdCkge1xuICAgICAgICAgICAgb25FcnJvckNhbGxCYWNrKHJlcXVlc3Quc3RhdHVzICsgXCIgXCIgKyByZXF1ZXN0LnN0YXR1c1RleHQsIGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2xvYWRGaWxlKHVybCwgb25sb2FkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSwgb25lcnJvcik7XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLl9jYXNjYWRlTG9hZEZpbGVzID0gZnVuY3Rpb24gKHNjZW5lLCBvbmZpbmlzaCwgZmlsZXMsIG9uRXJyb3IgPSBudWxsKSB7XG4gICAgY29uc3QgbG9hZGVkRmlsZXMgPSBbXTtcbiAgICBsb2FkZWRGaWxlcy5faW50ZXJuYWxDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDY7IGluZGV4KyspIHtcbiAgICAgICAgdGhpcy5fcGFydGlhbExvYWRGaWxlKGZpbGVzW2luZGV4XSwgaW5kZXgsIGxvYWRlZEZpbGVzLCBvbmZpbmlzaCwgb25FcnJvcik7XG4gICAgfVxufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5fY2FzY2FkZUxvYWRJbWdzID0gZnVuY3Rpb24gKHNjZW5lLCB0ZXh0dXJlLCBvbmZpbmlzaCwgZmlsZXMsIG9uRXJyb3IgPSBudWxsLCBtaW1lVHlwZSkge1xuICAgIGNvbnN0IGxvYWRlZEltYWdlcyA9IFtdO1xuICAgIGxvYWRlZEltYWdlcy5faW50ZXJuYWxDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDY7IGluZGV4KyspIHtcbiAgICAgICAgdGhpcy5fcGFydGlhbExvYWRJbWcoZmlsZXNbaW5kZXhdLCBpbmRleCwgbG9hZGVkSW1hZ2VzLCBzY2VuZSwgdGV4dHVyZSwgb25maW5pc2gsIG9uRXJyb3IsIG1pbWVUeXBlKTtcbiAgICB9XG59O1xuQWJzdHJhY3RFbmdpbmUucHJvdG90eXBlLl9wYXJ0aWFsTG9hZEltZyA9IGZ1bmN0aW9uICh1cmwsIGluZGV4LCBsb2FkZWRJbWFnZXMsIHNjZW5lLCB0ZXh0dXJlLCBvbmZpbmlzaCwgb25FcnJvckNhbGxCYWNrID0gbnVsbCwgbWltZVR5cGUpIHtcbiAgICBjb25zdCB0b2tlblBlbmRpbmdEYXRhID0gUmFuZG9tR1VJRCgpO1xuICAgIGNvbnN0IG9ubG9hZCA9IChpbWcpID0+IHtcbiAgICAgICAgbG9hZGVkSW1hZ2VzW2luZGV4XSA9IGltZztcbiAgICAgICAgbG9hZGVkSW1hZ2VzLl9pbnRlcm5hbENvdW50Kys7XG4gICAgICAgIGlmIChzY2VuZSkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlUGVuZGluZ0RhdGEodG9rZW5QZW5kaW5nRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvYWRlZEltYWdlcy5faW50ZXJuYWxDb3VudCA9PT0gNiAmJiBvbmZpbmlzaCkge1xuICAgICAgICAgICAgb25maW5pc2godGV4dHVyZSwgbG9hZGVkSW1hZ2VzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25lcnJvciA9IChtZXNzYWdlLCBleGNlcHRpb24pID0+IHtcbiAgICAgICAgaWYgKHNjZW5lKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmVQZW5kaW5nRGF0YSh0b2tlblBlbmRpbmdEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25FcnJvckNhbGxCYWNrKSB7XG4gICAgICAgICAgICBvbkVycm9yQ2FsbEJhY2sobWVzc2FnZSwgZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9hZEltYWdlKHVybCwgb25sb2FkLCBvbmVycm9yLCBzY2VuZSA/IHNjZW5lLm9mZmxpbmVQcm92aWRlciA6IG51bGwsIG1pbWVUeXBlKTtcbiAgICBpZiAoc2NlbmUpIHtcbiAgICAgICAgc2NlbmUuYWRkUGVuZGluZ0RhdGEodG9rZW5QZW5kaW5nRGF0YSk7XG4gICAgfVxufTtcbkFic3RyYWN0RW5naW5lLnByb3RvdHlwZS5jcmVhdGVDdWJlVGV4dHVyZUJhc2UgPSBmdW5jdGlvbiAocm9vdFVybCwgc2NlbmUsIGZpbGVzLCBub01pcG1hcCwgb25Mb2FkID0gbnVsbCwgb25FcnJvciA9IG51bGwsIGZvcm1hdCwgZm9yY2VkRXh0ZW5zaW9uID0gbnVsbCwgY3JlYXRlUG9seW5vbWlhbHMgPSBmYWxzZSwgbG9kU2NhbGUgPSAwLCBsb2RPZmZzZXQgPSAwLCBmYWxsYmFjayA9IG51bGwsIGJlZm9yZUxvYWRDdWJlRGF0YUNhbGxiYWNrID0gbnVsbCwgaW1hZ2VIYW5kbGVyID0gbnVsbCwgdXNlU1JHQkJ1ZmZlciA9IGZhbHNlLCBidWZmZXIgPSBudWxsKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IGZhbGxiYWNrID8gZmFsbGJhY2sgOiBuZXcgSW50ZXJuYWxUZXh0dXJlKHRoaXMsIDcgLyogSW50ZXJuYWxUZXh0dXJlU291cmNlLkN1YmUgKi8pO1xuICAgIHRleHR1cmUuaXNDdWJlID0gdHJ1ZTtcbiAgICB0ZXh0dXJlLnVybCA9IHJvb3RVcmw7XG4gICAgdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMgPSAhbm9NaXBtYXA7XG4gICAgdGV4dHVyZS5fbG9kR2VuZXJhdGlvblNjYWxlID0gbG9kU2NhbGU7XG4gICAgdGV4dHVyZS5fbG9kR2VuZXJhdGlvbk9mZnNldCA9IGxvZE9mZnNldDtcbiAgICB0ZXh0dXJlLl91c2VTUkdCQnVmZmVyID0gISF1c2VTUkdCQnVmZmVyICYmIHRoaXMuX2NhcHMuc3VwcG9ydFNSR0JCdWZmZXJzICYmICh0aGlzLnZlcnNpb24gPiAxIHx8IHRoaXMuaXNXZWJHUFUgfHwgISFub01pcG1hcCk7XG4gICAgaWYgKHRleHR1cmUgIT09IGZhbGxiYWNrKSB7XG4gICAgICAgIHRleHR1cmUubGFiZWwgPSByb290VXJsLnN1YnN0cmluZygwLCA2MCk7IC8vIGRlZmF1bHQgbGFiZWwsIGNhbiBiZSBvdmVycmlkZW4gYnkgdGhlIGNhbGxlclxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2RvTm90SGFuZGxlQ29udGV4dExvc3QpIHtcbiAgICAgICAgdGV4dHVyZS5fZXh0ZW5zaW9uID0gZm9yY2VkRXh0ZW5zaW9uO1xuICAgICAgICB0ZXh0dXJlLl9maWxlcyA9IGZpbGVzO1xuICAgICAgICB0ZXh0dXJlLl9idWZmZXIgPSBidWZmZXI7XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsUm9vdFVybCA9IHJvb3RVcmw7XG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybVRleHR1cmVVcmwgJiYgIWZhbGxiYWNrKSB7XG4gICAgICAgIHJvb3RVcmwgPSB0aGlzLl90cmFuc2Zvcm1UZXh0dXJlVXJsKHJvb3RVcmwpO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSBmb3JjZWRFeHRlbnNpb24gPz8gR2V0RXh0ZW5zaW9uRnJvbVVybChyb290VXJsKTtcbiAgICBjb25zdCBsb2FkZXJQcm9taXNlID0gX0dldENvbXBhdGlibGVUZXh0dXJlTG9hZGVyKGV4dGVuc2lvbik7XG4gICAgY29uc3Qgb25JbnRlcm5hbEVycm9yID0gKHJlcXVlc3QsIGV4Y2VwdGlvbikgPT4ge1xuICAgICAgICBpZiAocm9vdFVybCA9PT0gb3JpZ2luYWxSb290VXJsKSB7XG4gICAgICAgICAgICBpZiAob25FcnJvciAmJiByZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihyZXF1ZXN0LnN0YXR1cyArIFwiIFwiICsgcmVxdWVzdC5zdGF0dXNUZXh0LCBleGNlcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB1cmwgaWYgdGhlIHRyYW5zZm9ybWVkIHVybCBmYWlscyB0byBsb2FkXG4gICAgICAgICAgICBMb2dnZXIuV2FybihgRmFpbGVkIHRvIGxvYWQgJHtyb290VXJsfSwgZmFsbGluZyBiYWNrIHRvIHRoZSAke29yaWdpbmFsUm9vdFVybH1gKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ3ViZVRleHR1cmVCYXNlKG9yaWdpbmFsUm9vdFVybCwgc2NlbmUsIGZpbGVzLCAhIW5vTWlwbWFwLCBvbkxvYWQsIG9uRXJyb3IsIGZvcm1hdCwgZm9yY2VkRXh0ZW5zaW9uLCBjcmVhdGVQb2x5bm9taWFscywgbG9kU2NhbGUsIGxvZE9mZnNldCwgdGV4dHVyZSwgYmVmb3JlTG9hZEN1YmVEYXRhQ2FsbGJhY2ssIGltYWdlSGFuZGxlciwgdXNlU1JHQkJ1ZmZlciwgYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGxvYWRlclByb21pc2UpIHtcbiAgICAgICAgbG9hZGVyUHJvbWlzZS50aGVuKChsb2FkZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9ubG9hZGRhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmVMb2FkQ3ViZURhdGFDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVMb2FkQ3ViZURhdGFDYWxsYmFjayh0ZXh0dXJlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9hZGVyLmxvYWRDdWJlRGF0YShkYXRhLCB0ZXh0dXJlLCBjcmVhdGVQb2x5bm9taWFscywgb25Mb2FkLCBvbkVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgb25sb2FkZGF0YShidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoID09PSA2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlci5zdXBwb3J0Q2FzY2FkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzY2FkZUxvYWRGaWxlcyhzY2VuZSwgKGltYWdlcykgPT4gb25sb2FkZGF0YShpbWFnZXMubWFwKChpbWFnZSkgPT4gbmV3IFVpbnQ4QXJyYXkoaW1hZ2UpKSksIGZpbGVzLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKFwiVGV4dHVyZXMgdHlwZSBkb2VzIG5vdCBzdXBwb3J0IGNhc2NhZGVzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5XYXJuKFwiVGV4dHVyZSBsb2FkZXIgZG9lcyBub3Qgc3VwcG9ydCBjYXNjYWRlcy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkRmlsZShyb290VXJsLCAoZGF0YSkgPT4gb25sb2FkZGF0YShuZXcgVWludDhBcnJheShkYXRhKSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCBvbkludGVybmFsRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghZmlsZXMgfHwgZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbG9hZCBjdWJlbWFwIGJlY2F1c2UgZmlsZXMgd2VyZSBub3QgZGVmaW5lZCwgb3IgdGhlIGNvcnJlY3QgbG9hZGVyIHdhcyBub3QgZm91bmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nhc2NhZGVMb2FkSW1ncyhzY2VuZSwgdGV4dHVyZSwgKHRleHR1cmUsIGltZ3MpID0+IHtcbiAgICAgICAgICAgIGlmIChpbWFnZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUhhbmRsZXIodGV4dHVyZSwgaW1ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZpbGVzLCBvbkVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5faW50ZXJuYWxUZXh0dXJlc0NhY2hlLnB1c2godGV4dHVyZSk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3RFbmdpbmUuY3ViZVRleHR1cmUuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5pbXBvcnQgeyBDbGFtcCB9IGZyb20gXCIuLi9NYXRocy9tYXRoLnNjYWxhci5mdW5jdGlvbnMuanNcIjtcblxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL01pc2MvbG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyBDdWJlTWFwVG9TcGhlcmljYWxQb2x5bm9taWFsVG9vbHMgfSBmcm9tIFwiLi4vTWlzYy9IaWdoRHluYW1pY1JhbmdlL2N1YmVtYXBUb1NwaGVyaWNhbFBvbHlub21pYWwuanNcIjtcbmltcG9ydCB7IEZyb21IYWxmRmxvYXQsIFRvSGFsZkZsb2F0IH0gZnJvbSBcIi4vdGV4dHVyZVRvb2xzLmpzXCI7XG5pbXBvcnQgXCIuLi9FbmdpbmVzL0Fic3RyYWN0RW5naW5lL2Fic3RyYWN0RW5naW5lLmN1YmVUZXh0dXJlLmpzXCI7XG4vLyBCYXNlZCBvbiBkZW1vIGRvbmUgYnkgQnJhbmRvbiBKb25lcyAtIGh0dHA6Ly9tZWRpYS50b2ppY29kZS5jb20vd2ViZ2wtc2FtcGxlcy9kZHMuaHRtbFxuLy8gQWxsIHZhbHVlcyBhbmQgc3RydWN0dXJlcyByZWZlcmVuY2VkIGZyb206XG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvYmI5NDM5OTEuYXNweC9cbmNvbnN0IEREU19NQUdJQyA9IDB4MjA1MzQ0NDQ7XG5jb25zdCAvL0REU0RfQ0FQUyA9IDB4MSxcbi8vRERTRF9IRUlHSFQgPSAweDIsXG4vL0REU0RfV0lEVEggPSAweDQsXG4vL0REU0RfUElUQ0ggPSAweDgsXG4vL0REU0RfUElYRUxGT1JNQVQgPSAweDEwMDAsXG5ERFNEX01JUE1BUENPVU5UID0gMHgyMDAwMDtcbi8vRERTRF9MSU5FQVJTSVpFID0gMHg4MDAwMCxcbi8vRERTRF9ERVBUSCA9IDB4ODAwMDAwO1xuLy8gdmFyIEREU0NBUFNfQ09NUExFWCA9IDB4OCxcbi8vICAgICBERFNDQVBTX01JUE1BUCA9IDB4NDAwMDAwLFxuLy8gICAgIEREU0NBUFNfVEVYVFVSRSA9IDB4MTAwMDtcbmNvbnN0IEREU0NBUFMyX0NVQkVNQVAgPSAweDIwMDtcbi8vIEREU0NBUFMyX0NVQkVNQVBfUE9TSVRJVkVYID0gMHg0MDAsXG4vLyBERFNDQVBTMl9DVUJFTUFQX05FR0FUSVZFWCA9IDB4ODAwLFxuLy8gRERTQ0FQUzJfQ1VCRU1BUF9QT1NJVElWRVkgPSAweDEwMDAsXG4vLyBERFNDQVBTMl9DVUJFTUFQX05FR0FUSVZFWSA9IDB4MjAwMCxcbi8vIEREU0NBUFMyX0NVQkVNQVBfUE9TSVRJVkVaID0gMHg0MDAwLFxuLy8gRERTQ0FQUzJfQ1VCRU1BUF9ORUdBVElWRVogPSAweDgwMDAsXG4vLyBERFNDQVBTMl9WT0xVTUUgPSAweDIwMDAwMDtcbmNvbnN0IC8vRERQRl9BTFBIQVBJWEVMUyA9IDB4MSxcbi8vRERQRl9BTFBIQSA9IDB4MixcbkREUEZfRk9VUkNDID0gMHg0LCBERFBGX1JHQiA9IDB4NDAsIFxuLy9ERFBGX1lVViA9IDB4MjAwLFxuRERQRl9MVU1JTkFOQ0UgPSAweDIwMDAwO1xuZnVuY3Rpb24gRm91ckNDVG9JbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5jaGFyQ29kZUF0KDApICsgKHZhbHVlLmNoYXJDb2RlQXQoMSkgPDwgOCkgKyAodmFsdWUuY2hhckNvZGVBdCgyKSA8PCAxNikgKyAodmFsdWUuY2hhckNvZGVBdCgzKSA8PCAyNCk7XG59XG5mdW5jdGlvbiBJbnQzMlRvRm91ckNDKHZhbHVlKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUgJiAweGZmLCAodmFsdWUgPj4gOCkgJiAweGZmLCAodmFsdWUgPj4gMTYpICYgMHhmZiwgKHZhbHVlID4+IDI0KSAmIDB4ZmYpO1xufVxuY29uc3QgRk9VUkNDX0RYVDEgPSBGb3VyQ0NUb0ludDMyKFwiRFhUMVwiKTtcbmNvbnN0IEZPVVJDQ19EWFQzID0gRm91ckNDVG9JbnQzMihcIkRYVDNcIik7XG5jb25zdCBGT1VSQ0NfRFhUNSA9IEZvdXJDQ1RvSW50MzIoXCJEWFQ1XCIpO1xuY29uc3QgRk9VUkNDX0RYMTAgPSBGb3VyQ0NUb0ludDMyKFwiRFgxMFwiKTtcbmNvbnN0IEZPVVJDQ19EM0RGTVRfUjE2RzE2QjE2QTE2RiA9IDExMztcbmNvbnN0IEZPVVJDQ19EM0RGTVRfUjMyRzMyQjMyQTMyRiA9IDExNjtcbmNvbnN0IERYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVCA9IDI7XG5jb25zdCBEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfRkxPQVQgPSAxMDtcbmNvbnN0IERYR0lfRk9STUFUX0I4RzhSOFg4X1VOT1JNID0gODg7XG5jb25zdCBoZWFkZXJMZW5ndGhJbnQgPSAzMTsgLy8gVGhlIGhlYWRlciBsZW5ndGggaW4gMzIgYml0IGludHNcbi8vIE9mZnNldHMgaW50byB0aGUgaGVhZGVyIGFycmF5XG5jb25zdCBvZmZfbWFnaWMgPSAwO1xuY29uc3Qgb2ZmX3NpemUgPSAxO1xuY29uc3Qgb2ZmX2ZsYWdzID0gMjtcbmNvbnN0IG9mZl9oZWlnaHQgPSAzO1xuY29uc3Qgb2ZmX3dpZHRoID0gNDtcbmNvbnN0IG9mZl9taXBtYXBDb3VudCA9IDc7XG5jb25zdCBvZmZfcGZGbGFncyA9IDIwO1xuY29uc3Qgb2ZmX3BmRm91ckNDID0gMjE7XG5jb25zdCBvZmZfUkdCYnBwID0gMjI7XG5jb25zdCBvZmZfUk1hc2sgPSAyMztcbmNvbnN0IG9mZl9HTWFzayA9IDI0O1xuY29uc3Qgb2ZmX0JNYXNrID0gMjU7XG5jb25zdCBvZmZfQU1hc2sgPSAyNjtcbi8vIHZhciBvZmZfY2FwczEgPSAyNztcbmNvbnN0IG9mZl9jYXBzMiA9IDI4O1xuLy8gdmFyIG9mZl9jYXBzMyA9IDI5O1xuLy8gdmFyIG9mZl9jYXBzNCA9IDMwO1xuY29uc3Qgb2ZmX2R4Z2lGb3JtYXQgPSAzMjtcbi8qKlxuICogQ2xhc3MgdXNlZCB0byBwcm92aWRlIEREUyBkZWNvbXByZXNzaW9uIHRvb2xzXG4gKi9cbmV4cG9ydCBjbGFzcyBERFNUb29scyB7XG4gICAgLyoqXG4gICAgICogR2V0cyBERFMgaW5mb3JtYXRpb24gZnJvbSBhbiBhcnJheSBidWZmZXJcbiAgICAgKiBAcGFyYW0gZGF0YSBkZWZpbmVzIHRoZSBhcnJheSBidWZmZXIgdmlldyB0byByZWFkIGRhdGEgZnJvbVxuICAgICAqIEByZXR1cm5zIHRoZSBERFMgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgR2V0RERTSW5mbyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBJbnQzMkFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGhlYWRlckxlbmd0aEludCk7XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkSGVhZGVyID0gbmV3IEludDMyQXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgaGVhZGVyTGVuZ3RoSW50ICsgNCk7XG4gICAgICAgIGxldCBtaXBtYXBDb3VudCA9IDE7XG4gICAgICAgIGlmIChoZWFkZXJbb2ZmX2ZsYWdzXSAmIEREU0RfTUlQTUFQQ09VTlQpIHtcbiAgICAgICAgICAgIG1pcG1hcENvdW50ID0gTWF0aC5tYXgoMSwgaGVhZGVyW29mZl9taXBtYXBDb3VudF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvdXJDQyA9IGhlYWRlcltvZmZfcGZGb3VyQ0NdO1xuICAgICAgICBjb25zdCBkeGdpRm9ybWF0ID0gZm91ckNDID09PSBGT1VSQ0NfRFgxMCA/IGV4dGVuZGVkSGVhZGVyW29mZl9keGdpRm9ybWF0XSA6IDA7XG4gICAgICAgIGxldCB0ZXh0dXJlVHlwZSA9IDA7XG4gICAgICAgIHN3aXRjaCAoZm91ckNDKSB7XG4gICAgICAgICAgICBjYXNlIEZPVVJDQ19EM0RGTVRfUjE2RzE2QjE2QTE2RjpcbiAgICAgICAgICAgICAgICB0ZXh0dXJlVHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZPVVJDQ19EM0RGTVRfUjMyRzMyQjMyQTMyRjpcbiAgICAgICAgICAgICAgICB0ZXh0dXJlVHlwZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZPVVJDQ19EWDEwOlxuICAgICAgICAgICAgICAgIGlmIChkeGdpRm9ybWF0ID09PSBEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfRkxPQVQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVR5cGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGR4Z2lGb3JtYXQgPT09IERYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlVHlwZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IGhlYWRlcltvZmZfd2lkdGhdLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWFkZXJbb2ZmX2hlaWdodF0sXG4gICAgICAgICAgICBtaXBtYXBDb3VudDogbWlwbWFwQ291bnQsXG4gICAgICAgICAgICBpc0ZvdXJDQzogKGhlYWRlcltvZmZfcGZGbGFnc10gJiBERFBGX0ZPVVJDQykgPT09IEREUEZfRk9VUkNDLFxuICAgICAgICAgICAgaXNSR0I6IChoZWFkZXJbb2ZmX3BmRmxhZ3NdICYgRERQRl9SR0IpID09PSBERFBGX1JHQixcbiAgICAgICAgICAgIGlzTHVtaW5hbmNlOiAoaGVhZGVyW29mZl9wZkZsYWdzXSAmIEREUEZfTFVNSU5BTkNFKSA9PT0gRERQRl9MVU1JTkFOQ0UsXG4gICAgICAgICAgICBpc0N1YmU6IChoZWFkZXJbb2ZmX2NhcHMyXSAmIEREU0NBUFMyX0NVQkVNQVApID09PSBERFNDQVBTMl9DVUJFTUFQLFxuICAgICAgICAgICAgaXNDb21wcmVzc2VkOiBmb3VyQ0MgPT09IEZPVVJDQ19EWFQxIHx8IGZvdXJDQyA9PT0gRk9VUkNDX0RYVDMgfHwgZm91ckNDID09PSBGT1VSQ0NfRFhUNSxcbiAgICAgICAgICAgIGR4Z2lGb3JtYXQ6IGR4Z2lGb3JtYXQsXG4gICAgICAgICAgICB0ZXh0dXJlVHlwZTogdGV4dHVyZVR5cGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBfR2V0SGFsZkZsb2F0QXNGbG9hdFJHQkFBcnJheUJ1ZmZlcih3aWR0aCwgaGVpZ2h0LCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoLCBhcnJheUJ1ZmZlciwgbG9kKSB7XG4gICAgICAgIGNvbnN0IGRlc3RBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNyY0RhdGEgPSBuZXcgVWludDE2QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcmNQb3MgPSAoeCArIHkgKiB3aWR0aCkgKiA0O1xuICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleF0gPSBGcm9tSGFsZkZsb2F0KHNyY0RhdGFbc3JjUG9zXSk7XG4gICAgICAgICAgICAgICAgZGVzdEFycmF5W2luZGV4ICsgMV0gPSBGcm9tSGFsZkZsb2F0KHNyY0RhdGFbc3JjUG9zICsgMV0pO1xuICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleCArIDJdID0gRnJvbUhhbGZGbG9hdChzcmNEYXRhW3NyY1BvcyArIDJdKTtcbiAgICAgICAgICAgICAgICBpZiAoRERTVG9vbHMuU3RvcmVMT0RJbkFscGhhQ2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0QXJyYXlbaW5kZXggKyAzXSA9IGxvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleCArIDNdID0gRnJvbUhhbGZGbG9hdChzcmNEYXRhW3NyY1BvcyArIDNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdEFycmF5O1xuICAgIH1cbiAgICBzdGF0aWMgX0dldEhhbGZGbG9hdFJHQkFBcnJheUJ1ZmZlcih3aWR0aCwgaGVpZ2h0LCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoLCBhcnJheUJ1ZmZlciwgbG9kKSB7XG4gICAgICAgIGlmIChERFNUb29scy5TdG9yZUxPREluQWxwaGFDaGFubmVsKSB7XG4gICAgICAgICAgICBjb25zdCBkZXN0QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoZGF0YUxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBzcmNEYXRhID0gbmV3IFVpbnQxNkFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyY1BvcyA9ICh4ICsgeSAqIHdpZHRoKSAqIDQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleF0gPSBzcmNEYXRhW3NyY1Bvc107XG4gICAgICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleCArIDFdID0gc3JjRGF0YVtzcmNQb3MgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdEFycmF5W2luZGV4ICsgMl0gPSBzcmNEYXRhW3NyY1BvcyArIDJdO1xuICAgICAgICAgICAgICAgICAgICBkZXN0QXJyYXlbaW5kZXggKyAzXSA9IFRvSGFsZkZsb2F0KGxvZCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc3RBcnJheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgICB9XG4gICAgc3RhdGljIF9HZXRGbG9hdFJHQkFBcnJheUJ1ZmZlcih3aWR0aCwgaGVpZ2h0LCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoLCBhcnJheUJ1ZmZlciwgbG9kKSB7XG4gICAgICAgIGlmIChERFNUb29scy5TdG9yZUxPREluQWxwaGFDaGFubmVsKSB7XG4gICAgICAgICAgICBjb25zdCBkZXN0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGFMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3Qgc3JjRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3JjUG9zID0gKHggKyB5ICogd2lkdGgpICogNDtcbiAgICAgICAgICAgICAgICAgICAgZGVzdEFycmF5W2luZGV4XSA9IHNyY0RhdGFbc3JjUG9zXTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdEFycmF5W2luZGV4ICsgMV0gPSBzcmNEYXRhW3NyY1BvcyArIDFdO1xuICAgICAgICAgICAgICAgICAgICBkZXN0QXJyYXlbaW5kZXggKyAyXSA9IHNyY0RhdGFbc3JjUG9zICsgMl07XG4gICAgICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleCArIDNdID0gbG9kO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXN0QXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgpO1xuICAgIH1cbiAgICBzdGF0aWMgX0dldEZsb2F0QXNIYWxmRmxvYXRSR0JBQXJyYXlCdWZmZXIod2lkdGgsIGhlaWdodCwgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCwgYXJyYXlCdWZmZXIsIGxvZCkge1xuICAgICAgICBjb25zdCBkZXN0QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoZGF0YUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNyY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0KTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZGVzdEFycmF5W2luZGV4XSA9IFRvSGFsZkZsb2F0KHNyY0RhdGFbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICBkZXN0QXJyYXlbaW5kZXggKyAxXSA9IFRvSGFsZkZsb2F0KHNyY0RhdGFbaW5kZXggKyAxXSk7XG4gICAgICAgICAgICAgICAgZGVzdEFycmF5W2luZGV4ICsgMl0gPSBUb0hhbGZGbG9hdChzcmNEYXRhW2luZGV4ICsgMl0pO1xuICAgICAgICAgICAgICAgIGlmIChERFNUb29scy5TdG9yZUxPREluQWxwaGFDaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleCArIDNdID0gVG9IYWxmRmxvYXQobG9kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleCArIDNdID0gVG9IYWxmRmxvYXQoc3JjRGF0YVtpbmRleCArIDNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdEFycmF5O1xuICAgIH1cbiAgICBzdGF0aWMgX0dldEZsb2F0QXNVSW50UkdCQUFycmF5QnVmZmVyKHdpZHRoLCBoZWlnaHQsIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgsIGFycmF5QnVmZmVyLCBsb2QpIHtcbiAgICAgICAgY29uc3QgZGVzdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNyY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0KTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3JjUG9zID0gKHggKyB5ICogd2lkdGgpICogNDtcbiAgICAgICAgICAgICAgICBkZXN0QXJyYXlbaW5kZXhdID0gQ2xhbXAoc3JjRGF0YVtzcmNQb3NdKSAqIDI1NTtcbiAgICAgICAgICAgICAgICBkZXN0QXJyYXlbaW5kZXggKyAxXSA9IENsYW1wKHNyY0RhdGFbc3JjUG9zICsgMV0pICogMjU1O1xuICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleCArIDJdID0gQ2xhbXAoc3JjRGF0YVtzcmNQb3MgKyAyXSkgKiAyNTU7XG4gICAgICAgICAgICAgICAgaWYgKEREU1Rvb2xzLlN0b3JlTE9ESW5BbHBoYUNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdEFycmF5W2luZGV4ICsgM10gPSBsb2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXN0QXJyYXlbaW5kZXggKyAzXSA9IENsYW1wKHNyY0RhdGFbc3JjUG9zICsgM10pICogMjU1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0QXJyYXk7XG4gICAgfVxuICAgIHN0YXRpYyBfR2V0SGFsZkZsb2F0QXNVSW50UkdCQUFycmF5QnVmZmVyKHdpZHRoLCBoZWlnaHQsIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgsIGFycmF5QnVmZmVyLCBsb2QpIHtcbiAgICAgICAgY29uc3QgZGVzdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNyY0RhdGEgPSBuZXcgVWludDE2QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcmNQb3MgPSAoeCArIHkgKiB3aWR0aCkgKiA0O1xuICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleF0gPSBDbGFtcChGcm9tSGFsZkZsb2F0KHNyY0RhdGFbc3JjUG9zXSkpICogMjU1O1xuICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleCArIDFdID0gQ2xhbXAoRnJvbUhhbGZGbG9hdChzcmNEYXRhW3NyY1BvcyArIDFdKSkgKiAyNTU7XG4gICAgICAgICAgICAgICAgZGVzdEFycmF5W2luZGV4ICsgMl0gPSBDbGFtcChGcm9tSGFsZkZsb2F0KHNyY0RhdGFbc3JjUG9zICsgMl0pKSAqIDI1NTtcbiAgICAgICAgICAgICAgICBpZiAoRERTVG9vbHMuU3RvcmVMT0RJbkFscGhhQ2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0QXJyYXlbaW5kZXggKyAzXSA9IGxvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RBcnJheVtpbmRleCArIDNdID0gQ2xhbXAoRnJvbUhhbGZGbG9hdChzcmNEYXRhW3NyY1BvcyArIDNdKSkgKiAyNTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3RBcnJheTtcbiAgICB9XG4gICAgc3RhdGljIF9HZXRSR0JBQXJyYXlCdWZmZXIod2lkdGgsIGhlaWdodCwgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCwgYXJyYXlCdWZmZXIsIHJPZmZzZXQsIGdPZmZzZXQsIGJPZmZzZXQsIGFPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNyY0RhdGEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldCk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNyY1BvcyA9ICh4ICsgeSAqIHdpZHRoKSAqIDQ7XG4gICAgICAgICAgICAgICAgYnl0ZUFycmF5W2luZGV4XSA9IHNyY0RhdGFbc3JjUG9zICsgck9mZnNldF07XG4gICAgICAgICAgICAgICAgYnl0ZUFycmF5W2luZGV4ICsgMV0gPSBzcmNEYXRhW3NyY1BvcyArIGdPZmZzZXRdO1xuICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtpbmRleCArIDJdID0gc3JjRGF0YVtzcmNQb3MgKyBiT2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBieXRlQXJyYXlbaW5kZXggKyAzXSA9IHNyY0RhdGFbc3JjUG9zICsgYU9mZnNldF07XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZUFycmF5O1xuICAgIH1cbiAgICBzdGF0aWMgX0V4dHJhY3RMb25nV29yZE9yZGVyKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA9PT0gMjU1IHx8IHZhbHVlID09PSAtMTY3NzcyMTYpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxICsgRERTVG9vbHMuX0V4dHJhY3RMb25nV29yZE9yZGVyKHZhbHVlID4+IDgpO1xuICAgIH1cbiAgICBzdGF0aWMgX0dldFJHQkFycmF5QnVmZmVyKHdpZHRoLCBoZWlnaHQsIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgsIGFycmF5QnVmZmVyLCByT2Zmc2V0LCBnT2Zmc2V0LCBiT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGFMZW5ndGgpO1xuICAgICAgICBjb25zdCBzcmNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcmNQb3MgPSAoeCArIHkgKiB3aWR0aCkgKiAzO1xuICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtpbmRleF0gPSBzcmNEYXRhW3NyY1BvcyArIHJPZmZzZXRdO1xuICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtpbmRleCArIDFdID0gc3JjRGF0YVtzcmNQb3MgKyBnT2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBieXRlQXJyYXlbaW5kZXggKyAyXSA9IHNyY0RhdGFbc3JjUG9zICsgYk9mZnNldF07XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZUFycmF5O1xuICAgIH1cbiAgICBzdGF0aWMgX0dldEx1bWluYW5jZUFycmF5QnVmZmVyKHdpZHRoLCBoZWlnaHQsIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgsIGFycmF5QnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGFMZW5ndGgpO1xuICAgICAgICBjb25zdCBzcmNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGRhdGFPZmZzZXQpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcmNQb3MgPSB4ICsgeSAqIHdpZHRoO1xuICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtpbmRleF0gPSBzcmNEYXRhW3NyY1Bvc107XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZUFycmF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIEREUyBMZXZlbHMgdG8gYSBCYWJ5bG9uIFRleHR1cmVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgVXBsb2FkRERTTGV2ZWxzKGVuZ2luZSwgdGV4dHVyZSwgZGF0YSwgaW5mbywgbG9hZE1pcG1hcHMsIGZhY2VzLCBsb2RJbmRleCA9IC0xLCBjdXJyZW50RmFjZSwgZGVzdFR5cGVNdXN0QmVGaWx0ZXJhYmxlID0gdHJ1ZSkge1xuICAgICAgICBsZXQgc3BoZXJpY2FsUG9seW5vbWlhbEZhY2VzID0gbnVsbDtcbiAgICAgICAgaWYgKGluZm8uc3BoZXJpY2FsUG9seW5vbWlhbCkge1xuICAgICAgICAgICAgc3BoZXJpY2FsUG9seW5vbWlhbEZhY2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ID0gISFlbmdpbmUuZ2V0Q2FwcygpLnMzdGM7XG4gICAgICAgIC8vIFRPRE8gV0VCR1BVIE9uY2UgZ2VuZXJhdGVNaXBNYXBzIGlzIHNwbGl0IGludG8gZ2VuZXJhdGVNaXBNYXBzICsgaGFzTWlwTWFwcyBpbiBJbnRlcm5hbFRleHR1cmUgdGhpcyBsaW5lIGNhbiBiZSByZW1vdmVkXG4gICAgICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBNYXBzID0gbG9hZE1pcG1hcHM7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBJbnQzMkFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGhlYWRlckxlbmd0aEludCk7XG4gICAgICAgIGxldCBmb3VyQ0MsIHdpZHRoLCBoZWlnaHQsIGRhdGFMZW5ndGggPSAwLCBkYXRhT2Zmc2V0O1xuICAgICAgICBsZXQgYnl0ZUFycmF5LCBtaXBtYXBDb3VudCwgbWlwO1xuICAgICAgICBsZXQgaW50ZXJuYWxDb21wcmVzc2VkRm9ybWF0ID0gMDtcbiAgICAgICAgbGV0IGJsb2NrQnl0ZXMgPSAxO1xuICAgICAgICBpZiAoaGVhZGVyW29mZl9tYWdpY10gIT09IEREU19NQUdJQykge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFwiSW52YWxpZCBtYWdpYyBudW1iZXIgaW4gRERTIGhlYWRlclwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluZm8uaXNGb3VyQ0MgJiYgIWluZm8uaXNSR0IgJiYgIWluZm8uaXNMdW1pbmFuY2UpIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihcIlVuc3VwcG9ydGVkIGZvcm1hdCwgbXVzdCBjb250YWluIGEgRm91ckNDLCBSR0Igb3IgTFVNSU5BTkNFIGNvZGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8uaXNDb21wcmVzc2VkICYmICFleHQpIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihcIkNvbXByZXNzZWQgdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybS5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJwcCA9IGhlYWRlcltvZmZfUkdCYnBwXTtcbiAgICAgICAgZGF0YU9mZnNldCA9IGhlYWRlcltvZmZfc2l6ZV0gKyA0O1xuICAgICAgICBsZXQgY29tcHV0ZUZvcm1hdHMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGluZm8uaXNGb3VyQ0MpIHtcbiAgICAgICAgICAgIGZvdXJDQyA9IGhlYWRlcltvZmZfcGZGb3VyQ0NdO1xuICAgICAgICAgICAgc3dpdGNoIChmb3VyQ0MpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEZPVVJDQ19EWFQxOlxuICAgICAgICAgICAgICAgICAgICBibG9ja0J5dGVzID0gODtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDb21wcmVzc2VkRm9ybWF0ID0gMzM3Nzc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRk9VUkNDX0RYVDM6XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQnl0ZXMgPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDb21wcmVzc2VkRm9ybWF0ID0gMzM3Nzg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRk9VUkNDX0RYVDU6XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQnl0ZXMgPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDb21wcmVzc2VkRm9ybWF0ID0gMzM3Nzk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRk9VUkNDX0QzREZNVF9SMTZHMTZCMTZBMTZGOlxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlRm9ybWF0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJwcCA9IDY0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEZPVVJDQ19EM0RGTVRfUjMyRzMyQjMyQTMyRjpcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZUZvcm1hdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicHAgPSAxMjg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRk9VUkNDX0RYMTA6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYW4gYWRkaXRpb25uYWwgaGVhZGVyIHNvIGRhdGFPZmZzZXQgbmVlZCB0byBiZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgKz0gNSAqIDQ7IC8vIDUgdWludHNcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGluZm8uZHhnaUZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfRkxPQVQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZUZvcm1hdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJwcCA9IDY0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlRm9ybWF0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnBwID0gMTI4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERYR0lfRk9STUFUX0I4RzhSOFg4X1VOT1JNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uaXNSR0IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uaXNGb3VyQ0MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicHAgPSAzMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5FcnJvcihbXCJVbnN1cHBvcnRlZCBGb3VyQ0MgY29kZTpcIiwgSW50MzJUb0ZvdXJDQyhmb3VyQ0MpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByT2Zmc2V0ID0gRERTVG9vbHMuX0V4dHJhY3RMb25nV29yZE9yZGVyKGhlYWRlcltvZmZfUk1hc2tdKTtcbiAgICAgICAgY29uc3QgZ09mZnNldCA9IEREU1Rvb2xzLl9FeHRyYWN0TG9uZ1dvcmRPcmRlcihoZWFkZXJbb2ZmX0dNYXNrXSk7XG4gICAgICAgIGNvbnN0IGJPZmZzZXQgPSBERFNUb29scy5fRXh0cmFjdExvbmdXb3JkT3JkZXIoaGVhZGVyW29mZl9CTWFza10pO1xuICAgICAgICBjb25zdCBhT2Zmc2V0ID0gRERTVG9vbHMuX0V4dHJhY3RMb25nV29yZE9yZGVyKGhlYWRlcltvZmZfQU1hc2tdKTtcbiAgICAgICAgaWYgKGNvbXB1dGVGb3JtYXRzKSB7XG4gICAgICAgICAgICBpbnRlcm5hbENvbXByZXNzZWRGb3JtYXQgPSBlbmdpbmUuX2dldFJHQkFCdWZmZXJJbnRlcm5hbFNpemVkRm9ybWF0KGluZm8udGV4dHVyZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIG1pcG1hcENvdW50ID0gMTtcbiAgICAgICAgaWYgKGhlYWRlcltvZmZfZmxhZ3NdICYgRERTRF9NSVBNQVBDT1VOVCAmJiBsb2FkTWlwbWFwcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1pcG1hcENvdW50ID0gTWF0aC5tYXgoMSwgaGVhZGVyW29mZl9taXBtYXBDb3VudF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0RmFjZSA9IGN1cnJlbnRGYWNlIHx8IDA7XG4gICAgICAgIGNvbnN0IGNhcHMgPSBlbmdpbmUuZ2V0Q2FwcygpO1xuICAgICAgICBmb3IgKGxldCBmYWNlID0gc3RhcnRGYWNlOyBmYWNlIDwgZmFjZXM7IGZhY2UrKykge1xuICAgICAgICAgICAgd2lkdGggPSBoZWFkZXJbb2ZmX3dpZHRoXTtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlYWRlcltvZmZfaGVpZ2h0XTtcbiAgICAgICAgICAgIGZvciAobWlwID0gMDsgbWlwIDwgbWlwbWFwQ291bnQ7ICsrbWlwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZEluZGV4ID09PSAtMSB8fCBsb2RJbmRleCA9PT0gbWlwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgZml4ZWQgTE9ELCBpZiB0aGUgbG9kIGhhcyBqdXN0IGJlZW4gdXBsb2FkZWQsIGVhcmx5IGV4aXQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBsb2RJbmRleCA9PT0gLTEgPyBtaXAgOiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluZm8uaXNDb21wcmVzc2VkICYmIGluZm8uaXNGb3VyQ0MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFMZW5ndGggPSB3aWR0aCAqIGhlaWdodCAqIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxvYXRBcnJheSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5naW5lLl9iYWRPUyB8fCBlbmdpbmUuX2JhZERlc2t0b3BPUyB8fCAoIWNhcHMudGV4dHVyZUhhbGZGbG9hdCAmJiAhY2Fwcy50ZXh0dXJlRmxvYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVxdWlyZWQgYmVjYXVzZSBpT1MgaGFzIG1hbnkgaXNzdWVzIHdpdGggZmxvYXQgYW5kIGhhbGYgZmxvYXQgZ2VuZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicHAgPT09IDEyOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdEFycmF5ID0gRERTVG9vbHMuX0dldEZsb2F0QXNVSW50UkdCQUFycmF5QnVmZmVyKHdpZHRoLCBoZWlnaHQsIGRhdGEuYnl0ZU9mZnNldCArIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgsIGRhdGEuYnVmZmVyLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwaGVyaWNhbFBvbHlub21pYWxGYWNlcyAmJiBpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwaGVyaWNhbFBvbHlub21pYWxGYWNlcy5wdXNoKEREU1Rvb2xzLl9HZXRGbG9hdFJHQkFBcnJheUJ1ZmZlcih3aWR0aCwgaGVpZ2h0LCBkYXRhLmJ5dGVPZmZzZXQgKyBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoLCBkYXRhLmJ1ZmZlciwgaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJwcCA9PT0gNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXRBcnJheSA9IEREU1Rvb2xzLl9HZXRIYWxmRmxvYXRBc1VJbnRSR0JBQXJyYXlCdWZmZXIod2lkdGgsIGhlaWdodCwgZGF0YS5ieXRlT2Zmc2V0ICsgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCwgZGF0YS5idWZmZXIsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BoZXJpY2FsUG9seW5vbWlhbEZhY2VzICYmIGkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BoZXJpY2FsUG9seW5vbWlhbEZhY2VzLnB1c2goRERTVG9vbHMuX0dldEhhbGZGbG9hdEFzRmxvYXRSR0JBQXJyYXlCdWZmZXIod2lkdGgsIGhlaWdodCwgZGF0YS5ieXRlT2Zmc2V0ICsgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCwgZGF0YS5idWZmZXIsIGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxvYXRBdmFpbGFibGUgPSBjYXBzLnRleHR1cmVGbG9hdCAmJiAoKGRlc3RUeXBlTXVzdEJlRmlsdGVyYWJsZSAmJiBjYXBzLnRleHR1cmVGbG9hdExpbmVhckZpbHRlcmluZykgfHwgIWRlc3RUeXBlTXVzdEJlRmlsdGVyYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFsZkZsb2F0QXZhaWxhYmxlID0gY2Fwcy50ZXh0dXJlSGFsZkZsb2F0ICYmICgoZGVzdFR5cGVNdXN0QmVGaWx0ZXJhYmxlICYmIGNhcHMudGV4dHVyZUhhbGZGbG9hdExpbmVhckZpbHRlcmluZykgfHwgIWRlc3RUeXBlTXVzdEJlRmlsdGVyYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdFR5cGUgPSAoYnBwID09PSAxMjggfHwgKGJwcCA9PT0gNjQgJiYgIWhhbGZGbG9hdEF2YWlsYWJsZSkpICYmIGZsb2F0QXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChicHAgPT09IDY0IHx8IChicHAgPT09IDEyOCAmJiAhZmxvYXRBdmFpbGFibGUpKSAmJiBoYWxmRmxvYXRBdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhR2V0dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhR2V0dGVyUG9seW5vbWlhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChicHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZGVzdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFHZXR0ZXIgPSBERFNUb29scy5fR2V0RmxvYXRSR0JBQXJyYXlCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFHZXR0ZXJQb2x5bm9taWFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhR2V0dGVyID0gRERTVG9vbHMuX0dldEZsb2F0QXNIYWxmRmxvYXRSR0JBQXJyYXlCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFHZXR0ZXJQb2x5bm9taWFsID0gRERTVG9vbHMuX0dldEZsb2F0UkdCQUFycmF5QnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFHZXR0ZXIgPSBERFNUb29scy5fR2V0RmxvYXRBc1VJbnRSR0JBQXJyYXlCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFHZXR0ZXJQb2x5bm9taWFsID0gRERTVG9vbHMuX0dldEZsb2F0UkdCQUFycmF5QnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDY0IGJwcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkZXN0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUdldHRlciA9IEREU1Rvb2xzLl9HZXRIYWxmRmxvYXRBc0Zsb2F0UkdCQUFycmF5QnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhR2V0dGVyUG9seW5vbWlhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUdldHRlciA9IEREU1Rvb2xzLl9HZXRIYWxmRmxvYXRSR0JBQXJyYXlCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFHZXR0ZXJQb2x5bm9taWFsID0gRERTVG9vbHMuX0dldEhhbGZGbG9hdEFzRmxvYXRSR0JBQXJyYXlCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUdldHRlciA9IEREU1Rvb2xzLl9HZXRIYWxmRmxvYXRBc1VJbnRSR0JBQXJyYXlCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFHZXR0ZXJQb2x5bm9taWFsID0gRERTVG9vbHMuX0dldEhhbGZGbG9hdEFzRmxvYXRSR0JBQXJyYXlCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS50eXBlID0gZGVzdFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXRBcnJheSA9IGRhdGFHZXR0ZXIod2lkdGgsIGhlaWdodCwgZGF0YS5ieXRlT2Zmc2V0ICsgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCwgZGF0YS5idWZmZXIsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGhlcmljYWxQb2x5bm9taWFsRmFjZXMgJiYgaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwaGVyaWNhbFBvbHlub21pYWxGYWNlcy5wdXNoKGRhdGFHZXR0ZXJQb2x5bm9taWFsID8gZGF0YUdldHRlclBvbHlub21pYWwod2lkdGgsIGhlaWdodCwgZGF0YS5ieXRlT2Zmc2V0ICsgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCwgZGF0YS5idWZmZXIsIGkpIDogZmxvYXRBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsb2F0QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmdpbmUuX3VwbG9hZERhdGFUb1RleHR1cmVEaXJlY3RseSh0ZXh0dXJlLCBmbG9hdEFycmF5LCBmYWNlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmZvLmlzUkdCKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJwcCA9PT0gMjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkgPSBERFNUb29scy5fR2V0UkdCQXJyYXlCdWZmZXIod2lkdGgsIGhlaWdodCwgZGF0YS5ieXRlT2Zmc2V0ICsgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCwgZGF0YS5idWZmZXIsIHJPZmZzZXQsIGdPZmZzZXQsIGJPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZ2luZS5fdXBsb2FkRGF0YVRvVGV4dHVyZURpcmVjdGx5KHRleHR1cmUsIGJ5dGVBcnJheSwgZmFjZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhTGVuZ3RoID0gd2lkdGggKiBoZWlnaHQgKiA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheSA9IEREU1Rvb2xzLl9HZXRSR0JBQXJyYXlCdWZmZXIod2lkdGgsIGhlaWdodCwgZGF0YS5ieXRlT2Zmc2V0ICsgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCwgZGF0YS5idWZmZXIsIHJPZmZzZXQsIGdPZmZzZXQsIGJPZmZzZXQsIGFPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZ2luZS5fdXBsb2FkRGF0YVRvVGV4dHVyZURpcmVjdGx5KHRleHR1cmUsIGJ5dGVBcnJheSwgZmFjZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5mby5pc0x1bWluYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5wYWNrQWxpZ25tZW50ID0gZW5naW5lLl9nZXRVbnBhY2tBbGlnbmVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1bnBhZGRlZFJvd1NpemUgPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRlZFJvd1NpemUgPSBNYXRoLmZsb29yKCh3aWR0aCArIHVucGFja0FsaWdubWVudCAtIDEpIC8gdW5wYWNrQWxpZ25tZW50KSAqIHVucGFja0FsaWdubWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFMZW5ndGggPSBwYWRkZWRSb3dTaXplICogKGhlaWdodCAtIDEpICsgdW5wYWRkZWRSb3dTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5ID0gRERTVG9vbHMuX0dldEx1bWluYW5jZUFycmF5QnVmZmVyKHdpZHRoLCBoZWlnaHQsIGRhdGEuYnl0ZU9mZnNldCArIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgsIGRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmdpbmUuX3VwbG9hZERhdGFUb1RleHR1cmVEaXJlY3RseSh0ZXh0dXJlLCBieXRlQXJyYXksIGZhY2UsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxlbmd0aCA9ICgoKE1hdGgubWF4KDQsIHdpZHRoKSAvIDQpICogTWF0aC5tYXgoNCwgaGVpZ2h0KSkgLyA0KSAqIGJsb2NrQnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0ICsgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5naW5lLl91cGxvYWRDb21wcmVzc2VkRGF0YVRvVGV4dHVyZURpcmVjdGx5KHRleHR1cmUsIGludGVybmFsQ29tcHJlc3NlZEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgYnl0ZUFycmF5LCBmYWNlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ICs9IGJwcCA/IHdpZHRoICogaGVpZ2h0ICogKGJwcCAvIDgpIDogZGF0YUxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aWR0aCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICo9IDAuNTtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KDEuMCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KDEuMCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZGluZyBhIHNpbmdsZSBmYWNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwaGVyaWNhbFBvbHlub21pYWxGYWNlcyAmJiBzcGhlcmljYWxQb2x5bm9taWFsRmFjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaW5mby5zcGhlcmljYWxQb2x5bm9taWFsID0gQ3ViZU1hcFRvU3BoZXJpY2FsUG9seW5vbWlhbFRvb2xzLkNvbnZlcnRDdWJlTWFwVG9TcGhlcmljYWxQb2x5bm9taWFsKHtcbiAgICAgICAgICAgICAgICBzaXplOiBoZWFkZXJbb2ZmX3dpZHRoXSxcbiAgICAgICAgICAgICAgICByaWdodDogc3BoZXJpY2FsUG9seW5vbWlhbEZhY2VzWzBdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHNwaGVyaWNhbFBvbHlub21pYWxGYWNlc1sxXSxcbiAgICAgICAgICAgICAgICB1cDogc3BoZXJpY2FsUG9seW5vbWlhbEZhY2VzWzJdLFxuICAgICAgICAgICAgICAgIGRvd246IHNwaGVyaWNhbFBvbHlub21pYWxGYWNlc1szXSxcbiAgICAgICAgICAgICAgICBmcm9udDogc3BoZXJpY2FsUG9seW5vbWlhbEZhY2VzWzRdLFxuICAgICAgICAgICAgICAgIGJhY2s6IHNwaGVyaWNhbFBvbHlub21pYWxGYWNlc1s1XSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IDUsXG4gICAgICAgICAgICAgICAgdHlwZTogMSxcbiAgICAgICAgICAgICAgICBnYW1tYVNwYWNlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5mby5zcGhlcmljYWxQb2x5bm9taWFsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBHZXRzIG9yIHNldHMgYSBib29sZWFuIGluZGljYXRpbmcgdGhhdCBMT0QgaW5mbyBpcyBzdG9yZWQgaW4gYWxwaGEgY2hhbm5lbCAoZmFsc2UgYnkgZGVmYXVsdClcbiAqL1xuRERTVG9vbHMuU3RvcmVMT0RJbkFscGhhQ2hhbm5lbCA9IGZhbHNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGRzLmpzLm1hcCIsIi8qKlxuICogR2V0cyB0aGUgZmlsZSBleHRlbnNpb24gZnJvbSBhIFVSTC5cbiAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0byBnZXQgdGhlIGZpbGUgZXh0ZW5zaW9uIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgZmlsZSBleHRlbnNpb24sIG9yIGFuIGVtcHR5IHN0cmluZyBpZiBubyBleHRlbnNpb24gaXMgZm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRFeHRlbnNpb25Gcm9tVXJsKHVybCkge1xuICAgIGNvbnN0IHVybFdpdGhvdXRVcmlQYXJhbXMgPSB1cmwuc3BsaXQoXCI/XCIpWzBdO1xuICAgIGNvbnN0IGxhc3REb3QgPSB1cmxXaXRob3V0VXJpUGFyYW1zLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBsYXN0RG90ID4gLTEgPyB1cmxXaXRob3V0VXJpUGFyYW1zLnN1YnN0cmluZyhsYXN0RG90KS50b0xvd2VyQ2FzZSgpIDogXCJcIjtcbiAgICByZXR1cm4gZXh0ZW5zaW9uO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsVG9vbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9