"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["vendors-node_modules_babylonjs_core_Materials_Textures_texture_js"],{

/***/ "./node_modules/@babylonjs/core/Compat/compatibilityOptions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Compat/compatibilityOptions.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompatibilityOptions: () => (/* binding */ CompatibilityOptions),
/* harmony export */   setOpenGLOrientationForUV: () => (/* binding */ setOpenGLOrientationForUV),
/* harmony export */   useOpenGLOrientationForUV: () => (/* binding */ useOpenGLOrientationForUV)
/* harmony export */ });
/**
 * Defines if the system should use OpenGL convention for UVs when creating geometry or loading .babylon files (false by default)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
let useOpenGLOrientationForUV = false;
/**
 * Sets whether to use OpenGL convention for UVs
 * @param value the new value
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function setOpenGLOrientationForUV(value) {
    useOpenGLOrientationForUV = value;
}
/**
 * Options used to control default behaviors regarding compatibility support
 * @deprecated please use named exports
 */
const CompatibilityOptions = {
    /* eslint-disable @typescript-eslint/naming-convention */
    get UseOpenGLOrientationForUV() {
        return useOpenGLOrientationForUV;
    },
    set UseOpenGLOrientationForUV(value) {
        useOpenGLOrientationForUV = value;
    },
    /* eslint-enable @typescript-eslint/naming-convention */
};
//# sourceMappingURL=compatibilityOptions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/baseTexture.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/baseTexture.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTexture: () => (/* binding */ BaseTexture)
/* harmony export */ });
/* harmony import */ var _tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tslib.es6.js */ "./node_modules/@babylonjs/core/tslib.es6.js");
/* harmony import */ var _Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Misc/decorators.js */ "./node_modules/@babylonjs/core/Misc/decorators.js");
/* harmony import */ var _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Misc/observable.js */ "./node_modules/@babylonjs/core/Misc/observable.js");
/* harmony import */ var _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Maths/math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");
/* harmony import */ var _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Engines/engineStore.js */ "./node_modules/@babylonjs/core/Engines/engineStore.js");
/* harmony import */ var _Misc_guid_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Misc/guid.js */ "./node_modules/@babylonjs/core/Misc/guid.js");
/* harmony import */ var _Misc_fileTools_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Misc/fileTools.js */ "./node_modules/@babylonjs/core/Misc/fileTools.js");
/* harmony import */ var _thinTexture_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./thinTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/thinTexture.js");
/* harmony import */ var _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../Misc/decorators.serialization.js */ "./node_modules/@babylonjs/core/Misc/decorators.serialization.js");










/**
 * Base class of all the textures in babylon.
 * It groups all the common properties the materials, post process, lights... might need
 * in order to make a correct use of the texture.
 */
class BaseTexture extends _thinTexture_js__WEBPACK_IMPORTED_MODULE_7__.ThinTexture {
    /**
     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).
     */
    set hasAlpha(value) {
        if (this._hasAlpha === value) {
            return;
        }
        this._hasAlpha = value;
        if (this._scene) {
            this._scene.markAllMaterialsAsDirty(1, (mat) => {
                return mat.hasTexture(this);
            });
        }
    }
    get hasAlpha() {
        return this._hasAlpha;
    }
    /**
     * Defines if the alpha value should be determined via the rgb values.
     * If true the luminance of the pixel might be used to find the corresponding alpha value.
     */
    set getAlphaFromRGB(value) {
        if (this._getAlphaFromRGB === value) {
            return;
        }
        this._getAlphaFromRGB = value;
        if (this._scene) {
            this._scene.markAllMaterialsAsDirty(1, (mat) => {
                return mat.hasTexture(this);
            });
        }
    }
    get getAlphaFromRGB() {
        return this._getAlphaFromRGB;
    }
    /**
     * Define the UV channel to use starting from 0 and defaulting to 0.
     * This is part of the texture as textures usually maps to one uv set.
     */
    set coordinatesIndex(value) {
        if (this._coordinatesIndex === value) {
            return;
        }
        this._coordinatesIndex = value;
        if (this._scene) {
            this._scene.markAllMaterialsAsDirty(1, (mat) => {
                return mat.hasTexture(this);
            });
        }
    }
    get coordinatesIndex() {
        return this._coordinatesIndex;
    }
    /**
     * How a texture is mapped.
     *
     * | Value | Type                                | Description |
     * | ----- | ----------------------------------- | ----------- |
     * | 0     | EXPLICIT_MODE                       |             |
     * | 1     | SPHERICAL_MODE                      |             |
     * | 2     | PLANAR_MODE                         |             |
     * | 3     | CUBIC_MODE                          |             |
     * | 4     | PROJECTION_MODE                     |             |
     * | 5     | SKYBOX_MODE                         |             |
     * | 6     | INVCUBIC_MODE                       |             |
     * | 7     | EQUIRECTANGULAR_MODE                |             |
     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |
     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |
     */
    set coordinatesMode(value) {
        if (this._coordinatesMode === value) {
            return;
        }
        this._coordinatesMode = value;
        if (this._scene) {
            this._scene.markAllMaterialsAsDirty(1, (mat) => {
                return mat.hasTexture(this);
            });
        }
    }
    get coordinatesMode() {
        return this._coordinatesMode;
    }
    /**
     * | Value | Type               | Description |
     * | ----- | ------------------ | ----------- |
     * | 0     | CLAMP_ADDRESSMODE  |             |
     * | 1     | WRAP_ADDRESSMODE   |             |
     * | 2     | MIRROR_ADDRESSMODE |             |
     */
    get wrapU() {
        return this._wrapU;
    }
    set wrapU(value) {
        this._wrapU = value;
    }
    /**
     * | Value | Type               | Description |
     * | ----- | ------------------ | ----------- |
     * | 0     | CLAMP_ADDRESSMODE  |             |
     * | 1     | WRAP_ADDRESSMODE   |             |
     * | 2     | MIRROR_ADDRESSMODE |             |
     */
    get wrapV() {
        return this._wrapV;
    }
    set wrapV(value) {
        this._wrapV = value;
    }
    /**
     * Define if the texture is a cube texture or if false a 2d texture.
     */
    get isCube() {
        if (!this._texture) {
            return this._isCube;
        }
        return this._texture.isCube;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    set isCube(value) {
        if (!this._texture) {
            this._isCube = value;
        }
        else {
            this._texture.isCube = value;
        }
    }
    /**
     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.
     */
    get is3D() {
        if (!this._texture) {
            return false;
        }
        return this._texture.is3D;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    set is3D(value) {
        if (!this._texture) {
            return;
        }
        this._texture.is3D = value;
    }
    /**
     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.
     */
    get is2DArray() {
        if (!this._texture) {
            return false;
        }
        return this._texture.is2DArray;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    set is2DArray(value) {
        if (!this._texture) {
            return;
        }
        this._texture.is2DArray = value;
    }
    /**
     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).
     * HDR texture are usually stored in linear space.
     * This only impacts the PBR and Background materials
     */
    get gammaSpace() {
        if (!this._texture) {
            return this._gammaSpace;
        }
        else {
            if (this._texture._gammaSpace === null) {
                this._texture._gammaSpace = this._gammaSpace;
            }
        }
        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;
    }
    set gammaSpace(gamma) {
        if (!this._texture) {
            if (this._gammaSpace === gamma) {
                return;
            }
            this._gammaSpace = gamma;
        }
        else {
            if (this._texture._gammaSpace === gamma) {
                return;
            }
            this._texture._gammaSpace = gamma;
        }
        this.getScene()?.markAllMaterialsAsDirty(1, (mat) => {
            return mat.hasTexture(this);
        });
    }
    /**
     * Gets or sets whether or not the texture contains RGBD data.
     */
    get isRGBD() {
        return this._texture != null && this._texture._isRGBD;
    }
    set isRGBD(value) {
        if (value === this.isRGBD) {
            return;
        }
        if (this._texture) {
            this._texture._isRGBD = value;
        }
        this.getScene()?.markAllMaterialsAsDirty(1, (mat) => {
            return mat.hasTexture(this);
        });
    }
    /**
     * Are mip maps generated for this texture or not.
     */
    get noMipmap() {
        return false;
    }
    /**
     * With prefiltered texture, defined the offset used during the prefiltering steps.
     */
    get lodGenerationOffset() {
        if (this._texture) {
            return this._texture._lodGenerationOffset;
        }
        return 0.0;
    }
    set lodGenerationOffset(value) {
        if (this._texture) {
            this._texture._lodGenerationOffset = value;
        }
    }
    /**
     * With prefiltered texture, defined the scale used during the prefiltering steps.
     */
    get lodGenerationScale() {
        if (this._texture) {
            return this._texture._lodGenerationScale;
        }
        return 0.0;
    }
    set lodGenerationScale(value) {
        if (this._texture) {
            this._texture._lodGenerationScale = value;
        }
    }
    /**
     * With prefiltered texture, defined if the specular generation is based on a linear ramp.
     * By default we are using a log2 of the linear roughness helping to keep a better resolution for
     * average roughness values.
     */
    get linearSpecularLOD() {
        if (this._texture) {
            return this._texture._linearSpecularLOD;
        }
        return false;
    }
    set linearSpecularLOD(value) {
        if (this._texture) {
            this._texture._linearSpecularLOD = value;
        }
    }
    /**
     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.
     * You can set the irradiance texture to rely on a texture instead of the spherical approach.
     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).
     */
    get irradianceTexture() {
        if (this._texture) {
            return this._texture._irradianceTexture;
        }
        return null;
    }
    set irradianceTexture(value) {
        if (this._texture) {
            this._texture._irradianceTexture = value;
        }
    }
    /**
     * Define the unique id of the texture in the scene.
     */
    get uid() {
        if (!this._uid) {
            this._uid = (0,_Misc_guid_js__WEBPACK_IMPORTED_MODULE_5__.RandomGUID)();
        }
        return this._uid;
    }
    /**
     * Return a string representation of the texture.
     * @returns the texture as a string
     */
    toString() {
        return this.name;
    }
    /**
     * Get the class name of the texture.
     * @returns "BaseTexture"
     */
    getClassName() {
        return "BaseTexture";
    }
    /**
     * Callback triggered when the texture has been disposed.
     * Kept for back compatibility, you can use the onDisposeObservable instead.
     */
    set onDispose(callback) {
        if (this._onDisposeObserver) {
            this.onDisposeObservable.remove(this._onDisposeObserver);
        }
        this._onDisposeObserver = this.onDisposeObservable.add(callback);
    }
    /**
     * Define if the texture is preventing a material to render or not.
     * If not and the texture is not ready, the engine will use a default black texture instead.
     */
    get isBlocking() {
        return true;
    }
    /**
     * Was there any loading error?
     */
    get loadingError() {
        return this._loadingError;
    }
    /**
     * If a loading error occurred this object will be populated with information about the error.
     */
    get errorObject() {
        return this._errorObject;
    }
    /**
     * Instantiates a new BaseTexture.
     * Base class of all the textures in babylon.
     * It groups all the common properties the materials, post process, lights... might need
     * in order to make a correct use of the texture.
     * @param sceneOrEngine Define the scene or engine the texture belongs to
     * @param internalTexture Define the internal texture associated with the texture
     */
    constructor(sceneOrEngine, internalTexture = null) {
        super(null);
        /**
         * Gets or sets an object used to store user defined information.
         */
        this.metadata = null;
        /**
         * For internal use only. Please do not use.
         */
        this.reservedDataStore = null;
        this._hasAlpha = false;
        this._getAlphaFromRGB = false;
        /**
         * Intensity or strength of the texture.
         * It is commonly used by materials to fine tune the intensity of the texture
         */
        this.level = 1;
        this._coordinatesIndex = 0;
        /**
         * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.
         * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)
         */
        this.optimizeUVAllocation = true;
        this._coordinatesMode = 0;
        /**
         * | Value | Type               | Description |
         * | ----- | ------------------ | ----------- |
         * | 0     | CLAMP_ADDRESSMODE  |             |
         * | 1     | WRAP_ADDRESSMODE   |             |
         * | 2     | MIRROR_ADDRESSMODE |             |
         */
        this.wrapR = 1;
        /**
         * With compliant hardware and browser (supporting anisotropic filtering)
         * this defines the level of anisotropic filtering in the texture.
         * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.
         */
        this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;
        /** @internal */
        this._isCube = false;
        /** @internal */
        this._gammaSpace = true;
        /**
         * Is Z inverted in the texture (useful in a cube texture).
         */
        this.invertZ = false;
        /**
         * @internal
         */
        this.lodLevelInAlpha = false;
        /**
         * Define if the texture is a render target.
         */
        this.isRenderTarget = false;
        /** @internal */
        this._prefiltered = false;
        /** @internal */
        this._forceSerialize = false;
        /**
         * Define the list of animation attached to the texture.
         */
        this.animations = [];
        /**
         * An event triggered when the texture is disposed.
         */
        this.onDisposeObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable();
        this._onDisposeObserver = null;
        this._scene = null;
        /** @internal */
        this._uid = null;
        /** @internal */
        this._parentContainer = null;
        this._loadingError = false;
        if (sceneOrEngine) {
            if (BaseTexture._IsScene(sceneOrEngine)) {
                this._scene = sceneOrEngine;
            }
            else {
                this._engine = sceneOrEngine;
            }
        }
        else {
            this._scene = _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_4__.EngineStore.LastCreatedScene;
        }
        if (this._scene) {
            this.uniqueId = this._scene.getUniqueId();
            this._scene.addTexture(this);
            this._engine = this._scene.getEngine();
        }
        this._texture = internalTexture;
        this._uid = null;
    }
    /**
     * Get the scene the texture belongs to.
     * @returns the scene or null if undefined
     */
    getScene() {
        return this._scene;
    }
    /** @internal */
    _getEngine() {
        return this._engine;
    }
    /**
     * Get the texture transform matrix used to offset tile the texture for instance.
     * @returns the transformation matrix
     */
    getTextureMatrix() {
        return _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.IdentityReadOnly;
    }
    /**
     * Get the texture reflection matrix used to rotate/transform the reflection.
     * @returns the reflection matrix
     */
    getReflectionTextureMatrix() {
        return _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.IdentityReadOnly;
    }
    /**
     * Gets a suitable rotate/transform matrix when the texture is used for refraction.
     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.
     * @returns The refraction matrix
     */
    getRefractionTextureMatrix() {
        return this.getReflectionTextureMatrix();
    }
    /**
     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)
     * @returns true if ready, not blocking or if there was an error loading the texture
     */
    isReadyOrNotBlocking() {
        return !this.isBlocking || this.isReady() || this.loadingError;
    }
    /**
     * Scales the texture if is `canRescale()`
     * @param ratio the resize factor we want to use to rescale
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    scale(ratio) { }
    /**
     * Get if the texture can rescale.
     */
    get canRescale() {
        return false;
    }
    /**
     * @internal
     */
    _getFromCache(url, noMipmap, sampling, invertY, useSRGBBuffer, isCube) {
        const engine = this._getEngine();
        if (!engine) {
            return null;
        }
        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
        const texturesCache = engine.getLoadedTexturesCache();
        for (let index = 0; index < texturesCache.length; index++) {
            const texturesCacheEntry = texturesCache[index];
            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {
                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {
                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {
                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {
                            if (isCube === undefined || isCube === texturesCacheEntry.isCube) {
                                texturesCacheEntry.incrementReferences();
                                return texturesCacheEntry;
                            }
                        }
                    }
                }
            }
        }
        return null;
    }
    /** @internal */
    _rebuild(_fromContextLost = false) { }
    /**
     * Clones the texture.
     * @returns the cloned texture
     */
    clone() {
        return null;
    }
    /**
     * Get the texture underlying type (INT, FLOAT...)
     */
    get textureType() {
        if (!this._texture) {
            return 0;
        }
        return this._texture.type !== undefined ? this._texture.type : 0;
    }
    /**
     * Get the texture underlying format (RGB, RGBA...)
     */
    get textureFormat() {
        if (!this._texture) {
            return 5;
        }
        return this._texture.format !== undefined ? this._texture.format : 5;
    }
    /**
     * Indicates that textures need to be re-calculated for all materials
     */
    _markAllSubMeshesAsTexturesDirty() {
        const scene = this.getScene();
        if (!scene) {
            return;
        }
        scene.markAllMaterialsAsDirty(1);
    }
    /**
     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.
     * This will returns an RGBA array buffer containing either in values (0-255) or
     * float values (0-1) depending of the underlying buffer type.
     * @param faceIndex defines the face of the texture to read (in case of cube texture)
     * @param level defines the LOD level of the texture to read (in case of Mip Maps)
     * @param buffer defines a user defined buffer to fill with data (can be null)
     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels
     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture
     * @param x defines the region x coordinates to start reading from (default to 0)
     * @param y defines the region y coordinates to start reading from (default to 0)
     * @param width defines the region width to read from (default to the texture size at level)
     * @param height defines the region width to read from (default to the texture size at level)
     * @returns The Array buffer promise containing the pixels data.
     */
    readPixels(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0, width = Number.MAX_VALUE, height = Number.MAX_VALUE) {
        if (!this._texture) {
            return null;
        }
        const engine = this._getEngine();
        if (!engine) {
            return null;
        }
        const size = this.getSize();
        let maxWidth = size.width;
        let maxHeight = size.height;
        if (level !== 0) {
            maxWidth = maxWidth / Math.pow(2, level);
            maxHeight = maxHeight / Math.pow(2, level);
            maxWidth = Math.round(maxWidth);
            maxHeight = Math.round(maxHeight);
        }
        width = Math.min(maxWidth, width);
        height = Math.min(maxHeight, height);
        try {
            if (this._texture.isCube) {
                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);
            }
            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);
        }
        catch (e) {
            return null;
        }
    }
    /**
     * @internal
     */
    _readPixelsSync(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false) {
        if (!this._texture) {
            return null;
        }
        const size = this.getSize();
        let width = size.width;
        let height = size.height;
        const engine = this._getEngine();
        if (!engine) {
            return null;
        }
        if (level != 0) {
            width = width / Math.pow(2, level);
            height = height / Math.pow(2, level);
            width = Math.round(width);
            height = Math.round(height);
        }
        try {
            if (this._texture.isCube) {
                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);
            }
            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);
        }
        catch (e) {
            return null;
        }
    }
    /** @internal */
    get _lodTextureHigh() {
        if (this._texture) {
            return this._texture._lodTextureHigh;
        }
        return null;
    }
    /** @internal */
    get _lodTextureMid() {
        if (this._texture) {
            return this._texture._lodTextureMid;
        }
        return null;
    }
    /** @internal */
    get _lodTextureLow() {
        if (this._texture) {
            return this._texture._lodTextureLow;
        }
        return null;
    }
    /**
     * Dispose the texture and release its associated resources.
     */
    dispose() {
        if (this._scene) {
            // Animations
            if (this._scene.stopAnimation) {
                this._scene.stopAnimation(this);
            }
            // Remove from scene
            this._scene.removePendingData(this);
            const index = this._scene.textures.indexOf(this);
            if (index >= 0) {
                this._scene.textures.splice(index, 1);
            }
            this._scene.onTextureRemovedObservable.notifyObservers(this);
            this._scene = null;
            if (this._parentContainer) {
                const index = this._parentContainer.textures.indexOf(this);
                if (index > -1) {
                    this._parentContainer.textures.splice(index, 1);
                }
                this._parentContainer = null;
            }
        }
        // Callback
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.metadata = null;
        super.dispose();
    }
    /**
     * Serialize the texture into a JSON representation that can be parsed later on.
     * @param allowEmptyName True to force serialization even if name is empty. Default: false
     * @returns the JSON representation of the texture
     */
    serialize(allowEmptyName = false) {
        if (!this.name && !allowEmptyName) {
            return null;
        }
        const serializationObject = _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_8__.SerializationHelper.Serialize(this);
        // Animations
        _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_8__.SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        return serializationObject;
    }
    /**
     * Helper function to be called back once a list of texture contains only ready textures.
     * @param textures Define the list of textures to wait for
     * @param callback Define the callback triggered once the entire list will be ready
     */
    static WhenAllReady(textures, callback) {
        let numRemaining = textures.length;
        if (numRemaining === 0) {
            callback();
            return;
        }
        for (let i = 0; i < textures.length; i++) {
            const texture = textures[i];
            if (texture.isReady()) {
                if (--numRemaining === 0) {
                    callback();
                }
            }
            else {
                const onLoadObservable = texture.onLoadObservable;
                if (onLoadObservable) {
                    onLoadObservable.addOnce(() => {
                        if (--numRemaining === 0) {
                            callback();
                        }
                    });
                }
                else {
                    if (--numRemaining === 0) {
                        callback();
                    }
                }
            }
        }
    }
    static _IsScene(sceneOrEngine) {
        return sceneOrEngine.getClassName() === "Scene";
    }
}
/**
 * Default anisotropic filtering level for the application.
 * It is set to 4 as a good tradeoff between perf and quality.
 */
BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "uniqueId", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "name", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "displayName", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "metadata", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)("hasAlpha")
], BaseTexture.prototype, "_hasAlpha", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)("getAlphaFromRGB")
], BaseTexture.prototype, "_getAlphaFromRGB", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "level", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)("coordinatesIndex")
], BaseTexture.prototype, "_coordinatesIndex", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "optimizeUVAllocation", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)("coordinatesMode")
], BaseTexture.prototype, "_coordinatesMode", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "wrapU", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "wrapV", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "wrapR", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "anisotropicFilteringLevel", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "isCube", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "is3D", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "is2DArray", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "gammaSpace", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "invertZ", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "lodLevelInAlpha", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "lodGenerationOffset", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "lodGenerationScale", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "linearSpecularLOD", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serializeAsTexture)()
], BaseTexture.prototype, "irradianceTexture", null);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], BaseTexture.prototype, "isRenderTarget", void 0);
//# sourceMappingURL=baseTexture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/texture.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/texture.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Texture: () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var _tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tslib.es6.js */ "./node_modules/@babylonjs/core/tslib.es6.js");
/* harmony import */ var _Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Misc/decorators.js */ "./node_modules/@babylonjs/core/Misc/decorators.js");
/* harmony import */ var _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Misc/observable.js */ "./node_modules/@babylonjs/core/Misc/observable.js");
/* harmony import */ var _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Maths/math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");
/* harmony import */ var _Materials_Textures_baseTexture_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Materials/Textures/baseTexture.js */ "./node_modules/@babylonjs/core/Materials/Textures/baseTexture.js");
/* harmony import */ var _Misc_typeStore_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Misc/typeStore.js */ "./node_modules/@babylonjs/core/Misc/typeStore.js");
/* harmony import */ var _Misc_devTools_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Misc/devTools.js */ "./node_modules/@babylonjs/core/Misc/devTools.js");
/* harmony import */ var _Misc_timingTools_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../Misc/timingTools.js */ "./node_modules/@babylonjs/core/Misc/timingTools.js");
/* harmony import */ var _Misc_instantiationTools_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../Misc/instantiationTools.js */ "./node_modules/@babylonjs/core/Misc/instantiationTools.js");
/* harmony import */ var _Maths_math_plane_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../Maths/math.plane.js */ "./node_modules/@babylonjs/core/Maths/math.plane.js");
/* harmony import */ var _Misc_stringTools_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../Misc/stringTools.js */ "./node_modules/@babylonjs/core/Misc/stringTools.js");
/* harmony import */ var _Misc_copyTools_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../Misc/copyTools.js */ "./node_modules/@babylonjs/core/Misc/copyTools.js");
/* harmony import */ var _Compat_compatibilityOptions_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../Compat/compatibilityOptions.js */ "./node_modules/@babylonjs/core/Compat/compatibilityOptions.js");
/* harmony import */ var _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../Misc/decorators.serialization.js */ "./node_modules/@babylonjs/core/Misc/decorators.serialization.js");















/**
 * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
 * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture
 */
class Texture extends _Materials_Textures_baseTexture_js__WEBPACK_IMPORTED_MODULE_4__.BaseTexture {
    /**
     * @internal
     */
    static _CreateVideoTexture(name, src, scene, generateMipMaps = false, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, settings = {}, onError, format = 5) {
        throw (0,_Misc_devTools_js__WEBPACK_IMPORTED_MODULE_6__._WarnImport)("VideoTexture");
    }
    /**
     * Are mip maps generated for this texture or not.
     */
    get noMipmap() {
        return this._noMipmap;
    }
    /** Returns the texture mime type if it was defined by a loader (undefined else) */
    get mimeType() {
        return this._mimeType;
    }
    /**
     * Is the texture preventing material to render while loading.
     * If false, a default texture will be used instead of the loading one during the preparation step.
     */
    set isBlocking(value) {
        this._isBlocking = value;
    }
    get isBlocking() {
        return this._isBlocking;
    }
    /**
     * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading
     */
    get invertY() {
        return this._invertY;
    }
    /**
     * Instantiates a new texture.
     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture
     * @param url defines the url of the picture to load as a texture
     * @param sceneOrEngine defines the scene or engine the texture will belong to
     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture
     * @param invertY defines if the texture needs to be inverted on the y axis during loading
     * @param samplingMode defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)
     * @param onLoad defines a callback triggered when the texture has been loaded
     * @param onError defines a callback triggered when an error occurred during the loading session
     * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation
     * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load
     * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
     * @param mimeType defines an optional mime type information
     * @param loaderOptions options to be passed to the loader
     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
     * @param forcedExtension defines the extension to use to pick the right loader
     */
    constructor(url, sceneOrEngine, noMipmapOrOptions, invertY, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, buffer = null, deleteBuffer = false, format, mimeType, loaderOptions, creationFlags, forcedExtension) {
        super(sceneOrEngine);
        /**
         * Define the url of the texture.
         */
        this.url = null;
        /**
         * Define an offset on the texture to offset the u coordinates of the UVs
         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting
         */
        this.uOffset = 0;
        /**
         * Define an offset on the texture to offset the v coordinates of the UVs
         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting
         */
        this.vOffset = 0;
        /**
         * Define an offset on the texture to scale the u coordinates of the UVs
         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling
         */
        this.uScale = 1.0;
        /**
         * Define an offset on the texture to scale the v coordinates of the UVs
         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling
         */
        this.vScale = 1.0;
        /**
         * Define an offset on the texture to rotate around the u coordinates of the UVs
         * The angle is defined in radians.
         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials
         */
        this.uAng = 0;
        /**
         * Define an offset on the texture to rotate around the v coordinates of the UVs
         * The angle is defined in radians.
         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials
         */
        this.vAng = 0;
        /**
         * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)
         * The angle is defined in radians.
         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials
         */
        this.wAng = 0;
        /**
         * Defines the center of rotation (U)
         */
        this.uRotationCenter = 0.5;
        /**
         * Defines the center of rotation (V)
         */
        this.vRotationCenter = 0.5;
        /**
         * Defines the center of rotation (W)
         */
        this.wRotationCenter = 0.5;
        /**
         * Sets this property to true to avoid deformations when rotating the texture with non-uniform scaling
         */
        this.homogeneousRotationInUVTransform = false;
        /**
         * List of inspectable custom properties (used by the Inspector)
         * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility
         */
        this.inspectableCustomProperties = null;
        /** @internal */
        this._noMipmap = false;
        /** @internal */
        this._invertY = false;
        this._rowGenerationMatrix = null;
        this._cachedTextureMatrix = null;
        this._projectionModeMatrix = null;
        this._t0 = null;
        this._t1 = null;
        this._t2 = null;
        this._cachedUOffset = -1;
        this._cachedVOffset = -1;
        this._cachedUScale = 0;
        this._cachedVScale = 0;
        this._cachedUAng = -1;
        this._cachedVAng = -1;
        this._cachedWAng = -1;
        this._cachedReflectionProjectionMatrixId = -1;
        this._cachedURotationCenter = -1;
        this._cachedVRotationCenter = -1;
        this._cachedWRotationCenter = -1;
        this._cachedHomogeneousRotationInUVTransform = false;
        this._cachedIdentity3x2 = true;
        this._cachedReflectionTextureMatrix = null;
        this._cachedReflectionUOffset = -1;
        this._cachedReflectionVOffset = -1;
        this._cachedReflectionUScale = 0;
        this._cachedReflectionVScale = 0;
        this._cachedReflectionCoordinatesMode = -1;
        /** @internal */
        this._buffer = null;
        this._deleteBuffer = false;
        this._format = null;
        this._delayedOnLoad = null;
        this._delayedOnError = null;
        /**
         * Observable triggered once the texture has been loaded.
         */
        this.onLoadObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable();
        this._isBlocking = true;
        this.name = url || "";
        this.url = url;
        let noMipmap;
        let useSRGBBuffer = false;
        let internalTexture = null;
        let gammaSpace = true;
        if (typeof noMipmapOrOptions === "object" && noMipmapOrOptions !== null) {
            noMipmap = noMipmapOrOptions.noMipmap ?? false;
            invertY = noMipmapOrOptions.invertY ?? !_Compat_compatibilityOptions_js__WEBPACK_IMPORTED_MODULE_12__.useOpenGLOrientationForUV;
            samplingMode = noMipmapOrOptions.samplingMode ?? Texture.TRILINEAR_SAMPLINGMODE;
            onLoad = noMipmapOrOptions.onLoad ?? null;
            onError = noMipmapOrOptions.onError ?? null;
            buffer = noMipmapOrOptions.buffer ?? null;
            deleteBuffer = noMipmapOrOptions.deleteBuffer ?? false;
            format = noMipmapOrOptions.format;
            mimeType = noMipmapOrOptions.mimeType;
            loaderOptions = noMipmapOrOptions.loaderOptions;
            creationFlags = noMipmapOrOptions.creationFlags;
            useSRGBBuffer = noMipmapOrOptions.useSRGBBuffer ?? false;
            internalTexture = noMipmapOrOptions.internalTexture ?? null;
            gammaSpace = noMipmapOrOptions.gammaSpace ?? gammaSpace;
            forcedExtension = noMipmapOrOptions.forcedExtension ?? forcedExtension;
        }
        else {
            noMipmap = !!noMipmapOrOptions;
        }
        this._gammaSpace = gammaSpace;
        this._noMipmap = noMipmap;
        this._invertY = invertY === undefined ? !_Compat_compatibilityOptions_js__WEBPACK_IMPORTED_MODULE_12__.useOpenGLOrientationForUV : invertY;
        this._initialSamplingMode = samplingMode;
        this._buffer = buffer;
        this._deleteBuffer = deleteBuffer;
        this._mimeType = mimeType;
        this._loaderOptions = loaderOptions;
        this._creationFlags = creationFlags;
        this._useSRGBBuffer = useSRGBBuffer;
        this._forcedExtension = forcedExtension;
        if (format !== undefined) {
            this._format = format;
        }
        const scene = this.getScene();
        const engine = this._getEngine();
        if (!engine) {
            return;
        }
        engine.onBeforeTextureInitObservable.notifyObservers(this);
        const load = () => {
            if (this._texture) {
                if (this._texture._invertVScale) {
                    this.vScale *= -1;
                    this.vOffset += 1;
                }
                // Update texture to match internal texture's wrapping
                if (this._texture._cachedWrapU !== null) {
                    this.wrapU = this._texture._cachedWrapU;
                    this._texture._cachedWrapU = null;
                }
                if (this._texture._cachedWrapV !== null) {
                    this.wrapV = this._texture._cachedWrapV;
                    this._texture._cachedWrapV = null;
                }
                if (this._texture._cachedWrapR !== null) {
                    this.wrapR = this._texture._cachedWrapR;
                    this._texture._cachedWrapR = null;
                }
            }
            if (this.onLoadObservable.hasObservers()) {
                this.onLoadObservable.notifyObservers(this);
            }
            if (onLoad) {
                onLoad();
            }
            if (!this.isBlocking && scene) {
                scene.resetCachedMaterial();
            }
        };
        const errorHandler = (message, exception) => {
            this._loadingError = true;
            this._errorObject = { message, exception };
            if (onError) {
                onError(message, exception);
            }
            Texture.OnTextureLoadErrorObservable.notifyObservers(this);
        };
        if (!this.url && !internalTexture) {
            this._delayedOnLoad = load;
            this._delayedOnError = errorHandler;
            return;
        }
        this._texture = internalTexture ?? this._getFromCache(this.url, noMipmap, samplingMode, this._invertY, useSRGBBuffer, this.isCube);
        if (!this._texture) {
            if (!scene || !scene.useDelayedTextureLoading) {
                try {
                    this._texture = engine.createTexture(this.url, noMipmap, this._invertY, scene, samplingMode, load, errorHandler, this._buffer, undefined, this._format, this._forcedExtension, mimeType, loaderOptions, creationFlags, useSRGBBuffer);
                }
                catch (e) {
                    errorHandler("error loading", e);
                    throw e;
                }
                if (deleteBuffer) {
                    this._buffer = null;
                }
            }
            else {
                this.delayLoadState = 4;
                this._delayedOnLoad = load;
                this._delayedOnError = errorHandler;
            }
        }
        else {
            if (this._texture.isReady) {
                _Misc_timingTools_js__WEBPACK_IMPORTED_MODULE_7__.TimingTools.SetImmediate(() => load());
            }
            else {
                const loadObserver = this._texture.onLoadedObservable.add(load);
                this._texture.onErrorObservable.add((e) => {
                    errorHandler(e.message, e.exception);
                    this._texture?.onLoadedObservable.remove(loadObserver);
                });
            }
        }
    }
    /**
     * Update the url (and optional buffer) of this texture if url was null during construction.
     * @param url the url of the texture
     * @param buffer the buffer of the texture (defaults to null)
     * @param onLoad callback called when the texture is loaded  (defaults to null)
     * @param forcedExtension defines the extension to use to pick the right loader
     */
    updateURL(url, buffer = null, onLoad, forcedExtension) {
        if (this.url) {
            this.releaseInternalTexture();
            this.getScene().markAllMaterialsAsDirty(1, (mat) => {
                return mat.hasTexture(this);
            });
        }
        if (!this.name || this.name.startsWith("data:")) {
            this.name = url;
        }
        this.url = url;
        this._buffer = buffer;
        this._forcedExtension = forcedExtension;
        this.delayLoadState = 4;
        if (onLoad) {
            this._delayedOnLoad = onLoad;
        }
        this.delayLoad();
    }
    /**
     * Finish the loading sequence of a texture flagged as delayed load.
     * @internal
     */
    delayLoad() {
        if (this.delayLoadState !== 4) {
            return;
        }
        const scene = this.getScene();
        if (!scene) {
            return;
        }
        this.delayLoadState = 1;
        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer, this.isCube);
        if (!this._texture) {
            this._texture = scene
                .getEngine()
                .createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer);
            if (this._deleteBuffer) {
                this._buffer = null;
            }
        }
        else {
            if (this._delayedOnLoad) {
                if (this._texture.isReady) {
                    _Misc_timingTools_js__WEBPACK_IMPORTED_MODULE_7__.TimingTools.SetImmediate(this._delayedOnLoad);
                }
                else {
                    this._texture.onLoadedObservable.add(this._delayedOnLoad);
                }
            }
        }
        this._delayedOnLoad = null;
        this._delayedOnError = null;
    }
    _prepareRowForTextureGeneration(x, y, z, t) {
        x *= this._cachedUScale;
        y *= this._cachedVScale;
        x -= this.uRotationCenter * this._cachedUScale;
        y -= this.vRotationCenter * this._cachedVScale;
        z -= this.wRotationCenter;
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);
        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;
        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;
        t.z += this.wRotationCenter;
    }
    /**
     * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.
     * @param uBase The horizontal base offset multiplier (1 by default)
     * @returns the transform matrix of the texture.
     */
    getTextureMatrix(uBase = 1) {
        if (this.uOffset === this._cachedUOffset &&
            this.vOffset === this._cachedVOffset &&
            this.uScale * uBase === this._cachedUScale &&
            this.vScale === this._cachedVScale &&
            this.uAng === this._cachedUAng &&
            this.vAng === this._cachedVAng &&
            this.wAng === this._cachedWAng &&
            this.uRotationCenter === this._cachedURotationCenter &&
            this.vRotationCenter === this._cachedVRotationCenter &&
            this.wRotationCenter === this._cachedWRotationCenter &&
            this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {
            return this._cachedTextureMatrix;
        }
        this._cachedUOffset = this.uOffset;
        this._cachedVOffset = this.vOffset;
        this._cachedUScale = this.uScale * uBase;
        this._cachedVScale = this.vScale;
        this._cachedUAng = this.uAng;
        this._cachedVAng = this.vAng;
        this._cachedWAng = this.wAng;
        this._cachedURotationCenter = this.uRotationCenter;
        this._cachedVRotationCenter = this.vRotationCenter;
        this._cachedWRotationCenter = this.wRotationCenter;
        this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;
        if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {
            this._cachedTextureMatrix = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.Zero();
            this._rowGenerationMatrix = new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix();
            this._t0 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Vector3.Zero();
            this._t1 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Vector3.Zero();
            this._t2 = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Vector3.Zero();
        }
        _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);
        if (this.homogeneousRotationInUVTransform) {
            _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.TmpVectors.Matrix[0]);
            _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.TmpVectors.Matrix[1]);
            _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.TmpVectors.Matrix[2]);
            _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.TmpVectors.Matrix[3]);
            _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);
            this._cachedTextureMatrix.multiplyToRef(_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.TmpVectors.Matrix[1], this._cachedTextureMatrix);
            this._cachedTextureMatrix.multiplyToRef(_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.TmpVectors.Matrix[2], this._cachedTextureMatrix);
            this._cachedTextureMatrix.multiplyToRef(_Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.TmpVectors.Matrix[3], this._cachedTextureMatrix);
            // copy the translation row to the 3rd row of the matrix so that we don't need to update the shaders (which expects the translation to be on the 3rd row)
            this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);
        }
        else {
            this._prepareRowForTextureGeneration(0, 0, 0, this._t0);
            this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1);
            this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2);
            this._t1.subtractInPlace(this._t0);
            this._t2.subtractInPlace(this._t0);
            _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0.0, this._t2.x, this._t2.y, this._t2.z, 0.0, this._t0.x, this._t0.y, this._t0.z, 0.0, 0.0, 0.0, 0.0, 1.0, this._cachedTextureMatrix);
        }
        const scene = this.getScene();
        if (!scene) {
            return this._cachedTextureMatrix;
        }
        const previousIdentity3x2 = this._cachedIdentity3x2;
        this._cachedIdentity3x2 = this._cachedTextureMatrix.isIdentityAs3x2();
        if (this.optimizeUVAllocation && previousIdentity3x2 !== this._cachedIdentity3x2) {
            // We flag the materials that are using this texture as "texture dirty" because depending on the fact that the matrix is the identity or not, some defines
            // will get different values (see PrepareDefinesForMergedUV), meaning we should regenerate the effect accordingly
            scene.markAllMaterialsAsDirty(1, (mat) => {
                return mat.hasTexture(this);
            });
        }
        return this._cachedTextureMatrix;
    }
    /**
     * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.
     * @returns The reflection texture transform
     */
    getReflectionTextureMatrix() {
        const scene = this.getScene();
        if (!scene) {
            return this._cachedReflectionTextureMatrix;
        }
        if (this.uOffset === this._cachedReflectionUOffset &&
            this.vOffset === this._cachedReflectionVOffset &&
            this.uScale === this._cachedReflectionUScale &&
            this.vScale === this._cachedReflectionVScale &&
            this.coordinatesMode === this._cachedReflectionCoordinatesMode) {
            if (this.coordinatesMode === Texture.PROJECTION_MODE) {
                if (this._cachedReflectionProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {
                    return this._cachedReflectionTextureMatrix;
                }
            }
            else {
                return this._cachedReflectionTextureMatrix;
            }
        }
        if (!this._cachedReflectionTextureMatrix) {
            this._cachedReflectionTextureMatrix = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.Zero();
        }
        if (!this._projectionModeMatrix) {
            this._projectionModeMatrix = _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.Zero();
        }
        const flagMaterialsAsTextureDirty = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;
        this._cachedReflectionUOffset = this.uOffset;
        this._cachedReflectionVOffset = this.vOffset;
        this._cachedReflectionUScale = this.uScale;
        this._cachedReflectionVScale = this.vScale;
        this._cachedReflectionCoordinatesMode = this.coordinatesMode;
        switch (this.coordinatesMode) {
            case Texture.PLANAR_MODE: {
                _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);
                this._cachedReflectionTextureMatrix[0] = this.uScale;
                this._cachedReflectionTextureMatrix[5] = this.vScale;
                this._cachedReflectionTextureMatrix[12] = this.uOffset;
                this._cachedReflectionTextureMatrix[13] = this.vOffset;
                break;
            }
            case Texture.PROJECTION_MODE: {
                _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.FromValuesToRef(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, this._projectionModeMatrix);
                const projectionMatrix = scene.getProjectionMatrix();
                this._cachedReflectionProjectionMatrixId = projectionMatrix.updateFlag;
                projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);
                break;
            }
            default:
                _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_3__.Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);
                break;
        }
        if (flagMaterialsAsTextureDirty) {
            // We flag the materials that are using this texture as "texture dirty" if the coordinatesMode has changed.
            // Indeed, this property is used to set the value of some defines used to generate the effect (in material.isReadyForSubMesh), so we must make sure this code will be re-executed and the effect recreated if necessary
            scene.markAllMaterialsAsDirty(1, (mat) => {
                return mat.hasTexture(this);
            });
        }
        return this._cachedReflectionTextureMatrix;
    }
    /**
     * Clones the texture.
     * @returns the cloned texture
     */
    clone() {
        const options = {
            noMipmap: this._noMipmap,
            invertY: this._invertY,
            samplingMode: this.samplingMode,
            onLoad: undefined,
            onError: undefined,
            buffer: this._texture ? this._texture._buffer : undefined,
            deleteBuffer: this._deleteBuffer,
            format: this.textureFormat,
            mimeType: this.mimeType,
            loaderOptions: this._loaderOptions,
            creationFlags: this._creationFlags,
            useSRGBBuffer: this._useSRGBBuffer,
        };
        return _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_13__.SerializationHelper.Clone(() => {
            return new Texture(this._texture ? this._texture.url : null, this.getScene(), options);
        }, this);
    }
    /**
     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.
     * @returns The JSON representation of the texture
     */
    serialize() {
        const savedName = this.name;
        if (!Texture.SerializeBuffers) {
            if (this.name.startsWith("data:")) {
                this.name = "";
            }
        }
        if (this.name.startsWith("data:") && this.url === this.name) {
            this.url = "";
        }
        const serializationObject = super.serialize(Texture._SerializeInternalTextureUniqueId);
        if (!serializationObject) {
            return null;
        }
        if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {
            if (typeof this._buffer === "string" && this._buffer.startsWith("data:")) {
                serializationObject.base64String = this._buffer;
                serializationObject.name = serializationObject.name.replace("data:", "");
            }
            else if (this.url && this.url.startsWith("data:") && this._buffer instanceof Uint8Array) {
                const mimeType = this.mimeType || "image/png";
                serializationObject.base64String = `data:${mimeType};base64,${(0,_Misc_stringTools_js__WEBPACK_IMPORTED_MODULE_10__.EncodeArrayBufferToBase64)(this._buffer)}`;
            }
            else if (Texture.ForceSerializeBuffers || (this.url && this.url.startsWith("blob:")) || this._forceSerialize) {
                serializationObject.base64String =
                    !this._engine || this._engine._features.supportSyncTextureRead ? (0,_Misc_copyTools_js__WEBPACK_IMPORTED_MODULE_11__.GenerateBase64StringFromTexture)(this) : (0,_Misc_copyTools_js__WEBPACK_IMPORTED_MODULE_11__.GenerateBase64StringFromTextureAsync)(this);
            }
        }
        serializationObject.invertY = this._invertY;
        serializationObject.samplingMode = this.samplingMode;
        serializationObject._creationFlags = this._creationFlags;
        serializationObject._useSRGBBuffer = this._useSRGBBuffer;
        if (Texture._SerializeInternalTextureUniqueId) {
            serializationObject.internalTextureUniqueId = this._texture?.uniqueId;
        }
        serializationObject.internalTextureLabel = this._texture?.label;
        serializationObject.noMipmap = this._noMipmap;
        this.name = savedName;
        return serializationObject;
    }
    /**
     * Get the current class name of the texture useful for serialization or dynamic coding.
     * @returns "Texture"
     */
    getClassName() {
        return "Texture";
    }
    /**
     * Dispose the texture and release its associated resources.
     */
    dispose() {
        super.dispose();
        this.onLoadObservable.clear();
        this._delayedOnLoad = null;
        this._delayedOnError = null;
        this._buffer = null;
    }
    /**
     * Parse the JSON representation of a texture in order to recreate the texture in the given scene.
     * @param parsedTexture Define the JSON representation of the texture
     * @param scene Define the scene the parsed texture should be instantiated in
     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies
     * @returns The parsed texture if successful
     */
    static Parse(parsedTexture, scene, rootUrl) {
        if (parsedTexture.customType) {
            const customTexture = _Misc_instantiationTools_js__WEBPACK_IMPORTED_MODULE_8__.InstantiationTools.Instantiate(parsedTexture.customType);
            // Update Sampling Mode
            const parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);
            if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {
                if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {
                    parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);
                }
            }
            return parsedCustomTexture;
        }
        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {
            return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);
        }
        const hasInternalTextureUniqueId = parsedTexture.internalTextureUniqueId !== undefined;
        if (!parsedTexture.name && !parsedTexture.isRenderTarget && !hasInternalTextureUniqueId) {
            return null;
        }
        let internalTexture;
        if (hasInternalTextureUniqueId) {
            const cache = scene.getEngine().getLoadedTexturesCache();
            for (const texture of cache) {
                if (texture.uniqueId === parsedTexture.internalTextureUniqueId) {
                    internalTexture = texture;
                    break;
                }
            }
        }
        const onLoaded = (texture) => {
            // Clear cache
            if (texture && texture._texture) {
                texture._texture._cachedWrapU = null;
                texture._texture._cachedWrapV = null;
                texture._texture._cachedWrapR = null;
            }
            // Update Sampling Mode
            if (parsedTexture.samplingMode) {
                const sampling = parsedTexture.samplingMode;
                if (texture && texture.samplingMode !== sampling) {
                    texture.updateSamplingMode(sampling);
                }
            }
            // Animations
            if (texture && parsedTexture.animations) {
                for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
                    const parsedAnimation = parsedTexture.animations[animationIndex];
                    const internalClass = (0,_Misc_typeStore_js__WEBPACK_IMPORTED_MODULE_5__.GetClass)("BABYLON.Animation");
                    if (internalClass) {
                        texture.animations.push(internalClass.Parse(parsedAnimation));
                    }
                }
            }
            if (texture && texture._texture) {
                if (hasInternalTextureUniqueId && !internalTexture) {
                    texture._texture._setUniqueId(parsedTexture.internalTextureUniqueId);
                }
                texture._texture.label = parsedTexture.internalTextureLabel;
            }
        };
        const texture = _Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_13__.SerializationHelper.Parse(() => {
            let generateMipMaps = true;
            if (parsedTexture.noMipmap) {
                generateMipMaps = false;
            }
            if (parsedTexture.mirrorPlane) {
                const mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);
                mirrorTexture._waitingRenderList = parsedTexture.renderList;
                mirrorTexture.mirrorPlane = _Maths_math_plane_js__WEBPACK_IMPORTED_MODULE_9__.Plane.FromArray(parsedTexture.mirrorPlane);
                onLoaded(mirrorTexture);
                return mirrorTexture;
            }
            else if (parsedTexture.isRenderTarget) {
                let renderTargetTexture = null;
                if (parsedTexture.isCube) {
                    // Search for an existing reflection probe (which contains a cube render target texture)
                    if (scene.reflectionProbes) {
                        for (let index = 0; index < scene.reflectionProbes.length; index++) {
                            const probe = scene.reflectionProbes[index];
                            if (probe.name === parsedTexture.name) {
                                return probe.cubeTexture;
                            }
                        }
                    }
                }
                else {
                    renderTargetTexture = Texture._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps, parsedTexture._creationFlags ?? 0);
                    renderTargetTexture._waitingRenderList = parsedTexture.renderList;
                }
                onLoaded(renderTargetTexture);
                return renderTargetTexture;
            }
            else if (parsedTexture.isVideo) {
                const texture = Texture._CreateVideoTexture(rootUrl + (parsedTexture.url || parsedTexture.name), rootUrl + (parsedTexture.src || parsedTexture.url), scene, generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, parsedTexture.settings || {});
                onLoaded(texture);
                return texture;
            }
            else {
                let texture;
                if (parsedTexture.base64String && !internalTexture) {
                    // name and url are the same to ensure caching happens from the actual base64 string
                    texture = Texture.CreateFromBase64String(parsedTexture.base64String, parsedTexture.base64String, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, () => {
                        onLoaded(texture);
                    }, parsedTexture._creationFlags ?? 0, parsedTexture._useSRGBBuffer ?? false);
                    // prettier name to fit with the loaded data
                    texture.name = parsedTexture.name;
                }
                else {
                    let url;
                    if (parsedTexture.name && (parsedTexture.name.indexOf("://") > 0 || parsedTexture.name.startsWith("data:"))) {
                        url = parsedTexture.name;
                    }
                    else {
                        url = rootUrl + parsedTexture.name;
                    }
                    if (parsedTexture.url && (parsedTexture.url.startsWith("data:") || Texture.UseSerializedUrlIfAny)) {
                        url = parsedTexture.url;
                    }
                    const options = {
                        noMipmap: !generateMipMaps,
                        invertY: parsedTexture.invertY,
                        samplingMode: parsedTexture.samplingMode,
                        onLoad: () => {
                            onLoaded(texture);
                        },
                        internalTexture,
                    };
                    texture = new Texture(url, scene, options);
                }
                return texture;
            }
        }, parsedTexture, scene);
        return texture;
    }
    /**
     * Creates a texture from its base 64 representation.
     * @param data Define the base64 payload without the data: prefix
     * @param name Define the name of the texture in the scene useful fo caching purpose for instance
     * @param scene Define the scene the texture should belong to
     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture
     * @param invertY define if the texture needs to be inverted on the y axis during loading
     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)
     * @param onLoad define a callback triggered when the texture has been loaded
     * @param onError define a callback triggered when an error occurred during the loading session
     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
     * @param forcedExtension defines the extension to use to pick the right loader
     * @returns the created texture
     */
    static CreateFromBase64String(data, name, scene, noMipmapOrOptions, invertY, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, format = 5, creationFlags, forcedExtension) {
        return new Texture("data:" + name, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, data, false, format, undefined, undefined, creationFlags, forcedExtension);
    }
    /**
     * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)
     * @param name Define the name of the texture in the scene useful fo caching purpose for instance
     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation
     * @param scene Define the scene the texture should belong to
     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load
     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture
     * @param invertY define if the texture needs to be inverted on the y axis during loading
     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)
     * @param onLoad define a callback triggered when the texture has been loaded
     * @param onError define a callback triggered when an error occurred during the loading session
     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
     * @param forcedExtension defines the extension to use to pick the right loader
     * @returns the created texture
     */
    static LoadFromDataString(name, buffer, scene, deleteBuffer = false, noMipmapOrOptions, invertY = true, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, format = 5, creationFlags, forcedExtension) {
        if (name.substring(0, 5) !== "data:") {
            name = "data:" + name;
        }
        return new Texture(name, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, undefined, undefined, creationFlags, forcedExtension);
    }
}
/**
 * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process
 */
Texture.SerializeBuffers = true;
/**
 * Gets or sets a general boolean used to indicate that texture buffers must be saved as part of the serialization process.
 * If no buffer exists, one will be created as base64 string from the internal webgl data.
 */
Texture.ForceSerializeBuffers = false;
/**
 * This observable will notify when any texture had a loading error
 */
Texture.OnTextureLoadErrorObservable = new _Misc_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable();
/** @internal */
Texture._SerializeInternalTextureUniqueId = false;
/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
Texture._CubeTextureParser = (jsonTexture, scene, rootUrl) => {
    throw (0,_Misc_devTools_js__WEBPACK_IMPORTED_MODULE_6__._WarnImport)("CubeTexture");
};
/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
Texture._CreateMirror = (name, renderTargetSize, scene, generateMipMaps) => {
    throw (0,_Misc_devTools_js__WEBPACK_IMPORTED_MODULE_6__._WarnImport)("MirrorTexture");
};
/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
Texture._CreateRenderTargetTexture = (name, renderTargetSize, scene, generateMipMaps, creationFlags) => {
    throw (0,_Misc_devTools_js__WEBPACK_IMPORTED_MODULE_6__._WarnImport)("RenderTargetTexture");
};
/** nearest is mag = nearest and min = nearest and no mip */
Texture.NEAREST_SAMPLINGMODE = 1;
/** nearest is mag = nearest and min = nearest and mip = linear */
Texture.NEAREST_NEAREST_MIPLINEAR = 8; // nearest is mag = nearest and min = nearest and mip = linear
/** Bilinear is mag = linear and min = linear and no mip */
Texture.BILINEAR_SAMPLINGMODE = 2;
/** Bilinear is mag = linear and min = linear and mip = nearest */
Texture.LINEAR_LINEAR_MIPNEAREST = 11; // Bilinear is mag = linear and min = linear and mip = nearest
/** Trilinear is mag = linear and min = linear and mip = linear */
Texture.TRILINEAR_SAMPLINGMODE = 3;
/** Trilinear is mag = linear and min = linear and mip = linear */
Texture.LINEAR_LINEAR_MIPLINEAR = 3; // Trilinear is mag = linear and min = linear and mip = linear
/** mag = nearest and min = nearest and mip = nearest */
Texture.NEAREST_NEAREST_MIPNEAREST = 4;
/** mag = nearest and min = linear and mip = nearest */
Texture.NEAREST_LINEAR_MIPNEAREST = 5;
/** mag = nearest and min = linear and mip = linear */
Texture.NEAREST_LINEAR_MIPLINEAR = 6;
/** mag = nearest and min = linear and mip = none */
Texture.NEAREST_LINEAR = 7;
/** mag = nearest and min = nearest and mip = none */
Texture.NEAREST_NEAREST = 1;
/** mag = linear and min = nearest and mip = nearest */
Texture.LINEAR_NEAREST_MIPNEAREST = 9;
/** mag = linear and min = nearest and mip = linear */
Texture.LINEAR_NEAREST_MIPLINEAR = 10;
/** mag = linear and min = linear and mip = none */
Texture.LINEAR_LINEAR = 2;
/** mag = linear and min = nearest and mip = none */
Texture.LINEAR_NEAREST = 12;
/** Explicit coordinates mode */
Texture.EXPLICIT_MODE = 0;
/** Spherical coordinates mode */
Texture.SPHERICAL_MODE = 1;
/** Planar coordinates mode */
Texture.PLANAR_MODE = 2;
/** Cubic coordinates mode */
Texture.CUBIC_MODE = 3;
/** Projection coordinates mode */
Texture.PROJECTION_MODE = 4;
/** Inverse Cubic coordinates mode */
Texture.SKYBOX_MODE = 5;
/** Inverse Cubic coordinates mode */
Texture.INVCUBIC_MODE = 6;
/** Equirectangular coordinates mode */
Texture.EQUIRECTANGULAR_MODE = 7;
/** Equirectangular Fixed coordinates mode */
Texture.FIXED_EQUIRECTANGULAR_MODE = 8;
/** Equirectangular Fixed Mirrored coordinates mode */
Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
/** Texture is not repeating outside of 0..1 UVs */
Texture.CLAMP_ADDRESSMODE = 0;
/** Texture is repeating outside of 0..1 UVs */
Texture.WRAP_ADDRESSMODE = 1;
/** Texture is repeating and mirrored */
Texture.MIRROR_ADDRESSMODE = 2;
/**
 * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file
 */
Texture.UseSerializedUrlIfAny = false;
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "url", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "uOffset", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "vOffset", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "uScale", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "vScale", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "uAng", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "vAng", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "wAng", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "uRotationCenter", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "vRotationCenter", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "wRotationCenter", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "homogeneousRotationInUVTransform", void 0);
(0,_tslib_es6_js__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_Misc_decorators_js__WEBPACK_IMPORTED_MODULE_1__.serialize)()
], Texture.prototype, "isBlocking", null);
// References the dependencies.
(0,_Misc_typeStore_js__WEBPACK_IMPORTED_MODULE_5__.RegisterClass)("BABYLON.Texture", Texture);
_Misc_decorators_serialization_js__WEBPACK_IMPORTED_MODULE_13__.SerializationHelper._TextureParser = Texture.Parse;
//# sourceMappingURL=texture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/thinTexture.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/thinTexture.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ThinTexture: () => (/* binding */ ThinTexture)
/* harmony export */ });
/* harmony import */ var _Maths_math_size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math.size.js */ "./node_modules/@babylonjs/core/Maths/math.size.js");


/**
 * Base class of all the textures in babylon.
 * It groups all the common properties required to work with Thin Engine.
 */
class ThinTexture {
    /**
     * | Value | Type               | Description |
     * | ----- | ------------------ | ----------- |
     * | 0     | CLAMP_ADDRESSMODE  |             |
     * | 1     | WRAP_ADDRESSMODE   |             |
     * | 2     | MIRROR_ADDRESSMODE |             |
     */
    get wrapU() {
        return this._wrapU;
    }
    set wrapU(value) {
        this._wrapU = value;
    }
    /**
     * | Value | Type               | Description |
     * | ----- | ------------------ | ----------- |
     * | 0     | CLAMP_ADDRESSMODE  |             |
     * | 1     | WRAP_ADDRESSMODE   |             |
     * | 2     | MIRROR_ADDRESSMODE |             |
     */
    get wrapV() {
        return this._wrapV;
    }
    set wrapV(value) {
        this._wrapV = value;
    }
    /**
     * How a texture is mapped.
     * Unused in thin texture mode.
     */
    get coordinatesMode() {
        return 0;
    }
    /**
     * Define if the texture is a cube texture or if false a 2d texture.
     */
    get isCube() {
        if (!this._texture) {
            return false;
        }
        return this._texture.isCube;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    set isCube(value) {
        if (!this._texture) {
            return;
        }
        this._texture.isCube = value;
    }
    /**
     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.
     */
    get is3D() {
        if (!this._texture) {
            return false;
        }
        return this._texture.is3D;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    set is3D(value) {
        if (!this._texture) {
            return;
        }
        this._texture.is3D = value;
    }
    /**
     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.
     */
    get is2DArray() {
        if (!this._texture) {
            return false;
        }
        return this._texture.is2DArray;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    set is2DArray(value) {
        if (!this._texture) {
            return;
        }
        this._texture.is2DArray = value;
    }
    /**
     * Get the class name of the texture.
     * @returns "ThinTexture"
     */
    getClassName() {
        return "ThinTexture";
    }
    static _IsRenderTargetWrapper(texture) {
        return texture?.shareDepth !== undefined;
    }
    /**
     * Instantiates a new ThinTexture.
     * Base class of all the textures in babylon.
     * This can be used as an internal texture wrapper in AbstractEngine to benefit from the cache
     * @param internalTexture Define the internalTexture to wrap. You can also pass a RenderTargetWrapper, in which case the texture will be the render target's texture
     */
    constructor(internalTexture) {
        this._wrapU = 1;
        this._wrapV = 1;
        /**
         * | Value | Type               | Description |
         * | ----- | ------------------ | ----------- |
         * | 0     | CLAMP_ADDRESSMODE  |             |
         * | 1     | WRAP_ADDRESSMODE   |             |
         * | 2     | MIRROR_ADDRESSMODE |             |
         */
        this.wrapR = 1;
        /**
         * With compliant hardware and browser (supporting anisotropic filtering)
         * this defines the level of anisotropic filtering in the texture.
         * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.
         */
        this.anisotropicFilteringLevel = 4;
        /**
         * Define the current state of the loading sequence when in delayed load mode.
         */
        this.delayLoadState = 0;
        /** @internal */
        this._texture = null;
        this._engine = null;
        this._cachedSize = _Maths_math_size_js__WEBPACK_IMPORTED_MODULE_0__.Size.Zero();
        this._cachedBaseSize = _Maths_math_size_js__WEBPACK_IMPORTED_MODULE_0__.Size.Zero();
        /** @internal */
        this._initialSamplingMode = 2;
        this._texture = ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;
        if (this._texture) {
            this._engine = this._texture.getEngine();
        }
    }
    /**
     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).
     * @returns true if fully ready
     */
    isReady() {
        if (this.delayLoadState === 4) {
            this.delayLoad();
            return false;
        }
        if (this._texture) {
            return this._texture.isReady;
        }
        return false;
    }
    /**
     * Triggers the load sequence in delayed load mode.
     */
    delayLoad() { }
    /**
     * Get the underlying lower level texture from Babylon.
     * @returns the internal texture
     */
    getInternalTexture() {
        return this._texture;
    }
    /**
     * Get the size of the texture.
     * @returns the texture size.
     */
    getSize() {
        if (this._texture) {
            if (this._texture.width) {
                this._cachedSize.width = this._texture.width;
                this._cachedSize.height = this._texture.height;
                return this._cachedSize;
            }
            if (this._texture._size) {
                this._cachedSize.width = this._texture._size;
                this._cachedSize.height = this._texture._size;
                return this._cachedSize;
            }
        }
        return this._cachedSize;
    }
    /**
     * Get the base size of the texture.
     * It can be different from the size if the texture has been resized for POT for instance
     * @returns the base size
     */
    getBaseSize() {
        if (!this.isReady() || !this._texture) {
            this._cachedBaseSize.width = 0;
            this._cachedBaseSize.height = 0;
            return this._cachedBaseSize;
        }
        if (this._texture._size) {
            this._cachedBaseSize.width = this._texture._size;
            this._cachedBaseSize.height = this._texture._size;
            return this._cachedBaseSize;
        }
        this._cachedBaseSize.width = this._texture.baseWidth;
        this._cachedBaseSize.height = this._texture.baseHeight;
        return this._cachedBaseSize;
    }
    /**
     * Get the current sampling mode associated with the texture.
     */
    get samplingMode() {
        if (!this._texture) {
            return this._initialSamplingMode;
        }
        return this._texture.samplingMode;
    }
    /**
     * Update the sampling mode of the texture.
     * Default is Trilinear mode.
     *
     * | Value | Type               | Description |
     * | ----- | ------------------ | ----------- |
     * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |
     * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |
     * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |
     * | 4     | NEAREST_NEAREST_MIPNEAREST |             |
     * | 5    | NEAREST_LINEAR_MIPNEAREST |             |
     * | 6    | NEAREST_LINEAR_MIPLINEAR |             |
     * | 7    | NEAREST_LINEAR |             |
     * | 8    | NEAREST_NEAREST |             |
     * | 9   | LINEAR_NEAREST_MIPNEAREST |             |
     * | 10   | LINEAR_NEAREST_MIPLINEAR |             |
     * | 11   | LINEAR_LINEAR |             |
     * | 12   | LINEAR_NEAREST |             |
     *
     *    > _mag_: magnification filter (close to the viewer)
     *    > _min_: minification filter (far from the viewer)
     *    > _mip_: filter used between mip map levels
     *@param samplingMode Define the new sampling mode of the texture
     */
    updateSamplingMode(samplingMode) {
        if (this._texture && this._engine) {
            this._engine.updateTextureSamplingMode(samplingMode, this._texture, this._texture.generateMipMaps);
        }
    }
    /**
     * Release and destroy the underlying lower level texture aka internalTexture.
     */
    releaseInternalTexture() {
        if (this._texture) {
            this._texture.dispose();
            this._texture = null;
        }
    }
    /**
     * Dispose the texture and release its associated resources.
     */
    dispose() {
        if (this._texture) {
            this.releaseInternalTexture();
            this._engine = null;
        }
    }
}
//# sourceMappingURL=thinTexture.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Maths/math.size.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Maths/math.size.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Size: () => (/* binding */ Size)
/* harmony export */ });
/**
 * Size containing width and height
 */
class Size {
    /**
     * Creates a Size object from the given width and height (floats).
     * @param width width of the new size
     * @param height height of the new size
     */
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
    /**
     * Returns a string with the Size width and height
     * @returns a string with the Size width and height
     */
    toString() {
        return `{W: ${this.width}, H: ${this.height}}`;
    }
    /**
     * "Size"
     * @returns the string "Size"
     */
    getClassName() {
        return "Size";
    }
    /**
     * Returns the Size hash code.
     * @returns a hash code for a unique width and height
     */
    getHashCode() {
        let hash = this.width | 0;
        hash = (hash * 397) ^ (this.height | 0);
        return hash;
    }
    /**
     * Updates the current size from the given one.
     * @param src the given size
     */
    copyFrom(src) {
        this.width = src.width;
        this.height = src.height;
    }
    /**
     * Updates in place the current Size from the given floats.
     * @param width width of the new size
     * @param height height of the new size
     * @returns the updated Size.
     */
    copyFromFloats(width, height) {
        this.width = width;
        this.height = height;
        return this;
    }
    /**
     * Updates in place the current Size from the given floats.
     * @param width width to set
     * @param height height to set
     * @returns the updated Size.
     */
    set(width, height) {
        return this.copyFromFloats(width, height);
    }
    /**
     * Multiplies the width and height by numbers
     * @param w factor to multiple the width by
     * @param h factor to multiple the height by
     * @returns a new Size set with the multiplication result of the current Size and the given floats.
     */
    multiplyByFloats(w, h) {
        return new Size(this.width * w, this.height * h);
    }
    /**
     * Clones the size
     * @returns a new Size copied from the given one.
     */
    clone() {
        return new Size(this.width, this.height);
    }
    /**
     * True if the current Size and the given one width and height are strictly equal.
     * @param other the other size to compare against
     * @returns True if the current Size and the given one width and height are strictly equal.
     */
    equals(other) {
        if (!other) {
            return false;
        }
        return this.width === other.width && this.height === other.height;
    }
    /**
     * The surface of the Size : width * height (float).
     */
    get surface() {
        return this.width * this.height;
    }
    /**
     * Create a new size of zero
     * @returns a new Size set to (0.0, 0.0)
     */
    static Zero() {
        return new Size(0.0, 0.0);
    }
    /**
     * Sums the width and height of two sizes
     * @param otherSize size to add to this size
     * @returns a new Size set as the addition result of the current Size and the given one.
     */
    add(otherSize) {
        const r = new Size(this.width + otherSize.width, this.height + otherSize.height);
        return r;
    }
    /**
     * Subtracts the width and height of two
     * @param otherSize size to subtract to this size
     * @returns a new Size set as the subtraction result of  the given one from the current Size.
     */
    subtract(otherSize) {
        const r = new Size(this.width - otherSize.width, this.height - otherSize.height);
        return r;
    }
    /**
     * Scales the width and height
     * @param scale the scale to multiply the width and height by
     * @returns a new Size set with the multiplication result of the current Size and the given floats.
     */
    scale(scale) {
        return new Size(this.width * scale, this.height * scale);
    }
    /**
     * Creates a new Size set at the linear interpolation "amount" between "start" and "end"
     * @param start starting size to lerp between
     * @param end end size to lerp between
     * @param amount amount to lerp between the start and end values
     * @returns a new Size set at the linear interpolation "amount" between "start" and "end"
     */
    static Lerp(start, end, amount) {
        const w = start.width + (end.width - start.width) * amount;
        const h = start.height + (end.height - start.height) * amount;
        return new Size(w, h);
    }
}
//# sourceMappingURL=math.size.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/copyTools.js":
/*!********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/copyTools.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CopyTools: () => (/* binding */ CopyTools),
/* harmony export */   GenerateBase64StringFromPixelData: () => (/* binding */ GenerateBase64StringFromPixelData),
/* harmony export */   GenerateBase64StringFromTexture: () => (/* binding */ GenerateBase64StringFromTexture),
/* harmony export */   GenerateBase64StringFromTextureAsync: () => (/* binding */ GenerateBase64StringFromTextureAsync)
/* harmony export */ });
/**
 * Transform some pixel data to a base64 string
 * @param pixels defines the pixel data to transform to base64
 * @param size defines the width and height of the (texture) data
 * @param invertY true if the data must be inverted for the Y coordinate during the conversion
 * @returns The base64 encoded string or null
 */
function GenerateBase64StringFromPixelData(pixels, size, invertY = false) {
    const width = size.width;
    const height = size.height;
    if (pixels instanceof Float32Array) {
        let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;
        const npixels = new Uint8Array(len);
        while (--len >= 0) {
            let val = pixels[len];
            if (val < 0) {
                val = 0;
            }
            else if (val > 1) {
                val = 1;
            }
            npixels[len] = val * 255;
        }
        pixels = npixels;
    }
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
        return null;
    }
    const imageData = ctx.createImageData(width, height);
    const castData = imageData.data;
    castData.set(pixels);
    ctx.putImageData(imageData, 0, 0);
    if (invertY) {
        const canvas2 = document.createElement("canvas");
        canvas2.width = width;
        canvas2.height = height;
        const ctx2 = canvas2.getContext("2d");
        if (!ctx2) {
            return null;
        }
        ctx2.translate(0, height);
        ctx2.scale(1, -1);
        ctx2.drawImage(canvas, 0, 0);
        return canvas2.toDataURL("image/png");
    }
    return canvas.toDataURL("image/png");
}
/**
 * Reads the pixels stored in the webgl texture and returns them as a base64 string
 * @param texture defines the texture to read pixels from
 * @param faceIndex defines the face of the texture to read (in case of cube texture)
 * @param level defines the LOD level of the texture to read (in case of Mip Maps)
 * @returns The base64 encoded string or null
 */
function GenerateBase64StringFromTexture(texture, faceIndex = 0, level = 0) {
    const internalTexture = texture.getInternalTexture();
    if (!internalTexture) {
        return null;
    }
    const pixels = texture._readPixelsSync(faceIndex, level);
    if (!pixels) {
        return null;
    }
    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
/**
 * Reads the pixels stored in the webgl texture and returns them as a base64 string
 * @param texture defines the texture to read pixels from
 * @param faceIndex defines the face of the texture to read (in case of cube texture)
 * @param level defines the LOD level of the texture to read (in case of Mip Maps)
 * @returns The base64 encoded string or null wrapped in a promise
 */
async function GenerateBase64StringFromTextureAsync(texture, faceIndex = 0, level = 0) {
    const internalTexture = texture.getInternalTexture();
    if (!internalTexture) {
        return null;
    }
    const pixels = await texture.readPixels(faceIndex, level);
    if (!pixels) {
        return null;
    }
    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
/**
 * Class used to host copy specific utilities
 * (Back-compat)
 */
const CopyTools = {
    /**
     * Transform some pixel data to a base64 string
     * @param pixels defines the pixel data to transform to base64
     * @param size defines the width and height of the (texture) data
     * @param invertY true if the data must be inverted for the Y coordinate during the conversion
     * @returns The base64 encoded string or null
     */
    GenerateBase64StringFromPixelData,
    /**
     * Reads the pixels stored in the webgl texture and returns them as a base64 string
     * @param texture defines the texture to read pixels from
     * @param faceIndex defines the face of the texture to read (in case of cube texture)
     * @param level defines the LOD level of the texture to read (in case of Mip Maps)
     * @returns The base64 encoded string or null
     */
    GenerateBase64StringFromTexture,
    /**
     * Reads the pixels stored in the webgl texture and returns them as a base64 string
     * @param texture defines the texture to read pixels from
     * @param faceIndex defines the face of the texture to read (in case of cube texture)
     * @param level defines the LOD level of the texture to read (in case of Mip Maps)
     * @returns The base64 encoded string or null wrapped in a promise
     */
    GenerateBase64StringFromTextureAsync,
};
//# sourceMappingURL=copyTools.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfTWF0ZXJpYWxzX1RleHR1cmVzX3RleHR1cmVfanMuYnJvd3Nlci1wYWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQmdEO0FBQ3lCO0FBQ25CO0FBQ0Y7QUFDTzs7QUFFWDtBQUNmO0FBQ2M7QUFDOEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQix3REFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJEQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0ZBQW1CO0FBQ3ZEO0FBQ0EsUUFBUSxrRkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksdUVBQWtCO0FBQ3RCO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2x6QmdEO0FBQ0s7QUFDQztBQUNtQjtBQUNIOztBQUVKO0FBQ2I7QUFDRztBQUNjO0FBQ3BCO0FBQ29CO0FBQzBDO0FBQy9CO0FBQ0o7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQkFBc0IsMkVBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKO0FBQ3ZKLGNBQWMsOERBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyREFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUZBQXlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVGQUF5QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZEQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2REFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5REFBTTtBQUM5Qyw0Q0FBNEMseURBQU07QUFDbEQsdUJBQXVCLDBEQUFPO0FBQzlCLHVCQUF1QiwwREFBTztBQUM5Qix1QkFBdUIsMERBQU87QUFDOUI7QUFDQSxRQUFRLHlEQUFNO0FBQ2Q7QUFDQSxZQUFZLHlEQUFNLDRHQUE0Ryw2REFBVTtBQUN4SSxZQUFZLHlEQUFNLHlHQUF5Ryw2REFBVTtBQUNySSxZQUFZLHlEQUFNLHlEQUF5RCw2REFBVTtBQUNyRixZQUFZLHlEQUFNLCtEQUErRCw2REFBVTtBQUMzRixZQUFZLDZEQUFVO0FBQ3RCLG9EQUFvRCw2REFBVTtBQUM5RCxvREFBb0QsNkRBQVU7QUFDOUQsb0RBQW9ELDZEQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx5REFBTTtBQUN4RDtBQUNBO0FBQ0EseUNBQXlDLHlEQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1GQUFtQjtBQUNsQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVUsU0FBUyxnRkFBeUIsZUFBZTtBQUN0SDtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsb0ZBQStCLFNBQVMseUZBQW9DO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJFQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0RBQWtEO0FBQy9GO0FBQ0EsMENBQTBDLDREQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdURBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1Q0FBdUM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNFFBQTRRO0FBQzVRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyREFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOERBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4REFBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhEQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQSx5REFBVTtBQUNWLElBQUksOERBQVM7QUFDYjtBQUNBLHlEQUFVO0FBQ1YsSUFBSSw4REFBUztBQUNiO0FBQ0EseURBQVU7QUFDVixJQUFJLDhEQUFTO0FBQ2I7QUFDQTtBQUNBLGlFQUFhO0FBQ2IsbUZBQW1CO0FBQ25COzs7Ozs7Ozs7Ozs7Ozs7O0FDOTRCZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFJO0FBQy9CLCtCQUErQixxREFBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbFFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFLLFdBQVcsT0FBTyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL0NvbXBhdC9jb21wYXRpYmlsaXR5T3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL2Jhc2VUZXh0dXJlLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvdGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL3RoaW5UZXh0dXJlLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NYXRocy9tYXRoLnNpemUuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01pc2MvY29weVRvb2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGVmaW5lcyBpZiB0aGUgc3lzdGVtIHNob3VsZCB1c2UgT3BlbkdMIGNvbnZlbnRpb24gZm9yIFVWcyB3aGVuIGNyZWF0aW5nIGdlb21ldHJ5IG9yIGxvYWRpbmcgLmJhYnlsb24gZmlsZXMgKGZhbHNlIGJ5IGRlZmF1bHQpXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBsZXQgdXNlT3BlbkdMT3JpZW50YXRpb25Gb3JVViA9IGZhbHNlO1xuLyoqXG4gKiBTZXRzIHdoZXRoZXIgdG8gdXNlIE9wZW5HTCBjb252ZW50aW9uIGZvciBVVnNcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgbmV3IHZhbHVlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBmdW5jdGlvbiBzZXRPcGVuR0xPcmllbnRhdGlvbkZvclVWKHZhbHVlKSB7XG4gICAgdXNlT3BlbkdMT3JpZW50YXRpb25Gb3JVViA9IHZhbHVlO1xufVxuLyoqXG4gKiBPcHRpb25zIHVzZWQgdG8gY29udHJvbCBkZWZhdWx0IGJlaGF2aW9ycyByZWdhcmRpbmcgY29tcGF0aWJpbGl0eSBzdXBwb3J0XG4gKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIG5hbWVkIGV4cG9ydHNcbiAqL1xuZXhwb3J0IGNvbnN0IENvbXBhdGliaWxpdHlPcHRpb25zID0ge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuICAgIGdldCBVc2VPcGVuR0xPcmllbnRhdGlvbkZvclVWKCkge1xuICAgICAgICByZXR1cm4gdXNlT3BlbkdMT3JpZW50YXRpb25Gb3JVVjtcbiAgICB9LFxuICAgIHNldCBVc2VPcGVuR0xPcmllbnRhdGlvbkZvclVWKHZhbHVlKSB7XG4gICAgICAgIHVzZU9wZW5HTE9yaWVudGF0aW9uRm9yVVYgPSB2YWx1ZTtcbiAgICB9LFxuICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGF0aWJpbGl0eU9wdGlvbnMuanMubWFwIiwiaW1wb3J0IHsgX19kZWNvcmF0ZSB9IGZyb20gXCIuLi8uLi90c2xpYi5lczYuanNcIjtcbmltcG9ydCB7IHNlcmlhbGl6ZSwgc2VyaWFsaXplQXNUZXh0dXJlIH0gZnJvbSBcIi4uLy4uL01pc2MvZGVjb3JhdG9ycy5qc1wiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCIuLi8uLi9NaXNjL29ic2VydmFibGUuanNcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi8uLi9NYXRocy9tYXRoLnZlY3Rvci5qc1wiO1xuaW1wb3J0IHsgRW5naW5lU3RvcmUgfSBmcm9tIFwiLi4vLi4vRW5naW5lcy9lbmdpbmVTdG9yZS5qc1wiO1xuXG5pbXBvcnQgeyBSYW5kb21HVUlEIH0gZnJvbSBcIi4uLy4uL01pc2MvZ3VpZC5qc1wiO1xuaW1wb3J0IFwiLi4vLi4vTWlzYy9maWxlVG9vbHMuanNcIjtcbmltcG9ydCB7IFRoaW5UZXh0dXJlIH0gZnJvbSBcIi4vdGhpblRleHR1cmUuanNcIjtcbmltcG9ydCB7IFNlcmlhbGl6YXRpb25IZWxwZXIgfSBmcm9tIFwiLi4vLi4vTWlzYy9kZWNvcmF0b3JzLnNlcmlhbGl6YXRpb24uanNcIjtcbi8qKlxuICogQmFzZSBjbGFzcyBvZiBhbGwgdGhlIHRleHR1cmVzIGluIGJhYnlsb24uXG4gKiBJdCBncm91cHMgYWxsIHRoZSBjb21tb24gcHJvcGVydGllcyB0aGUgbWF0ZXJpYWxzLCBwb3N0IHByb2Nlc3MsIGxpZ2h0cy4uLiBtaWdodCBuZWVkXG4gKiBpbiBvcmRlciB0byBtYWtlIGEgY29ycmVjdCB1c2Ugb2YgdGhlIHRleHR1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlVGV4dHVyZSBleHRlbmRzIFRoaW5UZXh0dXJlIHtcbiAgICAvKipcbiAgICAgKiBEZWZpbmUgaWYgdGhlIHRleHR1cmUgaXMgaGF2aW5nIGEgdXNhYmxlIGFscGhhIHZhbHVlIChjYW4gYmUgdXNlIGZvciB0cmFuc3BhcmVuY3kgb3IgZ2xvc3NpbmVzcyBmb3IgaW5zdGFuY2UpLlxuICAgICAqL1xuICAgIHNldCBoYXNBbHBoYSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5faGFzQWxwaGEgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFzQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3NjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2VuZS5tYXJrQWxsTWF0ZXJpYWxzQXNEaXJ0eSgxLCAobWF0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdC5oYXNUZXh0dXJlKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhhc0FscGhhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzQWxwaGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgaWYgdGhlIGFscGhhIHZhbHVlIHNob3VsZCBiZSBkZXRlcm1pbmVkIHZpYSB0aGUgcmdiIHZhbHVlcy5cbiAgICAgKiBJZiB0cnVlIHRoZSBsdW1pbmFuY2Ugb2YgdGhlIHBpeGVsIG1pZ2h0IGJlIHVzZWQgdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyBhbHBoYSB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXQgZ2V0QWxwaGFGcm9tUkdCKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRBbHBoYUZyb21SR0IgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2V0QWxwaGFGcm9tUkdCID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9zY2VuZSkge1xuICAgICAgICAgICAgdGhpcy5fc2NlbmUubWFya0FsbE1hdGVyaWFsc0FzRGlydHkoMSwgKG1hdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXQuaGFzVGV4dHVyZSh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBnZXRBbHBoYUZyb21SR0IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRBbHBoYUZyb21SR0I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSB0aGUgVVYgY2hhbm5lbCB0byB1c2Ugc3RhcnRpbmcgZnJvbSAwIGFuZCBkZWZhdWx0aW5nIHRvIDAuXG4gICAgICogVGhpcyBpcyBwYXJ0IG9mIHRoZSB0ZXh0dXJlIGFzIHRleHR1cmVzIHVzdWFsbHkgbWFwcyB0byBvbmUgdXYgc2V0LlxuICAgICAqL1xuICAgIHNldCBjb29yZGluYXRlc0luZGV4KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb29yZGluYXRlc0luZGV4ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzSW5kZXggPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3NjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2VuZS5tYXJrQWxsTWF0ZXJpYWxzQXNEaXJ0eSgxLCAobWF0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdC5oYXNUZXh0dXJlKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvb3JkaW5hdGVzSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlc0luZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIb3cgYSB0ZXh0dXJlIGlzIG1hcHBlZC5cbiAgICAgKlxuICAgICAqIHwgVmFsdWUgfCBUeXBlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uIHxcbiAgICAgKiB8IC0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLSB8XG4gICAgICogfCAwICAgICB8IEVYUExJQ0lUX01PREUgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfFxuICAgICAqIHwgMSAgICAgfCBTUEhFUklDQUxfTU9ERSAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHxcbiAgICAgKiB8IDIgICAgIHwgUExBTkFSX01PREUgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8XG4gICAgICogfCAzICAgICB8IENVQklDX01PREUgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfFxuICAgICAqIHwgNCAgICAgfCBQUk9KRUNUSU9OX01PREUgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHxcbiAgICAgKiB8IDUgICAgIHwgU0tZQk9YX01PREUgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8XG4gICAgICogfCA2ICAgICB8IElOVkNVQklDX01PREUgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfFxuICAgICAqIHwgNyAgICAgfCBFUVVJUkVDVEFOR1VMQVJfTU9ERSAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHxcbiAgICAgKiB8IDggICAgIHwgRklYRURfRVFVSVJFQ1RBTkdVTEFSX01PREUgICAgICAgICAgfCAgICAgICAgICAgICB8XG4gICAgICogfCA5ICAgICB8IEZJWEVEX0VRVUlSRUNUQU5HVUxBUl9NSVJST1JFRF9NT0RFIHwgICAgICAgICAgICAgfFxuICAgICAqL1xuICAgIHNldCBjb29yZGluYXRlc01vZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nvb3JkaW5hdGVzTW9kZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb29yZGluYXRlc01vZGUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3NjZW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2VuZS5tYXJrQWxsTWF0ZXJpYWxzQXNEaXJ0eSgxLCAobWF0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdC5oYXNUZXh0dXJlKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvb3JkaW5hdGVzTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzTW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogfCBWYWx1ZSB8IFR5cGUgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uIHxcbiAgICAgKiB8IC0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0gfFxuICAgICAqIHwgMCAgICAgfCBDTEFNUF9BRERSRVNTTU9ERSAgfCAgICAgICAgICAgICB8XG4gICAgICogfCAxICAgICB8IFdSQVBfQUREUkVTU01PREUgICB8ICAgICAgICAgICAgIHxcbiAgICAgKiB8IDIgICAgIHwgTUlSUk9SX0FERFJFU1NNT0RFIHwgICAgICAgICAgICAgfFxuICAgICAqL1xuICAgIGdldCB3cmFwVSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBVO1xuICAgIH1cbiAgICBzZXQgd3JhcFUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fd3JhcFUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogfCBWYWx1ZSB8IFR5cGUgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uIHxcbiAgICAgKiB8IC0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0gfFxuICAgICAqIHwgMCAgICAgfCBDTEFNUF9BRERSRVNTTU9ERSAgfCAgICAgICAgICAgICB8XG4gICAgICogfCAxICAgICB8IFdSQVBfQUREUkVTU01PREUgICB8ICAgICAgICAgICAgIHxcbiAgICAgKiB8IDIgICAgIHwgTUlSUk9SX0FERFJFU1NNT0RFIHwgICAgICAgICAgICAgfFxuICAgICAqL1xuICAgIGdldCB3cmFwVigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBWO1xuICAgIH1cbiAgICBzZXQgd3JhcFYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fd3JhcFYgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lIGlmIHRoZSB0ZXh0dXJlIGlzIGEgY3ViZSB0ZXh0dXJlIG9yIGlmIGZhbHNlIGEgMmQgdGV4dHVyZS5cbiAgICAgKi9cbiAgICBnZXQgaXNDdWJlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0N1YmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmUuaXNDdWJlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgc2V0IGlzQ3ViZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQ3ViZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5pc0N1YmUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgaWYgdGhlIHRleHR1cmUgaXMgYSAzZCB0ZXh0dXJlICh3ZWJnbCAyKSBvciBpZiBmYWxzZSBhIDJkIHRleHR1cmUuXG4gICAgICovXG4gICAgZ2V0IGlzM0QoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlLmlzM0Q7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBzZXQgaXMzRCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXh0dXJlLmlzM0QgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lIGlmIHRoZSB0ZXh0dXJlIGlzIGEgMmQgYXJyYXkgdGV4dHVyZSAod2ViZ2wgMikgb3IgaWYgZmFsc2UgYSAyZCB0ZXh0dXJlLlxuICAgICAqL1xuICAgIGdldCBpczJEQXJyYXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlLmlzMkRBcnJheTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIHNldCBpczJEQXJyYXkodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGV4dHVyZS5pczJEQXJyYXkgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lIGlmIHRoZSB0ZXh0dXJlIGNvbnRhaW5zIGRhdGEgaW4gZ2FtbWEgc3BhY2UgKG1vc3Qgb2YgdGhlIHBuZy9qcGcgYXNpZGUgYnVtcCkuXG4gICAgICogSERSIHRleHR1cmUgYXJlIHVzdWFsbHkgc3RvcmVkIGluIGxpbmVhciBzcGFjZS5cbiAgICAgKiBUaGlzIG9ubHkgaW1wYWN0cyB0aGUgUEJSIGFuZCBCYWNrZ3JvdW5kIG1hdGVyaWFsc1xuICAgICAqL1xuICAgIGdldCBnYW1tYVNwYWNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nYW1tYVNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUuX2dhbW1hU3BhY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlLl9nYW1tYVNwYWNlID0gdGhpcy5fZ2FtbWFTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZS5fZ2FtbWFTcGFjZSAmJiAhdGhpcy5fdGV4dHVyZS5fdXNlU1JHQkJ1ZmZlcjtcbiAgICB9XG4gICAgc2V0IGdhbW1hU3BhY2UoZ2FtbWEpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2FtbWFTcGFjZSA9PT0gZ2FtbWEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9nYW1tYVNwYWNlID0gZ2FtbWE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZS5fZ2FtbWFTcGFjZSA9PT0gZ2FtbWEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlLl9nYW1tYVNwYWNlID0gZ2FtbWE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRTY2VuZSgpPy5tYXJrQWxsTWF0ZXJpYWxzQXNEaXJ0eSgxLCAobWF0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Lmhhc1RleHR1cmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciBvciBub3QgdGhlIHRleHR1cmUgY29udGFpbnMgUkdCRCBkYXRhLlxuICAgICAqL1xuICAgIGdldCBpc1JHQkQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlICE9IG51bGwgJiYgdGhpcy5fdGV4dHVyZS5faXNSR0JEO1xuICAgIH1cbiAgICBzZXQgaXNSR0JEKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5pc1JHQkQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5faXNSR0JEID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRTY2VuZSgpPy5tYXJrQWxsTWF0ZXJpYWxzQXNEaXJ0eSgxLCAobWF0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Lmhhc1RleHR1cmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcmUgbWlwIG1hcHMgZ2VuZXJhdGVkIGZvciB0aGlzIHRleHR1cmUgb3Igbm90LlxuICAgICAqL1xuICAgIGdldCBub01pcG1hcCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaXRoIHByZWZpbHRlcmVkIHRleHR1cmUsIGRlZmluZWQgdGhlIG9mZnNldCB1c2VkIGR1cmluZyB0aGUgcHJlZmlsdGVyaW5nIHN0ZXBzLlxuICAgICAqL1xuICAgIGdldCBsb2RHZW5lcmF0aW9uT2Zmc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmUuX2xvZEdlbmVyYXRpb25PZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuMDtcbiAgICB9XG4gICAgc2V0IGxvZEdlbmVyYXRpb25PZmZzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUuX2xvZEdlbmVyYXRpb25PZmZzZXQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaXRoIHByZWZpbHRlcmVkIHRleHR1cmUsIGRlZmluZWQgdGhlIHNjYWxlIHVzZWQgZHVyaW5nIHRoZSBwcmVmaWx0ZXJpbmcgc3RlcHMuXG4gICAgICovXG4gICAgZ2V0IGxvZEdlbmVyYXRpb25TY2FsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlLl9sb2RHZW5lcmF0aW9uU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuMDtcbiAgICB9XG4gICAgc2V0IGxvZEdlbmVyYXRpb25TY2FsZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5fbG9kR2VuZXJhdGlvblNjYWxlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2l0aCBwcmVmaWx0ZXJlZCB0ZXh0dXJlLCBkZWZpbmVkIGlmIHRoZSBzcGVjdWxhciBnZW5lcmF0aW9uIGlzIGJhc2VkIG9uIGEgbGluZWFyIHJhbXAuXG4gICAgICogQnkgZGVmYXVsdCB3ZSBhcmUgdXNpbmcgYSBsb2cyIG9mIHRoZSBsaW5lYXIgcm91Z2huZXNzIGhlbHBpbmcgdG8ga2VlcCBhIGJldHRlciByZXNvbHV0aW9uIGZvclxuICAgICAqIGF2ZXJhZ2Ugcm91Z2huZXNzIHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXQgbGluZWFyU3BlY3VsYXJMT0QoKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZS5fbGluZWFyU3BlY3VsYXJMT0Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZXQgbGluZWFyU3BlY3VsYXJMT0QodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUuX2xpbmVhclNwZWN1bGFyTE9EID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBhIGJldHRlciBkZWZpbml0aW9uIHRoYW4gc3BoZXJpY2FsIGhhcm1vbmljcyBpcyByZXF1aXJlZCBmb3IgdGhlIGRpZmZ1c2UgcGFydCBvZiB0aGUgZW52aXJvbm1lbnQuXG4gICAgICogWW91IGNhbiBzZXQgdGhlIGlycmFkaWFuY2UgdGV4dHVyZSB0byByZWx5IG9uIGEgdGV4dHVyZSBpbnN0ZWFkIG9mIHRoZSBzcGhlcmljYWwgYXBwcm9hY2guXG4gICAgICogVGhpcyB0ZXh0dXJlIG5lZWQgdG8gaGF2ZSB0aGUgc2FtZSBjaGFyYWN0ZXJpc3RpY3MgdGhhbiBpdHMgcGFyZW50IChDdWJlIHZzIDJkLCBjb29yZGluYXRlcyBtb2RlLCBHYW1tYS9MaW5lYXIsIFJHQkQpLlxuICAgICAqL1xuICAgIGdldCBpcnJhZGlhbmNlVGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlLl9pcnJhZGlhbmNlVGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2V0IGlycmFkaWFuY2VUZXh0dXJlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlLl9pcnJhZGlhbmNlVGV4dHVyZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSB0aGUgdW5pcXVlIGlkIG9mIHRoZSB0ZXh0dXJlIGluIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBnZXQgdWlkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3VpZCkge1xuICAgICAgICAgICAgdGhpcy5fdWlkID0gUmFuZG9tR1VJRCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl91aWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgdGV4dHVyZSBhcyBhIHN0cmluZ1xuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNsYXNzIG5hbWUgb2YgdGhlIHRleHR1cmUuXG4gICAgICogQHJldHVybnMgXCJCYXNlVGV4dHVyZVwiXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJCYXNlVGV4dHVyZVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiB0aGUgdGV4dHVyZSBoYXMgYmVlbiBkaXNwb3NlZC5cbiAgICAgKiBLZXB0IGZvciBiYWNrIGNvbXBhdGliaWxpdHksIHlvdSBjYW4gdXNlIHRoZSBvbkRpc3Bvc2VPYnNlcnZhYmxlIGluc3RlYWQuXG4gICAgICovXG4gICAgc2V0IG9uRGlzcG9zZShjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5fb25EaXNwb3NlT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub25EaXNwb3NlT2JzZXJ2YWJsZS5yZW1vdmUodGhpcy5fb25EaXNwb3NlT2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uRGlzcG9zZU9ic2VydmVyID0gdGhpcy5vbkRpc3Bvc2VPYnNlcnZhYmxlLmFkZChjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSBpZiB0aGUgdGV4dHVyZSBpcyBwcmV2ZW50aW5nIGEgbWF0ZXJpYWwgdG8gcmVuZGVyIG9yIG5vdC5cbiAgICAgKiBJZiBub3QgYW5kIHRoZSB0ZXh0dXJlIGlzIG5vdCByZWFkeSwgdGhlIGVuZ2luZSB3aWxsIHVzZSBhIGRlZmF1bHQgYmxhY2sgdGV4dHVyZSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGdldCBpc0Jsb2NraW5nKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FzIHRoZXJlIGFueSBsb2FkaW5nIGVycm9yP1xuICAgICAqL1xuICAgIGdldCBsb2FkaW5nRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkaW5nRXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGEgbG9hZGluZyBlcnJvciBvY2N1cnJlZCB0aGlzIG9iamVjdCB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvci5cbiAgICAgKi9cbiAgICBnZXQgZXJyb3JPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvck9iamVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGEgbmV3IEJhc2VUZXh0dXJlLlxuICAgICAqIEJhc2UgY2xhc3Mgb2YgYWxsIHRoZSB0ZXh0dXJlcyBpbiBiYWJ5bG9uLlxuICAgICAqIEl0IGdyb3VwcyBhbGwgdGhlIGNvbW1vbiBwcm9wZXJ0aWVzIHRoZSBtYXRlcmlhbHMsIHBvc3QgcHJvY2VzcywgbGlnaHRzLi4uIG1pZ2h0IG5lZWRcbiAgICAgKiBpbiBvcmRlciB0byBtYWtlIGEgY29ycmVjdCB1c2Ugb2YgdGhlIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHNjZW5lT3JFbmdpbmUgRGVmaW5lIHRoZSBzY2VuZSBvciBlbmdpbmUgdGhlIHRleHR1cmUgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSBpbnRlcm5hbFRleHR1cmUgRGVmaW5lIHRoZSBpbnRlcm5hbCB0ZXh0dXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNjZW5lT3JFbmdpbmUsIGludGVybmFsVGV4dHVyZSA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobnVsbCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgYW4gb2JqZWN0IHVzZWQgdG8gc3RvcmUgdXNlciBkZWZpbmVkIGluZm9ybWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuIFBsZWFzZSBkbyBub3QgdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNlcnZlZERhdGFTdG9yZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hhc0FscGhhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2dldEFscGhhRnJvbVJHQiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZW5zaXR5IG9yIHN0cmVuZ3RoIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBJdCBpcyBjb21tb25seSB1c2VkIGJ5IG1hdGVyaWFscyB0byBmaW5lIHR1bmUgdGhlIGludGVuc2l0eSBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZXZlbCA9IDE7XG4gICAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzSW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBvciBzZXRzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhlIHRleHR1cmUgc2hvdWxkIHRyeSB0byByZWR1Y2Ugc2hhZGVyIGNvZGUgaWYgdGhlcmUgaXMgbm8gVVYgbWFuaXB1bGF0aW9uLlxuICAgICAgICAgKiAoaWUuIHdoZW4gdGV4dHVyZS5nZXRUZXh0dXJlTWF0cml4KCkuaXNJZGVudGl0eUFzM3gyKCkgcmV0dXJucyB0cnVlKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpbWl6ZVVWQWxsb2NhdGlvbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzTW9kZSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB8IFZhbHVlIHwgVHlwZSAgICAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gfFxuICAgICAgICAgKiB8IC0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0gfFxuICAgICAgICAgKiB8IDAgICAgIHwgQ0xBTVBfQUREUkVTU01PREUgIHwgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDEgICAgIHwgV1JBUF9BRERSRVNTTU9ERSAgIHwgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDIgICAgIHwgTUlSUk9SX0FERFJFU1NNT0RFIHwgICAgICAgICAgICAgfFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwUiA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIGNvbXBsaWFudCBoYXJkd2FyZSBhbmQgYnJvd3NlciAoc3VwcG9ydGluZyBhbmlzb3Ryb3BpYyBmaWx0ZXJpbmcpXG4gICAgICAgICAqIHRoaXMgZGVmaW5lcyB0aGUgbGV2ZWwgb2YgYW5pc290cm9waWMgZmlsdGVyaW5nIGluIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBUaGUgaGlnaGVyIHRoZSBiZXR0ZXIgYnV0IHRoZSBzbG93ZXIuIFRoaXMgZGVmYXVsdHMgdG8gNCBhcyBpdCBzZWVtcyB0byBiZSB0aGUgYmVzdCB0cmFkZW9mZi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCA9IEJhc2VUZXh0dXJlLkRFRkFVTFRfQU5JU09UUk9QSUNfRklMVEVSSU5HX0xFVkVMO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2lzQ3ViZSA9IGZhbHNlO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2dhbW1hU3BhY2UgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSXMgWiBpbnZlcnRlZCBpbiB0aGUgdGV4dHVyZSAodXNlZnVsIGluIGEgY3ViZSB0ZXh0dXJlKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW52ZXJ0WiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvZExldmVsSW5BbHBoYSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIGlmIHRoZSB0ZXh0dXJlIGlzIGEgcmVuZGVyIHRhcmdldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNSZW5kZXJUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9wcmVmaWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2ZvcmNlU2VyaWFsaXplID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgdGhlIGxpc3Qgb2YgYW5pbWF0aW9uIGF0dGFjaGVkIHRvIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgdGV4dHVyZSBpcyBkaXNwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25EaXNwb3NlT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuX29uRGlzcG9zZU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2NlbmUgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3VpZCA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fcGFyZW50Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbG9hZGluZ0Vycm9yID0gZmFsc2U7XG4gICAgICAgIGlmIChzY2VuZU9yRW5naW5lKSB7XG4gICAgICAgICAgICBpZiAoQmFzZVRleHR1cmUuX0lzU2NlbmUoc2NlbmVPckVuZ2luZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2VuZSA9IHNjZW5lT3JFbmdpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBzY2VuZU9yRW5naW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NlbmUgPSBFbmdpbmVTdG9yZS5MYXN0Q3JlYXRlZFNjZW5lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zY2VuZSkge1xuICAgICAgICAgICAgdGhpcy51bmlxdWVJZCA9IHRoaXMuX3NjZW5lLmdldFVuaXF1ZUlkKCk7XG4gICAgICAgICAgICB0aGlzLl9zY2VuZS5hZGRUZXh0dXJlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gdGhpcy5fc2NlbmUuZ2V0RW5naW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IGludGVybmFsVGV4dHVyZTtcbiAgICAgICAgdGhpcy5fdWlkID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzY2VuZSB0aGUgdGV4dHVyZSBiZWxvbmdzIHRvLlxuICAgICAqIEByZXR1cm5zIHRoZSBzY2VuZSBvciBudWxsIGlmIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGdldFNjZW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NlbmU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0RW5naW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5naW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRleHR1cmUgdHJhbnNmb3JtIG1hdHJpeCB1c2VkIHRvIG9mZnNldCB0aWxlIHRoZSB0ZXh0dXJlIGZvciBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAgICovXG4gICAgZ2V0VGV4dHVyZU1hdHJpeCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdHJpeC5JZGVudGl0eVJlYWRPbmx5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRleHR1cmUgcmVmbGVjdGlvbiBtYXRyaXggdXNlZCB0byByb3RhdGUvdHJhbnNmb3JtIHRoZSByZWZsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHRoZSByZWZsZWN0aW9uIG1hdHJpeFxuICAgICAqL1xuICAgIGdldFJlZmxlY3Rpb25UZXh0dXJlTWF0cml4KCkge1xuICAgICAgICByZXR1cm4gTWF0cml4LklkZW50aXR5UmVhZE9ubHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBzdWl0YWJsZSByb3RhdGUvdHJhbnNmb3JtIG1hdHJpeCB3aGVuIHRoZSB0ZXh0dXJlIGlzIHVzZWQgZm9yIHJlZnJhY3Rpb24uXG4gICAgICogVGhlcmUncyBhIHNlcGFyYXRlIGZ1bmN0aW9uIGZyb20gZ2V0UmVmbGVjdGlvblRleHR1cmVNYXRyaXggYmVjYXVzZSByZWZyYWN0aW9uIHJlcXVpcmVzIGEgc3BlY2lhbCBjb25maWd1cmF0aW9uIG9mIHRoZSBtYXRyaXggaW4gcmlnaHQtaGFuZGVkIG1vZGUuXG4gICAgICogQHJldHVybnMgVGhlIHJlZnJhY3Rpb24gbWF0cml4XG4gICAgICovXG4gICAgZ2V0UmVmcmFjdGlvblRleHR1cmVNYXRyaXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlZmxlY3Rpb25UZXh0dXJlTWF0cml4KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBpZiB0aGUgdGV4dHVyZSBpcyByZWFkeSB0byBiZSBjb25zdW1lZCAoZWl0aGVyIGl0IGlzIHJlYWR5IG9yIGl0IGlzIG5vdCBibG9ja2luZylcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHJlYWR5LCBub3QgYmxvY2tpbmcgb3IgaWYgdGhlcmUgd2FzIGFuIGVycm9yIGxvYWRpbmcgdGhlIHRleHR1cmVcbiAgICAgKi9cbiAgICBpc1JlYWR5T3JOb3RCbG9ja2luZygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQmxvY2tpbmcgfHwgdGhpcy5pc1JlYWR5KCkgfHwgdGhpcy5sb2FkaW5nRXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGUgdGV4dHVyZSBpZiBpcyBgY2FuUmVzY2FsZSgpYFxuICAgICAqIEBwYXJhbSByYXRpbyB0aGUgcmVzaXplIGZhY3RvciB3ZSB3YW50IHRvIHVzZSB0byByZXNjYWxlXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHNjYWxlKHJhdGlvKSB7IH1cbiAgICAvKipcbiAgICAgKiBHZXQgaWYgdGhlIHRleHR1cmUgY2FuIHJlc2NhbGUuXG4gICAgICovXG4gICAgZ2V0IGNhblJlc2NhbGUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2dldEZyb21DYWNoZSh1cmwsIG5vTWlwbWFwLCBzYW1wbGluZywgaW52ZXJ0WSwgdXNlU1JHQkJ1ZmZlciwgaXNDdWJlKSB7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX2dldEVuZ2luZSgpO1xuICAgICAgICBpZiAoIWVuZ2luZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ycmVjdGVkVXNlU1JHQkJ1ZmZlciA9IGVuZ2luZS5fZ2V0VXNlU1JHQkJ1ZmZlcighIXVzZVNSR0JCdWZmZXIsIG5vTWlwbWFwKTtcbiAgICAgICAgY29uc3QgdGV4dHVyZXNDYWNoZSA9IGVuZ2luZS5nZXRMb2FkZWRUZXh0dXJlc0NhY2hlKCk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0dXJlc0NhY2hlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZXNDYWNoZUVudHJ5ID0gdGV4dHVyZXNDYWNoZVtpbmRleF07XG4gICAgICAgICAgICBpZiAodXNlU1JHQkJ1ZmZlciA9PT0gdW5kZWZpbmVkIHx8IGNvcnJlY3RlZFVzZVNSR0JCdWZmZXIgPT09IHRleHR1cmVzQ2FjaGVFbnRyeS5fdXNlU1JHQkJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGlmIChpbnZlcnRZID09PSB1bmRlZmluZWQgfHwgaW52ZXJ0WSA9PT0gdGV4dHVyZXNDYWNoZUVudHJ5LmludmVydFkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHR1cmVzQ2FjaGVFbnRyeS51cmwgPT09IHVybCAmJiB0ZXh0dXJlc0NhY2hlRW50cnkuZ2VuZXJhdGVNaXBNYXBzID09PSAhbm9NaXBtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2FtcGxpbmcgfHwgc2FtcGxpbmcgPT09IHRleHR1cmVzQ2FjaGVFbnRyeS5zYW1wbGluZ01vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdWJlID09PSB1bmRlZmluZWQgfHwgaXNDdWJlID09PSB0ZXh0dXJlc0NhY2hlRW50cnkuaXNDdWJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVzQ2FjaGVFbnRyeS5pbmNyZW1lbnRSZWZlcmVuY2VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlc0NhY2hlRW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlYnVpbGQoX2Zyb21Db250ZXh0TG9zdCA9IGZhbHNlKSB7IH1cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgdGhlIHRleHR1cmUuXG4gICAgICogQHJldHVybnMgdGhlIGNsb25lZCB0ZXh0dXJlXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRleHR1cmUgdW5kZXJseWluZyB0eXBlIChJTlQsIEZMT0FULi4uKVxuICAgICAqL1xuICAgIGdldCB0ZXh0dXJlVHlwZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZS50eXBlICE9PSB1bmRlZmluZWQgPyB0aGlzLl90ZXh0dXJlLnR5cGUgOiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRleHR1cmUgdW5kZXJseWluZyBmb3JtYXQgKFJHQiwgUkdCQS4uLilcbiAgICAgKi9cbiAgICBnZXQgdGV4dHVyZUZvcm1hdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZS5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IHRoaXMuX3RleHR1cmUuZm9ybWF0IDogNTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGV4dHVyZXMgbmVlZCB0byBiZSByZS1jYWxjdWxhdGVkIGZvciBhbGwgbWF0ZXJpYWxzXG4gICAgICovXG4gICAgX21hcmtBbGxTdWJNZXNoZXNBc1RleHR1cmVzRGlydHkoKSB7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5nZXRTY2VuZSgpO1xuICAgICAgICBpZiAoIXNjZW5lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2NlbmUubWFya0FsbE1hdGVyaWFsc0FzRGlydHkoMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBwaXhlbHMgc3RvcmVkIGluIHRoZSB3ZWJnbCB0ZXh0dXJlIGFuZCByZXR1cm5zIHRoZW0gYXMgYW4gQXJyYXlCdWZmZXIuXG4gICAgICogVGhpcyB3aWxsIHJldHVybnMgYW4gUkdCQSBhcnJheSBidWZmZXIgY29udGFpbmluZyBlaXRoZXIgaW4gdmFsdWVzICgwLTI1NSkgb3JcbiAgICAgKiBmbG9hdCB2YWx1ZXMgKDAtMSkgZGVwZW5kaW5nIG9mIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciB0eXBlLlxuICAgICAqIEBwYXJhbSBmYWNlSW5kZXggZGVmaW5lcyB0aGUgZmFjZSBvZiB0aGUgdGV4dHVyZSB0byByZWFkIChpbiBjYXNlIG9mIGN1YmUgdGV4dHVyZSlcbiAgICAgKiBAcGFyYW0gbGV2ZWwgZGVmaW5lcyB0aGUgTE9EIGxldmVsIG9mIHRoZSB0ZXh0dXJlIHRvIHJlYWQgKGluIGNhc2Ugb2YgTWlwIE1hcHMpXG4gICAgICogQHBhcmFtIGJ1ZmZlciBkZWZpbmVzIGEgdXNlciBkZWZpbmVkIGJ1ZmZlciB0byBmaWxsIHdpdGggZGF0YSAoY2FuIGJlIG51bGwpXG4gICAgICogQHBhcmFtIGZsdXNoUmVuZGVyZXIgdHJ1ZSB0byBmbHVzaCB0aGUgcmVuZGVyZXIgZnJvbSB0aGUgcGVuZGluZyBjb21tYW5kcyBiZWZvcmUgcmVhZGluZyB0aGUgcGl4ZWxzXG4gICAgICogQHBhcmFtIG5vRGF0YUNvbnZlcnNpb24gZmFsc2UgdG8gY29udmVydCB0aGUgZGF0YSB0byBVaW50OEFycmF5IChpZiB0ZXh0dXJlIHR5cGUgaXMgVU5TSUdORURfQllURSkgb3IgdG8gRmxvYXQzMkFycmF5IChpZiB0ZXh0dXJlIHR5cGUgaXMgYW55dGhpbmcgYnV0IFVOU0lHTkVEX0JZVEUpLiBJZiB0cnVlLCB0aGUgdHlwZSBvZiB0aGUgZ2VuZXJhdGVkIGJ1ZmZlciAoaWYgYnVmZmVyPT1udWxsKSB3aWxsIGRlcGVuZCBvbiB0aGUgdHlwZSBvZiB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB4IGRlZmluZXMgdGhlIHJlZ2lvbiB4IGNvb3JkaW5hdGVzIHRvIHN0YXJ0IHJlYWRpbmcgZnJvbSAoZGVmYXVsdCB0byAwKVxuICAgICAqIEBwYXJhbSB5IGRlZmluZXMgdGhlIHJlZ2lvbiB5IGNvb3JkaW5hdGVzIHRvIHN0YXJ0IHJlYWRpbmcgZnJvbSAoZGVmYXVsdCB0byAwKVxuICAgICAqIEBwYXJhbSB3aWR0aCBkZWZpbmVzIHRoZSByZWdpb24gd2lkdGggdG8gcmVhZCBmcm9tIChkZWZhdWx0IHRvIHRoZSB0ZXh0dXJlIHNpemUgYXQgbGV2ZWwpXG4gICAgICogQHBhcmFtIGhlaWdodCBkZWZpbmVzIHRoZSByZWdpb24gd2lkdGggdG8gcmVhZCBmcm9tIChkZWZhdWx0IHRvIHRoZSB0ZXh0dXJlIHNpemUgYXQgbGV2ZWwpXG4gICAgICogQHJldHVybnMgVGhlIEFycmF5IGJ1ZmZlciBwcm9taXNlIGNvbnRhaW5pbmcgdGhlIHBpeGVscyBkYXRhLlxuICAgICAqL1xuICAgIHJlYWRQaXhlbHMoZmFjZUluZGV4ID0gMCwgbGV2ZWwgPSAwLCBidWZmZXIgPSBudWxsLCBmbHVzaFJlbmRlcmVyID0gdHJ1ZSwgbm9EYXRhQ29udmVyc2lvbiA9IGZhbHNlLCB4ID0gMCwgeSA9IDAsIHdpZHRoID0gTnVtYmVyLk1BWF9WQUxVRSwgaGVpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX2dldEVuZ2luZSgpO1xuICAgICAgICBpZiAoIWVuZ2luZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgICBsZXQgbWF4V2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICBsZXQgbWF4SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIGlmIChsZXZlbCAhPT0gMCkge1xuICAgICAgICAgICAgbWF4V2lkdGggPSBtYXhXaWR0aCAvIE1hdGgucG93KDIsIGxldmVsKTtcbiAgICAgICAgICAgIG1heEhlaWdodCA9IG1heEhlaWdodCAvIE1hdGgucG93KDIsIGxldmVsKTtcbiAgICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5yb3VuZChtYXhXaWR0aCk7XG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLnJvdW5kKG1heEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgd2lkdGggPSBNYXRoLm1pbihtYXhXaWR0aCwgd2lkdGgpO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLm1pbihtYXhIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZS5pc0N1YmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5naW5lLl9yZWFkVGV4dHVyZVBpeGVscyh0aGlzLl90ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBmYWNlSW5kZXgsIGxldmVsLCBidWZmZXIsIGZsdXNoUmVuZGVyZXIsIG5vRGF0YUNvbnZlcnNpb24sIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVuZ2luZS5fcmVhZFRleHR1cmVQaXhlbHModGhpcy5fdGV4dHVyZSwgd2lkdGgsIGhlaWdodCwgLTEsIGxldmVsLCBidWZmZXIsIGZsdXNoUmVuZGVyZXIsIG5vRGF0YUNvbnZlcnNpb24sIHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfcmVhZFBpeGVsc1N5bmMoZmFjZUluZGV4ID0gMCwgbGV2ZWwgPSAwLCBidWZmZXIgPSBudWxsLCBmbHVzaFJlbmRlcmVyID0gdHJ1ZSwgbm9EYXRhQ29udmVyc2lvbiA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgICBsZXQgd2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX2dldEVuZ2luZSgpO1xuICAgICAgICBpZiAoIWVuZ2luZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsICE9IDApIHtcbiAgICAgICAgICAgIHdpZHRoID0gd2lkdGggLyBNYXRoLnBvdygyLCBsZXZlbCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgLyBNYXRoLnBvdygyLCBsZXZlbCk7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZS5pc0N1YmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5naW5lLl9yZWFkVGV4dHVyZVBpeGVsc1N5bmModGhpcy5fdGV4dHVyZSwgd2lkdGgsIGhlaWdodCwgZmFjZUluZGV4LCBsZXZlbCwgYnVmZmVyLCBmbHVzaFJlbmRlcmVyLCBub0RhdGFDb252ZXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbmdpbmUuX3JlYWRUZXh0dXJlUGl4ZWxzU3luYyh0aGlzLl90ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCAtMSwgbGV2ZWwsIGJ1ZmZlciwgZmx1c2hSZW5kZXJlciwgbm9EYXRhQ29udmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBnZXQgX2xvZFRleHR1cmVIaWdoKCkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmUuX2xvZFRleHR1cmVIaWdoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZ2V0IF9sb2RUZXh0dXJlTWlkKCkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmUuX2xvZFRleHR1cmVNaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBnZXQgX2xvZFRleHR1cmVMb3coKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZS5fbG9kVGV4dHVyZUxvdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB0aGUgdGV4dHVyZSBhbmQgcmVsZWFzZSBpdHMgYXNzb2NpYXRlZCByZXNvdXJjZXMuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NjZW5lKSB7XG4gICAgICAgICAgICAvLyBBbmltYXRpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5fc2NlbmUuc3RvcEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjZW5lLnN0b3BBbmltYXRpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBzY2VuZVxuICAgICAgICAgICAgdGhpcy5fc2NlbmUucmVtb3ZlUGVuZGluZ0RhdGEodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3NjZW5lLnRleHR1cmVzLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjZW5lLnRleHR1cmVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zY2VuZS5vblRleHR1cmVSZW1vdmVkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnModGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zY2VuZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wYXJlbnRDb250YWluZXIudGV4dHVyZXMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnRDb250YWluZXIudGV4dHVyZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsYmFja1xuICAgICAgICB0aGlzLm9uRGlzcG9zZU9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgICB0aGlzLm9uRGlzcG9zZU9ic2VydmFibGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSB0ZXh0dXJlIGludG8gYSBKU09OIHJlcHJlc2VudGF0aW9uIHRoYXQgY2FuIGJlIHBhcnNlZCBsYXRlciBvbi5cbiAgICAgKiBAcGFyYW0gYWxsb3dFbXB0eU5hbWUgVHJ1ZSB0byBmb3JjZSBzZXJpYWxpemF0aW9uIGV2ZW4gaWYgbmFtZSBpcyBlbXB0eS4gRGVmYXVsdDogZmFsc2VcbiAgICAgKiBAcmV0dXJucyB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZShhbGxvd0VtcHR5TmFtZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5uYW1lICYmICFhbGxvd0VtcHR5TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXphdGlvbk9iamVjdCA9IFNlcmlhbGl6YXRpb25IZWxwZXIuU2VyaWFsaXplKHRoaXMpO1xuICAgICAgICAvLyBBbmltYXRpb25zXG4gICAgICAgIFNlcmlhbGl6YXRpb25IZWxwZXIuQXBwZW5kU2VyaWFsaXplZEFuaW1hdGlvbnModGhpcywgc2VyaWFsaXphdGlvbk9iamVjdCk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uT2JqZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGJhY2sgb25jZSBhIGxpc3Qgb2YgdGV4dHVyZSBjb250YWlucyBvbmx5IHJlYWR5IHRleHR1cmVzLlxuICAgICAqIEBwYXJhbSB0ZXh0dXJlcyBEZWZpbmUgdGhlIGxpc3Qgb2YgdGV4dHVyZXMgdG8gd2FpdCBmb3JcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgRGVmaW5lIHRoZSBjYWxsYmFjayB0cmlnZ2VyZWQgb25jZSB0aGUgZW50aXJlIGxpc3Qgd2lsbCBiZSByZWFkeVxuICAgICAqL1xuICAgIHN0YXRpYyBXaGVuQWxsUmVhZHkodGV4dHVyZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBudW1SZW1haW5pbmcgPSB0ZXh0dXJlcy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1SZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRleHR1cmVzW2ldO1xuICAgICAgICAgICAgaWYgKHRleHR1cmUuaXNSZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKC0tbnVtUmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25Mb2FkT2JzZXJ2YWJsZSA9IHRleHR1cmUub25Mb2FkT2JzZXJ2YWJsZTtcbiAgICAgICAgICAgICAgICBpZiAob25Mb2FkT2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBvbkxvYWRPYnNlcnZhYmxlLmFkZE9uY2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbnVtUmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoLS1udW1SZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIF9Jc1NjZW5lKHNjZW5lT3JFbmdpbmUpIHtcbiAgICAgICAgcmV0dXJuIHNjZW5lT3JFbmdpbmUuZ2V0Q2xhc3NOYW1lKCkgPT09IFwiU2NlbmVcIjtcbiAgICB9XG59XG4vKipcbiAqIERlZmF1bHQgYW5pc290cm9waWMgZmlsdGVyaW5nIGxldmVsIGZvciB0aGUgYXBwbGljYXRpb24uXG4gKiBJdCBpcyBzZXQgdG8gNCBhcyBhIGdvb2QgdHJhZGVvZmYgYmV0d2VlbiBwZXJmIGFuZCBxdWFsaXR5LlxuICovXG5CYXNlVGV4dHVyZS5ERUZBVUxUX0FOSVNPVFJPUElDX0ZJTFRFUklOR19MRVZFTCA9IDQ7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgQmFzZVRleHR1cmUucHJvdG90eXBlLCBcInVuaXF1ZUlkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgQmFzZVRleHR1cmUucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBCYXNlVGV4dHVyZS5wcm90b3R5cGUsIFwiZGlzcGxheU5hbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBCYXNlVGV4dHVyZS5wcm90b3R5cGUsIFwibWV0YWRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZShcImhhc0FscGhhXCIpXG5dLCBCYXNlVGV4dHVyZS5wcm90b3R5cGUsIFwiX2hhc0FscGhhXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoXCJnZXRBbHBoYUZyb21SR0JcIilcbl0sIEJhc2VUZXh0dXJlLnByb3RvdHlwZSwgXCJfZ2V0QWxwaGFGcm9tUkdCXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgQmFzZVRleHR1cmUucHJvdG90eXBlLCBcImxldmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoXCJjb29yZGluYXRlc0luZGV4XCIpXG5dLCBCYXNlVGV4dHVyZS5wcm90b3R5cGUsIFwiX2Nvb3JkaW5hdGVzSW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBCYXNlVGV4dHVyZS5wcm90b3R5cGUsIFwib3B0aW1pemVVVkFsbG9jYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZShcImNvb3JkaW5hdGVzTW9kZVwiKVxuXSwgQmFzZVRleHR1cmUucHJvdG90eXBlLCBcIl9jb29yZGluYXRlc01vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBCYXNlVGV4dHVyZS5wcm90b3R5cGUsIFwid3JhcFVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgQmFzZVRleHR1cmUucHJvdG90eXBlLCBcIndyYXBWXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIEJhc2VUZXh0dXJlLnByb3RvdHlwZSwgXCJ3cmFwUlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIEJhc2VUZXh0dXJlLnByb3RvdHlwZSwgXCJhbmlzb3Ryb3BpY0ZpbHRlcmluZ0xldmVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgQmFzZVRleHR1cmUucHJvdG90eXBlLCBcImlzQ3ViZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBCYXNlVGV4dHVyZS5wcm90b3R5cGUsIFwiaXMzRFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBCYXNlVGV4dHVyZS5wcm90b3R5cGUsIFwiaXMyREFycmF5XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIEJhc2VUZXh0dXJlLnByb3RvdHlwZSwgXCJnYW1tYVNwYWNlXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIEJhc2VUZXh0dXJlLnByb3RvdHlwZSwgXCJpbnZlcnRaXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgQmFzZVRleHR1cmUucHJvdG90eXBlLCBcImxvZExldmVsSW5BbHBoYVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIEJhc2VUZXh0dXJlLnByb3RvdHlwZSwgXCJsb2RHZW5lcmF0aW9uT2Zmc2V0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIEJhc2VUZXh0dXJlLnByb3RvdHlwZSwgXCJsb2RHZW5lcmF0aW9uU2NhbGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgQmFzZVRleHR1cmUucHJvdG90eXBlLCBcImxpbmVhclNwZWN1bGFyTE9EXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplQXNUZXh0dXJlKClcbl0sIEJhc2VUZXh0dXJlLnByb3RvdHlwZSwgXCJpcnJhZGlhbmNlVGV4dHVyZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBCYXNlVGV4dHVyZS5wcm90b3R5cGUsIFwiaXNSZW5kZXJUYXJnZXRcIiwgdm9pZCAwKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2VUZXh0dXJlLmpzLm1hcCIsImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tIFwiLi4vLi4vdHNsaWIuZXM2LmpzXCI7XG5pbXBvcnQgeyBzZXJpYWxpemUgfSBmcm9tIFwiLi4vLi4vTWlzYy9kZWNvcmF0b3JzLmpzXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSBcIi4uLy4uL01pc2Mvb2JzZXJ2YWJsZS5qc1wiO1xuaW1wb3J0IHsgTWF0cml4LCBUbXBWZWN0b3JzLCBWZWN0b3IzIH0gZnJvbSBcIi4uLy4uL01hdGhzL21hdGgudmVjdG9yLmpzXCI7XG5pbXBvcnQgeyBCYXNlVGV4dHVyZSB9IGZyb20gXCIuLi8uLi9NYXRlcmlhbHMvVGV4dHVyZXMvYmFzZVRleHR1cmUuanNcIjtcblxuaW1wb3J0IHsgR2V0Q2xhc3MsIFJlZ2lzdGVyQ2xhc3MgfSBmcm9tIFwiLi4vLi4vTWlzYy90eXBlU3RvcmUuanNcIjtcbmltcG9ydCB7IF9XYXJuSW1wb3J0IH0gZnJvbSBcIi4uLy4uL01pc2MvZGV2VG9vbHMuanNcIjtcbmltcG9ydCB7IFRpbWluZ1Rvb2xzIH0gZnJvbSBcIi4uLy4uL01pc2MvdGltaW5nVG9vbHMuanNcIjtcbmltcG9ydCB7IEluc3RhbnRpYXRpb25Ub29scyB9IGZyb20gXCIuLi8uLi9NaXNjL2luc3RhbnRpYXRpb25Ub29scy5qc1wiO1xuaW1wb3J0IHsgUGxhbmUgfSBmcm9tIFwiLi4vLi4vTWF0aHMvbWF0aC5wbGFuZS5qc1wiO1xuaW1wb3J0IHsgRW5jb2RlQXJyYXlCdWZmZXJUb0Jhc2U2NCB9IGZyb20gXCIuLi8uLi9NaXNjL3N0cmluZ1Rvb2xzLmpzXCI7XG5pbXBvcnQgeyBHZW5lcmF0ZUJhc2U2NFN0cmluZ0Zyb21UZXh0dXJlLCBHZW5lcmF0ZUJhc2U2NFN0cmluZ0Zyb21UZXh0dXJlQXN5bmMgfSBmcm9tIFwiLi4vLi4vTWlzYy9jb3B5VG9vbHMuanNcIjtcbmltcG9ydCB7IHVzZU9wZW5HTE9yaWVudGF0aW9uRm9yVVYgfSBmcm9tIFwiLi4vLi4vQ29tcGF0L2NvbXBhdGliaWxpdHlPcHRpb25zLmpzXCI7XG5pbXBvcnQgeyBTZXJpYWxpemF0aW9uSGVscGVyIH0gZnJvbSBcIi4uLy4uL01pc2MvZGVjb3JhdG9ycy5zZXJpYWxpemF0aW9uLmpzXCI7XG4vKipcbiAqIFRoaXMgcmVwcmVzZW50cyBhIHRleHR1cmUgaW4gYmFieWxvbi4gSXQgY2FuIGJlIGVhc2lseSBsb2FkZWQgZnJvbSBhIG5ldHdvcmssIGJhc2U2NCBvciBodG1sIGlucHV0LlxuICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL2ZlYXR1cmVzL2ZlYXR1cmVzRGVlcERpdmUvbWF0ZXJpYWxzL3VzaW5nL21hdGVyaWFsc19pbnRyb2R1Y3Rpb24jdGV4dHVyZVxuICovXG5leHBvcnQgY2xhc3MgVGV4dHVyZSBleHRlbmRzIEJhc2VUZXh0dXJlIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgX0NyZWF0ZVZpZGVvVGV4dHVyZShuYW1lLCBzcmMsIHNjZW5lLCBnZW5lcmF0ZU1pcE1hcHMgPSBmYWxzZSwgaW52ZXJ0WSA9IGZhbHNlLCBzYW1wbGluZ01vZGUgPSBUZXh0dXJlLlRSSUxJTkVBUl9TQU1QTElOR01PREUsIHNldHRpbmdzID0ge30sIG9uRXJyb3IsIGZvcm1hdCA9IDUpIHtcbiAgICAgICAgdGhyb3cgX1dhcm5JbXBvcnQoXCJWaWRlb1RleHR1cmVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFyZSBtaXAgbWFwcyBnZW5lcmF0ZWQgZm9yIHRoaXMgdGV4dHVyZSBvciBub3QuXG4gICAgICovXG4gICAgZ2V0IG5vTWlwbWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9NaXBtYXA7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSB0ZXh0dXJlIG1pbWUgdHlwZSBpZiBpdCB3YXMgZGVmaW5lZCBieSBhIGxvYWRlciAodW5kZWZpbmVkIGVsc2UpICovXG4gICAgZ2V0IG1pbWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWltZVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSB0ZXh0dXJlIHByZXZlbnRpbmcgbWF0ZXJpYWwgdG8gcmVuZGVyIHdoaWxlIGxvYWRpbmcuXG4gICAgICogSWYgZmFsc2UsIGEgZGVmYXVsdCB0ZXh0dXJlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBsb2FkaW5nIG9uZSBkdXJpbmcgdGhlIHByZXBhcmF0aW9uIHN0ZXAuXG4gICAgICovXG4gICAgc2V0IGlzQmxvY2tpbmcodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faXNCbG9ja2luZyA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaXNCbG9ja2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQmxvY2tpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIHRleHR1cmUgbmVlZHMgdG8gYmUgaW52ZXJ0ZWQgb24gdGhlIHkgYXhpcyBkdXJpbmcgbG9hZGluZ1xuICAgICAqL1xuICAgIGdldCBpbnZlcnRZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52ZXJ0WTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGEgbmV3IHRleHR1cmUuXG4gICAgICogVGhpcyByZXByZXNlbnRzIGEgdGV4dHVyZSBpbiBiYWJ5bG9uLiBJdCBjYW4gYmUgZWFzaWx5IGxvYWRlZCBmcm9tIGEgbmV0d29yaywgYmFzZTY0IG9yIGh0bWwgaW5wdXQuXG4gICAgICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL2ZlYXR1cmVzL2ZlYXR1cmVzRGVlcERpdmUvbWF0ZXJpYWxzL3VzaW5nL21hdGVyaWFsc19pbnRyb2R1Y3Rpb24jdGV4dHVyZVxuICAgICAqIEBwYXJhbSB1cmwgZGVmaW5lcyB0aGUgdXJsIG9mIHRoZSBwaWN0dXJlIHRvIGxvYWQgYXMgYSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHNjZW5lT3JFbmdpbmUgZGVmaW5lcyB0aGUgc2NlbmUgb3IgZW5naW5lIHRoZSB0ZXh0dXJlIHdpbGwgYmVsb25nIHRvXG4gICAgICogQHBhcmFtIG5vTWlwbWFwT3JPcHRpb25zIGRlZmluZXMgaWYgdGhlIHRleHR1cmUgd2lsbCByZXF1aXJlIG1pcCBtYXBzIG9yIG5vdCBvciBzZXQgb2YgYWxsIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGludmVydFkgZGVmaW5lcyBpZiB0aGUgdGV4dHVyZSBuZWVkcyB0byBiZSBpbnZlcnRlZCBvbiB0aGUgeSBheGlzIGR1cmluZyBsb2FkaW5nXG4gICAgICogQHBhcmFtIHNhbXBsaW5nTW9kZSBkZWZpbmVzIHRoZSBzYW1wbGluZyBtb2RlIHdlIHdhbnQgZm9yIHRoZSB0ZXh0dXJlIHdoaWxlIGZldGNoaW5nIGZyb20gaXQgKFRleHR1cmUuTkVBUkVTVF9TQU1QTElOR01PREUuLi4pXG4gICAgICogQHBhcmFtIG9uTG9hZCBkZWZpbmVzIGEgY2FsbGJhY2sgdHJpZ2dlcmVkIHdoZW4gdGhlIHRleHR1cmUgaGFzIGJlZW4gbG9hZGVkXG4gICAgICogQHBhcmFtIG9uRXJyb3IgZGVmaW5lcyBhIGNhbGxiYWNrIHRyaWdnZXJlZCB3aGVuIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgbG9hZGluZyBzZXNzaW9uXG4gICAgICogQHBhcmFtIGJ1ZmZlciBkZWZpbmVzIHRoZSBidWZmZXIgdG8gbG9hZCB0aGUgdGV4dHVyZSBmcm9tIGluIGNhc2UgdGhlIHRleHR1cmUgaXMgbG9hZGVkIGZyb20gYSBidWZmZXIgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcGFyYW0gZGVsZXRlQnVmZmVyIGRlZmluZXMgaWYgdGhlIGJ1ZmZlciB3ZSBhcmUgbG9hZGluZyB0aGUgdGV4dHVyZSBmcm9tIHNob3VsZCBiZSBkZWxldGVkIGFmdGVyIGxvYWRcbiAgICAgKiBAcGFyYW0gZm9ybWF0IGRlZmluZXMgdGhlIGZvcm1hdCBvZiB0aGUgdGV4dHVyZSB3ZSBhcmUgdHJ5aW5nIHRvIGxvYWQgKEVuZ2luZS5URVhUVVJFRk9STUFUX1JHQkEuLi4pXG4gICAgICogQHBhcmFtIG1pbWVUeXBlIGRlZmluZXMgYW4gb3B0aW9uYWwgbWltZSB0eXBlIGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIGxvYWRlck9wdGlvbnMgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGxvYWRlclxuICAgICAqIEBwYXJhbSBjcmVhdGlvbkZsYWdzIHNwZWNpZmljIGZsYWdzIHRvIHVzZSB3aGVuIGNyZWF0aW5nIHRoZSB0ZXh0dXJlICgxIGZvciBzdG9yYWdlIHRleHR1cmVzLCBmb3IgZWcpXG4gICAgICogQHBhcmFtIGZvcmNlZEV4dGVuc2lvbiBkZWZpbmVzIHRoZSBleHRlbnNpb24gdG8gdXNlIHRvIHBpY2sgdGhlIHJpZ2h0IGxvYWRlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgc2NlbmVPckVuZ2luZSwgbm9NaXBtYXBPck9wdGlvbnMsIGludmVydFksIHNhbXBsaW5nTW9kZSA9IFRleHR1cmUuVFJJTElORUFSX1NBTVBMSU5HTU9ERSwgb25Mb2FkID0gbnVsbCwgb25FcnJvciA9IG51bGwsIGJ1ZmZlciA9IG51bGwsIGRlbGV0ZUJ1ZmZlciA9IGZhbHNlLCBmb3JtYXQsIG1pbWVUeXBlLCBsb2FkZXJPcHRpb25zLCBjcmVhdGlvbkZsYWdzLCBmb3JjZWRFeHRlbnNpb24pIHtcbiAgICAgICAgc3VwZXIoc2NlbmVPckVuZ2luZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgdGhlIHVybCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSBhbiBvZmZzZXQgb24gdGhlIHRleHR1cmUgdG8gb2Zmc2V0IHRoZSB1IGNvb3JkaW5hdGVzIG9mIHRoZSBVVnNcbiAgICAgICAgICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL2ZlYXR1cmVzL2ZlYXR1cmVzRGVlcERpdmUvbWF0ZXJpYWxzL3VzaW5nL21vcmVNYXRlcmlhbHMjb2Zmc2V0dGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51T2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSBhbiBvZmZzZXQgb24gdGhlIHRleHR1cmUgdG8gb2Zmc2V0IHRoZSB2IGNvb3JkaW5hdGVzIG9mIHRoZSBVVnNcbiAgICAgICAgICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL2ZlYXR1cmVzL2ZlYXR1cmVzRGVlcERpdmUvbWF0ZXJpYWxzL3VzaW5nL21vcmVNYXRlcmlhbHMjb2Zmc2V0dGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52T2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSBhbiBvZmZzZXQgb24gdGhlIHRleHR1cmUgdG8gc2NhbGUgdGhlIHUgY29vcmRpbmF0ZXMgb2YgdGhlIFVWc1xuICAgICAgICAgKiBAc2VlIGh0dHBzOi8vZG9jLmJhYnlsb25qcy5jb20vZmVhdHVyZXMvZmVhdHVyZXNEZWVwRGl2ZS9tYXRlcmlhbHMvdXNpbmcvbW9yZU1hdGVyaWFscyN0aWxpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudVNjYWxlID0gMS4wO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIGFuIG9mZnNldCBvbiB0aGUgdGV4dHVyZSB0byBzY2FsZSB0aGUgdiBjb29yZGluYXRlcyBvZiB0aGUgVVZzXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9kb2MuYmFieWxvbmpzLmNvbS9mZWF0dXJlcy9mZWF0dXJlc0RlZXBEaXZlL21hdGVyaWFscy91c2luZy9tb3JlTWF0ZXJpYWxzI3RpbGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52U2NhbGUgPSAxLjA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgYW4gb2Zmc2V0IG9uIHRoZSB0ZXh0dXJlIHRvIHJvdGF0ZSBhcm91bmQgdGhlIHUgY29vcmRpbmF0ZXMgb2YgdGhlIFVWc1xuICAgICAgICAgKiBUaGUgYW5nbGUgaXMgZGVmaW5lZCBpbiByYWRpYW5zLlxuICAgICAgICAgKiBAc2VlIGh0dHBzOi8vZG9jLmJhYnlsb25qcy5jb20vZmVhdHVyZXMvZmVhdHVyZXNEZWVwRGl2ZS9tYXRlcmlhbHMvdXNpbmcvbW9yZU1hdGVyaWFsc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51QW5nID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSBhbiBvZmZzZXQgb24gdGhlIHRleHR1cmUgdG8gcm90YXRlIGFyb3VuZCB0aGUgdiBjb29yZGluYXRlcyBvZiB0aGUgVVZzXG4gICAgICAgICAqIFRoZSBhbmdsZSBpcyBkZWZpbmVkIGluIHJhZGlhbnMuXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9kb2MuYmFieWxvbmpzLmNvbS9mZWF0dXJlcy9mZWF0dXJlc0RlZXBEaXZlL21hdGVyaWFscy91c2luZy9tb3JlTWF0ZXJpYWxzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZBbmcgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIGFuIG9mZnNldCBvbiB0aGUgdGV4dHVyZSB0byByb3RhdGUgYXJvdW5kIHRoZSB3IGNvb3JkaW5hdGVzIG9mIHRoZSBVVnMgKGluIGNhc2Ugb2YgM2QgdGV4dHVyZSlcbiAgICAgICAgICogVGhlIGFuZ2xlIGlzIGRlZmluZWQgaW4gcmFkaWFucy5cbiAgICAgICAgICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL2ZlYXR1cmVzL2ZlYXR1cmVzRGVlcERpdmUvbWF0ZXJpYWxzL3VzaW5nL21vcmVNYXRlcmlhbHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud0FuZyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBjZW50ZXIgb2Ygcm90YXRpb24gKFUpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVSb3RhdGlvbkNlbnRlciA9IDAuNTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGNlbnRlciBvZiByb3RhdGlvbiAoVilcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudlJvdGF0aW9uQ2VudGVyID0gMC41O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgY2VudGVyIG9mIHJvdGF0aW9uIChXKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53Um90YXRpb25DZW50ZXIgPSAwLjU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoaXMgcHJvcGVydHkgdG8gdHJ1ZSB0byBhdm9pZCBkZWZvcm1hdGlvbnMgd2hlbiByb3RhdGluZyB0aGUgdGV4dHVyZSB3aXRoIG5vbi11bmlmb3JtIHNjYWxpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaG9tb2dlbmVvdXNSb3RhdGlvbkluVVZUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgaW5zcGVjdGFibGUgY3VzdG9tIHByb3BlcnRpZXMgKHVzZWQgYnkgdGhlIEluc3BlY3RvcilcbiAgICAgICAgICogQHNlZSBodHRwczovL2RvYy5iYWJ5bG9uanMuY29tL3Rvb2xzQW5kUmVzb3VyY2VzL2luc3BlY3RvciNleHRlbnNpYmlsaXR5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluc3BlY3RhYmxlQ3VzdG9tUHJvcGVydGllcyA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fbm9NaXBtYXAgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9pbnZlcnRZID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jvd0dlbmVyYXRpb25NYXRyaXggPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvamVjdGlvbk1vZGVNYXRyaXggPSBudWxsO1xuICAgICAgICB0aGlzLl90MCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3QxID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdDIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWNoZWRVT2Zmc2V0ID0gLTE7XG4gICAgICAgIHRoaXMuX2NhY2hlZFZPZmZzZXQgPSAtMTtcbiAgICAgICAgdGhpcy5fY2FjaGVkVVNjYWxlID0gMDtcbiAgICAgICAgdGhpcy5fY2FjaGVkVlNjYWxlID0gMDtcbiAgICAgICAgdGhpcy5fY2FjaGVkVUFuZyA9IC0xO1xuICAgICAgICB0aGlzLl9jYWNoZWRWQW5nID0gLTE7XG4gICAgICAgIHRoaXMuX2NhY2hlZFdBbmcgPSAtMTtcbiAgICAgICAgdGhpcy5fY2FjaGVkUmVmbGVjdGlvblByb2plY3Rpb25NYXRyaXhJZCA9IC0xO1xuICAgICAgICB0aGlzLl9jYWNoZWRVUm90YXRpb25DZW50ZXIgPSAtMTtcbiAgICAgICAgdGhpcy5fY2FjaGVkVlJvdGF0aW9uQ2VudGVyID0gLTE7XG4gICAgICAgIHRoaXMuX2NhY2hlZFdSb3RhdGlvbkNlbnRlciA9IC0xO1xuICAgICAgICB0aGlzLl9jYWNoZWRIb21vZ2VuZW91c1JvdGF0aW9uSW5VVlRyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jYWNoZWRJZGVudGl0eTN4MiA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NhY2hlZFJlZmxlY3Rpb25UZXh0dXJlTWF0cml4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FjaGVkUmVmbGVjdGlvblVPZmZzZXQgPSAtMTtcbiAgICAgICAgdGhpcy5fY2FjaGVkUmVmbGVjdGlvblZPZmZzZXQgPSAtMTtcbiAgICAgICAgdGhpcy5fY2FjaGVkUmVmbGVjdGlvblVTY2FsZSA9IDA7XG4gICAgICAgIHRoaXMuX2NhY2hlZFJlZmxlY3Rpb25WU2NhbGUgPSAwO1xuICAgICAgICB0aGlzLl9jYWNoZWRSZWZsZWN0aW9uQ29vcmRpbmF0ZXNNb2RlID0gLTE7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGVsZXRlQnVmZmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Zvcm1hdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlbGF5ZWRPbkxvYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWxheWVkT25FcnJvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnNlcnZhYmxlIHRyaWdnZXJlZCBvbmNlIHRoZSB0ZXh0dXJlIGhhcyBiZWVuIGxvYWRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Mb2FkT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuX2lzQmxvY2tpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSB1cmwgfHwgXCJcIjtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIGxldCBub01pcG1hcDtcbiAgICAgICAgbGV0IHVzZVNSR0JCdWZmZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IGludGVybmFsVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIGxldCBnYW1tYVNwYWNlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBub01pcG1hcE9yT3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBub01pcG1hcE9yT3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbm9NaXBtYXAgPSBub01pcG1hcE9yT3B0aW9ucy5ub01pcG1hcCA/PyBmYWxzZTtcbiAgICAgICAgICAgIGludmVydFkgPSBub01pcG1hcE9yT3B0aW9ucy5pbnZlcnRZID8/ICF1c2VPcGVuR0xPcmllbnRhdGlvbkZvclVWO1xuICAgICAgICAgICAgc2FtcGxpbmdNb2RlID0gbm9NaXBtYXBPck9wdGlvbnMuc2FtcGxpbmdNb2RlID8/IFRleHR1cmUuVFJJTElORUFSX1NBTVBMSU5HTU9ERTtcbiAgICAgICAgICAgIG9uTG9hZCA9IG5vTWlwbWFwT3JPcHRpb25zLm9uTG9hZCA/PyBudWxsO1xuICAgICAgICAgICAgb25FcnJvciA9IG5vTWlwbWFwT3JPcHRpb25zLm9uRXJyb3IgPz8gbnVsbDtcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5vTWlwbWFwT3JPcHRpb25zLmJ1ZmZlciA/PyBudWxsO1xuICAgICAgICAgICAgZGVsZXRlQnVmZmVyID0gbm9NaXBtYXBPck9wdGlvbnMuZGVsZXRlQnVmZmVyID8/IGZhbHNlO1xuICAgICAgICAgICAgZm9ybWF0ID0gbm9NaXBtYXBPck9wdGlvbnMuZm9ybWF0O1xuICAgICAgICAgICAgbWltZVR5cGUgPSBub01pcG1hcE9yT3B0aW9ucy5taW1lVHlwZTtcbiAgICAgICAgICAgIGxvYWRlck9wdGlvbnMgPSBub01pcG1hcE9yT3B0aW9ucy5sb2FkZXJPcHRpb25zO1xuICAgICAgICAgICAgY3JlYXRpb25GbGFncyA9IG5vTWlwbWFwT3JPcHRpb25zLmNyZWF0aW9uRmxhZ3M7XG4gICAgICAgICAgICB1c2VTUkdCQnVmZmVyID0gbm9NaXBtYXBPck9wdGlvbnMudXNlU1JHQkJ1ZmZlciA/PyBmYWxzZTtcbiAgICAgICAgICAgIGludGVybmFsVGV4dHVyZSA9IG5vTWlwbWFwT3JPcHRpb25zLmludGVybmFsVGV4dHVyZSA/PyBudWxsO1xuICAgICAgICAgICAgZ2FtbWFTcGFjZSA9IG5vTWlwbWFwT3JPcHRpb25zLmdhbW1hU3BhY2UgPz8gZ2FtbWFTcGFjZTtcbiAgICAgICAgICAgIGZvcmNlZEV4dGVuc2lvbiA9IG5vTWlwbWFwT3JPcHRpb25zLmZvcmNlZEV4dGVuc2lvbiA/PyBmb3JjZWRFeHRlbnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub01pcG1hcCA9ICEhbm9NaXBtYXBPck9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2FtbWFTcGFjZSA9IGdhbW1hU3BhY2U7XG4gICAgICAgIHRoaXMuX25vTWlwbWFwID0gbm9NaXBtYXA7XG4gICAgICAgIHRoaXMuX2ludmVydFkgPSBpbnZlcnRZID09PSB1bmRlZmluZWQgPyAhdXNlT3BlbkdMT3JpZW50YXRpb25Gb3JVViA6IGludmVydFk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxTYW1wbGluZ01vZGUgPSBzYW1wbGluZ01vZGU7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5fZGVsZXRlQnVmZmVyID0gZGVsZXRlQnVmZmVyO1xuICAgICAgICB0aGlzLl9taW1lVHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICB0aGlzLl9sb2FkZXJPcHRpb25zID0gbG9hZGVyT3B0aW9ucztcbiAgICAgICAgdGhpcy5fY3JlYXRpb25GbGFncyA9IGNyZWF0aW9uRmxhZ3M7XG4gICAgICAgIHRoaXMuX3VzZVNSR0JCdWZmZXIgPSB1c2VTUkdCQnVmZmVyO1xuICAgICAgICB0aGlzLl9mb3JjZWRFeHRlbnNpb24gPSBmb3JjZWRFeHRlbnNpb247XG4gICAgICAgIGlmIChmb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5nZXRTY2VuZSgpO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9nZXRFbmdpbmUoKTtcbiAgICAgICAgaWYgKCFlbmdpbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbmdpbmUub25CZWZvcmVUZXh0dXJlSW5pdE9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZS5faW52ZXJ0VlNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudlNjYWxlICo9IC0xO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZPZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRleHR1cmUgdG8gbWF0Y2ggaW50ZXJuYWwgdGV4dHVyZSdzIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUuX2NhY2hlZFdyYXBVICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcFUgPSB0aGlzLl90ZXh0dXJlLl9jYWNoZWRXcmFwVTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5fY2FjaGVkV3JhcFUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZS5fY2FjaGVkV3JhcFYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwViA9IHRoaXMuX3RleHR1cmUuX2NhY2hlZFdyYXBWO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlLl9jYWNoZWRXcmFwViA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0dXJlLl9jYWNoZWRXcmFwUiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBSID0gdGhpcy5fdGV4dHVyZS5fY2FjaGVkV3JhcFI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmUuX2NhY2hlZFdyYXBSID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vbkxvYWRPYnNlcnZhYmxlLmhhc09ic2VydmVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBvbkxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Jsb2NraW5nICYmIHNjZW5lKSB7XG4gICAgICAgICAgICAgICAgc2NlbmUucmVzZXRDYWNoZWRNYXRlcmlhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAobWVzc2FnZSwgZXhjZXB0aW9uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkaW5nRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JPYmplY3QgPSB7IG1lc3NhZ2UsIGV4Y2VwdGlvbiB9O1xuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKG1lc3NhZ2UsIGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUZXh0dXJlLk9uVGV4dHVyZUxvYWRFcnJvck9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMudXJsICYmICFpbnRlcm5hbFRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ZWRPbkxvYWQgPSBsb2FkO1xuICAgICAgICAgICAgdGhpcy5fZGVsYXllZE9uRXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IGludGVybmFsVGV4dHVyZSA/PyB0aGlzLl9nZXRGcm9tQ2FjaGUodGhpcy51cmwsIG5vTWlwbWFwLCBzYW1wbGluZ01vZGUsIHRoaXMuX2ludmVydFksIHVzZVNSR0JCdWZmZXIsIHRoaXMuaXNDdWJlKTtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICBpZiAoIXNjZW5lIHx8ICFzY2VuZS51c2VEZWxheWVkVGV4dHVyZUxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlID0gZW5naW5lLmNyZWF0ZVRleHR1cmUodGhpcy51cmwsIG5vTWlwbWFwLCB0aGlzLl9pbnZlcnRZLCBzY2VuZSwgc2FtcGxpbmdNb2RlLCBsb2FkLCBlcnJvckhhbmRsZXIsIHRoaXMuX2J1ZmZlciwgdW5kZWZpbmVkLCB0aGlzLl9mb3JtYXQsIHRoaXMuX2ZvcmNlZEV4dGVuc2lvbiwgbWltZVR5cGUsIGxvYWRlck9wdGlvbnMsIGNyZWF0aW9uRmxhZ3MsIHVzZVNSR0JCdWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoXCJlcnJvciBsb2FkaW5nXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheUxvYWRTdGF0ZSA9IDQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsYXllZE9uTG9hZCA9IGxvYWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsYXllZE9uRXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZS5pc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgVGltaW5nVG9vbHMuU2V0SW1tZWRpYXRlKCgpID0+IGxvYWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkT2JzZXJ2ZXIgPSB0aGlzLl90ZXh0dXJlLm9uTG9hZGVkT2JzZXJ2YWJsZS5hZGQobG9hZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5vbkVycm9yT2JzZXJ2YWJsZS5hZGQoKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGUubWVzc2FnZSwgZS5leGNlcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlPy5vbkxvYWRlZE9ic2VydmFibGUucmVtb3ZlKGxvYWRPYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB1cmwgKGFuZCBvcHRpb25hbCBidWZmZXIpIG9mIHRoaXMgdGV4dHVyZSBpZiB1cmwgd2FzIG51bGwgZHVyaW5nIGNvbnN0cnVjdGlvbi5cbiAgICAgKiBAcGFyYW0gdXJsIHRoZSB1cmwgb2YgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gYnVmZmVyIHRoZSBidWZmZXIgb2YgdGhlIHRleHR1cmUgKGRlZmF1bHRzIHRvIG51bGwpXG4gICAgICogQHBhcmFtIG9uTG9hZCBjYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgdGV4dHVyZSBpcyBsb2FkZWQgIChkZWZhdWx0cyB0byBudWxsKVxuICAgICAqIEBwYXJhbSBmb3JjZWRFeHRlbnNpb24gZGVmaW5lcyB0aGUgZXh0ZW5zaW9uIHRvIHVzZSB0byBwaWNrIHRoZSByaWdodCBsb2FkZXJcbiAgICAgKi9cbiAgICB1cGRhdGVVUkwodXJsLCBidWZmZXIgPSBudWxsLCBvbkxvYWQsIGZvcmNlZEV4dGVuc2lvbikge1xuICAgICAgICBpZiAodGhpcy51cmwpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZUludGVybmFsVGV4dHVyZSgpO1xuICAgICAgICAgICAgdGhpcy5nZXRTY2VuZSgpLm1hcmtBbGxNYXRlcmlhbHNBc0RpcnR5KDEsIChtYXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Lmhhc1RleHR1cmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubmFtZSB8fCB0aGlzLm5hbWUuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5fZm9yY2VkRXh0ZW5zaW9uID0gZm9yY2VkRXh0ZW5zaW9uO1xuICAgICAgICB0aGlzLmRlbGF5TG9hZFN0YXRlID0gNDtcbiAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVsYXllZE9uTG9hZCA9IG9uTG9hZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5TG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggdGhlIGxvYWRpbmcgc2VxdWVuY2Ugb2YgYSB0ZXh0dXJlIGZsYWdnZWQgYXMgZGVsYXllZCBsb2FkLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGRlbGF5TG9hZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXlMb2FkU3RhdGUgIT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoKTtcbiAgICAgICAgaWYgKCFzY2VuZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXlMb2FkU3RhdGUgPSAxO1xuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdGhpcy5fZ2V0RnJvbUNhY2hlKHRoaXMudXJsLCB0aGlzLl9ub01pcG1hcCwgdGhpcy5zYW1wbGluZ01vZGUsIHRoaXMuX2ludmVydFksIHRoaXMuX3VzZVNSR0JCdWZmZXIsIHRoaXMuaXNDdWJlKTtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlID0gc2NlbmVcbiAgICAgICAgICAgICAgICAuZ2V0RW5naW5lKClcbiAgICAgICAgICAgICAgICAuY3JlYXRlVGV4dHVyZSh0aGlzLnVybCwgdGhpcy5fbm9NaXBtYXAsIHRoaXMuX2ludmVydFksIHNjZW5lLCB0aGlzLnNhbXBsaW5nTW9kZSwgdGhpcy5fZGVsYXllZE9uTG9hZCwgdGhpcy5fZGVsYXllZE9uRXJyb3IsIHRoaXMuX2J1ZmZlciwgbnVsbCwgdGhpcy5fZm9ybWF0LCB0aGlzLl9mb3JjZWRFeHRlbnNpb24sIHRoaXMuX21pbWVUeXBlLCB0aGlzLl9sb2FkZXJPcHRpb25zLCB0aGlzLl9jcmVhdGlvbkZsYWdzLCB0aGlzLl91c2VTUkdCQnVmZmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWxldGVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RlbGF5ZWRPbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZS5pc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgIFRpbWluZ1Rvb2xzLlNldEltbWVkaWF0ZSh0aGlzLl9kZWxheWVkT25Mb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmUub25Mb2FkZWRPYnNlcnZhYmxlLmFkZCh0aGlzLl9kZWxheWVkT25Mb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVsYXllZE9uTG9hZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlbGF5ZWRPbkVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgX3ByZXBhcmVSb3dGb3JUZXh0dXJlR2VuZXJhdGlvbih4LCB5LCB6LCB0KSB7XG4gICAgICAgIHggKj0gdGhpcy5fY2FjaGVkVVNjYWxlO1xuICAgICAgICB5ICo9IHRoaXMuX2NhY2hlZFZTY2FsZTtcbiAgICAgICAgeCAtPSB0aGlzLnVSb3RhdGlvbkNlbnRlciAqIHRoaXMuX2NhY2hlZFVTY2FsZTtcbiAgICAgICAgeSAtPSB0aGlzLnZSb3RhdGlvbkNlbnRlciAqIHRoaXMuX2NhY2hlZFZTY2FsZTtcbiAgICAgICAgeiAtPSB0aGlzLndSb3RhdGlvbkNlbnRlcjtcbiAgICAgICAgVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc0Zyb21GbG9hdHNUb1JlZih4LCB5LCB6LCB0aGlzLl9yb3dHZW5lcmF0aW9uTWF0cml4LCB0KTtcbiAgICAgICAgdC54ICs9IHRoaXMudVJvdGF0aW9uQ2VudGVyICogdGhpcy5fY2FjaGVkVVNjYWxlICsgdGhpcy5fY2FjaGVkVU9mZnNldDtcbiAgICAgICAgdC55ICs9IHRoaXMudlJvdGF0aW9uQ2VudGVyICogdGhpcy5fY2FjaGVkVlNjYWxlICsgdGhpcy5fY2FjaGVkVk9mZnNldDtcbiAgICAgICAgdC56ICs9IHRoaXMud1JvdGF0aW9uQ2VudGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgdGV4dHVyZSBtYXRyaXggd2hpY2ggaW5jbHVkZXMgdGhlIHJlcXVlc3RlZCBvZmZzZXR0aW5nLCB0aWxpbmcgYW5kIHJvdGF0aW9uIGNvbXBvbmVudHMuXG4gICAgICogQHBhcmFtIHVCYXNlIFRoZSBob3Jpem9udGFsIGJhc2Ugb2Zmc2V0IG11bHRpcGxpZXIgKDEgYnkgZGVmYXVsdClcbiAgICAgKiBAcmV0dXJucyB0aGUgdHJhbnNmb3JtIG1hdHJpeCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKi9cbiAgICBnZXRUZXh0dXJlTWF0cml4KHVCYXNlID0gMSkge1xuICAgICAgICBpZiAodGhpcy51T2Zmc2V0ID09PSB0aGlzLl9jYWNoZWRVT2Zmc2V0ICYmXG4gICAgICAgICAgICB0aGlzLnZPZmZzZXQgPT09IHRoaXMuX2NhY2hlZFZPZmZzZXQgJiZcbiAgICAgICAgICAgIHRoaXMudVNjYWxlICogdUJhc2UgPT09IHRoaXMuX2NhY2hlZFVTY2FsZSAmJlxuICAgICAgICAgICAgdGhpcy52U2NhbGUgPT09IHRoaXMuX2NhY2hlZFZTY2FsZSAmJlxuICAgICAgICAgICAgdGhpcy51QW5nID09PSB0aGlzLl9jYWNoZWRVQW5nICYmXG4gICAgICAgICAgICB0aGlzLnZBbmcgPT09IHRoaXMuX2NhY2hlZFZBbmcgJiZcbiAgICAgICAgICAgIHRoaXMud0FuZyA9PT0gdGhpcy5fY2FjaGVkV0FuZyAmJlxuICAgICAgICAgICAgdGhpcy51Um90YXRpb25DZW50ZXIgPT09IHRoaXMuX2NhY2hlZFVSb3RhdGlvbkNlbnRlciAmJlxuICAgICAgICAgICAgdGhpcy52Um90YXRpb25DZW50ZXIgPT09IHRoaXMuX2NhY2hlZFZSb3RhdGlvbkNlbnRlciAmJlxuICAgICAgICAgICAgdGhpcy53Um90YXRpb25DZW50ZXIgPT09IHRoaXMuX2NhY2hlZFdSb3RhdGlvbkNlbnRlciAmJlxuICAgICAgICAgICAgdGhpcy5ob21vZ2VuZW91c1JvdGF0aW9uSW5VVlRyYW5zZm9ybSA9PT0gdGhpcy5fY2FjaGVkSG9tb2dlbmVvdXNSb3RhdGlvbkluVVZUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhY2hlZFVPZmZzZXQgPSB0aGlzLnVPZmZzZXQ7XG4gICAgICAgIHRoaXMuX2NhY2hlZFZPZmZzZXQgPSB0aGlzLnZPZmZzZXQ7XG4gICAgICAgIHRoaXMuX2NhY2hlZFVTY2FsZSA9IHRoaXMudVNjYWxlICogdUJhc2U7XG4gICAgICAgIHRoaXMuX2NhY2hlZFZTY2FsZSA9IHRoaXMudlNjYWxlO1xuICAgICAgICB0aGlzLl9jYWNoZWRVQW5nID0gdGhpcy51QW5nO1xuICAgICAgICB0aGlzLl9jYWNoZWRWQW5nID0gdGhpcy52QW5nO1xuICAgICAgICB0aGlzLl9jYWNoZWRXQW5nID0gdGhpcy53QW5nO1xuICAgICAgICB0aGlzLl9jYWNoZWRVUm90YXRpb25DZW50ZXIgPSB0aGlzLnVSb3RhdGlvbkNlbnRlcjtcbiAgICAgICAgdGhpcy5fY2FjaGVkVlJvdGF0aW9uQ2VudGVyID0gdGhpcy52Um90YXRpb25DZW50ZXI7XG4gICAgICAgIHRoaXMuX2NhY2hlZFdSb3RhdGlvbkNlbnRlciA9IHRoaXMud1JvdGF0aW9uQ2VudGVyO1xuICAgICAgICB0aGlzLl9jYWNoZWRIb21vZ2VuZW91c1JvdGF0aW9uSW5VVlRyYW5zZm9ybSA9IHRoaXMuaG9tb2dlbmVvdXNSb3RhdGlvbkluVVZUcmFuc2Zvcm07XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeCB8fCAhdGhpcy5fcm93R2VuZXJhdGlvbk1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeCA9IE1hdHJpeC5aZXJvKCk7XG4gICAgICAgICAgICB0aGlzLl9yb3dHZW5lcmF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICAgICAgdGhpcy5fdDAgPSBWZWN0b3IzLlplcm8oKTtcbiAgICAgICAgICAgIHRoaXMuX3QxID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgICAgICB0aGlzLl90MiA9IFZlY3RvcjMuWmVybygpO1xuICAgICAgICB9XG4gICAgICAgIE1hdHJpeC5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKHRoaXMudkFuZywgdGhpcy51QW5nLCB0aGlzLndBbmcsIHRoaXMuX3Jvd0dlbmVyYXRpb25NYXRyaXgpO1xuICAgICAgICBpZiAodGhpcy5ob21vZ2VuZW91c1JvdGF0aW9uSW5VVlRyYW5zZm9ybSkge1xuICAgICAgICAgICAgTWF0cml4LlRyYW5zbGF0aW9uVG9SZWYoLXRoaXMuX2NhY2hlZFVSb3RhdGlvbkNlbnRlciwgLXRoaXMuX2NhY2hlZFZSb3RhdGlvbkNlbnRlciwgLXRoaXMuX2NhY2hlZFdSb3RhdGlvbkNlbnRlciwgVG1wVmVjdG9ycy5NYXRyaXhbMF0pO1xuICAgICAgICAgICAgTWF0cml4LlRyYW5zbGF0aW9uVG9SZWYodGhpcy5fY2FjaGVkVVJvdGF0aW9uQ2VudGVyLCB0aGlzLl9jYWNoZWRWUm90YXRpb25DZW50ZXIsIHRoaXMuX2NhY2hlZFdSb3RhdGlvbkNlbnRlciwgVG1wVmVjdG9ycy5NYXRyaXhbMV0pO1xuICAgICAgICAgICAgTWF0cml4LlNjYWxpbmdUb1JlZih0aGlzLl9jYWNoZWRVU2NhbGUsIHRoaXMuX2NhY2hlZFZTY2FsZSwgMCwgVG1wVmVjdG9ycy5NYXRyaXhbMl0pO1xuICAgICAgICAgICAgTWF0cml4LlRyYW5zbGF0aW9uVG9SZWYodGhpcy5fY2FjaGVkVU9mZnNldCwgdGhpcy5fY2FjaGVkVk9mZnNldCwgMCwgVG1wVmVjdG9ycy5NYXRyaXhbM10pO1xuICAgICAgICAgICAgVG1wVmVjdG9ycy5NYXRyaXhbMF0ubXVsdGlwbHlUb1JlZih0aGlzLl9yb3dHZW5lcmF0aW9uTWF0cml4LCB0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4KTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubXVsdGlwbHlUb1JlZihUbXBWZWN0b3JzLk1hdHJpeFsxXSwgdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4Lm11bHRpcGx5VG9SZWYoVG1wVmVjdG9ycy5NYXRyaXhbMl0sIHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeC5tdWx0aXBseVRvUmVmKFRtcFZlY3RvcnMuTWF0cml4WzNdLCB0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4KTtcbiAgICAgICAgICAgIC8vIGNvcHkgdGhlIHRyYW5zbGF0aW9uIHJvdyB0byB0aGUgM3JkIHJvdyBvZiB0aGUgbWF0cml4IHNvIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIHNoYWRlcnMgKHdoaWNoIGV4cGVjdHMgdGhlIHRyYW5zbGF0aW9uIHRvIGJlIG9uIHRoZSAzcmQgcm93KVxuICAgICAgICAgICAgdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeC5zZXRSb3dGcm9tRmxvYXRzKDIsIHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVsxMl0sIHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVsxM10sIHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVsxNF0sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZVJvd0ZvclRleHR1cmVHZW5lcmF0aW9uKDAsIDAsIDAsIHRoaXMuX3QwKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVSb3dGb3JUZXh0dXJlR2VuZXJhdGlvbigxLjAsIDAsIDAsIHRoaXMuX3QxKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVSb3dGb3JUZXh0dXJlR2VuZXJhdGlvbigwLCAxLjAsIDAsIHRoaXMuX3QyKTtcbiAgICAgICAgICAgIHRoaXMuX3QxLnN1YnRyYWN0SW5QbGFjZSh0aGlzLl90MCk7XG4gICAgICAgICAgICB0aGlzLl90Mi5zdWJ0cmFjdEluUGxhY2UodGhpcy5fdDApO1xuICAgICAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZih0aGlzLl90MS54LCB0aGlzLl90MS55LCB0aGlzLl90MS56LCAwLjAsIHRoaXMuX3QyLngsIHRoaXMuX3QyLnksIHRoaXMuX3QyLnosIDAuMCwgdGhpcy5fdDAueCwgdGhpcy5fdDAueSwgdGhpcy5fdDAueiwgMC4wLCAwLjAsIDAuMCwgMC4wLCAxLjAsIHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjZW5lID0gdGhpcy5nZXRTY2VuZSgpO1xuICAgICAgICBpZiAoIXNjZW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c0lkZW50aXR5M3gyID0gdGhpcy5fY2FjaGVkSWRlbnRpdHkzeDI7XG4gICAgICAgIHRoaXMuX2NhY2hlZElkZW50aXR5M3gyID0gdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeC5pc0lkZW50aXR5QXMzeDIoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW1pemVVVkFsbG9jYXRpb24gJiYgcHJldmlvdXNJZGVudGl0eTN4MiAhPT0gdGhpcy5fY2FjaGVkSWRlbnRpdHkzeDIpIHtcbiAgICAgICAgICAgIC8vIFdlIGZsYWcgdGhlIG1hdGVyaWFscyB0aGF0IGFyZSB1c2luZyB0aGlzIHRleHR1cmUgYXMgXCJ0ZXh0dXJlIGRpcnR5XCIgYmVjYXVzZSBkZXBlbmRpbmcgb24gdGhlIGZhY3QgdGhhdCB0aGUgbWF0cml4IGlzIHRoZSBpZGVudGl0eSBvciBub3QsIHNvbWUgZGVmaW5lc1xuICAgICAgICAgICAgLy8gd2lsbCBnZXQgZGlmZmVyZW50IHZhbHVlcyAoc2VlIFByZXBhcmVEZWZpbmVzRm9yTWVyZ2VkVVYpLCBtZWFuaW5nIHdlIHNob3VsZCByZWdlbmVyYXRlIHRoZSBlZmZlY3QgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgIHNjZW5lLm1hcmtBbGxNYXRlcmlhbHNBc0RpcnR5KDEsIChtYXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Lmhhc1RleHR1cmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IG1hdHJpeCB1c2VkIHRvIGFwcGx5IHJlZmxlY3Rpb24uIFRoaXMgaXMgdXNlZnVsIHRvIHJvdGF0ZSBhbiBlbnZpcm9ubWVudCB0ZXh0dXJlIGZvciBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVmbGVjdGlvbiB0ZXh0dXJlIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGdldFJlZmxlY3Rpb25UZXh0dXJlTWF0cml4KCkge1xuICAgICAgICBjb25zdCBzY2VuZSA9IHRoaXMuZ2V0U2NlbmUoKTtcbiAgICAgICAgaWYgKCFzY2VuZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFJlZmxlY3Rpb25UZXh0dXJlTWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVPZmZzZXQgPT09IHRoaXMuX2NhY2hlZFJlZmxlY3Rpb25VT2Zmc2V0ICYmXG4gICAgICAgICAgICB0aGlzLnZPZmZzZXQgPT09IHRoaXMuX2NhY2hlZFJlZmxlY3Rpb25WT2Zmc2V0ICYmXG4gICAgICAgICAgICB0aGlzLnVTY2FsZSA9PT0gdGhpcy5fY2FjaGVkUmVmbGVjdGlvblVTY2FsZSAmJlxuICAgICAgICAgICAgdGhpcy52U2NhbGUgPT09IHRoaXMuX2NhY2hlZFJlZmxlY3Rpb25WU2NhbGUgJiZcbiAgICAgICAgICAgIHRoaXMuY29vcmRpbmF0ZXNNb2RlID09PSB0aGlzLl9jYWNoZWRSZWZsZWN0aW9uQ29vcmRpbmF0ZXNNb2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb29yZGluYXRlc01vZGUgPT09IFRleHR1cmUuUFJPSkVDVElPTl9NT0RFKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlZFJlZmxlY3Rpb25Qcm9qZWN0aW9uTWF0cml4SWQgPT09IHNjZW5lLmdldFByb2plY3Rpb25NYXRyaXgoKS51cGRhdGVGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRSZWZsZWN0aW9uVGV4dHVyZU1hdHJpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUmVmbGVjdGlvblRleHR1cmVNYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRSZWZsZWN0aW9uVGV4dHVyZU1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkUmVmbGVjdGlvblRleHR1cmVNYXRyaXggPSBNYXRyaXguWmVybygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcHJvamVjdGlvbk1vZGVNYXRyaXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3Rpb25Nb2RlTWF0cml4ID0gTWF0cml4Llplcm8oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbGFnTWF0ZXJpYWxzQXNUZXh0dXJlRGlydHkgPSB0aGlzLl9jYWNoZWRSZWZsZWN0aW9uQ29vcmRpbmF0ZXNNb2RlICE9PSB0aGlzLmNvb3JkaW5hdGVzTW9kZTtcbiAgICAgICAgdGhpcy5fY2FjaGVkUmVmbGVjdGlvblVPZmZzZXQgPSB0aGlzLnVPZmZzZXQ7XG4gICAgICAgIHRoaXMuX2NhY2hlZFJlZmxlY3Rpb25WT2Zmc2V0ID0gdGhpcy52T2Zmc2V0O1xuICAgICAgICB0aGlzLl9jYWNoZWRSZWZsZWN0aW9uVVNjYWxlID0gdGhpcy51U2NhbGU7XG4gICAgICAgIHRoaXMuX2NhY2hlZFJlZmxlY3Rpb25WU2NhbGUgPSB0aGlzLnZTY2FsZTtcbiAgICAgICAgdGhpcy5fY2FjaGVkUmVmbGVjdGlvbkNvb3JkaW5hdGVzTW9kZSA9IHRoaXMuY29vcmRpbmF0ZXNNb2RlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY29vcmRpbmF0ZXNNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFRleHR1cmUuUExBTkFSX01PREU6IHtcbiAgICAgICAgICAgICAgICBNYXRyaXguSWRlbnRpdHlUb1JlZih0aGlzLl9jYWNoZWRSZWZsZWN0aW9uVGV4dHVyZU1hdHJpeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUmVmbGVjdGlvblRleHR1cmVNYXRyaXhbMF0gPSB0aGlzLnVTY2FsZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRSZWZsZWN0aW9uVGV4dHVyZU1hdHJpeFs1XSA9IHRoaXMudlNjYWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFJlZmxlY3Rpb25UZXh0dXJlTWF0cml4WzEyXSA9IHRoaXMudU9mZnNldDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRSZWZsZWN0aW9uVGV4dHVyZU1hdHJpeFsxM10gPSB0aGlzLnZPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFRleHR1cmUuUFJPSkVDVElPTl9NT0RFOiB7XG4gICAgICAgICAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZigwLjUsIDAuMCwgMC4wLCAwLjAsIDAuMCwgLTAuNSwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC41LCAwLjUsIDEuMCwgMS4wLCB0aGlzLl9wcm9qZWN0aW9uTW9kZU1hdHJpeCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IHNjZW5lLmdldFByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRSZWZsZWN0aW9uUHJvamVjdGlvbk1hdHJpeElkID0gcHJvamVjdGlvbk1hdHJpeC51cGRhdGVGbGFnO1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXgubXVsdGlwbHlUb1JlZih0aGlzLl9wcm9qZWN0aW9uTW9kZU1hdHJpeCwgdGhpcy5fY2FjaGVkUmVmbGVjdGlvblRleHR1cmVNYXRyaXgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBNYXRyaXguSWRlbnRpdHlUb1JlZih0aGlzLl9jYWNoZWRSZWZsZWN0aW9uVGV4dHVyZU1hdHJpeCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdNYXRlcmlhbHNBc1RleHR1cmVEaXJ0eSkge1xuICAgICAgICAgICAgLy8gV2UgZmxhZyB0aGUgbWF0ZXJpYWxzIHRoYXQgYXJlIHVzaW5nIHRoaXMgdGV4dHVyZSBhcyBcInRleHR1cmUgZGlydHlcIiBpZiB0aGUgY29vcmRpbmF0ZXNNb2RlIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgLy8gSW5kZWVkLCB0aGlzIHByb3BlcnR5IGlzIHVzZWQgdG8gc2V0IHRoZSB2YWx1ZSBvZiBzb21lIGRlZmluZXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZWZmZWN0IChpbiBtYXRlcmlhbC5pc1JlYWR5Rm9yU3ViTWVzaCksIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoaXMgY29kZSB3aWxsIGJlIHJlLWV4ZWN1dGVkIGFuZCB0aGUgZWZmZWN0IHJlY3JlYXRlZCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIHNjZW5lLm1hcmtBbGxNYXRlcmlhbHNBc0RpcnR5KDEsIChtYXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Lmhhc1RleHR1cmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUmVmbGVjdGlvblRleHR1cmVNYXRyaXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgY2xvbmVkIHRleHR1cmVcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5vTWlwbWFwOiB0aGlzLl9ub01pcG1hcCxcbiAgICAgICAgICAgIGludmVydFk6IHRoaXMuX2ludmVydFksXG4gICAgICAgICAgICBzYW1wbGluZ01vZGU6IHRoaXMuc2FtcGxpbmdNb2RlLFxuICAgICAgICAgICAgb25Mb2FkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvbkVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBidWZmZXI6IHRoaXMuX3RleHR1cmUgPyB0aGlzLl90ZXh0dXJlLl9idWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkZWxldGVCdWZmZXI6IHRoaXMuX2RlbGV0ZUJ1ZmZlcixcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy50ZXh0dXJlRm9ybWF0LFxuICAgICAgICAgICAgbWltZVR5cGU6IHRoaXMubWltZVR5cGUsXG4gICAgICAgICAgICBsb2FkZXJPcHRpb25zOiB0aGlzLl9sb2FkZXJPcHRpb25zLFxuICAgICAgICAgICAgY3JlYXRpb25GbGFnczogdGhpcy5fY3JlYXRpb25GbGFncyxcbiAgICAgICAgICAgIHVzZVNSR0JCdWZmZXI6IHRoaXMuX3VzZVNSR0JCdWZmZXIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTZXJpYWxpemF0aW9uSGVscGVyLkNsb25lKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dHVyZSh0aGlzLl90ZXh0dXJlID8gdGhpcy5fdGV4dHVyZS51cmwgOiBudWxsLCB0aGlzLmdldFNjZW5lKCksIG9wdGlvbnMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSB0ZXh0dXJlIHRvIGEgSlNPTiByZXByZXNlbnRhdGlvbiB3ZSBjYW4gZWFzaWx5IHVzZSBpbiB0aGUgcmVzcGVjdGl2ZSBQYXJzZSBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2F2ZWROYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBpZiAoIVRleHR1cmUuU2VyaWFsaXplQnVmZmVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMubmFtZS5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5hbWUuc3RhcnRzV2l0aChcImRhdGE6XCIpICYmIHRoaXMudXJsID09PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMudXJsID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpYWxpemF0aW9uT2JqZWN0ID0gc3VwZXIuc2VyaWFsaXplKFRleHR1cmUuX1NlcmlhbGl6ZUludGVybmFsVGV4dHVyZVVuaXF1ZUlkKTtcbiAgICAgICAgaWYgKCFzZXJpYWxpemF0aW9uT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVGV4dHVyZS5TZXJpYWxpemVCdWZmZXJzIHx8IFRleHR1cmUuRm9yY2VTZXJpYWxpemVCdWZmZXJzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2J1ZmZlciA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzLl9idWZmZXIuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9iamVjdC5iYXNlNjRTdHJpbmcgPSB0aGlzLl9idWZmZXI7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9iamVjdC5uYW1lID0gc2VyaWFsaXphdGlvbk9iamVjdC5uYW1lLnJlcGxhY2UoXCJkYXRhOlwiLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudXJsICYmIHRoaXMudXJsLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSAmJiB0aGlzLl9idWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWltZVR5cGUgPSB0aGlzLm1pbWVUeXBlIHx8IFwiaW1hZ2UvcG5nXCI7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9iamVjdC5iYXNlNjRTdHJpbmcgPSBgZGF0YToke21pbWVUeXBlfTtiYXNlNjQsJHtFbmNvZGVBcnJheUJ1ZmZlclRvQmFzZTY0KHRoaXMuX2J1ZmZlcil9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFRleHR1cmUuRm9yY2VTZXJpYWxpemVCdWZmZXJzIHx8ICh0aGlzLnVybCAmJiB0aGlzLnVybC5zdGFydHNXaXRoKFwiYmxvYjpcIikpIHx8IHRoaXMuX2ZvcmNlU2VyaWFsaXplKSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9iamVjdC5iYXNlNjRTdHJpbmcgPVxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5fZW5naW5lIHx8IHRoaXMuX2VuZ2luZS5fZmVhdHVyZXMuc3VwcG9ydFN5bmNUZXh0dXJlUmVhZCA/IEdlbmVyYXRlQmFzZTY0U3RyaW5nRnJvbVRleHR1cmUodGhpcykgOiBHZW5lcmF0ZUJhc2U2NFN0cmluZ0Zyb21UZXh0dXJlQXN5bmModGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWFsaXphdGlvbk9iamVjdC5pbnZlcnRZID0gdGhpcy5faW52ZXJ0WTtcbiAgICAgICAgc2VyaWFsaXphdGlvbk9iamVjdC5zYW1wbGluZ01vZGUgPSB0aGlzLnNhbXBsaW5nTW9kZTtcbiAgICAgICAgc2VyaWFsaXphdGlvbk9iamVjdC5fY3JlYXRpb25GbGFncyA9IHRoaXMuX2NyZWF0aW9uRmxhZ3M7XG4gICAgICAgIHNlcmlhbGl6YXRpb25PYmplY3QuX3VzZVNSR0JCdWZmZXIgPSB0aGlzLl91c2VTUkdCQnVmZmVyO1xuICAgICAgICBpZiAoVGV4dHVyZS5fU2VyaWFsaXplSW50ZXJuYWxUZXh0dXJlVW5pcXVlSWQpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25PYmplY3QuaW50ZXJuYWxUZXh0dXJlVW5pcXVlSWQgPSB0aGlzLl90ZXh0dXJlPy51bmlxdWVJZDtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemF0aW9uT2JqZWN0LmludGVybmFsVGV4dHVyZUxhYmVsID0gdGhpcy5fdGV4dHVyZT8ubGFiZWw7XG4gICAgICAgIHNlcmlhbGl6YXRpb25PYmplY3Qubm9NaXBtYXAgPSB0aGlzLl9ub01pcG1hcDtcbiAgICAgICAgdGhpcy5uYW1lID0gc2F2ZWROYW1lO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXphdGlvbk9iamVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGNsYXNzIG5hbWUgb2YgdGhlIHRleHR1cmUgdXNlZnVsIGZvciBzZXJpYWxpemF0aW9uIG9yIGR5bmFtaWMgY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFwiVGV4dHVyZVwiXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJUZXh0dXJlXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgdGhlIHRleHR1cmUgYW5kIHJlbGVhc2UgaXRzIGFzc29jaWF0ZWQgcmVzb3VyY2VzLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbkxvYWRPYnNlcnZhYmxlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2RlbGF5ZWRPbkxvYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWxheWVkT25FcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgdGV4dHVyZSBpbiBvcmRlciB0byByZWNyZWF0ZSB0aGUgdGV4dHVyZSBpbiB0aGUgZ2l2ZW4gc2NlbmUuXG4gICAgICogQHBhcmFtIHBhcnNlZFRleHR1cmUgRGVmaW5lIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHNjZW5lIERlZmluZSB0aGUgc2NlbmUgdGhlIHBhcnNlZCB0ZXh0dXJlIHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgaW5cbiAgICAgKiBAcGFyYW0gcm9vdFVybCBEZWZpbmUgdGhlIHJvb3QgdXJsIG9mIHRoZSBwYXJzaW5nIHNlcXVlbmNlIGluIHRoZSBjYXNlIG9mIHJlbGF0aXZlIGRlcGVuZGVuY2llc1xuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdGV4dHVyZSBpZiBzdWNjZXNzZnVsXG4gICAgICovXG4gICAgc3RhdGljIFBhcnNlKHBhcnNlZFRleHR1cmUsIHNjZW5lLCByb290VXJsKSB7XG4gICAgICAgIGlmIChwYXJzZWRUZXh0dXJlLmN1c3RvbVR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbVRleHR1cmUgPSBJbnN0YW50aWF0aW9uVG9vbHMuSW5zdGFudGlhdGUocGFyc2VkVGV4dHVyZS5jdXN0b21UeXBlKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBTYW1wbGluZyBNb2RlXG4gICAgICAgICAgICBjb25zdCBwYXJzZWRDdXN0b21UZXh0dXJlID0gY3VzdG9tVGV4dHVyZS5QYXJzZShwYXJzZWRUZXh0dXJlLCBzY2VuZSwgcm9vdFVybCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkVGV4dHVyZS5zYW1wbGluZ01vZGUgJiYgcGFyc2VkQ3VzdG9tVGV4dHVyZS51cGRhdGVTYW1wbGluZ01vZGUgJiYgcGFyc2VkQ3VzdG9tVGV4dHVyZS5fc2FtcGxpbmdNb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZEN1c3RvbVRleHR1cmUuX3NhbXBsaW5nTW9kZSAhPT0gcGFyc2VkVGV4dHVyZS5zYW1wbGluZ01vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQ3VzdG9tVGV4dHVyZS51cGRhdGVTYW1wbGluZ01vZGUocGFyc2VkVGV4dHVyZS5zYW1wbGluZ01vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRDdXN0b21UZXh0dXJlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWRUZXh0dXJlLmlzQ3ViZSAmJiAhcGFyc2VkVGV4dHVyZS5pc1JlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuX0N1YmVUZXh0dXJlUGFyc2VyKHBhcnNlZFRleHR1cmUsIHNjZW5lLCByb290VXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNJbnRlcm5hbFRleHR1cmVVbmlxdWVJZCA9IHBhcnNlZFRleHR1cmUuaW50ZXJuYWxUZXh0dXJlVW5pcXVlSWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFwYXJzZWRUZXh0dXJlLm5hbWUgJiYgIXBhcnNlZFRleHR1cmUuaXNSZW5kZXJUYXJnZXQgJiYgIWhhc0ludGVybmFsVGV4dHVyZVVuaXF1ZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW50ZXJuYWxUZXh0dXJlO1xuICAgICAgICBpZiAoaGFzSW50ZXJuYWxUZXh0dXJlVW5pcXVlSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gc2NlbmUuZ2V0RW5naW5lKCkuZ2V0TG9hZGVkVGV4dHVyZXNDYWNoZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0ZXh0dXJlIG9mIGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmUudW5pcXVlSWQgPT09IHBhcnNlZFRleHR1cmUuaW50ZXJuYWxUZXh0dXJlVW5pcXVlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uTG9hZGVkID0gKHRleHR1cmUpID0+IHtcbiAgICAgICAgICAgIC8vIENsZWFyIGNhY2hlXG4gICAgICAgICAgICBpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5fdGV4dHVyZS5fY2FjaGVkV3JhcFUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRleHR1cmUuX3RleHR1cmUuX2NhY2hlZFdyYXBWID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLl90ZXh0dXJlLl9jYWNoZWRXcmFwUiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgU2FtcGxpbmcgTW9kZVxuICAgICAgICAgICAgaWYgKHBhcnNlZFRleHR1cmUuc2FtcGxpbmdNb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxpbmcgPSBwYXJzZWRUZXh0dXJlLnNhbXBsaW5nTW9kZTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLnNhbXBsaW5nTW9kZSAhPT0gc2FtcGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS51cGRhdGVTYW1wbGluZ01vZGUoc2FtcGxpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbnNcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlICYmIHBhcnNlZFRleHR1cmUuYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGFuaW1hdGlvbkluZGV4ID0gMDsgYW5pbWF0aW9uSW5kZXggPCBwYXJzZWRUZXh0dXJlLmFuaW1hdGlvbnMubGVuZ3RoOyBhbmltYXRpb25JbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFuaW1hdGlvbiA9IHBhcnNlZFRleHR1cmUuYW5pbWF0aW9uc1thbmltYXRpb25JbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsQ2xhc3MgPSBHZXRDbGFzcyhcIkJBQllMT04uQW5pbWF0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5hbmltYXRpb25zLnB1c2goaW50ZXJuYWxDbGFzcy5QYXJzZShwYXJzZWRBbmltYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0dXJlICYmIHRleHR1cmUuX3RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzSW50ZXJuYWxUZXh0dXJlVW5pcXVlSWQgJiYgIWludGVybmFsVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLl90ZXh0dXJlLl9zZXRVbmlxdWVJZChwYXJzZWRUZXh0dXJlLmludGVybmFsVGV4dHVyZVVuaXF1ZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5fdGV4dHVyZS5sYWJlbCA9IHBhcnNlZFRleHR1cmUuaW50ZXJuYWxUZXh0dXJlTGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBTZXJpYWxpemF0aW9uSGVscGVyLlBhcnNlKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBnZW5lcmF0ZU1pcE1hcHMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHBhcnNlZFRleHR1cmUubm9NaXBtYXApIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pcE1hcHMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZWRUZXh0dXJlLm1pcnJvclBsYW5lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlycm9yVGV4dHVyZSA9IFRleHR1cmUuX0NyZWF0ZU1pcnJvcihwYXJzZWRUZXh0dXJlLm5hbWUsIHBhcnNlZFRleHR1cmUucmVuZGVyVGFyZ2V0U2l6ZSwgc2NlbmUsIGdlbmVyYXRlTWlwTWFwcyk7XG4gICAgICAgICAgICAgICAgbWlycm9yVGV4dHVyZS5fd2FpdGluZ1JlbmRlckxpc3QgPSBwYXJzZWRUZXh0dXJlLnJlbmRlckxpc3Q7XG4gICAgICAgICAgICAgICAgbWlycm9yVGV4dHVyZS5taXJyb3JQbGFuZSA9IFBsYW5lLkZyb21BcnJheShwYXJzZWRUZXh0dXJlLm1pcnJvclBsYW5lKTtcbiAgICAgICAgICAgICAgICBvbkxvYWRlZChtaXJyb3JUZXh0dXJlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlycm9yVGV4dHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlZFRleHR1cmUuaXNSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyVGFyZ2V0VGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFRleHR1cmUuaXNDdWJlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgYW4gZXhpc3RpbmcgcmVmbGVjdGlvbiBwcm9iZSAod2hpY2ggY29udGFpbnMgYSBjdWJlIHJlbmRlciB0YXJnZXQgdGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjZW5lLnJlZmxlY3Rpb25Qcm9iZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBzY2VuZS5yZWZsZWN0aW9uUHJvYmVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2JlID0gc2NlbmUucmVmbGVjdGlvblByb2Jlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2JlLm5hbWUgPT09IHBhcnNlZFRleHR1cmUubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvYmUuY3ViZVRleHR1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRUZXh0dXJlID0gVGV4dHVyZS5fQ3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZShwYXJzZWRUZXh0dXJlLm5hbWUsIHBhcnNlZFRleHR1cmUucmVuZGVyVGFyZ2V0U2l6ZSwgc2NlbmUsIGdlbmVyYXRlTWlwTWFwcywgcGFyc2VkVGV4dHVyZS5fY3JlYXRpb25GbGFncyA/PyAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0VGV4dHVyZS5fd2FpdGluZ1JlbmRlckxpc3QgPSBwYXJzZWRUZXh0dXJlLnJlbmRlckxpc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uTG9hZGVkKHJlbmRlclRhcmdldFRleHR1cmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJUYXJnZXRUZXh0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VkVGV4dHVyZS5pc1ZpZGVvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IFRleHR1cmUuX0NyZWF0ZVZpZGVvVGV4dHVyZShyb290VXJsICsgKHBhcnNlZFRleHR1cmUudXJsIHx8IHBhcnNlZFRleHR1cmUubmFtZSksIHJvb3RVcmwgKyAocGFyc2VkVGV4dHVyZS5zcmMgfHwgcGFyc2VkVGV4dHVyZS51cmwpLCBzY2VuZSwgZ2VuZXJhdGVNaXBNYXBzLCBwYXJzZWRUZXh0dXJlLmludmVydFksIHBhcnNlZFRleHR1cmUuc2FtcGxpbmdNb2RlLCBwYXJzZWRUZXh0dXJlLnNldHRpbmdzIHx8IHt9KTtcbiAgICAgICAgICAgICAgICBvbkxvYWRlZCh0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRUZXh0dXJlLmJhc2U2NFN0cmluZyAmJiAhaW50ZXJuYWxUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHVybCBhcmUgdGhlIHNhbWUgdG8gZW5zdXJlIGNhY2hpbmcgaGFwcGVucyBmcm9tIHRoZSBhY3R1YWwgYmFzZTY0IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gVGV4dHVyZS5DcmVhdGVGcm9tQmFzZTY0U3RyaW5nKHBhcnNlZFRleHR1cmUuYmFzZTY0U3RyaW5nLCBwYXJzZWRUZXh0dXJlLmJhc2U2NFN0cmluZywgc2NlbmUsICFnZW5lcmF0ZU1pcE1hcHMsIHBhcnNlZFRleHR1cmUuaW52ZXJ0WSwgcGFyc2VkVGV4dHVyZS5zYW1wbGluZ01vZGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZGVkKHRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBwYXJzZWRUZXh0dXJlLl9jcmVhdGlvbkZsYWdzID8/IDAsIHBhcnNlZFRleHR1cmUuX3VzZVNSR0JCdWZmZXIgPz8gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV0dGllciBuYW1lIHRvIGZpdCB3aXRoIHRoZSBsb2FkZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSBwYXJzZWRUZXh0dXJlLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkVGV4dHVyZS5uYW1lICYmIChwYXJzZWRUZXh0dXJlLm5hbWUuaW5kZXhPZihcIjovL1wiKSA+IDAgfHwgcGFyc2VkVGV4dHVyZS5uYW1lLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHBhcnNlZFRleHR1cmUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHJvb3RVcmwgKyBwYXJzZWRUZXh0dXJlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZFRleHR1cmUudXJsICYmIChwYXJzZWRUZXh0dXJlLnVybC5zdGFydHNXaXRoKFwiZGF0YTpcIikgfHwgVGV4dHVyZS5Vc2VTZXJpYWxpemVkVXJsSWZBbnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBwYXJzZWRUZXh0dXJlLnVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9NaXBtYXA6ICFnZW5lcmF0ZU1pcE1hcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnRZOiBwYXJzZWRUZXh0dXJlLmludmVydFksXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGluZ01vZGU6IHBhcnNlZFRleHR1cmUuc2FtcGxpbmdNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25Mb2FkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Mb2FkZWQodGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUodXJsLCBzY2VuZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBwYXJzZWRUZXh0dXJlLCBzY2VuZSk7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGV4dHVyZSBmcm9tIGl0cyBiYXNlIDY0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSBkYXRhIERlZmluZSB0aGUgYmFzZTY0IHBheWxvYWQgd2l0aG91dCB0aGUgZGF0YTogcHJlZml4XG4gICAgICogQHBhcmFtIG5hbWUgRGVmaW5lIHRoZSBuYW1lIG9mIHRoZSB0ZXh0dXJlIGluIHRoZSBzY2VuZSB1c2VmdWwgZm8gY2FjaGluZyBwdXJwb3NlIGZvciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBzY2VuZSBEZWZpbmUgdGhlIHNjZW5lIHRoZSB0ZXh0dXJlIHNob3VsZCBiZWxvbmcgdG9cbiAgICAgKiBAcGFyYW0gbm9NaXBtYXBPck9wdGlvbnMgZGVmaW5lcyBpZiB0aGUgdGV4dHVyZSB3aWxsIHJlcXVpcmUgbWlwIG1hcHMgb3Igbm90IG9yIHNldCBvZiBhbGwgb3B0aW9ucyB0byBjcmVhdGUgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gaW52ZXJ0WSBkZWZpbmUgaWYgdGhlIHRleHR1cmUgbmVlZHMgdG8gYmUgaW52ZXJ0ZWQgb24gdGhlIHkgYXhpcyBkdXJpbmcgbG9hZGluZ1xuICAgICAqIEBwYXJhbSBzYW1wbGluZ01vZGUgZGVmaW5lIHRoZSBzYW1wbGluZyBtb2RlIHdlIHdhbnQgZm9yIHRoZSB0ZXh0dXJlIHdoaWxlIGZldGNoaW5nIGZyb20gaXQgKFRleHR1cmUuTkVBUkVTVF9TQU1QTElOR01PREUuLi4pXG4gICAgICogQHBhcmFtIG9uTG9hZCBkZWZpbmUgYSBjYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiB0aGUgdGV4dHVyZSBoYXMgYmVlbiBsb2FkZWRcbiAgICAgKiBAcGFyYW0gb25FcnJvciBkZWZpbmUgYSBjYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGxvYWRpbmcgc2Vzc2lvblxuICAgICAqIEBwYXJhbSBmb3JtYXQgZGVmaW5lIHRoZSBmb3JtYXQgb2YgdGhlIHRleHR1cmUgd2UgYXJlIHRyeWluZyB0byBsb2FkIChFbmdpbmUuVEVYVFVSRUZPUk1BVF9SR0JBLi4uKVxuICAgICAqIEBwYXJhbSBjcmVhdGlvbkZsYWdzIHNwZWNpZmljIGZsYWdzIHRvIHVzZSB3aGVuIGNyZWF0aW5nIHRoZSB0ZXh0dXJlICgxIGZvciBzdG9yYWdlIHRleHR1cmVzLCBmb3IgZWcpXG4gICAgICogQHBhcmFtIGZvcmNlZEV4dGVuc2lvbiBkZWZpbmVzIHRoZSBleHRlbnNpb24gdG8gdXNlIHRvIHBpY2sgdGhlIHJpZ2h0IGxvYWRlclxuICAgICAqIEByZXR1cm5zIHRoZSBjcmVhdGVkIHRleHR1cmVcbiAgICAgKi9cbiAgICBzdGF0aWMgQ3JlYXRlRnJvbUJhc2U2NFN0cmluZyhkYXRhLCBuYW1lLCBzY2VuZSwgbm9NaXBtYXBPck9wdGlvbnMsIGludmVydFksIHNhbXBsaW5nTW9kZSA9IFRleHR1cmUuVFJJTElORUFSX1NBTVBMSU5HTU9ERSwgb25Mb2FkID0gbnVsbCwgb25FcnJvciA9IG51bGwsIGZvcm1hdCA9IDUsIGNyZWF0aW9uRmxhZ3MsIGZvcmNlZEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IFRleHR1cmUoXCJkYXRhOlwiICsgbmFtZSwgc2NlbmUsIG5vTWlwbWFwT3JPcHRpb25zLCBpbnZlcnRZLCBzYW1wbGluZ01vZGUsIG9uTG9hZCwgb25FcnJvciwgZGF0YSwgZmFsc2UsIGZvcm1hdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNyZWF0aW9uRmxhZ3MsIGZvcmNlZEV4dGVuc2lvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0ZXh0dXJlIGZyb20gaXRzIGRhdGE6IHJlcHJlc2VudGF0aW9uLiAoZGF0YTogd2lsbCBiZSBhZGRlZCBpbiBjYXNlIG9ubHkgdGhlIHBheWxvYWQgaGFzIGJlZW4gcGFzc2VkIGluKVxuICAgICAqIEBwYXJhbSBuYW1lIERlZmluZSB0aGUgbmFtZSBvZiB0aGUgdGV4dHVyZSBpbiB0aGUgc2NlbmUgdXNlZnVsIGZvIGNhY2hpbmcgcHVycG9zZSBmb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gYnVmZmVyIGRlZmluZSB0aGUgYnVmZmVyIHRvIGxvYWQgdGhlIHRleHR1cmUgZnJvbSBpbiBjYXNlIHRoZSB0ZXh0dXJlIGlzIGxvYWRlZCBmcm9tIGEgYnVmZmVyIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIHNjZW5lIERlZmluZSB0aGUgc2NlbmUgdGhlIHRleHR1cmUgc2hvdWxkIGJlbG9uZyB0b1xuICAgICAqIEBwYXJhbSBkZWxldGVCdWZmZXIgZGVmaW5lIGlmIHRoZSBidWZmZXIgd2UgYXJlIGxvYWRpbmcgdGhlIHRleHR1cmUgZnJvbSBzaG91bGQgYmUgZGVsZXRlZCBhZnRlciBsb2FkXG4gICAgICogQHBhcmFtIG5vTWlwbWFwT3JPcHRpb25zIGRlZmluZXMgaWYgdGhlIHRleHR1cmUgd2lsbCByZXF1aXJlIG1pcCBtYXBzIG9yIG5vdCBvciBzZXQgb2YgYWxsIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGludmVydFkgZGVmaW5lIGlmIHRoZSB0ZXh0dXJlIG5lZWRzIHRvIGJlIGludmVydGVkIG9uIHRoZSB5IGF4aXMgZHVyaW5nIGxvYWRpbmdcbiAgICAgKiBAcGFyYW0gc2FtcGxpbmdNb2RlIGRlZmluZSB0aGUgc2FtcGxpbmcgbW9kZSB3ZSB3YW50IGZvciB0aGUgdGV4dHVyZSB3aGlsZSBmZXRjaGluZyBmcm9tIGl0IChUZXh0dXJlLk5FQVJFU1RfU0FNUExJTkdNT0RFLi4uKVxuICAgICAqIEBwYXJhbSBvbkxvYWQgZGVmaW5lIGEgY2FsbGJhY2sgdHJpZ2dlcmVkIHdoZW4gdGhlIHRleHR1cmUgaGFzIGJlZW4gbG9hZGVkXG4gICAgICogQHBhcmFtIG9uRXJyb3IgZGVmaW5lIGEgY2FsbGJhY2sgdHJpZ2dlcmVkIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBsb2FkaW5nIHNlc3Npb25cbiAgICAgKiBAcGFyYW0gZm9ybWF0IGRlZmluZSB0aGUgZm9ybWF0IG9mIHRoZSB0ZXh0dXJlIHdlIGFyZSB0cnlpbmcgdG8gbG9hZCAoRW5naW5lLlRFWFRVUkVGT1JNQVRfUkdCQS4uLilcbiAgICAgKiBAcGFyYW0gY3JlYXRpb25GbGFncyBzcGVjaWZpYyBmbGFncyB0byB1c2Ugd2hlbiBjcmVhdGluZyB0aGUgdGV4dHVyZSAoMSBmb3Igc3RvcmFnZSB0ZXh0dXJlcywgZm9yIGVnKVxuICAgICAqIEBwYXJhbSBmb3JjZWRFeHRlbnNpb24gZGVmaW5lcyB0aGUgZXh0ZW5zaW9uIHRvIHVzZSB0byBwaWNrIHRoZSByaWdodCBsb2FkZXJcbiAgICAgKiBAcmV0dXJucyB0aGUgY3JlYXRlZCB0ZXh0dXJlXG4gICAgICovXG4gICAgc3RhdGljIExvYWRGcm9tRGF0YVN0cmluZyhuYW1lLCBidWZmZXIsIHNjZW5lLCBkZWxldGVCdWZmZXIgPSBmYWxzZSwgbm9NaXBtYXBPck9wdGlvbnMsIGludmVydFkgPSB0cnVlLCBzYW1wbGluZ01vZGUgPSBUZXh0dXJlLlRSSUxJTkVBUl9TQU1QTElOR01PREUsIG9uTG9hZCA9IG51bGwsIG9uRXJyb3IgPSBudWxsLCBmb3JtYXQgPSA1LCBjcmVhdGlvbkZsYWdzLCBmb3JjZWRFeHRlbnNpb24pIHtcbiAgICAgICAgaWYgKG5hbWUuc3Vic3RyaW5nKDAsIDUpICE9PSBcImRhdGE6XCIpIHtcbiAgICAgICAgICAgIG5hbWUgPSBcImRhdGE6XCIgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZShuYW1lLCBzY2VuZSwgbm9NaXBtYXBPck9wdGlvbnMsIGludmVydFksIHNhbXBsaW5nTW9kZSwgb25Mb2FkLCBvbkVycm9yLCBidWZmZXIsIGRlbGV0ZUJ1ZmZlciwgZm9ybWF0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY3JlYXRpb25GbGFncywgZm9yY2VkRXh0ZW5zaW9uKTtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgb3Igc2V0cyBhIGdlbmVyYWwgYm9vbGVhbiB1c2VkIHRvIGluZGljYXRlIHRoYXQgdGV4dHVyZXMgY29udGFpbmluZyBkaXJlY3QgZGF0YSAoYnVmZmVycykgbXVzdCBiZSBzYXZlZCBhcyBwYXJ0IG9mIHRoZSBzZXJpYWxpemF0aW9uIHByb2Nlc3NcbiAqL1xuVGV4dHVyZS5TZXJpYWxpemVCdWZmZXJzID0gdHJ1ZTtcbi8qKlxuICogR2V0cyBvciBzZXRzIGEgZ2VuZXJhbCBib29sZWFuIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB0ZXh0dXJlIGJ1ZmZlcnMgbXVzdCBiZSBzYXZlZCBhcyBwYXJ0IG9mIHRoZSBzZXJpYWxpemF0aW9uIHByb2Nlc3MuXG4gKiBJZiBubyBidWZmZXIgZXhpc3RzLCBvbmUgd2lsbCBiZSBjcmVhdGVkIGFzIGJhc2U2NCBzdHJpbmcgZnJvbSB0aGUgaW50ZXJuYWwgd2ViZ2wgZGF0YS5cbiAqL1xuVGV4dHVyZS5Gb3JjZVNlcmlhbGl6ZUJ1ZmZlcnMgPSBmYWxzZTtcbi8qKlxuICogVGhpcyBvYnNlcnZhYmxlIHdpbGwgbm90aWZ5IHdoZW4gYW55IHRleHR1cmUgaGFkIGEgbG9hZGluZyBlcnJvclxuICovXG5UZXh0dXJlLk9uVGV4dHVyZUxvYWRFcnJvck9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuLyoqIEBpbnRlcm5hbCAqL1xuVGV4dHVyZS5fU2VyaWFsaXplSW50ZXJuYWxUZXh0dXJlVW5pcXVlSWQgPSBmYWxzZTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcblRleHR1cmUuX0N1YmVUZXh0dXJlUGFyc2VyID0gKGpzb25UZXh0dXJlLCBzY2VuZSwgcm9vdFVybCkgPT4ge1xuICAgIHRocm93IF9XYXJuSW1wb3J0KFwiQ3ViZVRleHR1cmVcIik7XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuVGV4dHVyZS5fQ3JlYXRlTWlycm9yID0gKG5hbWUsIHJlbmRlclRhcmdldFNpemUsIHNjZW5lLCBnZW5lcmF0ZU1pcE1hcHMpID0+IHtcbiAgICB0aHJvdyBfV2FybkltcG9ydChcIk1pcnJvclRleHR1cmVcIik7XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuVGV4dHVyZS5fQ3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IChuYW1lLCByZW5kZXJUYXJnZXRTaXplLCBzY2VuZSwgZ2VuZXJhdGVNaXBNYXBzLCBjcmVhdGlvbkZsYWdzKSA9PiB7XG4gICAgdGhyb3cgX1dhcm5JbXBvcnQoXCJSZW5kZXJUYXJnZXRUZXh0dXJlXCIpO1xufTtcbi8qKiBuZWFyZXN0IGlzIG1hZyA9IG5lYXJlc3QgYW5kIG1pbiA9IG5lYXJlc3QgYW5kIG5vIG1pcCAqL1xuVGV4dHVyZS5ORUFSRVNUX1NBTVBMSU5HTU9ERSA9IDE7XG4vKiogbmVhcmVzdCBpcyBtYWcgPSBuZWFyZXN0IGFuZCBtaW4gPSBuZWFyZXN0IGFuZCBtaXAgPSBsaW5lYXIgKi9cblRleHR1cmUuTkVBUkVTVF9ORUFSRVNUX01JUExJTkVBUiA9IDg7IC8vIG5lYXJlc3QgaXMgbWFnID0gbmVhcmVzdCBhbmQgbWluID0gbmVhcmVzdCBhbmQgbWlwID0gbGluZWFyXG4vKiogQmlsaW5lYXIgaXMgbWFnID0gbGluZWFyIGFuZCBtaW4gPSBsaW5lYXIgYW5kIG5vIG1pcCAqL1xuVGV4dHVyZS5CSUxJTkVBUl9TQU1QTElOR01PREUgPSAyO1xuLyoqIEJpbGluZWFyIGlzIG1hZyA9IGxpbmVhciBhbmQgbWluID0gbGluZWFyIGFuZCBtaXAgPSBuZWFyZXN0ICovXG5UZXh0dXJlLkxJTkVBUl9MSU5FQVJfTUlQTkVBUkVTVCA9IDExOyAvLyBCaWxpbmVhciBpcyBtYWcgPSBsaW5lYXIgYW5kIG1pbiA9IGxpbmVhciBhbmQgbWlwID0gbmVhcmVzdFxuLyoqIFRyaWxpbmVhciBpcyBtYWcgPSBsaW5lYXIgYW5kIG1pbiA9IGxpbmVhciBhbmQgbWlwID0gbGluZWFyICovXG5UZXh0dXJlLlRSSUxJTkVBUl9TQU1QTElOR01PREUgPSAzO1xuLyoqIFRyaWxpbmVhciBpcyBtYWcgPSBsaW5lYXIgYW5kIG1pbiA9IGxpbmVhciBhbmQgbWlwID0gbGluZWFyICovXG5UZXh0dXJlLkxJTkVBUl9MSU5FQVJfTUlQTElORUFSID0gMzsgLy8gVHJpbGluZWFyIGlzIG1hZyA9IGxpbmVhciBhbmQgbWluID0gbGluZWFyIGFuZCBtaXAgPSBsaW5lYXJcbi8qKiBtYWcgPSBuZWFyZXN0IGFuZCBtaW4gPSBuZWFyZXN0IGFuZCBtaXAgPSBuZWFyZXN0ICovXG5UZXh0dXJlLk5FQVJFU1RfTkVBUkVTVF9NSVBORUFSRVNUID0gNDtcbi8qKiBtYWcgPSBuZWFyZXN0IGFuZCBtaW4gPSBsaW5lYXIgYW5kIG1pcCA9IG5lYXJlc3QgKi9cblRleHR1cmUuTkVBUkVTVF9MSU5FQVJfTUlQTkVBUkVTVCA9IDU7XG4vKiogbWFnID0gbmVhcmVzdCBhbmQgbWluID0gbGluZWFyIGFuZCBtaXAgPSBsaW5lYXIgKi9cblRleHR1cmUuTkVBUkVTVF9MSU5FQVJfTUlQTElORUFSID0gNjtcbi8qKiBtYWcgPSBuZWFyZXN0IGFuZCBtaW4gPSBsaW5lYXIgYW5kIG1pcCA9IG5vbmUgKi9cblRleHR1cmUuTkVBUkVTVF9MSU5FQVIgPSA3O1xuLyoqIG1hZyA9IG5lYXJlc3QgYW5kIG1pbiA9IG5lYXJlc3QgYW5kIG1pcCA9IG5vbmUgKi9cblRleHR1cmUuTkVBUkVTVF9ORUFSRVNUID0gMTtcbi8qKiBtYWcgPSBsaW5lYXIgYW5kIG1pbiA9IG5lYXJlc3QgYW5kIG1pcCA9IG5lYXJlc3QgKi9cblRleHR1cmUuTElORUFSX05FQVJFU1RfTUlQTkVBUkVTVCA9IDk7XG4vKiogbWFnID0gbGluZWFyIGFuZCBtaW4gPSBuZWFyZXN0IGFuZCBtaXAgPSBsaW5lYXIgKi9cblRleHR1cmUuTElORUFSX05FQVJFU1RfTUlQTElORUFSID0gMTA7XG4vKiogbWFnID0gbGluZWFyIGFuZCBtaW4gPSBsaW5lYXIgYW5kIG1pcCA9IG5vbmUgKi9cblRleHR1cmUuTElORUFSX0xJTkVBUiA9IDI7XG4vKiogbWFnID0gbGluZWFyIGFuZCBtaW4gPSBuZWFyZXN0IGFuZCBtaXAgPSBub25lICovXG5UZXh0dXJlLkxJTkVBUl9ORUFSRVNUID0gMTI7XG4vKiogRXhwbGljaXQgY29vcmRpbmF0ZXMgbW9kZSAqL1xuVGV4dHVyZS5FWFBMSUNJVF9NT0RFID0gMDtcbi8qKiBTcGhlcmljYWwgY29vcmRpbmF0ZXMgbW9kZSAqL1xuVGV4dHVyZS5TUEhFUklDQUxfTU9ERSA9IDE7XG4vKiogUGxhbmFyIGNvb3JkaW5hdGVzIG1vZGUgKi9cblRleHR1cmUuUExBTkFSX01PREUgPSAyO1xuLyoqIEN1YmljIGNvb3JkaW5hdGVzIG1vZGUgKi9cblRleHR1cmUuQ1VCSUNfTU9ERSA9IDM7XG4vKiogUHJvamVjdGlvbiBjb29yZGluYXRlcyBtb2RlICovXG5UZXh0dXJlLlBST0pFQ1RJT05fTU9ERSA9IDQ7XG4vKiogSW52ZXJzZSBDdWJpYyBjb29yZGluYXRlcyBtb2RlICovXG5UZXh0dXJlLlNLWUJPWF9NT0RFID0gNTtcbi8qKiBJbnZlcnNlIEN1YmljIGNvb3JkaW5hdGVzIG1vZGUgKi9cblRleHR1cmUuSU5WQ1VCSUNfTU9ERSA9IDY7XG4vKiogRXF1aXJlY3Rhbmd1bGFyIGNvb3JkaW5hdGVzIG1vZGUgKi9cblRleHR1cmUuRVFVSVJFQ1RBTkdVTEFSX01PREUgPSA3O1xuLyoqIEVxdWlyZWN0YW5ndWxhciBGaXhlZCBjb29yZGluYXRlcyBtb2RlICovXG5UZXh0dXJlLkZJWEVEX0VRVUlSRUNUQU5HVUxBUl9NT0RFID0gODtcbi8qKiBFcXVpcmVjdGFuZ3VsYXIgRml4ZWQgTWlycm9yZWQgY29vcmRpbmF0ZXMgbW9kZSAqL1xuVGV4dHVyZS5GSVhFRF9FUVVJUkVDVEFOR1VMQVJfTUlSUk9SRURfTU9ERSA9IDk7XG4vKiogVGV4dHVyZSBpcyBub3QgcmVwZWF0aW5nIG91dHNpZGUgb2YgMC4uMSBVVnMgKi9cblRleHR1cmUuQ0xBTVBfQUREUkVTU01PREUgPSAwO1xuLyoqIFRleHR1cmUgaXMgcmVwZWF0aW5nIG91dHNpZGUgb2YgMC4uMSBVVnMgKi9cblRleHR1cmUuV1JBUF9BRERSRVNTTU9ERSA9IDE7XG4vKiogVGV4dHVyZSBpcyByZXBlYXRpbmcgYW5kIG1pcnJvcmVkICovXG5UZXh0dXJlLk1JUlJPUl9BRERSRVNTTU9ERSA9IDI7XG4vKipcbiAqIEdldHMgb3Igc2V0cyBhIGJvb2xlYW4gd2hpY2ggZGVmaW5lcyBpZiB0aGUgdGV4dHVyZSB1cmwgbXVzdCBiZSBidWlsZCBmcm9tIHRoZSBzZXJpYWxpemVkIFVSTCBpbnN0ZWFkIG9mIGp1c3QgdXNpbmcgdGhlIG5hbWUgYW5kIGxvYWRpbmcgdGhlbSBzaWRlIGJ5IHNpZGUgd2l0aCB0aGUgc2NlbmUgZmlsZVxuICovXG5UZXh0dXJlLlVzZVNlcmlhbGl6ZWRVcmxJZkFueSA9IGZhbHNlO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIFRleHR1cmUucHJvdG90eXBlLCBcInVybFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIFRleHR1cmUucHJvdG90eXBlLCBcInVPZmZzZXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBUZXh0dXJlLnByb3RvdHlwZSwgXCJ2T2Zmc2V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgVGV4dHVyZS5wcm90b3R5cGUsIFwidVNjYWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgVGV4dHVyZS5wcm90b3R5cGUsIFwidlNjYWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgVGV4dHVyZS5wcm90b3R5cGUsIFwidUFuZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgc2VyaWFsaXplKClcbl0sIFRleHR1cmUucHJvdG90eXBlLCBcInZBbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBUZXh0dXJlLnByb3RvdHlwZSwgXCJ3QW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgVGV4dHVyZS5wcm90b3R5cGUsIFwidVJvdGF0aW9uQ2VudGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgVGV4dHVyZS5wcm90b3R5cGUsIFwidlJvdGF0aW9uQ2VudGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgVGV4dHVyZS5wcm90b3R5cGUsIFwid1JvdGF0aW9uQ2VudGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBzZXJpYWxpemUoKVxuXSwgVGV4dHVyZS5wcm90b3R5cGUsIFwiaG9tb2dlbmVvdXNSb3RhdGlvbkluVVZUcmFuc2Zvcm1cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHNlcmlhbGl6ZSgpXG5dLCBUZXh0dXJlLnByb3RvdHlwZSwgXCJpc0Jsb2NraW5nXCIsIG51bGwpO1xuLy8gUmVmZXJlbmNlcyB0aGUgZGVwZW5kZW5jaWVzLlxuUmVnaXN0ZXJDbGFzcyhcIkJBQllMT04uVGV4dHVyZVwiLCBUZXh0dXJlKTtcblNlcmlhbGl6YXRpb25IZWxwZXIuX1RleHR1cmVQYXJzZXIgPSBUZXh0dXJlLlBhcnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZS5qcy5tYXAiLCJcbmltcG9ydCB7IFNpemUgfSBmcm9tIFwiLi4vLi4vTWF0aHMvbWF0aC5zaXplLmpzXCI7XG4vKipcbiAqIEJhc2UgY2xhc3Mgb2YgYWxsIHRoZSB0ZXh0dXJlcyBpbiBiYWJ5bG9uLlxuICogSXQgZ3JvdXBzIGFsbCB0aGUgY29tbW9uIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gd29yayB3aXRoIFRoaW4gRW5naW5lLlxuICovXG5leHBvcnQgY2xhc3MgVGhpblRleHR1cmUge1xuICAgIC8qKlxuICAgICAqIHwgVmFsdWUgfCBUeXBlICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiB8XG4gICAgICogfCAtLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tIHxcbiAgICAgKiB8IDAgICAgIHwgQ0xBTVBfQUREUkVTU01PREUgIHwgICAgICAgICAgICAgfFxuICAgICAqIHwgMSAgICAgfCBXUkFQX0FERFJFU1NNT0RFICAgfCAgICAgICAgICAgICB8XG4gICAgICogfCAyICAgICB8IE1JUlJPUl9BRERSRVNTTU9ERSB8ICAgICAgICAgICAgIHxcbiAgICAgKi9cbiAgICBnZXQgd3JhcFUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVTtcbiAgICB9XG4gICAgc2V0IHdyYXBVKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3dyYXBVID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHwgVmFsdWUgfCBUeXBlICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiB8XG4gICAgICogfCAtLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tIHxcbiAgICAgKiB8IDAgICAgIHwgQ0xBTVBfQUREUkVTU01PREUgIHwgICAgICAgICAgICAgfFxuICAgICAqIHwgMSAgICAgfCBXUkFQX0FERFJFU1NNT0RFICAgfCAgICAgICAgICAgICB8XG4gICAgICogfCAyICAgICB8IE1JUlJPUl9BRERSRVNTTU9ERSB8ICAgICAgICAgICAgIHxcbiAgICAgKi9cbiAgICBnZXQgd3JhcFYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVjtcbiAgICB9XG4gICAgc2V0IHdyYXBWKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3dyYXBWID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhvdyBhIHRleHR1cmUgaXMgbWFwcGVkLlxuICAgICAqIFVudXNlZCBpbiB0aGluIHRleHR1cmUgbW9kZS5cbiAgICAgKi9cbiAgICBnZXQgY29vcmRpbmF0ZXNNb2RlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lIGlmIHRoZSB0ZXh0dXJlIGlzIGEgY3ViZSB0ZXh0dXJlIG9yIGlmIGZhbHNlIGEgMmQgdGV4dHVyZS5cbiAgICAgKi9cbiAgICBnZXQgaXNDdWJlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZS5pc0N1YmU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBzZXQgaXNDdWJlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RleHR1cmUuaXNDdWJlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSBpZiB0aGUgdGV4dHVyZSBpcyBhIDNkIHRleHR1cmUgKHdlYmdsIDIpIG9yIGlmIGZhbHNlIGEgMmQgdGV4dHVyZS5cbiAgICAgKi9cbiAgICBnZXQgaXMzRCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmUuaXMzRDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIHNldCBpczNEKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RleHR1cmUuaXMzRCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgaWYgdGhlIHRleHR1cmUgaXMgYSAyZCBhcnJheSB0ZXh0dXJlICh3ZWJnbCAyKSBvciBpZiBmYWxzZSBhIDJkIHRleHR1cmUuXG4gICAgICovXG4gICAgZ2V0IGlzMkRBcnJheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmUuaXMyREFycmF5O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgc2V0IGlzMkRBcnJheSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXh0dXJlLmlzMkRBcnJheSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNsYXNzIG5hbWUgb2YgdGhlIHRleHR1cmUuXG4gICAgICogQHJldHVybnMgXCJUaGluVGV4dHVyZVwiXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJUaGluVGV4dHVyZVwiO1xuICAgIH1cbiAgICBzdGF0aWMgX0lzUmVuZGVyVGFyZ2V0V3JhcHBlcih0ZXh0dXJlKSB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlPy5zaGFyZURlcHRoICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIG5ldyBUaGluVGV4dHVyZS5cbiAgICAgKiBCYXNlIGNsYXNzIG9mIGFsbCB0aGUgdGV4dHVyZXMgaW4gYmFieWxvbi5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIGFzIGFuIGludGVybmFsIHRleHR1cmUgd3JhcHBlciBpbiBBYnN0cmFjdEVuZ2luZSB0byBiZW5lZml0IGZyb20gdGhlIGNhY2hlXG4gICAgICogQHBhcmFtIGludGVybmFsVGV4dHVyZSBEZWZpbmUgdGhlIGludGVybmFsVGV4dHVyZSB0byB3cmFwLiBZb3UgY2FuIGFsc28gcGFzcyBhIFJlbmRlclRhcmdldFdyYXBwZXIsIGluIHdoaWNoIGNhc2UgdGhlIHRleHR1cmUgd2lsbCBiZSB0aGUgcmVuZGVyIHRhcmdldCdzIHRleHR1cmVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnRlcm5hbFRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fd3JhcFUgPSAxO1xuICAgICAgICB0aGlzLl93cmFwViA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB8IFZhbHVlIHwgVHlwZSAgICAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gfFxuICAgICAgICAgKiB8IC0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0gfFxuICAgICAgICAgKiB8IDAgICAgIHwgQ0xBTVBfQUREUkVTU01PREUgIHwgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDEgICAgIHwgV1JBUF9BRERSRVNTTU9ERSAgIHwgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDIgICAgIHwgTUlSUk9SX0FERFJFU1NNT0RFIHwgICAgICAgICAgICAgfFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwUiA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIGNvbXBsaWFudCBoYXJkd2FyZSBhbmQgYnJvd3NlciAoc3VwcG9ydGluZyBhbmlzb3Ryb3BpYyBmaWx0ZXJpbmcpXG4gICAgICAgICAqIHRoaXMgZGVmaW5lcyB0aGUgbGV2ZWwgb2YgYW5pc290cm9waWMgZmlsdGVyaW5nIGluIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBUaGUgaGlnaGVyIHRoZSBiZXR0ZXIgYnV0IHRoZSBzbG93ZXIuIFRoaXMgZGVmYXVsdHMgdG8gNCBhcyBpdCBzZWVtcyB0byBiZSB0aGUgYmVzdCB0cmFkZW9mZi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCA9IDQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGxvYWRpbmcgc2VxdWVuY2Ugd2hlbiBpbiBkZWxheWVkIGxvYWQgbW9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsYXlMb2FkU3RhdGUgPSAwO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9lbmdpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWNoZWRTaXplID0gU2l6ZS5aZXJvKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEJhc2VTaXplID0gU2l6ZS5aZXJvKCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5faW5pdGlhbFNhbXBsaW5nTW9kZSA9IDI7XG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSBUaGluVGV4dHVyZS5fSXNSZW5kZXJUYXJnZXRXcmFwcGVyKGludGVybmFsVGV4dHVyZSkgPyBpbnRlcm5hbFRleHR1cmUudGV4dHVyZSA6IGludGVybmFsVGV4dHVyZTtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IHRoaXMuX3RleHR1cmUuZ2V0RW5naW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGlmIHRoZSB0ZXh0dXJlIGlzIHJlYWR5IHRvIGJlIHVzZWQgKGRvd25sb2FkZWQsIGNvbnZlcnRlZCwgbWlwIG1hcHBlZC4uLikuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBmdWxseSByZWFkeVxuICAgICAqL1xuICAgIGlzUmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5TG9hZFN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5TG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZS5pc1JlYWR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgdGhlIGxvYWQgc2VxdWVuY2UgaW4gZGVsYXllZCBsb2FkIG1vZGUuXG4gICAgICovXG4gICAgZGVsYXlMb2FkKCkgeyB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1bmRlcmx5aW5nIGxvd2VyIGxldmVsIHRleHR1cmUgZnJvbSBCYWJ5bG9uLlxuICAgICAqIEByZXR1cm5zIHRoZSBpbnRlcm5hbCB0ZXh0dXJlXG4gICAgICovXG4gICAgZ2V0SW50ZXJuYWxUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzaXplIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqIEByZXR1cm5zIHRoZSB0ZXh0dXJlIHNpemUuXG4gICAgICovXG4gICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0dXJlLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkU2l6ZS53aWR0aCA9IHRoaXMuX3RleHR1cmUud2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkU2l6ZS5oZWlnaHQgPSB0aGlzLl90ZXh0dXJlLmhlaWdodDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0dXJlLl9zaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkU2l6ZS53aWR0aCA9IHRoaXMuX3RleHR1cmUuX3NpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkU2l6ZS5oZWlnaHQgPSB0aGlzLl90ZXh0dXJlLl9zaXplO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJhc2Ugc2l6ZSBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKiBJdCBjYW4gYmUgZGlmZmVyZW50IGZyb20gdGhlIHNpemUgaWYgdGhlIHRleHR1cmUgaGFzIGJlZW4gcmVzaXplZCBmb3IgUE9UIGZvciBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHRoZSBiYXNlIHNpemVcbiAgICAgKi9cbiAgICBnZXRCYXNlU2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVhZHkoKSB8fCAhdGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkQmFzZVNpemUud2lkdGggPSAwO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkQmFzZVNpemUuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRCYXNlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZS5fc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkQmFzZVNpemUud2lkdGggPSB0aGlzLl90ZXh0dXJlLl9zaXplO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkQmFzZVNpemUuaGVpZ2h0ID0gdGhpcy5fdGV4dHVyZS5fc2l6ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRCYXNlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWNoZWRCYXNlU2l6ZS53aWR0aCA9IHRoaXMuX3RleHR1cmUuYmFzZVdpZHRoO1xuICAgICAgICB0aGlzLl9jYWNoZWRCYXNlU2l6ZS5oZWlnaHQgPSB0aGlzLl90ZXh0dXJlLmJhc2VIZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRCYXNlU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHNhbXBsaW5nIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHRoZSB0ZXh0dXJlLlxuICAgICAqL1xuICAgIGdldCBzYW1wbGluZ01vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxTYW1wbGluZ01vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmUuc2FtcGxpbmdNb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNhbXBsaW5nIG1vZGUgb2YgdGhlIHRleHR1cmUuXG4gICAgICogRGVmYXVsdCBpcyBUcmlsaW5lYXIgbW9kZS5cbiAgICAgKlxuICAgICAqIHwgVmFsdWUgfCBUeXBlICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiB8XG4gICAgICogfCAtLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tIHxcbiAgICAgKiB8IDEgICAgIHwgTkVBUkVTVF9TQU1QTElOR01PREUgb3IgTkVBUkVTVF9ORUFSRVNUX01JUExJTkVBUiAgfCBOZWFyZXN0IGlzOiBtYWcgPSBuZWFyZXN0LCBtaW4gPSBuZWFyZXN0LCBtaXAgPSBsaW5lYXIgfFxuICAgICAqIHwgMiAgICAgfCBCSUxJTkVBUl9TQU1QTElOR01PREUgb3IgTElORUFSX0xJTkVBUl9NSVBORUFSRVNUIHwgQmlsaW5lYXIgaXM6IG1hZyA9IGxpbmVhciwgbWluID0gbGluZWFyLCBtaXAgPSBuZWFyZXN0IHxcbiAgICAgKiB8IDMgICAgIHwgVFJJTElORUFSX1NBTVBMSU5HTU9ERSBvciBMSU5FQVJfTElORUFSX01JUExJTkVBUiB8IFRyaWxpbmVhciBpczogbWFnID0gbGluZWFyLCBtaW4gPSBsaW5lYXIsIG1pcCA9IGxpbmVhciB8XG4gICAgICogfCA0ICAgICB8IE5FQVJFU1RfTkVBUkVTVF9NSVBORUFSRVNUIHwgICAgICAgICAgICAgfFxuICAgICAqIHwgNSAgICB8IE5FQVJFU1RfTElORUFSX01JUE5FQVJFU1QgfCAgICAgICAgICAgICB8XG4gICAgICogfCA2ICAgIHwgTkVBUkVTVF9MSU5FQVJfTUlQTElORUFSIHwgICAgICAgICAgICAgfFxuICAgICAqIHwgNyAgICB8IE5FQVJFU1RfTElORUFSIHwgICAgICAgICAgICAgfFxuICAgICAqIHwgOCAgICB8IE5FQVJFU1RfTkVBUkVTVCB8ICAgICAgICAgICAgIHxcbiAgICAgKiB8IDkgICB8IExJTkVBUl9ORUFSRVNUX01JUE5FQVJFU1QgfCAgICAgICAgICAgICB8XG4gICAgICogfCAxMCAgIHwgTElORUFSX05FQVJFU1RfTUlQTElORUFSIHwgICAgICAgICAgICAgfFxuICAgICAqIHwgMTEgICB8IExJTkVBUl9MSU5FQVIgfCAgICAgICAgICAgICB8XG4gICAgICogfCAxMiAgIHwgTElORUFSX05FQVJFU1QgfCAgICAgICAgICAgICB8XG4gICAgICpcbiAgICAgKiAgICA+IF9tYWdfOiBtYWduaWZpY2F0aW9uIGZpbHRlciAoY2xvc2UgdG8gdGhlIHZpZXdlcilcbiAgICAgKiAgICA+IF9taW5fOiBtaW5pZmljYXRpb24gZmlsdGVyIChmYXIgZnJvbSB0aGUgdmlld2VyKVxuICAgICAqICAgID4gX21pcF86IGZpbHRlciB1c2VkIGJldHdlZW4gbWlwIG1hcCBsZXZlbHNcbiAgICAgKkBwYXJhbSBzYW1wbGluZ01vZGUgRGVmaW5lIHRoZSBuZXcgc2FtcGxpbmcgbW9kZSBvZiB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIHVwZGF0ZVNhbXBsaW5nTW9kZShzYW1wbGluZ01vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUgJiYgdGhpcy5fZW5naW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUudXBkYXRlVGV4dHVyZVNhbXBsaW5nTW9kZShzYW1wbGluZ01vZGUsIHRoaXMuX3RleHR1cmUsIHRoaXMuX3RleHR1cmUuZ2VuZXJhdGVNaXBNYXBzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIGFuZCBkZXN0cm95IHRoZSB1bmRlcmx5aW5nIGxvd2VyIGxldmVsIHRleHR1cmUgYWthIGludGVybmFsVGV4dHVyZS5cbiAgICAgKi9cbiAgICByZWxlYXNlSW50ZXJuYWxUZXh0dXJlKCkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHRoZSB0ZXh0dXJlIGFuZCByZWxlYXNlIGl0cyBhc3NvY2lhdGVkIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlSW50ZXJuYWxUZXh0dXJlKCk7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhpblRleHR1cmUuanMubWFwIiwiLyoqXG4gKiBTaXplIGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFNpemUgb2JqZWN0IGZyb20gdGhlIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHQgKGZsb2F0cykuXG4gICAgICogQHBhcmFtIHdpZHRoIHdpZHRoIG9mIHRoZSBuZXcgc2l6ZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgaGVpZ2h0IG9mIHRoZSBuZXcgc2l6ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSBTaXplIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSBTaXplIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGB7VzogJHt0aGlzLndpZHRofSwgSDogJHt0aGlzLmhlaWdodH19YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogXCJTaXplXCJcbiAgICAgKiBAcmV0dXJucyB0aGUgc3RyaW5nIFwiU2l6ZVwiXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJTaXplXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFNpemUgaGFzaCBjb2RlLlxuICAgICAqIEByZXR1cm5zIGEgaGFzaCBjb2RlIGZvciBhIHVuaXF1ZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICovXG4gICAgZ2V0SGFzaENvZGUoKSB7XG4gICAgICAgIGxldCBoYXNoID0gdGhpcy53aWR0aCB8IDA7XG4gICAgICAgIGhhc2ggPSAoaGFzaCAqIDM5NykgXiAodGhpcy5oZWlnaHQgfCAwKTtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgc2l6ZSBmcm9tIHRoZSBnaXZlbiBvbmUuXG4gICAgICogQHBhcmFtIHNyYyB0aGUgZ2l2ZW4gc2l6ZVxuICAgICAqL1xuICAgIGNvcHlGcm9tKHNyYykge1xuICAgICAgICB0aGlzLndpZHRoID0gc3JjLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNyYy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgaW4gcGxhY2UgdGhlIGN1cnJlbnQgU2l6ZSBmcm9tIHRoZSBnaXZlbiBmbG9hdHMuXG4gICAgICogQHBhcmFtIHdpZHRoIHdpZHRoIG9mIHRoZSBuZXcgc2l6ZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgaGVpZ2h0IG9mIHRoZSBuZXcgc2l6ZVxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIFNpemUuXG4gICAgICovXG4gICAgY29weUZyb21GbG9hdHMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBpbiBwbGFjZSB0aGUgY3VycmVudCBTaXplIGZyb20gdGhlIGdpdmVuIGZsb2F0cy5cbiAgICAgKiBAcGFyYW0gd2lkdGggd2lkdGggdG8gc2V0XG4gICAgICogQHBhcmFtIGhlaWdodCBoZWlnaHQgdG8gc2V0XG4gICAgICogQHJldHVybnMgdGhlIHVwZGF0ZWQgU2l6ZS5cbiAgICAgKi9cbiAgICBzZXQod2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5RnJvbUZsb2F0cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgd2lkdGggYW5kIGhlaWdodCBieSBudW1iZXJzXG4gICAgICogQHBhcmFtIHcgZmFjdG9yIHRvIG11bHRpcGxlIHRoZSB3aWR0aCBieVxuICAgICAqIEBwYXJhbSBoIGZhY3RvciB0byBtdWx0aXBsZSB0aGUgaGVpZ2h0IGJ5XG4gICAgICogQHJldHVybnMgYSBuZXcgU2l6ZSBzZXQgd2l0aCB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0IG9mIHRoZSBjdXJyZW50IFNpemUgYW5kIHRoZSBnaXZlbiBmbG9hdHMuXG4gICAgICovXG4gICAgbXVsdGlwbHlCeUZsb2F0cyh3LCBoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICogdywgdGhpcy5oZWlnaHQgKiBoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBzaXplXG4gICAgICogQHJldHVybnMgYSBuZXcgU2l6ZSBjb3BpZWQgZnJvbSB0aGUgZ2l2ZW4gb25lLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBjdXJyZW50IFNpemUgYW5kIHRoZSBnaXZlbiBvbmUgd2lkdGggYW5kIGhlaWdodCBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gICAgICogQHBhcmFtIG90aGVyIHRoZSBvdGhlciBzaXplIHRvIGNvbXBhcmUgYWdhaW5zdFxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGN1cnJlbnQgU2l6ZSBhbmQgdGhlIGdpdmVuIG9uZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBzdHJpY3RseSBlcXVhbC5cbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSBvdGhlci53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gb3RoZXIuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc3VyZmFjZSBvZiB0aGUgU2l6ZSA6IHdpZHRoICogaGVpZ2h0IChmbG9hdCkuXG4gICAgICovXG4gICAgZ2V0IHN1cmZhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzaXplIG9mIHplcm9cbiAgICAgKiBAcmV0dXJucyBhIG5ldyBTaXplIHNldCB0byAoMC4wLCAwLjApXG4gICAgICovXG4gICAgc3RhdGljIFplcm8oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZSgwLjAsIDAuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1bXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdHdvIHNpemVzXG4gICAgICogQHBhcmFtIG90aGVyU2l6ZSBzaXplIHRvIGFkZCB0byB0aGlzIHNpemVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBTaXplIHNldCBhcyB0aGUgYWRkaXRpb24gcmVzdWx0IG9mIHRoZSBjdXJyZW50IFNpemUgYW5kIHRoZSBnaXZlbiBvbmUuXG4gICAgICovXG4gICAgYWRkKG90aGVyU2l6ZSkge1xuICAgICAgICBjb25zdCByID0gbmV3IFNpemUodGhpcy53aWR0aCArIG90aGVyU2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKyBvdGhlclNpemUuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0d29cbiAgICAgKiBAcGFyYW0gb3RoZXJTaXplIHNpemUgdG8gc3VidHJhY3QgdG8gdGhpcyBzaXplXG4gICAgICogQHJldHVybnMgYSBuZXcgU2l6ZSBzZXQgYXMgdGhlIHN1YnRyYWN0aW9uIHJlc3VsdCBvZiAgdGhlIGdpdmVuIG9uZSBmcm9tIHRoZSBjdXJyZW50IFNpemUuXG4gICAgICovXG4gICAgc3VidHJhY3Qob3RoZXJTaXplKSB7XG4gICAgICAgIGNvbnN0IHIgPSBuZXcgU2l6ZSh0aGlzLndpZHRoIC0gb3RoZXJTaXplLndpZHRoLCB0aGlzLmhlaWdodCAtIG90aGVyU2l6ZS5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbGVzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICogQHBhcmFtIHNjYWxlIHRoZSBzY2FsZSB0byBtdWx0aXBseSB0aGUgd2lkdGggYW5kIGhlaWdodCBieVxuICAgICAqIEByZXR1cm5zIGEgbmV3IFNpemUgc2V0IHdpdGggdGhlIG11bHRpcGxpY2F0aW9uIHJlc3VsdCBvZiB0aGUgY3VycmVudCBTaXplIGFuZCB0aGUgZ2l2ZW4gZmxvYXRzLlxuICAgICAqL1xuICAgIHNjYWxlKHNjYWxlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICogc2NhbGUsIHRoaXMuaGVpZ2h0ICogc2NhbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNpemUgc2V0IGF0IHRoZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBcImFtb3VudFwiIGJldHdlZW4gXCJzdGFydFwiIGFuZCBcImVuZFwiXG4gICAgICogQHBhcmFtIHN0YXJ0IHN0YXJ0aW5nIHNpemUgdG8gbGVycCBiZXR3ZWVuXG4gICAgICogQHBhcmFtIGVuZCBlbmQgc2l6ZSB0byBsZXJwIGJldHdlZW5cbiAgICAgKiBAcGFyYW0gYW1vdW50IGFtb3VudCB0byBsZXJwIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzXG4gICAgICogQHJldHVybnMgYSBuZXcgU2l6ZSBzZXQgYXQgdGhlIGxpbmVhciBpbnRlcnBvbGF0aW9uIFwiYW1vdW50XCIgYmV0d2VlbiBcInN0YXJ0XCIgYW5kIFwiZW5kXCJcbiAgICAgKi9cbiAgICBzdGF0aWMgTGVycChzdGFydCwgZW5kLCBhbW91bnQpIHtcbiAgICAgICAgY29uc3QgdyA9IHN0YXJ0LndpZHRoICsgKGVuZC53aWR0aCAtIHN0YXJ0LndpZHRoKSAqIGFtb3VudDtcbiAgICAgICAgY29uc3QgaCA9IHN0YXJ0LmhlaWdodCArIChlbmQuaGVpZ2h0IC0gc3RhcnQuaGVpZ2h0KSAqIGFtb3VudDtcbiAgICAgICAgcmV0dXJuIG5ldyBTaXplKHcsIGgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGguc2l6ZS5qcy5tYXAiLCIvKipcbiAqIFRyYW5zZm9ybSBzb21lIHBpeGVsIGRhdGEgdG8gYSBiYXNlNjQgc3RyaW5nXG4gKiBAcGFyYW0gcGl4ZWxzIGRlZmluZXMgdGhlIHBpeGVsIGRhdGEgdG8gdHJhbnNmb3JtIHRvIGJhc2U2NFxuICogQHBhcmFtIHNpemUgZGVmaW5lcyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgKHRleHR1cmUpIGRhdGFcbiAqIEBwYXJhbSBpbnZlcnRZIHRydWUgaWYgdGhlIGRhdGEgbXVzdCBiZSBpbnZlcnRlZCBmb3IgdGhlIFkgY29vcmRpbmF0ZSBkdXJpbmcgdGhlIGNvbnZlcnNpb25cbiAqIEByZXR1cm5zIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb3IgbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gR2VuZXJhdGVCYXNlNjRTdHJpbmdGcm9tUGl4ZWxEYXRhKHBpeGVscywgc2l6ZSwgaW52ZXJ0WSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgd2lkdGggPSBzaXplLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgIGlmIChwaXhlbHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgbGV0IGxlbiA9IHBpeGVscy5ieXRlTGVuZ3RoIC8gcGl4ZWxzLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICBjb25zdCBucGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAgICAgd2hpbGUgKC0tbGVuID49IDApIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBwaXhlbHNbbGVuXTtcbiAgICAgICAgICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnBpeGVsc1tsZW5dID0gdmFsICogMjU1O1xuICAgICAgICB9XG4gICAgICAgIHBpeGVscyA9IG5waXhlbHM7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGNhc3REYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgY2FzdERhdGEuc2V0KHBpeGVscyk7XG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIGlmIChpbnZlcnRZKSB7XG4gICAgICAgIGNvbnN0IGNhbnZhczIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICBjYW52YXMyLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhczIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHgyID0gY2FudmFzMi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGlmICghY3R4Mikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY3R4Mi50cmFuc2xhdGUoMCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4Mi5zY2FsZSgxLCAtMSk7XG4gICAgICAgIGN0eDIuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgICAgIHJldHVybiBjYW52YXMyLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG59XG4vKipcbiAqIFJlYWRzIHRoZSBwaXhlbHMgc3RvcmVkIGluIHRoZSB3ZWJnbCB0ZXh0dXJlIGFuZCByZXR1cm5zIHRoZW0gYXMgYSBiYXNlNjQgc3RyaW5nXG4gKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSB0ZXh0dXJlIHRvIHJlYWQgcGl4ZWxzIGZyb21cbiAqIEBwYXJhbSBmYWNlSW5kZXggZGVmaW5lcyB0aGUgZmFjZSBvZiB0aGUgdGV4dHVyZSB0byByZWFkIChpbiBjYXNlIG9mIGN1YmUgdGV4dHVyZSlcbiAqIEBwYXJhbSBsZXZlbCBkZWZpbmVzIHRoZSBMT0QgbGV2ZWwgb2YgdGhlIHRleHR1cmUgdG8gcmVhZCAoaW4gY2FzZSBvZiBNaXAgTWFwcylcbiAqIEByZXR1cm5zIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb3IgbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gR2VuZXJhdGVCYXNlNjRTdHJpbmdGcm9tVGV4dHVyZSh0ZXh0dXJlLCBmYWNlSW5kZXggPSAwLCBsZXZlbCA9IDApIHtcbiAgICBjb25zdCBpbnRlcm5hbFRleHR1cmUgPSB0ZXh0dXJlLmdldEludGVybmFsVGV4dHVyZSgpO1xuICAgIGlmICghaW50ZXJuYWxUZXh0dXJlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwaXhlbHMgPSB0ZXh0dXJlLl9yZWFkUGl4ZWxzU3luYyhmYWNlSW5kZXgsIGxldmVsKTtcbiAgICBpZiAoIXBpeGVscykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEdlbmVyYXRlQmFzZTY0U3RyaW5nRnJvbVBpeGVsRGF0YShwaXhlbHMsIHRleHR1cmUuZ2V0U2l6ZSgpLCBpbnRlcm5hbFRleHR1cmUuaW52ZXJ0WSk7XG59XG4vKipcbiAqIFJlYWRzIHRoZSBwaXhlbHMgc3RvcmVkIGluIHRoZSB3ZWJnbCB0ZXh0dXJlIGFuZCByZXR1cm5zIHRoZW0gYXMgYSBiYXNlNjQgc3RyaW5nXG4gKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSB0ZXh0dXJlIHRvIHJlYWQgcGl4ZWxzIGZyb21cbiAqIEBwYXJhbSBmYWNlSW5kZXggZGVmaW5lcyB0aGUgZmFjZSBvZiB0aGUgdGV4dHVyZSB0byByZWFkIChpbiBjYXNlIG9mIGN1YmUgdGV4dHVyZSlcbiAqIEBwYXJhbSBsZXZlbCBkZWZpbmVzIHRoZSBMT0QgbGV2ZWwgb2YgdGhlIHRleHR1cmUgdG8gcmVhZCAoaW4gY2FzZSBvZiBNaXAgTWFwcylcbiAqIEByZXR1cm5zIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb3IgbnVsbCB3cmFwcGVkIGluIGEgcHJvbWlzZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR2VuZXJhdGVCYXNlNjRTdHJpbmdGcm9tVGV4dHVyZUFzeW5jKHRleHR1cmUsIGZhY2VJbmRleCA9IDAsIGxldmVsID0gMCkge1xuICAgIGNvbnN0IGludGVybmFsVGV4dHVyZSA9IHRleHR1cmUuZ2V0SW50ZXJuYWxUZXh0dXJlKCk7XG4gICAgaWYgKCFpbnRlcm5hbFRleHR1cmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBpeGVscyA9IGF3YWl0IHRleHR1cmUucmVhZFBpeGVscyhmYWNlSW5kZXgsIGxldmVsKTtcbiAgICBpZiAoIXBpeGVscykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEdlbmVyYXRlQmFzZTY0U3RyaW5nRnJvbVBpeGVsRGF0YShwaXhlbHMsIHRleHR1cmUuZ2V0U2l6ZSgpLCBpbnRlcm5hbFRleHR1cmUuaW52ZXJ0WSk7XG59XG4vKipcbiAqIENsYXNzIHVzZWQgdG8gaG9zdCBjb3B5IHNwZWNpZmljIHV0aWxpdGllc1xuICogKEJhY2stY29tcGF0KVxuICovXG5leHBvcnQgY29uc3QgQ29weVRvb2xzID0ge1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBzb21lIHBpeGVsIGRhdGEgdG8gYSBiYXNlNjQgc3RyaW5nXG4gICAgICogQHBhcmFtIHBpeGVscyBkZWZpbmVzIHRoZSBwaXhlbCBkYXRhIHRvIHRyYW5zZm9ybSB0byBiYXNlNjRcbiAgICAgKiBAcGFyYW0gc2l6ZSBkZWZpbmVzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSAodGV4dHVyZSkgZGF0YVxuICAgICAqIEBwYXJhbSBpbnZlcnRZIHRydWUgaWYgdGhlIGRhdGEgbXVzdCBiZSBpbnZlcnRlZCBmb3IgdGhlIFkgY29vcmRpbmF0ZSBkdXJpbmcgdGhlIGNvbnZlcnNpb25cbiAgICAgKiBAcmV0dXJucyBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9yIG51bGxcbiAgICAgKi9cbiAgICBHZW5lcmF0ZUJhc2U2NFN0cmluZ0Zyb21QaXhlbERhdGEsXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIHBpeGVscyBzdG9yZWQgaW4gdGhlIHdlYmdsIHRleHR1cmUgYW5kIHJldHVybnMgdGhlbSBhcyBhIGJhc2U2NCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSB0ZXh0dXJlIHRvIHJlYWQgcGl4ZWxzIGZyb21cbiAgICAgKiBAcGFyYW0gZmFjZUluZGV4IGRlZmluZXMgdGhlIGZhY2Ugb2YgdGhlIHRleHR1cmUgdG8gcmVhZCAoaW4gY2FzZSBvZiBjdWJlIHRleHR1cmUpXG4gICAgICogQHBhcmFtIGxldmVsIGRlZmluZXMgdGhlIExPRCBsZXZlbCBvZiB0aGUgdGV4dHVyZSB0byByZWFkIChpbiBjYXNlIG9mIE1pcCBNYXBzKVxuICAgICAqIEByZXR1cm5zIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb3IgbnVsbFxuICAgICAqL1xuICAgIEdlbmVyYXRlQmFzZTY0U3RyaW5nRnJvbVRleHR1cmUsXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIHBpeGVscyBzdG9yZWQgaW4gdGhlIHdlYmdsIHRleHR1cmUgYW5kIHJldHVybnMgdGhlbSBhcyBhIGJhc2U2NCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSB0ZXh0dXJlIHRvIHJlYWQgcGl4ZWxzIGZyb21cbiAgICAgKiBAcGFyYW0gZmFjZUluZGV4IGRlZmluZXMgdGhlIGZhY2Ugb2YgdGhlIHRleHR1cmUgdG8gcmVhZCAoaW4gY2FzZSBvZiBjdWJlIHRleHR1cmUpXG4gICAgICogQHBhcmFtIGxldmVsIGRlZmluZXMgdGhlIExPRCBsZXZlbCBvZiB0aGUgdGV4dHVyZSB0byByZWFkIChpbiBjYXNlIG9mIE1pcCBNYXBzKVxuICAgICAqIEByZXR1cm5zIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb3IgbnVsbCB3cmFwcGVkIGluIGEgcHJvbWlzZVxuICAgICAqL1xuICAgIEdlbmVyYXRlQmFzZTY0U3RyaW5nRnJvbVRleHR1cmVBc3luYyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3B5VG9vbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9