"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["node_modules_babylonjs_core_Misc_dumpTools_js"],{

/***/ "./node_modules/@babylonjs/core/Misc/dumpTools.js":
/*!********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/dumpTools.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dispose: () => (/* binding */ Dispose),
/* harmony export */   DumpData: () => (/* binding */ DumpData),
/* harmony export */   DumpDataAsync: () => (/* binding */ DumpDataAsync),
/* harmony export */   DumpFramebuffer: () => (/* binding */ DumpFramebuffer),
/* harmony export */   DumpTools: () => (/* binding */ DumpTools)
/* harmony export */ });
/* harmony import */ var _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Materials/effectRenderer.js */ "./node_modules/@babylonjs/core/Materials/effectRenderer.js");
/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools.js */ "./node_modules/@babylonjs/core/Misc/tools.js");
/* harmony import */ var _Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Maths/math.scalar.functions.js */ "./node_modules/@babylonjs/core/Maths/math.scalar.functions.js");
/* harmony import */ var _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Engines/engineStore.js */ "./node_modules/@babylonjs/core/Engines/engineStore.js");





let DumpToolsEngine;
let EnginePromise = null;
async function _CreateDumpRendererAsync() {
    if (!EnginePromise) {
        EnginePromise = new Promise((resolve, reject) => {
            let canvas;
            let engine = null;
            const options = {
                preserveDrawingBuffer: true,
                depth: false,
                stencil: false,
                alpha: true,
                premultipliedAlpha: false,
                antialias: false,
                failIfMajorPerformanceCaveat: false,
            };
            Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../Engines/thinEngine.js */ "./node_modules/@babylonjs/core/Engines/thinEngine.js"))
                .then(({ ThinEngine: thinEngineClass }) => {
                const engineInstanceCount = _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.Instances.length;
                try {
                    canvas = new OffscreenCanvas(100, 100); // will be resized later
                    engine = new thinEngineClass(canvas, false, options);
                }
                catch (e) {
                    if (engineInstanceCount < _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.Instances.length) {
                        // The engine was created by another instance, let's use it
                        _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.Instances.pop()?.dispose();
                    }
                    // The browser either does not support OffscreenCanvas or WebGL context in OffscreenCanvas, fallback on a regular canvas
                    canvas = document.createElement("canvas");
                    engine = new thinEngineClass(canvas, false, options);
                }
                // remove this engine from the list of instances to avoid using it for other purposes
                _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.Instances.pop();
                // However, make sure to dispose it when no other engines are left
                _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.OnEnginesDisposedObservable.add((e) => {
                    // guaranteed to run when no other instances are left
                    // only dispose if it's not the current engine
                    if (engine && e !== engine && !engine.isDisposed && _Engines_engineStore_js__WEBPACK_IMPORTED_MODULE_3__.EngineStore.Instances.length === 0) {
                        // Dump the engine and the associated resources
                        Dispose();
                    }
                });
                engine.getCaps().parallelShaderCompile = undefined;
                const renderer = new _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_0__.EffectRenderer(engine);
                __webpack_require__.e(/*! import() */ "node_modules_babylonjs_core_Shaders_pass_fragment_js").then(__webpack_require__.bind(__webpack_require__, /*! ../Shaders/pass.fragment.js */ "./node_modules/@babylonjs/core/Shaders/pass.fragment.js")).then(({ passPixelShader }) => {
                    if (!engine) {
                        reject("Engine is not defined");
                        return;
                    }
                    const wrapper = new _Materials_effectRenderer_js__WEBPACK_IMPORTED_MODULE_0__.EffectWrapper({
                        engine,
                        name: passPixelShader.name,
                        fragmentShader: passPixelShader.shader,
                        samplerNames: ["textureSampler"],
                    });
                    DumpToolsEngine = {
                        canvas,
                        engine,
                        renderer,
                        wrapper,
                    };
                    resolve(DumpToolsEngine);
                });
            })
                .catch(reject);
        });
    }
    return await EnginePromise;
}
/**
 * Dumps the current bound framebuffer
 * @param width defines the rendering width
 * @param height defines the rendering height
 * @param engine defines the hosting engine
 * @param successCallback defines the callback triggered once the data are available
 * @param mimeType defines the mime type of the result
 * @param fileName defines the filename to download. If present, the result will automatically be downloaded
 * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
 * @returns a void promise
 */
// Should have "Async" in the name but this is a public API and we can't break it now
// eslint-disable-next-line no-restricted-syntax
async function DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName, quality) {
    // Read the contents of the framebuffer
    const bufferView = await engine.readPixels(0, 0, width, height);
    const data = new Uint8Array(bufferView.buffer);
    DumpData(width, height, data, successCallback, mimeType, fileName, true, undefined, quality);
}
/**
 * Dumps an array buffer
 * @param width defines the rendering width
 * @param height defines the rendering height
 * @param data the data array
 * @param mimeType defines the mime type of the result
 * @param fileName defines the filename to download. If present, the result will automatically be downloaded
 * @param invertY true to invert the picture in the Y dimension
 * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string
 * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
 * @returns a promise that resolve to the final data
 */
async function DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    return new Promise((resolve) => {
        DumpData(width, height, data, (result) => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);
    });
}
/**
 * Dumps an array buffer
 * @param width defines the rendering width
 * @param height defines the rendering height
 * @param data the data array
 * @param successCallback defines the callback triggered once the data are available
 * @param mimeType defines the mime type of the result
 * @param fileName defines the filename to download. If present, the result will automatically be downloaded
 * @param invertY true to invert the picture in the Y dimension
 * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string
 * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
 */
function DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    _CreateDumpRendererAsync().then((renderer) => {
        renderer.engine.setSize(width, height, true);
        // Convert if data are float32
        if (data instanceof Float32Array) {
            const data2 = new Uint8Array(data.length);
            let n = data.length;
            while (n--) {
                const v = data[n];
                data2[n] = Math.round((0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_2__.Clamp)(v) * 255);
            }
            data = data2;
        }
        // Create the image
        const texture = renderer.engine.createRawTexture(data, width, height, 5, false, !invertY, 1);
        renderer.renderer.setViewport();
        renderer.renderer.applyEffectWrapper(renderer.wrapper);
        renderer.wrapper.effect._bindTexture("textureSampler", texture);
        renderer.renderer.draw();
        if (toArrayBuffer) {
            _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.ToBlob(renderer.canvas, (blob) => {
                const fileReader = new FileReader();
                fileReader.onload = (event) => {
                    const arrayBuffer = event.target.result;
                    if (successCallback) {
                        successCallback(arrayBuffer);
                    }
                };
                fileReader.readAsArrayBuffer(blob);
            }, mimeType, quality);
        }
        else {
            _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);
        }
        texture.dispose();
    });
}
/**
 * Dispose the dump tools associated resources
 */
function Dispose() {
    if (DumpToolsEngine) {
        DumpToolsEngine.wrapper.dispose();
        DumpToolsEngine.renderer.dispose();
        DumpToolsEngine.engine.dispose();
    }
    else {
        // in cases where the engine is not yet created, we need to wait for it to dispose it
        EnginePromise?.then((dumpToolsEngine) => {
            dumpToolsEngine.wrapper.dispose();
            dumpToolsEngine.renderer.dispose();
            dumpToolsEngine.engine.dispose();
        });
    }
    EnginePromise = null;
    DumpToolsEngine = null;
}
/**
 * Object containing a set of static utilities functions to dump data from a canvas
 * @deprecated use functions
 */
const DumpTools = {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    DumpData,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    DumpDataAsync,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    DumpFramebuffer,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    Dispose,
};
/**
 * This will be executed automatically for UMD and es5.
 * If esm dev wants the side effects to execute they will have to run it manually
 * Once we build native modules those need to be exported.
 * @internal
 */
const InitSideEffects = () => {
    // References the dependencies.
    _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.DumpData = DumpData;
    _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.DumpDataAsync = DumpDataAsync;
    _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.DumpFramebuffer = DumpFramebuffer;
};
InitSideEffects();
//# sourceMappingURL=dumpTools.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2JhYnlsb25qc19jb3JlX01pc2NfZHVtcFRvb2xzX2pzLmJyb3dzZXItcGFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQytFO0FBQzVDO0FBQ3VCO0FBQ0Y7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRLQUFrQztBQUM5Qyx5QkFBeUIsNkJBQTZCO0FBQ3RELDRDQUE0QyxnRUFBVztBQUN2RDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0VBQVc7QUFDekQ7QUFDQSx3QkFBd0IsZ0VBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdFQUFXO0FBQzNCO0FBQ0EsZ0JBQWdCLGdFQUFXO0FBQzNCO0FBQ0E7QUFDQSx3RUFBd0UsZ0VBQVc7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EscUNBQXFDLHdFQUFjO0FBQ25ELGdCQUFnQiwrT0FBcUMsU0FBUyxpQkFBaUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUVBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsNkdBQTZHO0FBQ3ROO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLDZHQUE2RztBQUN0TjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsNkdBQTZHO0FBQ3ROO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNFQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZLDRDQUFLO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNENBQUs7QUFDVCxJQUFJLDRDQUFLO0FBQ1QsSUFBSSw0Q0FBSztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NaXNjL2R1bXBUb29scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IEVmZmVjdFJlbmRlcmVyLCBFZmZlY3RXcmFwcGVyIH0gZnJvbSBcIi4uL01hdGVyaWFscy9lZmZlY3RSZW5kZXJlci5qc1wiO1xuaW1wb3J0IHsgVG9vbHMgfSBmcm9tIFwiLi90b29scy5qc1wiO1xuaW1wb3J0IHsgQ2xhbXAgfSBmcm9tIFwiLi4vTWF0aHMvbWF0aC5zY2FsYXIuZnVuY3Rpb25zLmpzXCI7XG5pbXBvcnQgeyBFbmdpbmVTdG9yZSB9IGZyb20gXCIuLi9FbmdpbmVzL2VuZ2luZVN0b3JlLmpzXCI7XG5sZXQgRHVtcFRvb2xzRW5naW5lO1xubGV0IEVuZ2luZVByb21pc2UgPSBudWxsO1xuYXN5bmMgZnVuY3Rpb24gX0NyZWF0ZUR1bXBSZW5kZXJlckFzeW5jKCkge1xuICAgIGlmICghRW5naW5lUHJvbWlzZSkge1xuICAgICAgICBFbmdpbmVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNhbnZhcztcbiAgICAgICAgICAgIGxldCBlbmdpbmUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbXBvcnQoXCIuLi9FbmdpbmVzL3RoaW5FbmdpbmUuanNcIilcbiAgICAgICAgICAgICAgICAudGhlbigoeyBUaGluRW5naW5lOiB0aGluRW5naW5lQ2xhc3MgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZ2luZUluc3RhbmNlQ291bnQgPSBFbmdpbmVTdG9yZS5JbnN0YW5jZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMTAwLCAxMDApOyAvLyB3aWxsIGJlIHJlc2l6ZWQgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgZW5naW5lID0gbmV3IHRoaW5FbmdpbmVDbGFzcyhjYW52YXMsIGZhbHNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZ2luZUluc3RhbmNlQ291bnQgPCBFbmdpbmVTdG9yZS5JbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW5naW5lIHdhcyBjcmVhdGVkIGJ5IGFub3RoZXIgaW5zdGFuY2UsIGxldCdzIHVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgRW5naW5lU3RvcmUuSW5zdGFuY2VzLnBvcCgpPy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJyb3dzZXIgZWl0aGVyIGRvZXMgbm90IHN1cHBvcnQgT2Zmc2NyZWVuQ2FudmFzIG9yIFdlYkdMIGNvbnRleHQgaW4gT2Zmc2NyZWVuQ2FudmFzLCBmYWxsYmFjayBvbiBhIHJlZ3VsYXIgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgIGVuZ2luZSA9IG5ldyB0aGluRW5naW5lQ2xhc3MoY2FudmFzLCBmYWxzZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGlzIGVuZ2luZSBmcm9tIHRoZSBsaXN0IG9mIGluc3RhbmNlcyB0byBhdm9pZCB1c2luZyBpdCBmb3Igb3RoZXIgcHVycG9zZXNcbiAgICAgICAgICAgICAgICBFbmdpbmVTdG9yZS5JbnN0YW5jZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgbWFrZSBzdXJlIHRvIGRpc3Bvc2UgaXQgd2hlbiBubyBvdGhlciBlbmdpbmVzIGFyZSBsZWZ0XG4gICAgICAgICAgICAgICAgRW5naW5lU3RvcmUuT25FbmdpbmVzRGlzcG9zZWRPYnNlcnZhYmxlLmFkZCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBndWFyYW50ZWVkIHRvIHJ1biB3aGVuIG5vIG90aGVyIGluc3RhbmNlcyBhcmUgbGVmdFxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGRpc3Bvc2UgaWYgaXQncyBub3QgdGhlIGN1cnJlbnQgZW5naW5lXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmdpbmUgJiYgZSAhPT0gZW5naW5lICYmICFlbmdpbmUuaXNEaXNwb3NlZCAmJiBFbmdpbmVTdG9yZS5JbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEdW1wIHRoZSBlbmdpbmUgYW5kIHRoZSBhc3NvY2lhdGVkIHJlc291cmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgRGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZW5naW5lLmdldENhcHMoKS5wYXJhbGxlbFNoYWRlckNvbXBpbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgRWZmZWN0UmVuZGVyZXIoZW5naW5lKTtcbiAgICAgICAgICAgICAgICBpbXBvcnQoXCIuLi9TaGFkZXJzL3Bhc3MuZnJhZ21lbnQuanNcIikudGhlbigoeyBwYXNzUGl4ZWxTaGFkZXIgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZ2luZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiRW5naW5lIGlzIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgRWZmZWN0V3JhcHBlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmdpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXNzUGl4ZWxTaGFkZXIubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBwYXNzUGl4ZWxTaGFkZXIuc2hhZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlck5hbWVzOiBbXCJ0ZXh0dXJlU2FtcGxlclwiXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIER1bXBUb29sc0VuZ2luZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZ2luZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShEdW1wVG9vbHNFbmdpbmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBFbmdpbmVQcm9taXNlO1xufVxuLyoqXG4gKiBEdW1wcyB0aGUgY3VycmVudCBib3VuZCBmcmFtZWJ1ZmZlclxuICogQHBhcmFtIHdpZHRoIGRlZmluZXMgdGhlIHJlbmRlcmluZyB3aWR0aFxuICogQHBhcmFtIGhlaWdodCBkZWZpbmVzIHRoZSByZW5kZXJpbmcgaGVpZ2h0XG4gKiBAcGFyYW0gZW5naW5lIGRlZmluZXMgdGhlIGhvc3RpbmcgZW5naW5lXG4gKiBAcGFyYW0gc3VjY2Vzc0NhbGxiYWNrIGRlZmluZXMgdGhlIGNhbGxiYWNrIHRyaWdnZXJlZCBvbmNlIHRoZSBkYXRhIGFyZSBhdmFpbGFibGVcbiAqIEBwYXJhbSBtaW1lVHlwZSBkZWZpbmVzIHRoZSBtaW1lIHR5cGUgb2YgdGhlIHJlc3VsdFxuICogQHBhcmFtIGZpbGVOYW1lIGRlZmluZXMgdGhlIGZpbGVuYW1lIHRvIGRvd25sb2FkLiBJZiBwcmVzZW50LCB0aGUgcmVzdWx0IHdpbGwgYXV0b21hdGljYWxseSBiZSBkb3dubG9hZGVkXG4gKiBAcGFyYW0gcXVhbGl0eSBUaGUgcXVhbGl0eSBvZiB0aGUgaW1hZ2UgaWYgbG9zc3kgbWltZVR5cGUgaXMgdXNlZCAoZS5nLiBpbWFnZS9qcGVnLCBpbWFnZS93ZWJwKS4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvdG9CbG9iIHwgSFRNTENhbnZhc0VsZW1lbnQudG9CbG9iKCl9J3MgYHF1YWxpdHlgIHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIGEgdm9pZCBwcm9taXNlXG4gKi9cbi8vIFNob3VsZCBoYXZlIFwiQXN5bmNcIiBpbiB0aGUgbmFtZSBidXQgdGhpcyBpcyBhIHB1YmxpYyBBUEkgYW5kIHdlIGNhbid0IGJyZWFrIGl0IG5vd1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gRHVtcEZyYW1lYnVmZmVyKHdpZHRoLCBoZWlnaHQsIGVuZ2luZSwgc3VjY2Vzc0NhbGxiYWNrLCBtaW1lVHlwZSA9IFwiaW1hZ2UvcG5nXCIsIGZpbGVOYW1lLCBxdWFsaXR5KSB7XG4gICAgLy8gUmVhZCB0aGUgY29udGVudHMgb2YgdGhlIGZyYW1lYnVmZmVyXG4gICAgY29uc3QgYnVmZmVyVmlldyA9IGF3YWl0IGVuZ2luZS5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXJWaWV3LmJ1ZmZlcik7XG4gICAgRHVtcERhdGEod2lkdGgsIGhlaWdodCwgZGF0YSwgc3VjY2Vzc0NhbGxiYWNrLCBtaW1lVHlwZSwgZmlsZU5hbWUsIHRydWUsIHVuZGVmaW5lZCwgcXVhbGl0eSk7XG59XG4vKipcbiAqIER1bXBzIGFuIGFycmF5IGJ1ZmZlclxuICogQHBhcmFtIHdpZHRoIGRlZmluZXMgdGhlIHJlbmRlcmluZyB3aWR0aFxuICogQHBhcmFtIGhlaWdodCBkZWZpbmVzIHRoZSByZW5kZXJpbmcgaGVpZ2h0XG4gKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBhcnJheVxuICogQHBhcmFtIG1pbWVUeXBlIGRlZmluZXMgdGhlIG1pbWUgdHlwZSBvZiB0aGUgcmVzdWx0XG4gKiBAcGFyYW0gZmlsZU5hbWUgZGVmaW5lcyB0aGUgZmlsZW5hbWUgdG8gZG93bmxvYWQuIElmIHByZXNlbnQsIHRoZSByZXN1bHQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRvd25sb2FkZWRcbiAqIEBwYXJhbSBpbnZlcnRZIHRydWUgdG8gaW52ZXJ0IHRoZSBwaWN0dXJlIGluIHRoZSBZIGRpbWVuc2lvblxuICogQHBhcmFtIHRvQXJyYXlCdWZmZXIgdHJ1ZSB0byBjb252ZXJ0IHRoZSBkYXRhIHRvIGFuIEFycmF5QnVmZmVyIChlbmNvZGVkIGFzIGBtaW1lVHlwZWApIGluc3RlYWQgb2YgYSBiYXNlNjQgc3RyaW5nXG4gKiBAcGFyYW0gcXVhbGl0eSBUaGUgcXVhbGl0eSBvZiB0aGUgaW1hZ2UgaWYgbG9zc3kgbWltZVR5cGUgaXMgdXNlZCAoZS5nLiBpbWFnZS9qcGVnLCBpbWFnZS93ZWJwKS4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvdG9CbG9iIHwgSFRNTENhbnZhc0VsZW1lbnQudG9CbG9iKCl9J3MgYHF1YWxpdHlgIHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmUgdG8gdGhlIGZpbmFsIGRhdGFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIER1bXBEYXRhQXN5bmMod2lkdGgsIGhlaWdodCwgZGF0YSwgbWltZVR5cGUgPSBcImltYWdlL3BuZ1wiLCBmaWxlTmFtZSwgaW52ZXJ0WSA9IGZhbHNlLCB0b0FycmF5QnVmZmVyID0gZmFsc2UsIHF1YWxpdHkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgRHVtcERhdGEod2lkdGgsIGhlaWdodCwgZGF0YSwgKHJlc3VsdCkgPT4gcmVzb2x2ZShyZXN1bHQpLCBtaW1lVHlwZSwgZmlsZU5hbWUsIGludmVydFksIHRvQXJyYXlCdWZmZXIsIHF1YWxpdHkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBEdW1wcyBhbiBhcnJheSBidWZmZXJcbiAqIEBwYXJhbSB3aWR0aCBkZWZpbmVzIHRoZSByZW5kZXJpbmcgd2lkdGhcbiAqIEBwYXJhbSBoZWlnaHQgZGVmaW5lcyB0aGUgcmVuZGVyaW5nIGhlaWdodFxuICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgYXJyYXlcbiAqIEBwYXJhbSBzdWNjZXNzQ2FsbGJhY2sgZGVmaW5lcyB0aGUgY2FsbGJhY2sgdHJpZ2dlcmVkIG9uY2UgdGhlIGRhdGEgYXJlIGF2YWlsYWJsZVxuICogQHBhcmFtIG1pbWVUeXBlIGRlZmluZXMgdGhlIG1pbWUgdHlwZSBvZiB0aGUgcmVzdWx0XG4gKiBAcGFyYW0gZmlsZU5hbWUgZGVmaW5lcyB0aGUgZmlsZW5hbWUgdG8gZG93bmxvYWQuIElmIHByZXNlbnQsIHRoZSByZXN1bHQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRvd25sb2FkZWRcbiAqIEBwYXJhbSBpbnZlcnRZIHRydWUgdG8gaW52ZXJ0IHRoZSBwaWN0dXJlIGluIHRoZSBZIGRpbWVuc2lvblxuICogQHBhcmFtIHRvQXJyYXlCdWZmZXIgdHJ1ZSB0byBjb252ZXJ0IHRoZSBkYXRhIHRvIGFuIEFycmF5QnVmZmVyIChlbmNvZGVkIGFzIGBtaW1lVHlwZWApIGluc3RlYWQgb2YgYSBiYXNlNjQgc3RyaW5nXG4gKiBAcGFyYW0gcXVhbGl0eSBUaGUgcXVhbGl0eSBvZiB0aGUgaW1hZ2UgaWYgbG9zc3kgbWltZVR5cGUgaXMgdXNlZCAoZS5nLiBpbWFnZS9qcGVnLCBpbWFnZS93ZWJwKS4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvdG9CbG9iIHwgSFRNTENhbnZhc0VsZW1lbnQudG9CbG9iKCl9J3MgYHF1YWxpdHlgIHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIER1bXBEYXRhKHdpZHRoLCBoZWlnaHQsIGRhdGEsIHN1Y2Nlc3NDYWxsYmFjaywgbWltZVR5cGUgPSBcImltYWdlL3BuZ1wiLCBmaWxlTmFtZSwgaW52ZXJ0WSA9IGZhbHNlLCB0b0FycmF5QnVmZmVyID0gZmFsc2UsIHF1YWxpdHkpIHtcbiAgICBfQ3JlYXRlRHVtcFJlbmRlcmVyQXN5bmMoKS50aGVuKChyZW5kZXJlcikgPT4ge1xuICAgICAgICByZW5kZXJlci5lbmdpbmUuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgLy8gQ29udmVydCBpZiBkYXRhIGFyZSBmbG9hdDMyXG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhMiA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IGRhdGFbbl07XG4gICAgICAgICAgICAgICAgZGF0YTJbbl0gPSBNYXRoLnJvdW5kKENsYW1wKHYpICogMjU1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBkYXRhMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIGltYWdlXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSByZW5kZXJlci5lbmdpbmUuY3JlYXRlUmF3VGV4dHVyZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCA1LCBmYWxzZSwgIWludmVydFksIDEpO1xuICAgICAgICByZW5kZXJlci5yZW5kZXJlci5zZXRWaWV3cG9ydCgpO1xuICAgICAgICByZW5kZXJlci5yZW5kZXJlci5hcHBseUVmZmVjdFdyYXBwZXIocmVuZGVyZXIud3JhcHBlcik7XG4gICAgICAgIHJlbmRlcmVyLndyYXBwZXIuZWZmZWN0Ll9iaW5kVGV4dHVyZShcInRleHR1cmVTYW1wbGVyXCIsIHRleHR1cmUpO1xuICAgICAgICByZW5kZXJlci5yZW5kZXJlci5kcmF3KCk7XG4gICAgICAgIGlmICh0b0FycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBUb29scy5Ub0Jsb2IocmVuZGVyZXIuY2FudmFzLCAoYmxvYikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICAgICAgICAgIH0sIG1pbWVUeXBlLCBxdWFsaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFRvb2xzLkVuY29kZVNjcmVlbnNob3RDYW52YXNEYXRhKHJlbmRlcmVyLmNhbnZhcywgc3VjY2Vzc0NhbGxiYWNrLCBtaW1lVHlwZSwgZmlsZU5hbWUsIHF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBEaXNwb3NlIHRoZSBkdW1wIHRvb2xzIGFzc29jaWF0ZWQgcmVzb3VyY2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBEaXNwb3NlKCkge1xuICAgIGlmIChEdW1wVG9vbHNFbmdpbmUpIHtcbiAgICAgICAgRHVtcFRvb2xzRW5naW5lLndyYXBwZXIuZGlzcG9zZSgpO1xuICAgICAgICBEdW1wVG9vbHNFbmdpbmUucmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICBEdW1wVG9vbHNFbmdpbmUuZW5naW5lLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGluIGNhc2VzIHdoZXJlIHRoZSBlbmdpbmUgaXMgbm90IHlldCBjcmVhdGVkLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0IHRvIGRpc3Bvc2UgaXRcbiAgICAgICAgRW5naW5lUHJvbWlzZT8udGhlbigoZHVtcFRvb2xzRW5naW5lKSA9PiB7XG4gICAgICAgICAgICBkdW1wVG9vbHNFbmdpbmUud3JhcHBlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICBkdW1wVG9vbHNFbmdpbmUucmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgZHVtcFRvb2xzRW5naW5lLmVuZ2luZS5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBFbmdpbmVQcm9taXNlID0gbnVsbDtcbiAgICBEdW1wVG9vbHNFbmdpbmUgPSBudWxsO1xufVxuLyoqXG4gKiBPYmplY3QgY29udGFpbmluZyBhIHNldCBvZiBzdGF0aWMgdXRpbGl0aWVzIGZ1bmN0aW9ucyB0byBkdW1wIGRhdGEgZnJvbSBhIGNhbnZhc1xuICogQGRlcHJlY2F0ZWQgdXNlIGZ1bmN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgRHVtcFRvb2xzID0ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBEdW1wRGF0YSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgRHVtcERhdGFBc3luYyxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgRHVtcEZyYW1lYnVmZmVyLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBEaXNwb3NlLFxufTtcbi8qKlxuICogVGhpcyB3aWxsIGJlIGV4ZWN1dGVkIGF1dG9tYXRpY2FsbHkgZm9yIFVNRCBhbmQgZXM1LlxuICogSWYgZXNtIGRldiB3YW50cyB0aGUgc2lkZSBlZmZlY3RzIHRvIGV4ZWN1dGUgdGhleSB3aWxsIGhhdmUgdG8gcnVuIGl0IG1hbnVhbGx5XG4gKiBPbmNlIHdlIGJ1aWxkIG5hdGl2ZSBtb2R1bGVzIHRob3NlIG5lZWQgdG8gYmUgZXhwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgSW5pdFNpZGVFZmZlY3RzID0gKCkgPT4ge1xuICAgIC8vIFJlZmVyZW5jZXMgdGhlIGRlcGVuZGVuY2llcy5cbiAgICBUb29scy5EdW1wRGF0YSA9IER1bXBEYXRhO1xuICAgIFRvb2xzLkR1bXBEYXRhQXN5bmMgPSBEdW1wRGF0YUFzeW5jO1xuICAgIFRvb2xzLkR1bXBGcmFtZWJ1ZmZlciA9IER1bXBGcmFtZWJ1ZmZlcjtcbn07XG5Jbml0U2lkZUVmZmVjdHMoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR1bXBUb29scy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=