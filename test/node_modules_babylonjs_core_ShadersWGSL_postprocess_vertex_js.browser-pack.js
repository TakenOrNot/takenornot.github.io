"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["node_modules_babylonjs_core_ShadersWGSL_postprocess_vertex_js"],{

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/postprocess.vertex.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/postprocess.vertex.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   postprocessVertexShaderWGSL: () => (/* binding */ postprocessVertexShaderWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "postprocessVertexShader";
const shader = `attribute position: vec2<f32>;uniform scale: vec2<f32>;varying vUV: vec2<f32>;const madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
vertexOutputs.vUV=(vertexInputs.position*madd+madd)*uniforms.scale;vertexOutputs.position=vec4(vertexInputs.position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}
`;
// Sideeffect
if (!_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.ShadersStoreWGSL[name]) {
    _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.ShadersStoreWGSL[name] = shader;
}
/** @internal */
const postprocessVertexShaderWGSL = { name, shader };
//# sourceMappingURL=postprocess.vertex.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2JhYnlsb25qc19jb3JlX1NoYWRlcnNXR1NMX3Bvc3Rwcm9jZXNzX3ZlcnRleF9qcy5icm93c2VyLXBhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3RDtBQUN4RDtBQUNBLDhDQUE4Qyx5QkFBeUIsdUJBQXVCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnRUFBVztBQUNoQixJQUFJLGdFQUFXO0FBQ2Y7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9TaGFkZXJzV0dTTC9wb3N0cHJvY2Vzcy52ZXJ0ZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5jb25zdCBuYW1lID0gXCJwb3N0cHJvY2Vzc1ZlcnRleFNoYWRlclwiO1xuY29uc3Qgc2hhZGVyID0gYGF0dHJpYnV0ZSBwb3NpdGlvbjogdmVjMjxmMzI+O3VuaWZvcm0gc2NhbGU6IHZlYzI8ZjMyPjt2YXJ5aW5nIHZVVjogdmVjMjxmMzI+O2NvbnN0IG1hZGQ9dmVjMigwLjUsMC41KTtcbiNkZWZpbmUgQ1VTVE9NX1ZFUlRFWF9ERUZJTklUSU9OU1xuQHZlcnRleFxuZm4gbWFpbihpbnB1dCA6IFZlcnRleElucHV0cyktPkZyYWdtZW50SW5wdXRzIHtcbiNkZWZpbmUgQ1VTVE9NX1ZFUlRFWF9NQUlOX0JFR0lOXG52ZXJ0ZXhPdXRwdXRzLnZVVj0odmVydGV4SW5wdXRzLnBvc2l0aW9uKm1hZGQrbWFkZCkqdW5pZm9ybXMuc2NhbGU7dmVydGV4T3V0cHV0cy5wb3NpdGlvbj12ZWM0KHZlcnRleElucHV0cy5wb3NpdGlvbiwwLjAsMS4wKTtcbiNkZWZpbmUgQ1VTVE9NX1ZFUlRFWF9NQUlOX0VORFxufVxuYDtcbi8vIFNpZGVlZmZlY3RcbmlmICghU2hhZGVyU3RvcmUuU2hhZGVyc1N0b3JlV0dTTFtuYW1lXSkge1xuICAgIFNoYWRlclN0b3JlLlNoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgcG9zdHByb2Nlc3NWZXJ0ZXhTaGFkZXJXR1NMID0geyBuYW1lLCBzaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvc3Rwcm9jZXNzLnZlcnRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=