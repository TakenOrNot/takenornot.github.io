"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["node_modules_babylonjs_core_ShadersWGSL_rgbdDecode_fragment_js"],{

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/helperFunctions.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/helperFunctions.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   helperFunctionsWGSL: () => (/* binding */ helperFunctionsWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
// Do not edit.

const name = "helperFunctions";
const shader = `const PI: f32=3.1415926535897932384626433832795;const TWO_PI: f32=6.283185307179586;const HALF_PI: f32=1.5707963267948966;const RECIPROCAL_PI: f32=0.3183098861837907;const RECIPROCAL_PI2: f32=0.15915494309189535;const RECIPROCAL_PI4: f32=0.07957747154594767;const HALF_MIN: f32=5.96046448e-08; 
const LinearEncodePowerApprox: f32=2.2;const GammaEncodePowerApprox: f32=1.0/LinearEncodePowerApprox;const LuminanceEncodeApprox: vec3f=vec3f(0.2126,0.7152,0.0722);const Epsilon:f32=0.0000001;fn square(x: f32)->f32 {return x*x;}
fn saturate(x: f32)->f32 {return clamp(x,0.0,1.0);}
fn saturateVec3(x: vec3f)->vec3f {return clamp(x,vec3f(),vec3f(1.0));}
fn saturateEps(x: f32)->f32 {return clamp(x,Epsilon,1.0);}
fn maxEps(x: f32)->f32 {return max(x,Epsilon);}
fn maxEpsVec3(x: vec3f)->vec3f {return max(x,vec3f(Epsilon));}
fn absEps(x: f32)->f32 {return abs(x)+Epsilon;}
fn transposeMat3(inMatrix: mat3x3f)->mat3x3f {let i0: vec3f=inMatrix[0];let i1: vec3f=inMatrix[1];let i2: vec3f=inMatrix[2];let outMatrix:mat3x3f=mat3x3f(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
fn inverseMat3(inMatrix: mat3x3f)->mat3x3f {let a00: f32=inMatrix[0][0];let a01: f32=inMatrix[0][1];let a02: f32=inMatrix[0][2];let a10: f32=inMatrix[1][0];let a11: f32=inMatrix[1][1];let a12: f32=inMatrix[1][2];let a20: f32=inMatrix[2][0];let a21: f32=inMatrix[2][1];let a22: f32=inMatrix[2][2];let b01: f32=a22*a11-a12*a21;let b11: f32=-a22*a10+a12*a20;let b21: f32=a21*a10-a11*a20;let det: f32=a00*b01+a01*b11+a02*b21;return mat3x3f(b01/det,(-a22*a01+a02*a21)/det,(a12*a01-a02*a11)/det,
b11/det,(a22*a00-a02*a20)/det,(-a12*a00+a02*a10)/det,
b21/det,(-a21*a00+a01*a20)/det,(a11*a00-a01*a10)/det);}
#if USE_EXACT_SRGB_CONVERSIONS
fn toLinearSpaceExact(color: vec3f)->vec3f
{let nearZeroSection: vec3f=0.0773993808*color;let remainingSection: vec3f=pow(0.947867299*(color+vec3f(0.055)),vec3f(2.4));return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3f(0.04045)));}
fn toGammaSpaceExact(color: vec3f)->vec3f
{let nearZeroSection: vec3f=12.92*color;let remainingSection: vec3f=1.055*pow(color,vec3f(0.41666))-vec3f(0.055);return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3f(0.0031308)));}
#endif
fn toLinearSpace(color: f32)->f32
{
#if USE_EXACT_SRGB_CONVERSIONS
var nearZeroSection=0.0773993808*color;var remainingSection=pow(0.947867299*(color+0.055),2.4);return select(remainingSection,nearZeroSection,color<=0.04045);
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
fn toLinearSpaceVec3(color: vec3f)->vec3f
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3f(LinearEncodePowerApprox));
#endif
}
fn toLinearSpaceVec4(color: vec4<f32>)->vec4<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4f(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4f(pow(color.rgb,vec3f(LinearEncodePowerApprox)),color.a);
#endif
}
fn toGammaSpace(color: vec4<f32>)->vec4<f32>
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4<f32>(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4<f32>(pow(color.rgb,vec3f(GammaEncodePowerApprox)),color.a);
#endif
}
fn toGammaSpaceVec3(color: vec3f)->vec3f
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3f(GammaEncodePowerApprox));
#endif
}
fn squareVec3(value: vec3f)->vec3f
{return value*value;}
fn pow5(value: f32)->f32 {let sq: f32=value*value;return sq*sq*value;}
fn getLuminance(color: vec3f)->f32
{return saturate(dot(color,LuminanceEncodeApprox));}
fn getRand(seed: vec2<f32>)->f32 {return fract(sin(dot(seed.xy ,vec2<f32>(12.9898,78.233)))*43758.5453);}
fn dither(seed: vec2<f32>,varianceAmount: f32)->f32 {let rand: f32=getRand(seed);let normVariance: f32=varianceAmount/255.0;let dither: f32=mix(-normVariance,normVariance,rand);return dither;}
const rgbdMaxRange: f32=255.0;fn toRGBD(color: vec3f)->vec4<f32> {let maxRGB: f32=max(max(color.r,max(color.g,color.b)),Epsilon);var D: f32 =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);var rgb: vec3f =color.rgb*D;rgb=toGammaSpaceVec3(rgb);return vec4<f32>(saturateVec3(rgb),D);}
fn fromRGBD(rgbd: vec4<f32>)->vec3f {let rgb=toLinearSpaceVec3(rgbd.rgb);return rgb/rgbd.a;}
fn parallaxCorrectNormal(vertexPos: vec3f,origVec: vec3f,cubeSize: vec3f,cubePos: vec3f)->vec3f {let invOrigVec: vec3f=vec3f(1.)/origVec;let halfSize: vec3f=cubeSize*0.5;let intersecAtMaxPlane: vec3f=(cubePos+halfSize-vertexPos)*invOrigVec;let intersecAtMinPlane: vec3f=(cubePos-halfSize-vertexPos)*invOrigVec;let largestIntersec: vec3f=max(intersecAtMaxPlane,intersecAtMinPlane);let distance: f32=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);let intersectPositionWS: vec3f=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
fn equirectangularToCubemapDirection(uv : vec2f)->vec3f {var longitude : f32=uv.x*TWO_PI-PI;var latitude : f32=HALF_PI-uv.y*PI;var direction : vec3f;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}
fn sqrtClamped(value: f32)->f32 {return sqrt(max(value,0.));}
fn avg(value: vec3f)->f32 {return dot(value,vec3f(0.333333333));}
`;
// Sideeffect
if (!_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name]) {
    _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.IncludesShadersStoreWGSL[name] = shader;
}
/** @internal */
const helperFunctionsWGSL = { name, shader };
//# sourceMappingURL=helperFunctions.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/ShadersWGSL/rgbdDecode.fragment.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/ShadersWGSL/rgbdDecode.fragment.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rgbdDecodePixelShaderWGSL: () => (/* binding */ rgbdDecodePixelShaderWGSL)
/* harmony export */ });
/* harmony import */ var _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Engines/shaderStore.js */ "./node_modules/@babylonjs/core/Engines/shaderStore.js");
/* harmony import */ var _ShadersInclude_helperFunctions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShadersInclude/helperFunctions.js */ "./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/helperFunctions.js");
// Do not edit.


const name = "rgbdDecodePixelShader";
const shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=vec4f(fromRGBD(textureSample(textureSampler,textureSamplerSampler,input.vUV)),1.0);}`;
// Sideeffect
if (!_Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.ShadersStoreWGSL[name]) {
    _Engines_shaderStore_js__WEBPACK_IMPORTED_MODULE_0__.ShaderStore.ShadersStoreWGSL[name] = shader;
}
/** @internal */
const rgbdDecodePixelShaderWGSL = { name, shader };
//# sourceMappingURL=rgbdDecode.fragment.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2JhYnlsb25qc19jb3JlX1NoYWRlcnNXR1NMX3JnYmREZWNvZGVfZnJhZ21lbnRfanMuYnJvd3Nlci1wYWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDMkQ7QUFDM0Q7QUFDQSxnRUFBZ0Usb0NBQW9DLHNDQUFzQyw0Q0FBNEMsOENBQThDLDhDQUE4QztBQUNsUix1Q0FBdUMsOERBQThELCtEQUErRCw0QkFBNEIsd0JBQXdCO0FBQ3hOLDBCQUEwQjtBQUMxQixrQ0FBa0M7QUFDbEMsNkJBQTZCO0FBQzdCLHdCQUF3QjtBQUN4QixnQ0FBZ0M7QUFDaEMsd0JBQXdCO0FBQ3hCLDhDQUE4QywwQkFBMEIsMEJBQTBCLDBCQUEwQjtBQUM1SDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsNENBQTRDLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDZCQUE2Qiw4QkFBOEIsNkJBQTZCLHFDQUFxQztBQUNyYTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDLDZFQUE2RTtBQUM1SDtBQUNBLENBQUMsdUNBQXVDLHlFQUF5RTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3REFBd0Q7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBLENBQUM7QUFDRCxrQ0FBa0M7QUFDbEMscURBQXFELDRCQUE0QiwyQ0FBMkMscURBQXFEO0FBQ2pMLDhCQUE4QixvQ0FBb0MsK0RBQStELHdDQUF3QywrQkFBK0IsNEJBQTRCLDBCQUEwQjtBQUM5UCxxQ0FBcUMsb0NBQW9DO0FBQ3pFLGlHQUFpRyx3Q0FBd0MsaUNBQWlDLHNFQUFzRSxzRUFBc0Usc0VBQXNFLGtGQUFrRiwwREFBMEQ7QUFDeGdCLHlEQUF5RCxtQ0FBbUMsbUNBQW1DLHNCQUFzQix5Q0FBeUMsMEJBQTBCLHlDQUF5QztBQUNqUSxpQ0FBaUM7QUFDakMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLLGdFQUFXO0FBQ2hCLElBQUksZ0VBQVc7QUFDZjtBQUNBO0FBQ08sOEJBQThCO0FBQ3JDOzs7Ozs7Ozs7Ozs7Ozs7O0FDckZBO0FBQ3dEO0FBQ1g7QUFDN0M7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwR0FBMEc7QUFDM0o7QUFDQSxLQUFLLGdFQUFXO0FBQ2hCLElBQUksZ0VBQVc7QUFDZjtBQUNBO0FBQ08sb0NBQW9DO0FBQzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL1NoYWRlcnNXR1NML1NoYWRlcnNJbmNsdWRlL2hlbHBlckZ1bmN0aW9ucy5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvU2hhZGVyc1dHU0wvcmdiZERlY29kZS5mcmFnbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEbyBub3QgZWRpdC5cbmltcG9ydCB7IFNoYWRlclN0b3JlIH0gZnJvbSBcIi4uLy4uL0VuZ2luZXMvc2hhZGVyU3RvcmUuanNcIjtcbmNvbnN0IG5hbWUgPSBcImhlbHBlckZ1bmN0aW9uc1wiO1xuY29uc3Qgc2hhZGVyID0gYGNvbnN0IFBJOiBmMzI9My4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1O2NvbnN0IFRXT19QSTogZjMyPTYuMjgzMTg1MzA3MTc5NTg2O2NvbnN0IEhBTEZfUEk6IGYzMj0xLjU3MDc5NjMyNjc5NDg5NjY7Y29uc3QgUkVDSVBST0NBTF9QSTogZjMyPTAuMzE4MzA5ODg2MTgzNzkwNztjb25zdCBSRUNJUFJPQ0FMX1BJMjogZjMyPTAuMTU5MTU0OTQzMDkxODk1MzU7Y29uc3QgUkVDSVBST0NBTF9QSTQ6IGYzMj0wLjA3OTU3NzQ3MTU0NTk0NzY3O2NvbnN0IEhBTEZfTUlOOiBmMzI9NS45NjA0NjQ0OGUtMDg7IFxuY29uc3QgTGluZWFyRW5jb2RlUG93ZXJBcHByb3g6IGYzMj0yLjI7Y29uc3QgR2FtbWFFbmNvZGVQb3dlckFwcHJveDogZjMyPTEuMC9MaW5lYXJFbmNvZGVQb3dlckFwcHJveDtjb25zdCBMdW1pbmFuY2VFbmNvZGVBcHByb3g6IHZlYzNmPXZlYzNmKDAuMjEyNiwwLjcxNTIsMC4wNzIyKTtjb25zdCBFcHNpbG9uOmYzMj0wLjAwMDAwMDE7Zm4gc3F1YXJlKHg6IGYzMiktPmYzMiB7cmV0dXJuIHgqeDt9XG5mbiBzYXR1cmF0ZSh4OiBmMzIpLT5mMzIge3JldHVybiBjbGFtcCh4LDAuMCwxLjApO31cbmZuIHNhdHVyYXRlVmVjMyh4OiB2ZWMzZiktPnZlYzNmIHtyZXR1cm4gY2xhbXAoeCx2ZWMzZigpLHZlYzNmKDEuMCkpO31cbmZuIHNhdHVyYXRlRXBzKHg6IGYzMiktPmYzMiB7cmV0dXJuIGNsYW1wKHgsRXBzaWxvbiwxLjApO31cbmZuIG1heEVwcyh4OiBmMzIpLT5mMzIge3JldHVybiBtYXgoeCxFcHNpbG9uKTt9XG5mbiBtYXhFcHNWZWMzKHg6IHZlYzNmKS0+dmVjM2Yge3JldHVybiBtYXgoeCx2ZWMzZihFcHNpbG9uKSk7fVxuZm4gYWJzRXBzKHg6IGYzMiktPmYzMiB7cmV0dXJuIGFicyh4KStFcHNpbG9uO31cbmZuIHRyYW5zcG9zZU1hdDMoaW5NYXRyaXg6IG1hdDN4M2YpLT5tYXQzeDNmIHtsZXQgaTA6IHZlYzNmPWluTWF0cml4WzBdO2xldCBpMTogdmVjM2Y9aW5NYXRyaXhbMV07bGV0IGkyOiB2ZWMzZj1pbk1hdHJpeFsyXTtsZXQgb3V0TWF0cml4Om1hdDN4M2Y9bWF0M3gzZihcbnZlYzMoaTAueCxpMS54LGkyLngpLFxudmVjMyhpMC55LGkxLnksaTIueSksXG52ZWMzKGkwLnosaTEueixpMi56KVxuKTtyZXR1cm4gb3V0TWF0cml4O31cbmZuIGludmVyc2VNYXQzKGluTWF0cml4OiBtYXQzeDNmKS0+bWF0M3gzZiB7bGV0IGEwMDogZjMyPWluTWF0cml4WzBdWzBdO2xldCBhMDE6IGYzMj1pbk1hdHJpeFswXVsxXTtsZXQgYTAyOiBmMzI9aW5NYXRyaXhbMF1bMl07bGV0IGExMDogZjMyPWluTWF0cml4WzFdWzBdO2xldCBhMTE6IGYzMj1pbk1hdHJpeFsxXVsxXTtsZXQgYTEyOiBmMzI9aW5NYXRyaXhbMV1bMl07bGV0IGEyMDogZjMyPWluTWF0cml4WzJdWzBdO2xldCBhMjE6IGYzMj1pbk1hdHJpeFsyXVsxXTtsZXQgYTIyOiBmMzI9aW5NYXRyaXhbMl1bMl07bGV0IGIwMTogZjMyPWEyMiphMTEtYTEyKmEyMTtsZXQgYjExOiBmMzI9LWEyMiphMTArYTEyKmEyMDtsZXQgYjIxOiBmMzI9YTIxKmExMC1hMTEqYTIwO2xldCBkZXQ6IGYzMj1hMDAqYjAxK2EwMSpiMTErYTAyKmIyMTtyZXR1cm4gbWF0M3gzZihiMDEvZGV0LCgtYTIyKmEwMSthMDIqYTIxKS9kZXQsKGExMiphMDEtYTAyKmExMSkvZGV0LFxuYjExL2RldCwoYTIyKmEwMC1hMDIqYTIwKS9kZXQsKC1hMTIqYTAwK2EwMiphMTApL2RldCxcbmIyMS9kZXQsKC1hMjEqYTAwK2EwMSphMjApL2RldCwoYTExKmEwMC1hMDEqYTEwKS9kZXQpO31cbiNpZiBVU0VfRVhBQ1RfU1JHQl9DT05WRVJTSU9OU1xuZm4gdG9MaW5lYXJTcGFjZUV4YWN0KGNvbG9yOiB2ZWMzZiktPnZlYzNmXG57bGV0IG5lYXJaZXJvU2VjdGlvbjogdmVjM2Y9MC4wNzczOTkzODA4KmNvbG9yO2xldCByZW1haW5pbmdTZWN0aW9uOiB2ZWMzZj1wb3coMC45NDc4NjcyOTkqKGNvbG9yK3ZlYzNmKDAuMDU1KSksdmVjM2YoMi40KSk7cmV0dXJuIG1peChyZW1haW5pbmdTZWN0aW9uLG5lYXJaZXJvU2VjdGlvbixsZXNzVGhhbkVxdWFsKGNvbG9yLHZlYzNmKDAuMDQwNDUpKSk7fVxuZm4gdG9HYW1tYVNwYWNlRXhhY3QoY29sb3I6IHZlYzNmKS0+dmVjM2ZcbntsZXQgbmVhclplcm9TZWN0aW9uOiB2ZWMzZj0xMi45Mipjb2xvcjtsZXQgcmVtYWluaW5nU2VjdGlvbjogdmVjM2Y9MS4wNTUqcG93KGNvbG9yLHZlYzNmKDAuNDE2NjYpKS12ZWMzZigwLjA1NSk7cmV0dXJuIG1peChyZW1haW5pbmdTZWN0aW9uLG5lYXJaZXJvU2VjdGlvbixsZXNzVGhhbkVxdWFsKGNvbG9yLHZlYzNmKDAuMDAzMTMwOCkpKTt9XG4jZW5kaWZcbmZuIHRvTGluZWFyU3BhY2UoY29sb3I6IGYzMiktPmYzMlxue1xuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG52YXIgbmVhclplcm9TZWN0aW9uPTAuMDc3Mzk5MzgwOCpjb2xvcjt2YXIgcmVtYWluaW5nU2VjdGlvbj1wb3coMC45NDc4NjcyOTkqKGNvbG9yKzAuMDU1KSwyLjQpO3JldHVybiBzZWxlY3QocmVtYWluaW5nU2VjdGlvbixuZWFyWmVyb1NlY3Rpb24sY29sb3I8PTAuMDQwNDUpO1xuI2Vsc2VcbnJldHVybiBwb3coY29sb3IsTGluZWFyRW5jb2RlUG93ZXJBcHByb3gpO1xuI2VuZGlmXG59XG5mbiB0b0xpbmVhclNwYWNlVmVjMyhjb2xvcjogdmVjM2YpLT52ZWMzZlxue1xuI2lmIFVTRV9FWEFDVF9TUkdCX0NPTlZFUlNJT05TXG5yZXR1cm4gdG9MaW5lYXJTcGFjZUV4YWN0KGNvbG9yKTtcbiNlbHNlXG5yZXR1cm4gcG93KGNvbG9yLHZlYzNmKExpbmVhckVuY29kZVBvd2VyQXBwcm94KSk7XG4jZW5kaWZcbn1cbmZuIHRvTGluZWFyU3BhY2VWZWM0KGNvbG9yOiB2ZWM0PGYzMj4pLT52ZWM0PGYzMj5cbntcbiNpZiBVU0VfRVhBQ1RfU1JHQl9DT05WRVJTSU9OU1xucmV0dXJuIHZlYzRmKHRvTGluZWFyU3BhY2VFeGFjdChjb2xvci5yZ2IpLGNvbG9yLmEpO1xuI2Vsc2VcbnJldHVybiB2ZWM0Zihwb3coY29sb3IucmdiLHZlYzNmKExpbmVhckVuY29kZVBvd2VyQXBwcm94KSksY29sb3IuYSk7XG4jZW5kaWZcbn1cbmZuIHRvR2FtbWFTcGFjZShjb2xvcjogdmVjNDxmMzI+KS0+dmVjNDxmMzI+XG57XG4jaWYgVVNFX0VYQUNUX1NSR0JfQ09OVkVSU0lPTlNcbnJldHVybiB2ZWM0PGYzMj4odG9HYW1tYVNwYWNlRXhhY3QoY29sb3IucmdiKSxjb2xvci5hKTtcbiNlbHNlXG5yZXR1cm4gdmVjNDxmMzI+KHBvdyhjb2xvci5yZ2IsdmVjM2YoR2FtbWFFbmNvZGVQb3dlckFwcHJveCkpLGNvbG9yLmEpO1xuI2VuZGlmXG59XG5mbiB0b0dhbW1hU3BhY2VWZWMzKGNvbG9yOiB2ZWMzZiktPnZlYzNmXG57XG4jaWYgVVNFX0VYQUNUX1NSR0JfQ09OVkVSU0lPTlNcbnJldHVybiB0b0dhbW1hU3BhY2VFeGFjdChjb2xvcik7XG4jZWxzZVxucmV0dXJuIHBvdyhjb2xvcix2ZWMzZihHYW1tYUVuY29kZVBvd2VyQXBwcm94KSk7XG4jZW5kaWZcbn1cbmZuIHNxdWFyZVZlYzModmFsdWU6IHZlYzNmKS0+dmVjM2ZcbntyZXR1cm4gdmFsdWUqdmFsdWU7fVxuZm4gcG93NSh2YWx1ZTogZjMyKS0+ZjMyIHtsZXQgc3E6IGYzMj12YWx1ZSp2YWx1ZTtyZXR1cm4gc3Eqc3EqdmFsdWU7fVxuZm4gZ2V0THVtaW5hbmNlKGNvbG9yOiB2ZWMzZiktPmYzMlxue3JldHVybiBzYXR1cmF0ZShkb3QoY29sb3IsTHVtaW5hbmNlRW5jb2RlQXBwcm94KSk7fVxuZm4gZ2V0UmFuZChzZWVkOiB2ZWMyPGYzMj4pLT5mMzIge3JldHVybiBmcmFjdChzaW4oZG90KHNlZWQueHkgLHZlYzI8ZjMyPigxMi45ODk4LDc4LjIzMykpKSo0Mzc1OC41NDUzKTt9XG5mbiBkaXRoZXIoc2VlZDogdmVjMjxmMzI+LHZhcmlhbmNlQW1vdW50OiBmMzIpLT5mMzIge2xldCByYW5kOiBmMzI9Z2V0UmFuZChzZWVkKTtsZXQgbm9ybVZhcmlhbmNlOiBmMzI9dmFyaWFuY2VBbW91bnQvMjU1LjA7bGV0IGRpdGhlcjogZjMyPW1peCgtbm9ybVZhcmlhbmNlLG5vcm1WYXJpYW5jZSxyYW5kKTtyZXR1cm4gZGl0aGVyO31cbmNvbnN0IHJnYmRNYXhSYW5nZTogZjMyPTI1NS4wO2ZuIHRvUkdCRChjb2xvcjogdmVjM2YpLT52ZWM0PGYzMj4ge2xldCBtYXhSR0I6IGYzMj1tYXgobWF4KGNvbG9yLnIsbWF4KGNvbG9yLmcsY29sb3IuYikpLEVwc2lsb24pO3ZhciBEOiBmMzIgPW1heChyZ2JkTWF4UmFuZ2UvbWF4UkdCLDEuKTtEID1jbGFtcChmbG9vcihEKS8yNTUuMCwwLiwxLik7dmFyIHJnYjogdmVjM2YgPWNvbG9yLnJnYipEO3JnYj10b0dhbW1hU3BhY2VWZWMzKHJnYik7cmV0dXJuIHZlYzQ8ZjMyPihzYXR1cmF0ZVZlYzMocmdiKSxEKTt9XG5mbiBmcm9tUkdCRChyZ2JkOiB2ZWM0PGYzMj4pLT52ZWMzZiB7bGV0IHJnYj10b0xpbmVhclNwYWNlVmVjMyhyZ2JkLnJnYik7cmV0dXJuIHJnYi9yZ2JkLmE7fVxuZm4gcGFyYWxsYXhDb3JyZWN0Tm9ybWFsKHZlcnRleFBvczogdmVjM2Ysb3JpZ1ZlYzogdmVjM2YsY3ViZVNpemU6IHZlYzNmLGN1YmVQb3M6IHZlYzNmKS0+dmVjM2Yge2xldCBpbnZPcmlnVmVjOiB2ZWMzZj12ZWMzZigxLikvb3JpZ1ZlYztsZXQgaGFsZlNpemU6IHZlYzNmPWN1YmVTaXplKjAuNTtsZXQgaW50ZXJzZWNBdE1heFBsYW5lOiB2ZWMzZj0oY3ViZVBvcytoYWxmU2l6ZS12ZXJ0ZXhQb3MpKmludk9yaWdWZWM7bGV0IGludGVyc2VjQXRNaW5QbGFuZTogdmVjM2Y9KGN1YmVQb3MtaGFsZlNpemUtdmVydGV4UG9zKSppbnZPcmlnVmVjO2xldCBsYXJnZXN0SW50ZXJzZWM6IHZlYzNmPW1heChpbnRlcnNlY0F0TWF4UGxhbmUsaW50ZXJzZWNBdE1pblBsYW5lKTtsZXQgZGlzdGFuY2U6IGYzMj1taW4obWluKGxhcmdlc3RJbnRlcnNlYy54LGxhcmdlc3RJbnRlcnNlYy55KSxsYXJnZXN0SW50ZXJzZWMueik7bGV0IGludGVyc2VjdFBvc2l0aW9uV1M6IHZlYzNmPXZlcnRleFBvcytvcmlnVmVjKmRpc3RhbmNlO3JldHVybiBpbnRlcnNlY3RQb3NpdGlvbldTLWN1YmVQb3M7fVxuZm4gZXF1aXJlY3Rhbmd1bGFyVG9DdWJlbWFwRGlyZWN0aW9uKHV2IDogdmVjMmYpLT52ZWMzZiB7dmFyIGxvbmdpdHVkZSA6IGYzMj11di54KlRXT19QSS1QSTt2YXIgbGF0aXR1ZGUgOiBmMzI9SEFMRl9QSS11di55KlBJO3ZhciBkaXJlY3Rpb24gOiB2ZWMzZjtkaXJlY3Rpb24ueD1jb3MobGF0aXR1ZGUpKnNpbihsb25naXR1ZGUpO2RpcmVjdGlvbi55PXNpbihsYXRpdHVkZSk7ZGlyZWN0aW9uLno9Y29zKGxhdGl0dWRlKSpjb3MobG9uZ2l0dWRlKTtyZXR1cm4gZGlyZWN0aW9uO31cbmZuIHNxcnRDbGFtcGVkKHZhbHVlOiBmMzIpLT5mMzIge3JldHVybiBzcXJ0KG1heCh2YWx1ZSwwLikpO31cbmZuIGF2Zyh2YWx1ZTogdmVjM2YpLT5mMzIge3JldHVybiBkb3QodmFsdWUsdmVjM2YoMC4zMzMzMzMzMzMpKTt9XG5gO1xuLy8gU2lkZWVmZmVjdFxuaWYgKCFTaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0pIHtcbiAgICBTaGFkZXJTdG9yZS5JbmNsdWRlc1NoYWRlcnNTdG9yZVdHU0xbbmFtZV0gPSBzaGFkZXI7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgaGVscGVyRnVuY3Rpb25zV0dTTCA9IHsgbmFtZSwgc2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJGdW5jdGlvbnMuanMubWFwIiwiLy8gRG8gbm90IGVkaXQuXG5pbXBvcnQgeyBTaGFkZXJTdG9yZSB9IGZyb20gXCIuLi9FbmdpbmVzL3NoYWRlclN0b3JlLmpzXCI7XG5pbXBvcnQgXCIuL1NoYWRlcnNJbmNsdWRlL2hlbHBlckZ1bmN0aW9ucy5qc1wiO1xuY29uc3QgbmFtZSA9IFwicmdiZERlY29kZVBpeGVsU2hhZGVyXCI7XG5jb25zdCBzaGFkZXIgPSBgdmFyeWluZyB2VVY6IHZlYzJmO3ZhciB0ZXh0dXJlU2FtcGxlclNhbXBsZXI6IHNhbXBsZXI7dmFyIHRleHR1cmVTYW1wbGVyOiB0ZXh0dXJlXzJkPGYzMj47XG4jaW5jbHVkZTxoZWxwZXJGdW5jdGlvbnM+XG4jZGVmaW5lIENVU1RPTV9GUkFHTUVOVF9ERUZJTklUSU9OU1xuQGZyYWdtZW50XG5mbiBtYWluKGlucHV0OiBGcmFnbWVudElucHV0cyktPkZyYWdtZW50T3V0cHV0cyB7ZnJhZ21lbnRPdXRwdXRzLmNvbG9yPXZlYzRmKGZyb21SR0JEKHRleHR1cmVTYW1wbGUodGV4dHVyZVNhbXBsZXIsdGV4dHVyZVNhbXBsZXJTYW1wbGVyLGlucHV0LnZVVikpLDEuMCk7fWA7XG4vLyBTaWRlZWZmZWN0XG5pZiAoIVNoYWRlclN0b3JlLlNoYWRlcnNTdG9yZVdHU0xbbmFtZV0pIHtcbiAgICBTaGFkZXJTdG9yZS5TaGFkZXJzU3RvcmVXR1NMW25hbWVdID0gc2hhZGVyO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHJnYmREZWNvZGVQaXhlbFNoYWRlcldHU0wgPSB7IG5hbWUsIHNoYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmdiZERlY29kZS5mcmFnbWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=