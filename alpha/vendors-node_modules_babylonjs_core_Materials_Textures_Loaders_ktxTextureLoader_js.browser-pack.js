"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["vendors-node_modules_babylonjs_core_Materials_Textures_Loaders_ktxTextureLoader_js"],{

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/ktxTextureLoader.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/ktxTextureLoader.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _KTXTextureLoader: () => (/* binding */ _KTXTextureLoader)
/* harmony export */ });
/* harmony import */ var _Misc_khronosTextureContainer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Misc/khronosTextureContainer.js */ "./node_modules/@babylonjs/core/Misc/khronosTextureContainer.js");
/* harmony import */ var _Misc_khronosTextureContainer2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Misc/khronosTextureContainer2.js */ "./node_modules/@babylonjs/core/Misc/khronosTextureContainer2.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");




function MapSRGBToLinear(format) {
    switch (format) {
        case 35916:
            return 33776;
        case 35918:
            return 33778;
        case 35919:
            return 33779;
        case 37493:
            return 37492;
        case 37497:
            return 37496;
        case 37495:
            return 37494;
        case 37840:
            return 37808;
        case 36493:
            return 36492;
    }
    return null;
}
/**
 * Implementation of the KTX Texture Loader.
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class _KTXTextureLoader {
    constructor() {
        /**
         * Defines whether the loader supports cascade loading the different faces.
         */
        this.supportCascades = false;
    }
    /**
     * Uploads the cube texture data to the WebGL texture. It has already been bound.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param createPolynomials will be true if polynomials have been requested
     * @param onLoad defines the callback to trigger once the texture is ready
     */
    loadCubeData(data, texture, createPolynomials, onLoad) {
        if (Array.isArray(data)) {
            return;
        }
        // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture
        texture._invertVScale = !texture.invertY;
        const engine = texture.getEngine();
        const ktx = new _Misc_khronosTextureContainer_js__WEBPACK_IMPORTED_MODULE_0__.KhronosTextureContainer(data, 6);
        const loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;
        engine._unpackFlipY(true);
        ktx.uploadLevels(texture, texture.generateMipMaps);
        texture.width = ktx.pixelWidth;
        texture.height = ktx.pixelHeight;
        engine._setCubeMapTextureParams(texture, loadMipmap, ktx.numberOfMipmapLevels - 1);
        texture.isReady = true;
        texture.onLoadedObservable.notifyObservers(texture);
        texture.onLoadedObservable.clear();
        if (onLoad) {
            onLoad();
        }
    }
    /**
     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param callback defines the method to call once ready to upload
     * @param options
     */
    loadData(data, texture, callback, options) {
        if (_Misc_khronosTextureContainer_js__WEBPACK_IMPORTED_MODULE_0__.KhronosTextureContainer.IsValid(data)) {
            // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture
            texture._invertVScale = !texture.invertY;
            const ktx = new _Misc_khronosTextureContainer_js__WEBPACK_IMPORTED_MODULE_0__.KhronosTextureContainer(data, 1);
            const mappedFormat = MapSRGBToLinear(ktx.glInternalFormat);
            if (mappedFormat) {
                texture.format = mappedFormat;
                texture._useSRGBBuffer = texture.getEngine()._getUseSRGBBuffer(true, texture.generateMipMaps);
                texture._gammaSpace = true;
            }
            else {
                texture.format = ktx.glInternalFormat;
            }
            callback(ktx.pixelWidth, ktx.pixelHeight, texture.generateMipMaps, true, () => {
                ktx.uploadLevels(texture, texture.generateMipMaps);
            }, ktx.isInvalid);
        }
        else if (_Misc_khronosTextureContainer2_js__WEBPACK_IMPORTED_MODULE_1__.KhronosTextureContainer2.IsValid(data)) {
            const ktx2 = new _Misc_khronosTextureContainer2_js__WEBPACK_IMPORTED_MODULE_1__.KhronosTextureContainer2(texture.getEngine());
            ktx2._uploadAsync(data, texture, options).then(() => {
                callback(texture.width, texture.height, texture.generateMipMaps, true, () => { }, false);
            }, (error) => {
                _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.Warn(`Failed to load KTX2 texture data: ${error.message}`);
                callback(0, 0, false, false, () => { }, true);
            });
        }
        else {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.Error("texture missing KTX identifier");
            callback(0, 0, false, false, () => { }, true);
        }
    }
}
//# sourceMappingURL=ktxTextureLoader.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/ktx2decoderTypes.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/ktx2decoderTypes.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EngineFormat: () => (/* binding */ EngineFormat),
/* harmony export */   SourceTextureFormat: () => (/* binding */ SourceTextureFormat),
/* harmony export */   TranscodeTarget: () => (/* binding */ TranscodeTarget)
/* harmony export */ });
var SourceTextureFormat;
(function (SourceTextureFormat) {
    SourceTextureFormat[SourceTextureFormat["ETC1S"] = 0] = "ETC1S";
    // eslint-disable-next-line @typescript-eslint/naming-convention
    SourceTextureFormat[SourceTextureFormat["UASTC4x4"] = 1] = "UASTC4x4";
})(SourceTextureFormat || (SourceTextureFormat = {}));
var TranscodeTarget;
(function (TranscodeTarget) {
    TranscodeTarget[TranscodeTarget["ASTC_4X4_RGBA"] = 0] = "ASTC_4X4_RGBA";
    TranscodeTarget[TranscodeTarget["BC7_RGBA"] = 1] = "BC7_RGBA";
    TranscodeTarget[TranscodeTarget["BC3_RGBA"] = 2] = "BC3_RGBA";
    TranscodeTarget[TranscodeTarget["BC1_RGB"] = 3] = "BC1_RGB";
    TranscodeTarget[TranscodeTarget["PVRTC1_4_RGBA"] = 4] = "PVRTC1_4_RGBA";
    TranscodeTarget[TranscodeTarget["PVRTC1_4_RGB"] = 5] = "PVRTC1_4_RGB";
    TranscodeTarget[TranscodeTarget["ETC2_RGBA"] = 6] = "ETC2_RGBA";
    TranscodeTarget[TranscodeTarget["ETC1_RGB"] = 7] = "ETC1_RGB";
    TranscodeTarget[TranscodeTarget["RGBA32"] = 8] = "RGBA32";
    TranscodeTarget[TranscodeTarget["R8"] = 9] = "R8";
    TranscodeTarget[TranscodeTarget["RG8"] = 10] = "RG8";
})(TranscodeTarget || (TranscodeTarget = {}));
var EngineFormat;
(function (EngineFormat) {
    EngineFormat[EngineFormat["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
    EngineFormat[EngineFormat["COMPRESSED_RGBA_ASTC_4X4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4X4_KHR";
    EngineFormat[EngineFormat["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    EngineFormat[EngineFormat["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    EngineFormat[EngineFormat["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
    EngineFormat[EngineFormat["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
    EngineFormat[EngineFormat["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
    EngineFormat[EngineFormat["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    EngineFormat[EngineFormat["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
    EngineFormat[EngineFormat["RGBA8Format"] = 32856] = "RGBA8Format";
    EngineFormat[EngineFormat["R8Format"] = 33321] = "R8Format";
    // eslint-disable-next-line @typescript-eslint/naming-convention
    EngineFormat[EngineFormat["RG8Format"] = 33323] = "RG8Format";
})(EngineFormat || (EngineFormat = {}));
//# sourceMappingURL=ktx2decoderTypes.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/khronosTextureContainer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/khronosTextureContainer.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KhronosTextureContainer: () => (/* binding */ KhronosTextureContainer)
/* harmony export */ });
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* eslint-disable @typescript-eslint/naming-convention */

/**
 * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 */
class KhronosTextureContainer {
    /**
     * Creates a new KhronosTextureContainer
     * @param data contents of the KTX container file
     * @param facesExpected should be either 1 or 6, based whether a cube texture or or
     */
    constructor(
    /** contents of the KTX container file */
    data, facesExpected) {
        this.data = data;
        /**
         * If the container has been made invalid (eg. constructor failed to correctly load array buffer)
         */
        this.isInvalid = false;
        if (!KhronosTextureContainer.IsValid(data)) {
            this.isInvalid = true;
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("texture missing KTX identifier");
            return;
        }
        // load the reset of the header in native 32 bit uint
        const dataSize = Uint32Array.BYTES_PER_ELEMENT;
        const headerDataView = new DataView(this.data.buffer, this.data.byteOffset + 12, 13 * dataSize);
        const endianness = headerDataView.getUint32(0, true);
        const littleEndian = endianness === 0x04030201;
        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures
        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays
        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6
        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures
        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data
        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
        if (this.glType !== 0) {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("only compressed formats currently supported");
            this.isInvalid = true;
            return;
        }
        else {
            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
            this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
        }
        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("only 2D textures currently supported");
            this.isInvalid = true;
            return;
        }
        if (this.numberOfArrayElements !== 0) {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("texture arrays not currently supported");
            this.isInvalid = true;
            return;
        }
        if (this.numberOfFaces !== facesExpected) {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("number of faces expected" + facesExpected + ", but found " + this.numberOfFaces);
            this.isInvalid = true;
            return;
        }
        // we now have a completely validated file, so could use existence of loadType as success
        // would need to make this more elaborate & adjust checks above to support more than one load type
        this.loadType = KhronosTextureContainer.COMPRESSED_2D;
    }
    /**
     * Uploads KTX content to a Babylon Texture.
     * It is assumed that the texture has already been created & is currently bound
     * @internal
     */
    uploadLevels(texture, loadMipmaps) {
        switch (this.loadType) {
            case KhronosTextureContainer.COMPRESSED_2D:
                this._upload2DCompressedLevels(texture, loadMipmaps);
                break;
            case KhronosTextureContainer.TEX_2D:
            case KhronosTextureContainer.COMPRESSED_3D:
            case KhronosTextureContainer.TEX_3D:
        }
    }
    _upload2DCompressedLevels(texture, loadMipmaps) {
        // initialize width & height for level 1
        let dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;
        let width = this.pixelWidth;
        let height = this.pixelHeight;
        const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;
        for (let level = 0; level < mipmapCount; level++) {
            const imageSize = new Int32Array(this.data.buffer, this.data.byteOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
            dataOffset += 4; //image data starts from next multiple of 4 offset. Each face refers to same imagesize field above.
            for (let face = 0; face < this.numberOfFaces; face++) {
                const byteArray = new Uint8Array(this.data.buffer, this.data.byteOffset + dataOffset, imageSize);
                const engine = texture.getEngine();
                engine._uploadCompressedDataToTextureDirectly(texture, texture.format, width, height, byteArray, face, level);
                dataOffset += imageSize; // add size of the image for the next face/mipmap
                dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image
            }
            width = Math.max(1.0, width * 0.5);
            height = Math.max(1.0, height * 0.5);
        }
    }
    /**
     * Checks if the given data starts with a KTX file identifier.
     * @param data the data to check
     * @returns true if the data is a KTX file or false otherwise
     */
    static IsValid(data) {
        if (data.byteLength >= 12) {
            // '«', 'K', 'T', 'X', ' ', '1', '1', '»', '\r', '\n', '\x1A', '\n'
            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);
            if (identifier[0] === 0xab &&
                identifier[1] === 0x4b &&
                identifier[2] === 0x54 &&
                identifier[3] === 0x58 &&
                identifier[4] === 0x20 &&
                identifier[5] === 0x31 &&
                identifier[6] === 0x31 &&
                identifier[7] === 0xbb &&
                identifier[8] === 0x0d &&
                identifier[9] === 0x0a &&
                identifier[10] === 0x1a &&
                identifier[11] === 0x0a) {
                return true;
            }
        }
        return false;
    }
}
KhronosTextureContainer.HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
// load types
KhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
KhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()
KhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()
KhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()
//# sourceMappingURL=khronosTextureContainer.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/khronosTextureContainer2.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/khronosTextureContainer2.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultKTX2DecoderOptions: () => (/* binding */ DefaultKTX2DecoderOptions),
/* harmony export */   KhronosTextureContainer2: () => (/* binding */ KhronosTextureContainer2)
/* harmony export */ });
/* harmony import */ var _workerPool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./workerPool.js */ "./node_modules/@babylonjs/core/Misc/workerPool.js");
/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools.js */ "./node_modules/@babylonjs/core/Misc/tools.js");
/* harmony import */ var _Materials_Textures_ktx2decoderTypes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Materials/Textures/ktx2decoderTypes.js */ "./node_modules/@babylonjs/core/Materials/Textures/ktx2decoderTypes.js");
/* harmony import */ var _khronosTextureContainer2Worker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./khronosTextureContainer2Worker.js */ "./node_modules/@babylonjs/core/Misc/khronosTextureContainer2Worker.js");





/**
 * Class that defines the default KTX2 decoder options.
 *
 * This class is useful for providing options to the KTX2 decoder to control how the source data is transcoded.
 */
class DefaultKTX2DecoderOptions {
    constructor() {
        this._isDirty = true;
        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = true;
        this._ktx2DecoderOptions = {};
    }
    /**
     * Gets the dirty flag
     */
    get isDirty() {
        return this._isDirty;
    }
    /**
     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and ASTC + BC7 are not available as a compressed transcoded format
     */
    get useRGBAIfASTCBC7NotAvailableWhenUASTC() {
        return this._useRGBAIfASTCBC7NotAvailableWhenUASTC;
    }
    set useRGBAIfASTCBC7NotAvailableWhenUASTC(value) {
        if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC === value) {
            return;
        }
        this._useRGBAIfASTCBC7NotAvailableWhenUASTC = value;
        this._isDirty = true;
    }
    /**
     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and only BC1 or BC3 are available as a compressed transcoded format.
     * This property is true by default to favor speed over memory, because currently transcoding from UASTC to BC1/3 is slow because the transcoder transcodes
     * to uncompressed and then recompresses the texture
     */
    get useRGBAIfOnlyBC1BC3AvailableWhenUASTC() {
        return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC;
    }
    set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(value) {
        if (this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC === value) {
            return;
        }
        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = value;
        this._isDirty = true;
    }
    /**
     * force to always use (uncompressed) RGBA for transcoded format
     */
    get forceRGBA() {
        return this._forceRGBA;
    }
    set forceRGBA(value) {
        if (this._forceRGBA === value) {
            return;
        }
        this._forceRGBA = value;
        this._isDirty = true;
    }
    /**
     * force to always use (uncompressed) R8 for transcoded format
     */
    get forceR8() {
        return this._forceR8;
    }
    set forceR8(value) {
        if (this._forceR8 === value) {
            return;
        }
        this._forceR8 = value;
        this._isDirty = true;
    }
    /**
     * force to always use (uncompressed) RG8 for transcoded format
     */
    get forceRG8() {
        return this._forceRG8;
    }
    set forceRG8(value) {
        if (this._forceRG8 === value) {
            return;
        }
        this._forceRG8 = value;
        this._isDirty = true;
    }
    /**
     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:
     *      UniversalTranscoder_UASTC_ASTC
     *      UniversalTranscoder_UASTC_BC7
     *      UniversalTranscoder_UASTC_RGBA_UNORM
     *      UniversalTranscoder_UASTC_RGBA_SRGB
     *      UniversalTranscoder_UASTC_R8_UNORM
     *      UniversalTranscoder_UASTC_RG8_UNORM
     *      MSCTranscoder
     */
    get bypassTranscoders() {
        return this._bypassTranscoders;
    }
    set bypassTranscoders(value) {
        if (this._bypassTranscoders === value) {
            return;
        }
        this._bypassTranscoders = value;
        this._isDirty = true;
    }
    /** @internal */
    _getKTX2DecoderOptions() {
        if (!this._isDirty) {
            return this._ktx2DecoderOptions;
        }
        this._isDirty = false;
        const options = {
            useRGBAIfASTCBC7NotAvailableWhenUASTC: this._useRGBAIfASTCBC7NotAvailableWhenUASTC,
            forceRGBA: this._forceRGBA,
            forceR8: this._forceR8,
            forceRG8: this._forceRG8,
            bypassTranscoders: this._bypassTranscoders,
        };
        if (this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC) {
            options.transcodeFormatDecisionTree = {
                UASTC: {
                    transcodeFormat: [_Materials_Textures_ktx2decoderTypes_js__WEBPACK_IMPORTED_MODULE_2__.TranscodeTarget.BC1_RGB, _Materials_Textures_ktx2decoderTypes_js__WEBPACK_IMPORTED_MODULE_2__.TranscodeTarget.BC3_RGBA],
                    yes: {
                        transcodeFormat: _Materials_Textures_ktx2decoderTypes_js__WEBPACK_IMPORTED_MODULE_2__.TranscodeTarget.RGBA32,
                        engineFormat: 32856 /* EngineFormat.RGBA8Format */,
                        roundToMultiple4: false,
                    },
                },
            };
        }
        this._ktx2DecoderOptions = options;
        return options;
    }
}
/**
 * Class for loading KTX2 files
 */
class KhronosTextureContainer2 {
    static GetDefaultNumWorkers() {
        if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
            return 1;
        }
        // Use 50% of the available logical processors but capped at 4.
        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
    }
    static _Initialize(numWorkers) {
        if (KhronosTextureContainer2._WorkerPoolPromise || KhronosTextureContainer2._DecoderModulePromise) {
            return;
        }
        const urls = {
            jsDecoderModule: _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.GetBabylonScriptURL(this.URLConfig.jsDecoderModule, true),
            wasmUASTCToASTC: _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToASTC, true),
            wasmUASTCToBC7: _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToBC7, true),
            wasmUASTCToRGBA_UNORM: _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_UNORM, true),
            wasmUASTCToRGBA_SRGB: _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_SRGB, true),
            wasmUASTCToR8_UNORM: _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToR8_UNORM, true),
            wasmUASTCToRG8_UNORM: _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRG8_UNORM, true),
            jsMSCTranscoder: _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.GetBabylonScriptURL(this.URLConfig.jsMSCTranscoder, true),
            wasmMSCTranscoder: _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.GetBabylonScriptURL(this.URLConfig.wasmMSCTranscoder, true),
            wasmZSTDDecoder: _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.GetBabylonScriptURL(this.URLConfig.wasmZSTDDecoder, true),
        };
        if (numWorkers && typeof Worker === "function" && typeof URL !== "undefined") {
            KhronosTextureContainer2._WorkerPoolPromise = new Promise((resolve) => {
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                const workerContent = `${_khronosTextureContainer2Worker_js__WEBPACK_IMPORTED_MODULE_3__.applyConfig}(${_khronosTextureContainer2Worker_js__WEBPACK_IMPORTED_MODULE_3__.workerFunction})()`;
                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
                resolve(new _workerPool_js__WEBPACK_IMPORTED_MODULE_0__.AutoReleaseWorkerPool(numWorkers, async () => (0,_khronosTextureContainer2Worker_js__WEBPACK_IMPORTED_MODULE_3__.initializeWebWorker)(new Worker(workerBlobUrl), undefined, urls)));
            });
        }
        else {
            if (typeof KhronosTextureContainer2._KTX2DecoderModule === "undefined") {
                KhronosTextureContainer2._DecoderModulePromise = _tools_js__WEBPACK_IMPORTED_MODULE_1__.Tools.LoadBabylonScriptAsync(urls.jsDecoderModule).then(() => {
                    KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;
                    KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;
                    KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;
                    (0,_khronosTextureContainer2Worker_js__WEBPACK_IMPORTED_MODULE_3__.applyConfig)(urls, KhronosTextureContainer2._KTX2DecoderModule);
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder();
                });
            }
            else {
                KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;
                KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;
                KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder());
            }
        }
    }
    /**
     * Constructor
     * @param engine The engine to use
     * @param numWorkersOrOptions The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.
     */
    constructor(engine, numWorkersOrOptions = KhronosTextureContainer2.DefaultNumWorkers) {
        this._engine = engine;
        const workerPoolOption = (typeof numWorkersOrOptions === "object" && numWorkersOrOptions.workerPool) || KhronosTextureContainer2.WorkerPool;
        if (workerPoolOption) {
            KhronosTextureContainer2._WorkerPoolPromise = Promise.resolve(workerPoolOption);
        }
        else {
            // set the KTX2 decoder module
            if (typeof numWorkersOrOptions === "object") {
                KhronosTextureContainer2._KTX2DecoderModule = numWorkersOrOptions?.binariesAndModulesContainer?.jsDecoderModule;
            }
            else if (typeof KTX2DECODER !== "undefined") {
                KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;
            }
            const numberOfWorkers = typeof numWorkersOrOptions === "number" ? numWorkersOrOptions : (numWorkersOrOptions.numWorkers ?? KhronosTextureContainer2.DefaultNumWorkers);
            KhronosTextureContainer2._Initialize(numberOfWorkers);
        }
    }
    /**
     * @internal
     */
    async _uploadAsync(data, internalTexture, options) {
        const caps = this._engine.getCaps();
        const compressedTexturesCaps = {
            astc: !!caps.astc,
            bptc: !!caps.bptc,
            s3tc: !!caps.s3tc,
            pvrtc: !!caps.pvrtc,
            etc2: !!caps.etc2,
            etc1: !!caps.etc1,
        };
        if (KhronosTextureContainer2._WorkerPoolPromise) {
            const workerPool = await KhronosTextureContainer2._WorkerPoolPromise;
            return new Promise((resolve, reject) => {
                workerPool.push((worker, onComplete) => {
                    const onError = (error) => {
                        worker.removeEventListener("error", onError);
                        worker.removeEventListener("message", onMessage);
                        reject(error);
                        onComplete();
                    };
                    const onMessage = (message) => {
                        if (message.data.action === "decoded") {
                            worker.removeEventListener("error", onError);
                            worker.removeEventListener("message", onMessage);
                            if (!message.data.success) {
                                reject({ message: message.data.msg });
                            }
                            else {
                                try {
                                    this._createTexture(message.data.decodedData, internalTexture, options);
                                    resolve();
                                }
                                catch (err) {
                                    reject({ message: err });
                                }
                            }
                            onComplete();
                        }
                    };
                    worker.addEventListener("error", onError);
                    worker.addEventListener("message", onMessage);
                    worker.postMessage({ action: "setDefaultDecoderOptions", options: KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions() });
                    const dataCopy = new Uint8Array(data.byteLength);
                    dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
                    worker.postMessage({ action: "decode", data: dataCopy, caps: compressedTexturesCaps, options }, [dataCopy.buffer]);
                });
            });
        }
        else if (KhronosTextureContainer2._DecoderModulePromise) {
            const decoder = await KhronosTextureContainer2._DecoderModulePromise;
            if (KhronosTextureContainer2.DefaultDecoderOptions.isDirty) {
                KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions();
            }
            return new Promise((resolve, reject) => {
                decoder
                    .decode(data, caps)
                    .then((data) => {
                    this._createTexture(data, internalTexture);
                    resolve();
                })
                    .catch((reason) => {
                    reject({ message: reason });
                });
            });
        }
        throw new Error("KTX2 decoder module is not available");
    }
    _createTexture(data, internalTexture, options) {
        const oglTexture2D = 3553; // gl.TEXTURE_2D
        this._engine._bindTextureDirectly(oglTexture2D, internalTexture);
        if (options) {
            // return back some information about the decoded data
            options.transcodedFormat = data.transcodedFormat;
            options.isInGammaSpace = data.isInGammaSpace;
            options.hasAlpha = data.hasAlpha;
            options.transcoderName = data.transcoderName;
        }
        let isUncompressedFormat = true;
        switch (data.transcodedFormat) {
            case 0x8058 /* RGBA8 */:
                internalTexture.type = 0;
                internalTexture.format = 5;
                break;
            case 0x8229 /* R8 */:
                internalTexture.type = 0;
                internalTexture.format = 6;
                break;
            case 0x822b /* RG8 */:
                internalTexture.type = 0;
                internalTexture.format = 7;
                break;
            default:
                internalTexture.format = data.transcodedFormat;
                isUncompressedFormat = false;
                break;
        }
        internalTexture._gammaSpace = data.isInGammaSpace;
        internalTexture.generateMipMaps = data.mipmaps.length > 1;
        if (data.errors) {
            throw new Error("KTX2 container - could not transcode the data. " + data.errors);
        }
        for (let t = 0; t < data.mipmaps.length; ++t) {
            const mipmap = data.mipmaps[t];
            if (!mipmap || !mipmap.data) {
                throw new Error("KTX2 container - could not transcode one of the image");
            }
            if (isUncompressedFormat) {
                // uncompressed RGBA / R8 / RG8
                internalTexture.width = mipmap.width; // need to set width/height so that the call to _uploadDataToTextureDirectly uses the right dimensions
                internalTexture.height = mipmap.height;
                this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, undefined, true);
            }
            else {
                this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);
            }
        }
        internalTexture._extension = ".ktx2";
        internalTexture.width = data.mipmaps[0].width;
        internalTexture.height = data.mipmaps[0].height;
        internalTexture.isReady = true;
        this._engine._bindTextureDirectly(oglTexture2D, null);
    }
    /**
     * Checks if the given data starts with a KTX2 file identifier.
     * @param data the data to check
     * @returns true if the data is a KTX2 file or false otherwise
     */
    static IsValid(data) {
        if (data.byteLength >= 12) {
            // '«', 'K', 'T', 'X', ' ', '2', '0', '»', '\r', '\n', '\x1A', '\n'
            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);
            if (identifier[0] === 0xab &&
                identifier[1] === 0x4b &&
                identifier[2] === 0x54 &&
                identifier[3] === 0x58 &&
                identifier[4] === 0x20 &&
                identifier[5] === 0x32 &&
                identifier[6] === 0x30 &&
                identifier[7] === 0xbb &&
                identifier[8] === 0x0d &&
                identifier[9] === 0x0a &&
                identifier[10] === 0x1a &&
                identifier[11] === 0x0a) {
                return true;
            }
        }
        return false;
    }
}
/**
 * URLs to use when loading the KTX2 decoder module as well as its dependencies
 * If a url is null, the default url is used (pointing to https://preview.babylonjs.com)
 * Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary
 * Urls you can change:
 *     URLConfig.jsDecoderModule
 *     URLConfig.wasmUASTCToASTC
 *     URLConfig.wasmUASTCToBC7
 *     URLConfig.wasmUASTCToRGBA_UNORM
 *     URLConfig.wasmUASTCToRGBA_SRGB
 *     URLConfig.wasmUASTCToR8_UNORM
 *     URLConfig.wasmUASTCToRG8_UNORM
 *     URLConfig.jsMSCTranscoder
 *     URLConfig.wasmMSCTranscoder
 *     URLConfig.wasmZSTDDecoder
 * You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#29
 */
KhronosTextureContainer2.URLConfig = {
    jsDecoderModule: "https://cdn.babylonjs.com/babylon.ktx2Decoder.js",
    wasmUASTCToASTC: null,
    wasmUASTCToBC7: null,
    wasmUASTCToRGBA_UNORM: null,
    wasmUASTCToRGBA_SRGB: null,
    wasmUASTCToR8_UNORM: null,
    wasmUASTCToRG8_UNORM: null,
    jsMSCTranscoder: null,
    wasmMSCTranscoder: null,
    wasmZSTDDecoder: null,
};
/**
 * Default number of workers used to handle data decoding
 */
KhronosTextureContainer2.DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();
/**
 * Default configuration for the KTX2 decoder.
 * The options defined in this way have priority over those passed when creating a KTX2 texture with new Texture(...).
 */
KhronosTextureContainer2.DefaultDecoderOptions = new DefaultKTX2DecoderOptions();
//# sourceMappingURL=khronosTextureContainer2.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/khronosTextureContainer2Worker.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/khronosTextureContainer2Worker.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyConfig: () => (/* binding */ applyConfig),
/* harmony export */   initializeWebWorker: () => (/* binding */ initializeWebWorker),
/* harmony export */   workerFunction: () => (/* binding */ workerFunction)
/* harmony export */ });
function applyConfig(urls, binariesAndModulesContainer) {
    const KTX2DecoderModule = binariesAndModulesContainer?.jsDecoderModule || KTX2DECODER;
    if (urls) {
        if (urls.wasmUASTCToASTC) {
            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;
        }
        if (urls.wasmUASTCToBC7) {
            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;
        }
        if (urls.wasmUASTCToRGBA_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;
        }
        if (urls.wasmUASTCToRGBA_SRGB) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;
        }
        if (urls.wasmUASTCToR8_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;
        }
        if (urls.wasmUASTCToRG8_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;
        }
        if (urls.jsMSCTranscoder) {
            KTX2DecoderModule.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;
        }
        if (urls.wasmMSCTranscoder) {
            KTX2DecoderModule.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;
        }
        if (urls.wasmZSTDDecoder) {
            KTX2DecoderModule.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;
        }
    }
    if (binariesAndModulesContainer) {
        if (binariesAndModulesContainer.wasmUASTCToASTC) {
            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmBinary = binariesAndModulesContainer.wasmUASTCToASTC;
        }
        if (binariesAndModulesContainer.wasmUASTCToBC7) {
            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmBinary = binariesAndModulesContainer.wasmUASTCToBC7;
        }
        if (binariesAndModulesContainer.wasmUASTCToRGBA_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_UNORM;
        }
        if (binariesAndModulesContainer.wasmUASTCToRGBA_SRGB) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_SRGB;
        }
        if (binariesAndModulesContainer.wasmUASTCToR8_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToR8_UNORM;
        }
        if (binariesAndModulesContainer.wasmUASTCToRG8_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRG8_UNORM;
        }
        if (binariesAndModulesContainer.jsMSCTranscoder) {
            KTX2DecoderModule.MSCTranscoder.JSModule = binariesAndModulesContainer.jsMSCTranscoder;
        }
        if (binariesAndModulesContainer.wasmMSCTranscoder) {
            KTX2DecoderModule.MSCTranscoder.WasmBinary = binariesAndModulesContainer.wasmMSCTranscoder;
        }
        if (binariesAndModulesContainer.wasmZSTDDecoder) {
            KTX2DecoderModule.ZSTDDecoder.WasmBinary = binariesAndModulesContainer.wasmZSTDDecoder;
        }
    }
}
function workerFunction(KTX2DecoderModule) {
    if (typeof KTX2DecoderModule === "undefined" && typeof KTX2DECODER !== "undefined") {
        KTX2DecoderModule = KTX2DECODER;
    }
    let ktx2Decoder;
    onmessage = (event) => {
        if (!event.data) {
            return;
        }
        switch (event.data.action) {
            case "init": {
                const urls = event.data.urls;
                if (urls) {
                    if (urls.jsDecoderModule && typeof KTX2DecoderModule === "undefined") {
                        importScripts(urls.jsDecoderModule);
                        // assuming global namespace populated by the script (UMD pattern)
                        KTX2DecoderModule = KTX2DECODER;
                    }
                    applyConfig(urls);
                }
                if (event.data.wasmBinaries) {
                    applyConfig(undefined, { ...event.data.wasmBinaries, jsDecoderModule: KTX2DecoderModule });
                }
                ktx2Decoder = new KTX2DecoderModule.KTX2Decoder();
                postMessage({ action: "init" });
                break;
            }
            case "setDefaultDecoderOptions": {
                KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = event.data.options;
                break;
            }
            case "decode":
                ktx2Decoder
                    .decode(event.data.data, event.data.caps, event.data.options)
                    .then((data) => {
                    const buffers = [];
                    for (let mip = 0; mip < data.mipmaps.length; ++mip) {
                        const mipmap = data.mipmaps[mip];
                        if (mipmap && mipmap.data) {
                            buffers.push(mipmap.data.buffer);
                        }
                    }
                    postMessage({ action: "decoded", success: true, decodedData: data }, buffers);
                })
                    .catch((reason) => {
                    postMessage({ action: "decoded", success: false, msg: reason });
                });
                break;
        }
    };
}
async function initializeWebWorker(worker, wasmBinaries, urls) {
    return new Promise((resolve, reject) => {
        const onError = (error) => {
            worker.removeEventListener("error", onError);
            worker.removeEventListener("message", onMessage);
            reject(error);
        };
        const onMessage = (message) => {
            if (message.data.action === "init") {
                worker.removeEventListener("error", onError);
                worker.removeEventListener("message", onMessage);
                resolve(worker);
            }
        };
        worker.addEventListener("error", onError);
        worker.addEventListener("message", onMessage);
        worker.postMessage({
            action: "init",
            urls,
            wasmBinaries,
        });
    });
}
//# sourceMappingURL=khronosTextureContainer2Worker.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/workerPool.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/workerPool.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutoReleaseWorkerPool: () => (/* binding */ AutoReleaseWorkerPool),
/* harmony export */   WorkerPool: () => (/* binding */ WorkerPool)
/* harmony export */ });
/**
 * Helper class to push actions to a pool of workers.
 */
class WorkerPool {
    /**
     * Constructor
     * @param workers Array of workers to use for actions
     */
    constructor(workers) {
        this._pendingActions = new Array();
        this._workerInfos = workers.map((worker) => ({
            workerPromise: Promise.resolve(worker),
            idle: true,
        }));
    }
    /**
     * Terminates all workers and clears any pending actions.
     */
    dispose() {
        for (const workerInfo of this._workerInfos) {
            workerInfo.workerPromise.then((worker) => {
                worker.terminate();
            });
        }
        this._workerInfos.length = 0;
        this._pendingActions.length = 0;
    }
    /**
     * Pushes an action to the worker pool. If all the workers are active, the action will be
     * pended until a worker has completed its action.
     * @param action The action to perform. Call onComplete when the action is complete.
     */
    push(action) {
        if (!this._executeOnIdleWorker(action)) {
            this._pendingActions.push(action);
        }
    }
    _executeOnIdleWorker(action) {
        for (const workerInfo of this._workerInfos) {
            if (workerInfo.idle) {
                this._execute(workerInfo, action);
                return true;
            }
        }
        return false;
    }
    _execute(workerInfo, action) {
        workerInfo.idle = false;
        workerInfo.workerPromise.then((worker) => {
            action(worker, () => {
                const nextAction = this._pendingActions.shift();
                if (nextAction) {
                    this._execute(workerInfo, nextAction);
                }
                else {
                    workerInfo.idle = true;
                }
            });
        });
    }
}
/**
 * Similar to the WorkerPool class except it creates and destroys workers automatically with a maximum of `maxWorkers` workers.
 * Workers are terminated when it is idle for at least `idleTimeElapsedBeforeRelease` milliseconds.
 */
class AutoReleaseWorkerPool extends WorkerPool {
    constructor(maxWorkers, createWorkerAsync, options = AutoReleaseWorkerPool.DefaultOptions) {
        super([]);
        this._maxWorkers = maxWorkers;
        this._createWorkerAsync = createWorkerAsync;
        this._options = options;
    }
    push(action) {
        if (!this._executeOnIdleWorker(action)) {
            if (this._workerInfos.length < this._maxWorkers) {
                const workerInfo = {
                    workerPromise: this._createWorkerAsync(),
                    idle: false,
                };
                this._workerInfos.push(workerInfo);
                this._execute(workerInfo, action);
            }
            else {
                this._pendingActions.push(action);
            }
        }
    }
    _execute(workerInfo, action) {
        // Reset the idle timeout.
        if (workerInfo.timeoutId) {
            clearTimeout(workerInfo.timeoutId);
            delete workerInfo.timeoutId;
        }
        super._execute(workerInfo, (worker, onComplete) => {
            action(worker, () => {
                onComplete();
                if (workerInfo.idle) {
                    // Schedule the worker to be terminated after the elapsed time.
                    workerInfo.timeoutId = setTimeout(() => {
                        workerInfo.workerPromise.then((worker) => {
                            worker.terminate();
                        });
                        const indexOf = this._workerInfos.indexOf(workerInfo);
                        if (indexOf !== -1) {
                            this._workerInfos.splice(indexOf, 1);
                        }
                    }, this._options.idleTimeElapsedBeforeRelease);
                }
            });
        });
    }
}
/**
 * Default options for the constructor.
 * Override to change the defaults.
 */
AutoReleaseWorkerPool.DefaultOptions = {
    idleTimeElapsedBeforeRelease: 1000,
};
//# sourceMappingURL=workerPool.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfTWF0ZXJpYWxzX1RleHR1cmVzX0xvYWRlcnNfa3R4VGV4dHVyZUxvYWRlcl9qcy5icm93c2VyLXBhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRjtBQUNFO0FBQ3BDOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFGQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFGQUF1QjtBQUNuQztBQUNBO0FBQ0EsNEJBQTRCLHFGQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCLHVGQUF3QjtBQUN6Qyw2QkFBNkIsdUZBQXdCO0FBQ3JEO0FBQ0EsZ0dBQWdHO0FBQ2hHLGFBQWE7QUFDYixnQkFBZ0IsbURBQU0sMkNBQTJDLGNBQWM7QUFDL0Usc0RBQXNEO0FBQ3RELGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxtREFBTTtBQUNsQixrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6R087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQzVDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDcEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7Ozs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUMyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RSxnRkFBZ0Y7QUFDaEYsOEVBQThFO0FBQzlFLHNGQUFzRjtBQUN0RiwwRkFBMEY7QUFDMUYsZ0ZBQWdGO0FBQ2hGLGlGQUFpRjtBQUNqRixnRkFBZ0Y7QUFDaEYsMkZBQTJGO0FBQzNGLG9GQUFvRjtBQUNwRiwyRkFBMkYscUJBQXFCO0FBQ2hILDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0EsWUFBWSxtREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRCx5R0FBeUc7QUFDekcsNkJBQTZCO0FBQzdCLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFJd0Q7QUFDckI7QUFDeUM7QUFDMkI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9GQUFlLFVBQVUsb0ZBQWU7QUFDOUU7QUFDQSx5Q0FBeUMsb0ZBQWU7QUFDeEQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNENBQUs7QUFDbEMsNkJBQTZCLDRDQUFLO0FBQ2xDLDRCQUE0Qiw0Q0FBSztBQUNqQyxtQ0FBbUMsNENBQUs7QUFDeEMsa0NBQWtDLDRDQUFLO0FBQ3ZDLGlDQUFpQyw0Q0FBSztBQUN0QyxrQ0FBa0MsNENBQUs7QUFDdkMsNkJBQTZCLDRDQUFLO0FBQ2xDLCtCQUErQiw0Q0FBSztBQUNwQyw2QkFBNkIsNENBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMkVBQVcsQ0FBQyxHQUFHLDhFQUFjLENBQUM7QUFDdkUsc0ZBQXNGLGdDQUFnQztBQUN0SCw0QkFBNEIsaUVBQXFCLHlCQUF5Qix1RkFBbUI7QUFDN0YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSw0Q0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQVc7QUFDL0I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJCQUEyQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNIQUFzSDtBQUMvSjtBQUNBO0FBQ0EseUNBQXlDLHlFQUF5RTtBQUNsSCxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUMsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwWk87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0VBQWdFO0FBQzdHO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscURBQXFEO0FBQ3ZGLGlCQUFpQjtBQUNqQjtBQUNBLGtDQUFrQyxnREFBZ0Q7QUFDbEYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdklBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL0xvYWRlcnMva3R4VGV4dHVyZUxvYWRlci5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL2t0eDJkZWNvZGVyVHlwZXMuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01pc2Mva2hyb25vc1RleHR1cmVDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01pc2Mva2hyb25vc1RleHR1cmVDb250YWluZXIyLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NaXNjL2tocm9ub3NUZXh0dXJlQ29udGFpbmVyMldvcmtlci5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWlzYy93b3JrZXJQb29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEtocm9ub3NUZXh0dXJlQ29udGFpbmVyIH0gZnJvbSBcIi4uLy4uLy4uL01pc2Mva2hyb25vc1RleHR1cmVDb250YWluZXIuanNcIjtcbmltcG9ydCB7IEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMiB9IGZyb20gXCIuLi8uLi8uLi9NaXNjL2tocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5qc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uLy4uLy4uL01pc2MvbG9nZ2VyLmpzXCI7XG5cbmZ1bmN0aW9uIE1hcFNSR0JUb0xpbmVhcihmb3JtYXQpIHtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICBjYXNlIDM1OTE2OlxuICAgICAgICAgICAgcmV0dXJuIDMzNzc2O1xuICAgICAgICBjYXNlIDM1OTE4OlxuICAgICAgICAgICAgcmV0dXJuIDMzNzc4O1xuICAgICAgICBjYXNlIDM1OTE5OlxuICAgICAgICAgICAgcmV0dXJuIDMzNzc5O1xuICAgICAgICBjYXNlIDM3NDkzOlxuICAgICAgICAgICAgcmV0dXJuIDM3NDkyO1xuICAgICAgICBjYXNlIDM3NDk3OlxuICAgICAgICAgICAgcmV0dXJuIDM3NDk2O1xuICAgICAgICBjYXNlIDM3NDk1OlxuICAgICAgICAgICAgcmV0dXJuIDM3NDk0O1xuICAgICAgICBjYXNlIDM3ODQwOlxuICAgICAgICAgICAgcmV0dXJuIDM3ODA4O1xuICAgICAgICBjYXNlIDM2NDkzOlxuICAgICAgICAgICAgcmV0dXJuIDM2NDkyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIEtUWCBUZXh0dXJlIExvYWRlci5cbiAqIEBpbnRlcm5hbFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY2xhc3MgX0tUWFRleHR1cmVMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBsb2FkZXIgc3VwcG9ydHMgY2FzY2FkZSBsb2FkaW5nIHRoZSBkaWZmZXJlbnQgZmFjZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRDYXNjYWRlcyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSBjdWJlIHRleHR1cmUgZGF0YSB0byB0aGUgV2ViR0wgdGV4dHVyZS4gSXQgaGFzIGFscmVhZHkgYmVlbiBib3VuZC5cbiAgICAgKiBAcGFyYW0gZGF0YSBjb250YWlucyB0aGUgdGV4dHVyZSBkYXRhXG4gICAgICogQHBhcmFtIHRleHR1cmUgZGVmaW5lcyB0aGUgQmFieWxvbkpTIGludGVybmFsIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gY3JlYXRlUG9seW5vbWlhbHMgd2lsbCBiZSB0cnVlIGlmIHBvbHlub21pYWxzIGhhdmUgYmVlbiByZXF1ZXN0ZWRcbiAgICAgKiBAcGFyYW0gb25Mb2FkIGRlZmluZXMgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgb25jZSB0aGUgdGV4dHVyZSBpcyByZWFkeVxuICAgICAqL1xuICAgIGxvYWRDdWJlRGF0YShkYXRhLCB0ZXh0dXJlLCBjcmVhdGVQb2x5bm9taWFscywgb25Mb2FkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmVlZCB0byBpbnZlcnQgdlNjYWxlIGFzIGludmVydFkgdmlhIFVOUEFDS19GTElQX1lfV0VCR0wgaXMgbm90IHN1cHBvcnRlZCBieSBjb21wcmVzc2VkIHRleHR1cmVcbiAgICAgICAgdGV4dHVyZS5faW52ZXJ0VlNjYWxlID0gIXRleHR1cmUuaW52ZXJ0WTtcbiAgICAgICAgY29uc3QgZW5naW5lID0gdGV4dHVyZS5nZXRFbmdpbmUoKTtcbiAgICAgICAgY29uc3Qga3R4ID0gbmV3IEtocm9ub3NUZXh0dXJlQ29udGFpbmVyKGRhdGEsIDYpO1xuICAgICAgICBjb25zdCBsb2FkTWlwbWFwID0ga3R4Lm51bWJlck9mTWlwbWFwTGV2ZWxzID4gMSAmJiB0ZXh0dXJlLmdlbmVyYXRlTWlwTWFwcztcbiAgICAgICAgZW5naW5lLl91bnBhY2tGbGlwWSh0cnVlKTtcbiAgICAgICAga3R4LnVwbG9hZExldmVscyh0ZXh0dXJlLCB0ZXh0dXJlLmdlbmVyYXRlTWlwTWFwcyk7XG4gICAgICAgIHRleHR1cmUud2lkdGggPSBrdHgucGl4ZWxXaWR0aDtcbiAgICAgICAgdGV4dHVyZS5oZWlnaHQgPSBrdHgucGl4ZWxIZWlnaHQ7XG4gICAgICAgIGVuZ2luZS5fc2V0Q3ViZU1hcFRleHR1cmVQYXJhbXModGV4dHVyZSwgbG9hZE1pcG1hcCwga3R4Lm51bWJlck9mTWlwbWFwTGV2ZWxzIC0gMSk7XG4gICAgICAgIHRleHR1cmUuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHRleHR1cmUub25Mb2FkZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyh0ZXh0dXJlKTtcbiAgICAgICAgdGV4dHVyZS5vbkxvYWRlZE9ic2VydmFibGUuY2xlYXIoKTtcbiAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgb25Mb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgMkQgdGV4dHVyZSBkYXRhIHRvIHRoZSBXZWJHTCB0ZXh0dXJlLiBJdCBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kIG9uY2UgaW4gdGhlIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSBkYXRhIGNvbnRhaW5zIHRoZSB0ZXh0dXJlIGRhdGFcbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSBCYWJ5bG9uSlMgaW50ZXJuYWwgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBkZWZpbmVzIHRoZSBtZXRob2QgdG8gY2FsbCBvbmNlIHJlYWR5IHRvIHVwbG9hZFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgbG9hZERhdGEoZGF0YSwgdGV4dHVyZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKEtocm9ub3NUZXh0dXJlQ29udGFpbmVyLklzVmFsaWQoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gaW52ZXJ0IHZTY2FsZSBhcyBpbnZlcnRZIHZpYSBVTlBBQ0tfRkxJUF9ZX1dFQkdMIGlzIG5vdCBzdXBwb3J0ZWQgYnkgY29tcHJlc3NlZCB0ZXh0dXJlXG4gICAgICAgICAgICB0ZXh0dXJlLl9pbnZlcnRWU2NhbGUgPSAhdGV4dHVyZS5pbnZlcnRZO1xuICAgICAgICAgICAgY29uc3Qga3R4ID0gbmV3IEtocm9ub3NUZXh0dXJlQ29udGFpbmVyKGRhdGEsIDEpO1xuICAgICAgICAgICAgY29uc3QgbWFwcGVkRm9ybWF0ID0gTWFwU1JHQlRvTGluZWFyKGt0eC5nbEludGVybmFsRm9ybWF0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWRGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IG1hcHBlZEZvcm1hdDtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLl91c2VTUkdCQnVmZmVyID0gdGV4dHVyZS5nZXRFbmdpbmUoKS5fZ2V0VXNlU1JHQkJ1ZmZlcih0cnVlLCB0ZXh0dXJlLmdlbmVyYXRlTWlwTWFwcyk7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5fZ2FtbWFTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IGt0eC5nbEludGVybmFsRm9ybWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soa3R4LnBpeGVsV2lkdGgsIGt0eC5waXhlbEhlaWdodCwgdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMsIHRydWUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBrdHgudXBsb2FkTGV2ZWxzKHRleHR1cmUsIHRleHR1cmUuZ2VuZXJhdGVNaXBNYXBzKTtcbiAgICAgICAgICAgIH0sIGt0eC5pc0ludmFsaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5Jc1ZhbGlkKGRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBrdHgyID0gbmV3IEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMih0ZXh0dXJlLmdldEVuZ2luZSgpKTtcbiAgICAgICAgICAgIGt0eDIuX3VwbG9hZEFzeW5jKGRhdGEsIHRleHR1cmUsIG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0LCB0ZXh0dXJlLmdlbmVyYXRlTWlwTWFwcywgdHJ1ZSwgKCkgPT4geyB9LCBmYWxzZSk7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuV2FybihgRmFpbGVkIHRvIGxvYWQgS1RYMiB0ZXh0dXJlIGRhdGE6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygwLCAwLCBmYWxzZSwgZmFsc2UsICgpID0+IHsgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihcInRleHR1cmUgbWlzc2luZyBLVFggaWRlbnRpZmllclwiKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKDAsIDAsIGZhbHNlLCBmYWxzZSwgKCkgPT4geyB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWt0eFRleHR1cmVMb2FkZXIuanMubWFwIiwiZXhwb3J0IHZhciBTb3VyY2VUZXh0dXJlRm9ybWF0O1xuKGZ1bmN0aW9uIChTb3VyY2VUZXh0dXJlRm9ybWF0KSB7XG4gICAgU291cmNlVGV4dHVyZUZvcm1hdFtTb3VyY2VUZXh0dXJlRm9ybWF0W1wiRVRDMVNcIl0gPSAwXSA9IFwiRVRDMVNcIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgU291cmNlVGV4dHVyZUZvcm1hdFtTb3VyY2VUZXh0dXJlRm9ybWF0W1wiVUFTVEM0eDRcIl0gPSAxXSA9IFwiVUFTVEM0eDRcIjtcbn0pKFNvdXJjZVRleHR1cmVGb3JtYXQgfHwgKFNvdXJjZVRleHR1cmVGb3JtYXQgPSB7fSkpO1xuZXhwb3J0IHZhciBUcmFuc2NvZGVUYXJnZXQ7XG4oZnVuY3Rpb24gKFRyYW5zY29kZVRhcmdldCkge1xuICAgIFRyYW5zY29kZVRhcmdldFtUcmFuc2NvZGVUYXJnZXRbXCJBU1RDXzRYNF9SR0JBXCJdID0gMF0gPSBcIkFTVENfNFg0X1JHQkFcIjtcbiAgICBUcmFuc2NvZGVUYXJnZXRbVHJhbnNjb2RlVGFyZ2V0W1wiQkM3X1JHQkFcIl0gPSAxXSA9IFwiQkM3X1JHQkFcIjtcbiAgICBUcmFuc2NvZGVUYXJnZXRbVHJhbnNjb2RlVGFyZ2V0W1wiQkMzX1JHQkFcIl0gPSAyXSA9IFwiQkMzX1JHQkFcIjtcbiAgICBUcmFuc2NvZGVUYXJnZXRbVHJhbnNjb2RlVGFyZ2V0W1wiQkMxX1JHQlwiXSA9IDNdID0gXCJCQzFfUkdCXCI7XG4gICAgVHJhbnNjb2RlVGFyZ2V0W1RyYW5zY29kZVRhcmdldFtcIlBWUlRDMV80X1JHQkFcIl0gPSA0XSA9IFwiUFZSVEMxXzRfUkdCQVwiO1xuICAgIFRyYW5zY29kZVRhcmdldFtUcmFuc2NvZGVUYXJnZXRbXCJQVlJUQzFfNF9SR0JcIl0gPSA1XSA9IFwiUFZSVEMxXzRfUkdCXCI7XG4gICAgVHJhbnNjb2RlVGFyZ2V0W1RyYW5zY29kZVRhcmdldFtcIkVUQzJfUkdCQVwiXSA9IDZdID0gXCJFVEMyX1JHQkFcIjtcbiAgICBUcmFuc2NvZGVUYXJnZXRbVHJhbnNjb2RlVGFyZ2V0W1wiRVRDMV9SR0JcIl0gPSA3XSA9IFwiRVRDMV9SR0JcIjtcbiAgICBUcmFuc2NvZGVUYXJnZXRbVHJhbnNjb2RlVGFyZ2V0W1wiUkdCQTMyXCJdID0gOF0gPSBcIlJHQkEzMlwiO1xuICAgIFRyYW5zY29kZVRhcmdldFtUcmFuc2NvZGVUYXJnZXRbXCJSOFwiXSA9IDldID0gXCJSOFwiO1xuICAgIFRyYW5zY29kZVRhcmdldFtUcmFuc2NvZGVUYXJnZXRbXCJSRzhcIl0gPSAxMF0gPSBcIlJHOFwiO1xufSkoVHJhbnNjb2RlVGFyZ2V0IHx8IChUcmFuc2NvZGVUYXJnZXQgPSB7fSkpO1xuZXhwb3J0IHZhciBFbmdpbmVGb3JtYXQ7XG4oZnVuY3Rpb24gKEVuZ2luZUZvcm1hdCkge1xuICAgIEVuZ2luZUZvcm1hdFtFbmdpbmVGb3JtYXRbXCJDT01QUkVTU0VEX1JHQkFfQlBUQ19VTk9STV9FWFRcIl0gPSAzNjQ5Ml0gPSBcIkNPTVBSRVNTRURfUkdCQV9CUFRDX1VOT1JNX0VYVFwiO1xuICAgIEVuZ2luZUZvcm1hdFtFbmdpbmVGb3JtYXRbXCJDT01QUkVTU0VEX1JHQkFfQVNUQ180WDRfS0hSXCJdID0gMzc4MDhdID0gXCJDT01QUkVTU0VEX1JHQkFfQVNUQ180WDRfS0hSXCI7XG4gICAgRW5naW5lRm9ybWF0W0VuZ2luZUZvcm1hdFtcIkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRcIl0gPSAzMzc3Nl0gPSBcIkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRcIjtcbiAgICBFbmdpbmVGb3JtYXRbRW5naW5lRm9ybWF0W1wiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFRcIl0gPSAzMzc3OV0gPSBcIkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUXCI7XG4gICAgRW5naW5lRm9ybWF0W0VuZ2luZUZvcm1hdFtcIkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HXCJdID0gMzU4NDJdID0gXCJDT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNR1wiO1xuICAgIEVuZ2luZUZvcm1hdFtFbmdpbmVGb3JtYXRbXCJDT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HXCJdID0gMzU4NDBdID0gXCJDT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HXCI7XG4gICAgRW5naW5lRm9ybWF0W0VuZ2luZUZvcm1hdFtcIkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUNcIl0gPSAzNzQ5Nl0gPSBcIkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUNcIjtcbiAgICBFbmdpbmVGb3JtYXRbRW5naW5lRm9ybWF0W1wiQ09NUFJFU1NFRF9SR0I4X0VUQzJcIl0gPSAzNzQ5Ml0gPSBcIkNPTVBSRVNTRURfUkdCOF9FVEMyXCI7XG4gICAgRW5naW5lRm9ybWF0W0VuZ2luZUZvcm1hdFtcIkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0xcIl0gPSAzNjE5Nl0gPSBcIkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0xcIjtcbiAgICBFbmdpbmVGb3JtYXRbRW5naW5lRm9ybWF0W1wiUkdCQThGb3JtYXRcIl0gPSAzMjg1Nl0gPSBcIlJHQkE4Rm9ybWF0XCI7XG4gICAgRW5naW5lRm9ybWF0W0VuZ2luZUZvcm1hdFtcIlI4Rm9ybWF0XCJdID0gMzMzMjFdID0gXCJSOEZvcm1hdFwiO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBFbmdpbmVGb3JtYXRbRW5naW5lRm9ybWF0W1wiUkc4Rm9ybWF0XCJdID0gMzMzMjNdID0gXCJSRzhGb3JtYXRcIjtcbn0pKEVuZ2luZUZvcm1hdCB8fCAoRW5naW5lRm9ybWF0ID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWt0eDJkZWNvZGVyVHlwZXMuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vTWlzYy9sb2dnZXIuanNcIjtcbi8qKlxuICogZm9yIGRlc2NyaXB0aW9uIHNlZSBodHRwczovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvdG9vbHMvS1RYL1xuICogZm9yIGZpbGUgbGF5b3V0IHNlZSBodHRwczovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvdG9vbHMvS1RYL2ZpbGVfZm9ybWF0X3NwZWMvXG4gKi9cbmV4cG9ydCBjbGFzcyBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lclxuICAgICAqIEBwYXJhbSBkYXRhIGNvbnRlbnRzIG9mIHRoZSBLVFggY29udGFpbmVyIGZpbGVcbiAgICAgKiBAcGFyYW0gZmFjZXNFeHBlY3RlZCBzaG91bGQgYmUgZWl0aGVyIDEgb3IgNiwgYmFzZWQgd2hldGhlciBhIGN1YmUgdGV4dHVyZSBvciBvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBjb250ZW50cyBvZiB0aGUgS1RYIGNvbnRhaW5lciBmaWxlICovXG4gICAgZGF0YSwgZmFjZXNFeHBlY3RlZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGNvbnRhaW5lciBoYXMgYmVlbiBtYWRlIGludmFsaWQgKGVnLiBjb25zdHJ1Y3RvciBmYWlsZWQgdG8gY29ycmVjdGx5IGxvYWQgYXJyYXkgYnVmZmVyKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFLaHJvbm9zVGV4dHVyZUNvbnRhaW5lci5Jc1ZhbGlkKGRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmlzSW52YWxpZCA9IHRydWU7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoXCJ0ZXh0dXJlIG1pc3NpbmcgS1RYIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9hZCB0aGUgcmVzZXQgb2YgdGhlIGhlYWRlciBpbiBuYXRpdmUgMzIgYml0IHVpbnRcbiAgICAgICAgY29uc3QgZGF0YVNpemUgPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgY29uc3QgaGVhZGVyRGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy5kYXRhLmJ5dGVPZmZzZXQgKyAxMiwgMTMgKiBkYXRhU2l6ZSk7XG4gICAgICAgIGNvbnN0IGVuZGlhbm5lc3MgPSBoZWFkZXJEYXRhVmlldy5nZXRVaW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGxpdHRsZUVuZGlhbiA9IGVuZGlhbm5lc3MgPT09IDB4MDQwMzAyMDE7XG4gICAgICAgIHRoaXMuZ2xUeXBlID0gaGVhZGVyRGF0YVZpZXcuZ2V0VWludDMyKDEgKiBkYXRhU2l6ZSwgbGl0dGxlRW5kaWFuKTsgLy8gbXVzdCBiZSAwIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXG4gICAgICAgIHRoaXMuZ2xUeXBlU2l6ZSA9IGhlYWRlckRhdGFWaWV3LmdldFVpbnQzMigyICogZGF0YVNpemUsIGxpdHRsZUVuZGlhbik7IC8vIG11c3QgYmUgMSBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xuICAgICAgICB0aGlzLmdsRm9ybWF0ID0gaGVhZGVyRGF0YVZpZXcuZ2V0VWludDMyKDMgKiBkYXRhU2l6ZSwgbGl0dGxlRW5kaWFuKTsgLy8gbXVzdCBiZSAwIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXG4gICAgICAgIHRoaXMuZ2xJbnRlcm5hbEZvcm1hdCA9IGhlYWRlckRhdGFWaWV3LmdldFVpbnQzMig0ICogZGF0YVNpemUsIGxpdHRsZUVuZGlhbik7IC8vIHRoZSB2YWx1ZSBvZiBhcmcgcGFzc2VkIHRvIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKCwseCwsLCwpXG4gICAgICAgIHRoaXMuZ2xCYXNlSW50ZXJuYWxGb3JtYXQgPSBoZWFkZXJEYXRhVmlldy5nZXRVaW50MzIoNSAqIGRhdGFTaXplLCBsaXR0bGVFbmRpYW4pOyAvLyBzcGVjaWZ5IEdMX1JHQiwgR0xfUkdCQSwgR0xfQUxQSEEsIGV0YyAodW4tY29tcHJlc3NlZCBvbmx5KVxuICAgICAgICB0aGlzLnBpeGVsV2lkdGggPSBoZWFkZXJEYXRhVmlldy5nZXRVaW50MzIoNiAqIGRhdGFTaXplLCBsaXR0bGVFbmRpYW4pOyAvLyBsZXZlbCAwIHZhbHVlIG9mIGFyZyBwYXNzZWQgdG8gZ2wuY29tcHJlc3NlZFRleEltYWdlMkQoLCwseCwsLClcbiAgICAgICAgdGhpcy5waXhlbEhlaWdodCA9IGhlYWRlckRhdGFWaWV3LmdldFVpbnQzMig3ICogZGF0YVNpemUsIGxpdHRsZUVuZGlhbik7IC8vIGxldmVsIDAgdmFsdWUgb2YgYXJnIHBhc3NlZCB0byBnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRCgsLCwseCwsKVxuICAgICAgICB0aGlzLnBpeGVsRGVwdGggPSBoZWFkZXJEYXRhVmlldy5nZXRVaW50MzIoOCAqIGRhdGFTaXplLCBsaXR0bGVFbmRpYW4pOyAvLyBsZXZlbCAwIHZhbHVlIG9mIGFyZyBwYXNzZWQgdG8gZ2wuY29tcHJlc3NlZFRleEltYWdlM0QoLCwsLCx4LCwpXG4gICAgICAgIHRoaXMubnVtYmVyT2ZBcnJheUVsZW1lbnRzID0gaGVhZGVyRGF0YVZpZXcuZ2V0VWludDMyKDkgKiBkYXRhU2l6ZSwgbGl0dGxlRW5kaWFuKTsgLy8gdXNlZCBmb3IgdGV4dHVyZSBhcnJheXNcbiAgICAgICAgdGhpcy5udW1iZXJPZkZhY2VzID0gaGVhZGVyRGF0YVZpZXcuZ2V0VWludDMyKDEwICogZGF0YVNpemUsIGxpdHRsZUVuZGlhbik7IC8vIHVzZWQgZm9yIGN1YmVtYXAgdGV4dHVyZXMsIHNob3VsZCBlaXRoZXIgYmUgMSBvciA2XG4gICAgICAgIHRoaXMubnVtYmVyT2ZNaXBtYXBMZXZlbHMgPSBoZWFkZXJEYXRhVmlldy5nZXRVaW50MzIoMTEgKiBkYXRhU2l6ZSwgbGl0dGxlRW5kaWFuKTsgLy8gbnVtYmVyIG9mIGxldmVsczsgZGlzcmVnYXJkIHBvc3NpYmlsaXR5IG9mIDAgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXNcbiAgICAgICAgdGhpcy5ieXRlc09mS2V5VmFsdWVEYXRhID0gaGVhZGVyRGF0YVZpZXcuZ2V0VWludDMyKDEyICogZGF0YVNpemUsIGxpdHRsZUVuZGlhbik7IC8vIHRoZSBhbW91bnQgb2Ygc3BhY2UgYWZ0ZXIgdGhlIGhlYWRlciBmb3IgbWV0YS1kYXRhXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgY29tcHJlc3NlZCB0eXBlLiAgTm90IG9ubHkgcmVkdWNlcyB3b3JrLCBidXQgcHJvYmFibHkgYmV0dGVyIHRvIGxldCBkZXYga25vdyB0aGV5IGFyZSBub3QgY29tcHJlc3NpbmcuXG4gICAgICAgIGlmICh0aGlzLmdsVHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgTG9nZ2VyLkVycm9yKFwib25seSBjb21wcmVzc2VkIGZvcm1hdHMgY3VycmVudGx5IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIHRoaXMuaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHZhbHVlIG9mIHplcm8gaXMgYW4gaW5kaWNhdGlvbiB0byBnZW5lcmF0ZSBtaXBtYXBzIEAgcnVudGltZS4gIE5vdCB1c3VhbGx5IGFsbG93ZWQgZm9yIGNvbXByZXNzZWQsIHNvIGRpc3JlZ2FyZC5cbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZNaXBtYXBMZXZlbHMgPSBNYXRoLm1heCgxLCB0aGlzLm51bWJlck9mTWlwbWFwTGV2ZWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5waXhlbEhlaWdodCA9PT0gMCB8fCB0aGlzLnBpeGVsRGVwdGggIT09IDApIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihcIm9ubHkgMkQgdGV4dHVyZXMgY3VycmVudGx5IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIHRoaXMuaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5udW1iZXJPZkFycmF5RWxlbWVudHMgIT09IDApIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihcInRleHR1cmUgYXJyYXlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgdGhpcy5pc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm51bWJlck9mRmFjZXMgIT09IGZhY2VzRXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIExvZ2dlci5FcnJvcihcIm51bWJlciBvZiBmYWNlcyBleHBlY3RlZFwiICsgZmFjZXNFeHBlY3RlZCArIFwiLCBidXQgZm91bmQgXCIgKyB0aGlzLm51bWJlck9mRmFjZXMpO1xuICAgICAgICAgICAgdGhpcy5pc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG5vdyBoYXZlIGEgY29tcGxldGVseSB2YWxpZGF0ZWQgZmlsZSwgc28gY291bGQgdXNlIGV4aXN0ZW5jZSBvZiBsb2FkVHlwZSBhcyBzdWNjZXNzXG4gICAgICAgIC8vIHdvdWxkIG5lZWQgdG8gbWFrZSB0aGlzIG1vcmUgZWxhYm9yYXRlICYgYWRqdXN0IGNoZWNrcyBhYm92ZSB0byBzdXBwb3J0IG1vcmUgdGhhbiBvbmUgbG9hZCB0eXBlXG4gICAgICAgIHRoaXMubG9hZFR5cGUgPSBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lci5DT01QUkVTU0VEXzJEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIEtUWCBjb250ZW50IHRvIGEgQmFieWxvbiBUZXh0dXJlLlxuICAgICAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdGV4dHVyZSBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgJiBpcyBjdXJyZW50bHkgYm91bmRcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGxvYWRMZXZlbHModGV4dHVyZSwgbG9hZE1pcG1hcHMpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmxvYWRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyLkNPTVBSRVNTRURfMkQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkMkRDb21wcmVzc2VkTGV2ZWxzKHRleHR1cmUsIGxvYWRNaXBtYXBzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS2hyb25vc1RleHR1cmVDb250YWluZXIuVEVYXzJEOlxuICAgICAgICAgICAgY2FzZSBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lci5DT01QUkVTU0VEXzNEOlxuICAgICAgICAgICAgY2FzZSBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lci5URVhfM0Q6XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3VwbG9hZDJEQ29tcHJlc3NlZExldmVscyh0ZXh0dXJlLCBsb2FkTWlwbWFwcykge1xuICAgICAgICAvLyBpbml0aWFsaXplIHdpZHRoICYgaGVpZ2h0IGZvciBsZXZlbCAxXG4gICAgICAgIGxldCBkYXRhT2Zmc2V0ID0gS2hyb25vc1RleHR1cmVDb250YWluZXIuSEVBREVSX0xFTiArIHRoaXMuYnl0ZXNPZktleVZhbHVlRGF0YTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5waXhlbFdpZHRoO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5waXhlbEhlaWdodDtcbiAgICAgICAgY29uc3QgbWlwbWFwQ291bnQgPSBsb2FkTWlwbWFwcyA/IHRoaXMubnVtYmVyT2ZNaXBtYXBMZXZlbHMgOiAxO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgbWlwbWFwQ291bnQ7IGxldmVsKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlU2l6ZSA9IG5ldyBJbnQzMkFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMuZGF0YS5ieXRlT2Zmc2V0ICsgZGF0YU9mZnNldCwgMSlbMF07IC8vIHNpemUgcGVyIGZhY2UsIHNpbmNlIG5vdCBzdXBwb3J0aW5nIGFycmF5IGN1YmVtYXBzXG4gICAgICAgICAgICBkYXRhT2Zmc2V0ICs9IDQ7IC8vaW1hZ2UgZGF0YSBzdGFydHMgZnJvbSBuZXh0IG11bHRpcGxlIG9mIDQgb2Zmc2V0LiBFYWNoIGZhY2UgcmVmZXJzIHRvIHNhbWUgaW1hZ2VzaXplIGZpZWxkIGFib3ZlLlxuICAgICAgICAgICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCB0aGlzLm51bWJlck9mRmFjZXM7IGZhY2UrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMuZGF0YS5ieXRlT2Zmc2V0ICsgZGF0YU9mZnNldCwgaW1hZ2VTaXplKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmdpbmUgPSB0ZXh0dXJlLmdldEVuZ2luZSgpO1xuICAgICAgICAgICAgICAgIGVuZ2luZS5fdXBsb2FkQ29tcHJlc3NlZERhdGFUb1RleHR1cmVEaXJlY3RseSh0ZXh0dXJlLCB0ZXh0dXJlLmZvcm1hdCwgd2lkdGgsIGhlaWdodCwgYnl0ZUFycmF5LCBmYWNlLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgZGF0YU9mZnNldCArPSBpbWFnZVNpemU7IC8vIGFkZCBzaXplIG9mIHRoZSBpbWFnZSBmb3IgdGhlIG5leHQgZmFjZS9taXBtYXBcbiAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0ICs9IDMgLSAoKGltYWdlU2l6ZSArIDMpICUgNCk7IC8vIGFkZCBwYWRkaW5nIGZvciBvZGQgc2l6ZWQgaW1hZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgoMS4wLCB3aWR0aCAqIDAuNSk7XG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCgxLjAsIGhlaWdodCAqIDAuNSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBkYXRhIHN0YXJ0cyB3aXRoIGEgS1RYIGZpbGUgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGRhdGEgaXMgYSBLVFggZmlsZSBvciBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgSXNWYWxpZChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPj0gMTIpIHtcbiAgICAgICAgICAgIC8vICfCqycsICdLJywgJ1QnLCAnWCcsICcgJywgJzEnLCAnMScsICfCuycsICdcXHInLCAnXFxuJywgJ1xceDFBJywgJ1xcbidcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCAxMik7XG4gICAgICAgICAgICBpZiAoaWRlbnRpZmllclswXSA9PT0gMHhhYiAmJlxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXJbMV0gPT09IDB4NGIgJiZcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyWzJdID09PSAweDU0ICYmXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllclszXSA9PT0gMHg1OCAmJlxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXJbNF0gPT09IDB4MjAgJiZcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyWzVdID09PSAweDMxICYmXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcls2XSA9PT0gMHgzMSAmJlxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXJbN10gPT09IDB4YmIgJiZcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyWzhdID09PSAweDBkICYmXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcls5XSA9PT0gMHgwYSAmJlxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXJbMTBdID09PSAweDFhICYmXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllclsxMV0gPT09IDB4MGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuS2hyb25vc1RleHR1cmVDb250YWluZXIuSEVBREVSX0xFTiA9IDEyICsgMTMgKiA0OyAvLyBpZGVudGlmaWVyICsgaGVhZGVyIGVsZW1lbnRzIChub3QgaW5jbHVkaW5nIGtleSB2YWx1ZSBtZXRhLWRhdGEgcGFpcnMpXG4vLyBsb2FkIHR5cGVzXG5LaHJvbm9zVGV4dHVyZUNvbnRhaW5lci5DT01QUkVTU0VEXzJEID0gMDsgLy8gdXNlcyBhIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKClcbktocm9ub3NUZXh0dXJlQ29udGFpbmVyLkNPTVBSRVNTRURfM0QgPSAxOyAvLyB1c2VzIGEgZ2wuY29tcHJlc3NlZFRleEltYWdlM0QoKVxuS2hyb25vc1RleHR1cmVDb250YWluZXIuVEVYXzJEID0gMjsgLy8gdXNlcyBhIGdsLnRleEltYWdlMkQoKVxuS2hyb25vc1RleHR1cmVDb250YWluZXIuVEVYXzNEID0gMzsgLy8gdXNlcyBhIGdsLnRleEltYWdlM0QoKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2hyb25vc1RleHR1cmVDb250YWluZXIuanMubWFwIiwiXG5pbXBvcnQgeyBBdXRvUmVsZWFzZVdvcmtlclBvb2wgfSBmcm9tIFwiLi93b3JrZXJQb29sLmpzXCI7XG5pbXBvcnQgeyBUb29scyB9IGZyb20gXCIuL3Rvb2xzLmpzXCI7XG5pbXBvcnQgeyBUcmFuc2NvZGVUYXJnZXQgfSBmcm9tIFwiLi4vTWF0ZXJpYWxzL1RleHR1cmVzL2t0eDJkZWNvZGVyVHlwZXMuanNcIjtcbmltcG9ydCB7IGFwcGx5Q29uZmlnLCBpbml0aWFsaXplV2ViV29ya2VyLCB3b3JrZXJGdW5jdGlvbiB9IGZyb20gXCIuL2tocm9ub3NUZXh0dXJlQ29udGFpbmVyMldvcmtlci5qc1wiO1xuLyoqXG4gKiBDbGFzcyB0aGF0IGRlZmluZXMgdGhlIGRlZmF1bHQgS1RYMiBkZWNvZGVyIG9wdGlvbnMuXG4gKlxuICogVGhpcyBjbGFzcyBpcyB1c2VmdWwgZm9yIHByb3ZpZGluZyBvcHRpb25zIHRvIHRoZSBLVFgyIGRlY29kZXIgdG8gY29udHJvbCBob3cgdGhlIHNvdXJjZSBkYXRhIGlzIHRyYW5zY29kZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0S1RYMkRlY29kZXJPcHRpb25zIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3VzZVJHQkFJZk9ubHlCQzFCQzNBdmFpbGFibGVXaGVuVUFTVEMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9rdHgyRGVjb2Rlck9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGlydHkgZmxhZ1xuICAgICAqL1xuICAgIGdldCBpc0RpcnR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXJ0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZm9yY2UgYSAodW5jb21wcmVzc2VkKSBSR0JBIHRyYW5zY29kZWQgZm9ybWF0IGlmIHRyYW5zY29kaW5nIGEgVUFTVEMgc291cmNlIGZvcm1hdCBhbmQgQVNUQyArIEJDNyBhcmUgbm90IGF2YWlsYWJsZSBhcyBhIGNvbXByZXNzZWQgdHJhbnNjb2RlZCBmb3JtYXRcbiAgICAgKi9cbiAgICBnZXQgdXNlUkdCQUlmQVNUQ0JDN05vdEF2YWlsYWJsZVdoZW5VQVNUQygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZVJHQkFJZkFTVENCQzdOb3RBdmFpbGFibGVXaGVuVUFTVEM7XG4gICAgfVxuICAgIHNldCB1c2VSR0JBSWZBU1RDQkM3Tm90QXZhaWxhYmxlV2hlblVBU1RDKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VSR0JBSWZBU1RDQkM3Tm90QXZhaWxhYmxlV2hlblVBU1RDID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VzZVJHQkFJZkFTVENCQzdOb3RBdmFpbGFibGVXaGVuVUFTVEMgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGZvcmNlIGEgKHVuY29tcHJlc3NlZCkgUkdCQSB0cmFuc2NvZGVkIGZvcm1hdCBpZiB0cmFuc2NvZGluZyBhIFVBU1RDIHNvdXJjZSBmb3JtYXQgYW5kIG9ubHkgQkMxIG9yIEJDMyBhcmUgYXZhaWxhYmxlIGFzIGEgY29tcHJlc3NlZCB0cmFuc2NvZGVkIGZvcm1hdC5cbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHRydWUgYnkgZGVmYXVsdCB0byBmYXZvciBzcGVlZCBvdmVyIG1lbW9yeSwgYmVjYXVzZSBjdXJyZW50bHkgdHJhbnNjb2RpbmcgZnJvbSBVQVNUQyB0byBCQzEvMyBpcyBzbG93IGJlY2F1c2UgdGhlIHRyYW5zY29kZXIgdHJhbnNjb2Rlc1xuICAgICAqIHRvIHVuY29tcHJlc3NlZCBhbmQgdGhlbiByZWNvbXByZXNzZXMgdGhlIHRleHR1cmVcbiAgICAgKi9cbiAgICBnZXQgdXNlUkdCQUlmT25seUJDMUJDM0F2YWlsYWJsZVdoZW5VQVNUQygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZVJHQkFJZk9ubHlCQzFCQzNBdmFpbGFibGVXaGVuVUFTVEM7XG4gICAgfVxuICAgIHNldCB1c2VSR0JBSWZPbmx5QkMxQkMzQXZhaWxhYmxlV2hlblVBU1RDKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VSR0JBSWZPbmx5QkMxQkMzQXZhaWxhYmxlV2hlblVBU1RDID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VzZVJHQkFJZk9ubHlCQzFCQzNBdmFpbGFibGVXaGVuVUFTVEMgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGZvcmNlIHRvIGFsd2F5cyB1c2UgKHVuY29tcHJlc3NlZCkgUkdCQSBmb3IgdHJhbnNjb2RlZCBmb3JtYXRcbiAgICAgKi9cbiAgICBnZXQgZm9yY2VSR0JBKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yY2VSR0JBO1xuICAgIH1cbiAgICBzZXQgZm9yY2VSR0JBKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9mb3JjZVJHQkEgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yY2VSR0JBID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2lzRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmb3JjZSB0byBhbHdheXMgdXNlICh1bmNvbXByZXNzZWQpIFI4IGZvciB0cmFuc2NvZGVkIGZvcm1hdFxuICAgICAqL1xuICAgIGdldCBmb3JjZVI4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yY2VSODtcbiAgICB9XG4gICAgc2V0IGZvcmNlUjgodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvcmNlUjggPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yY2VSOCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZm9yY2UgdG8gYWx3YXlzIHVzZSAodW5jb21wcmVzc2VkKSBSRzggZm9yIHRyYW5zY29kZWQgZm9ybWF0XG4gICAgICovXG4gICAgZ2V0IGZvcmNlUkc4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yY2VSRzg7XG4gICAgfVxuICAgIHNldCBmb3JjZVJHOCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fZm9yY2VSRzggPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yY2VSRzggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGxpc3Qgb2YgdHJhbnNjb2RlcnMgdG8gYnlwYXNzIHdoZW4gbG9va2luZyBmb3IgYSBzdWl0YWJsZSB0cmFuc2NvZGVyLiBUaGUgYXZhaWxhYmxlIHRyYW5zY29kZXJzIGFyZTpcbiAgICAgKiAgICAgIFVuaXZlcnNhbFRyYW5zY29kZXJfVUFTVENfQVNUQ1xuICAgICAqICAgICAgVW5pdmVyc2FsVHJhbnNjb2Rlcl9VQVNUQ19CQzdcbiAgICAgKiAgICAgIFVuaXZlcnNhbFRyYW5zY29kZXJfVUFTVENfUkdCQV9VTk9STVxuICAgICAqICAgICAgVW5pdmVyc2FsVHJhbnNjb2Rlcl9VQVNUQ19SR0JBX1NSR0JcbiAgICAgKiAgICAgIFVuaXZlcnNhbFRyYW5zY29kZXJfVUFTVENfUjhfVU5PUk1cbiAgICAgKiAgICAgIFVuaXZlcnNhbFRyYW5zY29kZXJfVUFTVENfUkc4X1VOT1JNXG4gICAgICogICAgICBNU0NUcmFuc2NvZGVyXG4gICAgICovXG4gICAgZ2V0IGJ5cGFzc1RyYW5zY29kZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnlwYXNzVHJhbnNjb2RlcnM7XG4gICAgfVxuICAgIHNldCBieXBhc3NUcmFuc2NvZGVycyh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fYnlwYXNzVHJhbnNjb2RlcnMgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnlwYXNzVHJhbnNjb2RlcnMgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0S1RYMkRlY29kZXJPcHRpb25zKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzRGlydHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rdHgyRGVjb2Rlck9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXNlUkdCQUlmQVNUQ0JDN05vdEF2YWlsYWJsZVdoZW5VQVNUQzogdGhpcy5fdXNlUkdCQUlmQVNUQ0JDN05vdEF2YWlsYWJsZVdoZW5VQVNUQyxcbiAgICAgICAgICAgIGZvcmNlUkdCQTogdGhpcy5fZm9yY2VSR0JBLFxuICAgICAgICAgICAgZm9yY2VSODogdGhpcy5fZm9yY2VSOCxcbiAgICAgICAgICAgIGZvcmNlUkc4OiB0aGlzLl9mb3JjZVJHOCxcbiAgICAgICAgICAgIGJ5cGFzc1RyYW5zY29kZXJzOiB0aGlzLl9ieXBhc3NUcmFuc2NvZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMudXNlUkdCQUlmT25seUJDMUJDM0F2YWlsYWJsZVdoZW5VQVNUQykge1xuICAgICAgICAgICAgb3B0aW9ucy50cmFuc2NvZGVGb3JtYXREZWNpc2lvblRyZWUgPSB7XG4gICAgICAgICAgICAgICAgVUFTVEM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjb2RlRm9ybWF0OiBbVHJhbnNjb2RlVGFyZ2V0LkJDMV9SR0IsIFRyYW5zY29kZVRhcmdldC5CQzNfUkdCQV0sXG4gICAgICAgICAgICAgICAgICAgIHllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNjb2RlRm9ybWF0OiBUcmFuc2NvZGVUYXJnZXQuUkdCQTMyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5naW5lRm9ybWF0OiAzMjg1NiAvKiBFbmdpbmVGb3JtYXQuUkdCQThGb3JtYXQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZFRvTXVsdGlwbGU0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9rdHgyRGVjb2Rlck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG59XG4vKipcbiAqIENsYXNzIGZvciBsb2FkaW5nIEtUWDIgZmlsZXNcbiAqL1xuZXhwb3J0IGNsYXNzIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMiB7XG4gICAgc3RhdGljIEdldERlZmF1bHROdW1Xb3JrZXJzKCkge1xuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJvYmplY3RcIiB8fCAhbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSA1MCUgb2YgdGhlIGF2YWlsYWJsZSBsb2dpY2FsIHByb2Nlc3NvcnMgYnV0IGNhcHBlZCBhdCA0LlxuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5mbG9vcihuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSAqIDAuNSksIDQpO1xuICAgIH1cbiAgICBzdGF0aWMgX0luaXRpYWxpemUobnVtV29ya2Vycykge1xuICAgICAgICBpZiAoS2hyb25vc1RleHR1cmVDb250YWluZXIyLl9Xb3JrZXJQb29sUHJvbWlzZSB8fCBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lcjIuX0RlY29kZXJNb2R1bGVQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJscyA9IHtcbiAgICAgICAgICAgIGpzRGVjb2Rlck1vZHVsZTogVG9vbHMuR2V0QmFieWxvblNjcmlwdFVSTCh0aGlzLlVSTENvbmZpZy5qc0RlY29kZXJNb2R1bGUsIHRydWUpLFxuICAgICAgICAgICAgd2FzbVVBU1RDVG9BU1RDOiBUb29scy5HZXRCYWJ5bG9uU2NyaXB0VVJMKHRoaXMuVVJMQ29uZmlnLndhc21VQVNUQ1RvQVNUQywgdHJ1ZSksXG4gICAgICAgICAgICB3YXNtVUFTVENUb0JDNzogVG9vbHMuR2V0QmFieWxvblNjcmlwdFVSTCh0aGlzLlVSTENvbmZpZy53YXNtVUFTVENUb0JDNywgdHJ1ZSksXG4gICAgICAgICAgICB3YXNtVUFTVENUb1JHQkFfVU5PUk06IFRvb2xzLkdldEJhYnlsb25TY3JpcHRVUkwodGhpcy5VUkxDb25maWcud2FzbVVBU1RDVG9SR0JBX1VOT1JNLCB0cnVlKSxcbiAgICAgICAgICAgIHdhc21VQVNUQ1RvUkdCQV9TUkdCOiBUb29scy5HZXRCYWJ5bG9uU2NyaXB0VVJMKHRoaXMuVVJMQ29uZmlnLndhc21VQVNUQ1RvUkdCQV9TUkdCLCB0cnVlKSxcbiAgICAgICAgICAgIHdhc21VQVNUQ1RvUjhfVU5PUk06IFRvb2xzLkdldEJhYnlsb25TY3JpcHRVUkwodGhpcy5VUkxDb25maWcud2FzbVVBU1RDVG9SOF9VTk9STSwgdHJ1ZSksXG4gICAgICAgICAgICB3YXNtVUFTVENUb1JHOF9VTk9STTogVG9vbHMuR2V0QmFieWxvblNjcmlwdFVSTCh0aGlzLlVSTENvbmZpZy53YXNtVUFTVENUb1JHOF9VTk9STSwgdHJ1ZSksXG4gICAgICAgICAgICBqc01TQ1RyYW5zY29kZXI6IFRvb2xzLkdldEJhYnlsb25TY3JpcHRVUkwodGhpcy5VUkxDb25maWcuanNNU0NUcmFuc2NvZGVyLCB0cnVlKSxcbiAgICAgICAgICAgIHdhc21NU0NUcmFuc2NvZGVyOiBUb29scy5HZXRCYWJ5bG9uU2NyaXB0VVJMKHRoaXMuVVJMQ29uZmlnLndhc21NU0NUcmFuc2NvZGVyLCB0cnVlKSxcbiAgICAgICAgICAgIHdhc21aU1RERGVjb2RlcjogVG9vbHMuR2V0QmFieWxvblNjcmlwdFVSTCh0aGlzLlVSTENvbmZpZy53YXNtWlNURERlY29kZXIsIHRydWUpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobnVtV29ya2VycyAmJiB0eXBlb2YgV29ya2VyID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFVSTCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgS2hyb25vc1RleHR1cmVDb250YWluZXIyLl9Xb3JrZXJQb29sUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtlckNvbnRlbnQgPSBgJHthcHBseUNvbmZpZ30oJHt3b3JrZXJGdW5jdGlvbn0pKClgO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtlckJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt3b3JrZXJDb250ZW50XSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiB9KSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgQXV0b1JlbGVhc2VXb3JrZXJQb29sKG51bVdvcmtlcnMsIGFzeW5jICgpID0+IGluaXRpYWxpemVXZWJXb3JrZXIobmV3IFdvcmtlcih3b3JrZXJCbG9iVXJsKSwgdW5kZWZpbmVkLCB1cmxzKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fS1RYMkRlY29kZXJNb2R1bGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lcjIuX0RlY29kZXJNb2R1bGVQcm9taXNlID0gVG9vbHMuTG9hZEJhYnlsb25TY3JpcHRBc3luYyh1cmxzLmpzRGVjb2Rlck1vZHVsZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fS1RYMkRlY29kZXJNb2R1bGUgPSBLVFgyREVDT0RFUjtcbiAgICAgICAgICAgICAgICAgICAgS2hyb25vc1RleHR1cmVDb250YWluZXIyLl9LVFgyRGVjb2Rlck1vZHVsZS5NU0NUcmFuc2NvZGVyLlVzZUZyb21Xb3JrZXJUaHJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgS2hyb25vc1RleHR1cmVDb250YWluZXIyLl9LVFgyRGVjb2Rlck1vZHVsZS5XQVNNTWVtb3J5TWFuYWdlci5Mb2FkQmluYXJpZXNGcm9tQ3VycmVudFRocmVhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5Q29uZmlnKHVybHMsIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fS1RYMkRlY29kZXJNb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lcjIuX0tUWDJEZWNvZGVyTW9kdWxlLktUWDJEZWNvZGVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lcjIuX0tUWDJEZWNvZGVyTW9kdWxlLk1TQ1RyYW5zY29kZXIuVXNlRnJvbVdvcmtlclRocmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fS1RYMkRlY29kZXJNb2R1bGUuV0FTTU1lbW9yeU1hbmFnZXIuTG9hZEJpbmFyaWVzRnJvbUN1cnJlbnRUaHJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fRGVjb2Rlck1vZHVsZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobmV3IEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fS1RYMkRlY29kZXJNb2R1bGUuS1RYMkRlY29kZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gZW5naW5lIFRoZSBlbmdpbmUgdG8gdXNlXG4gICAgICogQHBhcmFtIG51bVdvcmtlcnNPck9wdGlvbnMgVGhlIG51bWJlciBvZiB3b3JrZXJzIGZvciBhc3luYyBvcGVyYXRpb25zLiBTcGVjaWZ5IGAwYCB0byBkaXNhYmxlIHdlYiB3b3JrZXJzIGFuZCBydW4gc3luY2hyb25vdXNseSBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgbnVtV29ya2Vyc09yT3B0aW9ucyA9IEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5EZWZhdWx0TnVtV29ya2Vycykge1xuICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIGNvbnN0IHdvcmtlclBvb2xPcHRpb24gPSAodHlwZW9mIG51bVdvcmtlcnNPck9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgbnVtV29ya2Vyc09yT3B0aW9ucy53b3JrZXJQb29sKSB8fCBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lcjIuV29ya2VyUG9vbDtcbiAgICAgICAgaWYgKHdvcmtlclBvb2xPcHRpb24pIHtcbiAgICAgICAgICAgIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fV29ya2VyUG9vbFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUod29ya2VyUG9vbE9wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIEtUWDIgZGVjb2RlciBtb2R1bGVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtV29ya2Vyc09yT3B0aW9ucyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fS1RYMkRlY29kZXJNb2R1bGUgPSBudW1Xb3JrZXJzT3JPcHRpb25zPy5iaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXI/LmpzRGVjb2Rlck1vZHVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBLVFgyREVDT0RFUiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fS1RYMkRlY29kZXJNb2R1bGUgPSBLVFgyREVDT0RFUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG51bWJlck9mV29ya2VycyA9IHR5cGVvZiBudW1Xb3JrZXJzT3JPcHRpb25zID09PSBcIm51bWJlclwiID8gbnVtV29ya2Vyc09yT3B0aW9ucyA6IChudW1Xb3JrZXJzT3JPcHRpb25zLm51bVdvcmtlcnMgPz8gS2hyb25vc1RleHR1cmVDb250YWluZXIyLkRlZmF1bHROdW1Xb3JrZXJzKTtcbiAgICAgICAgICAgIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fSW5pdGlhbGl6ZShudW1iZXJPZldvcmtlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFzeW5jIF91cGxvYWRBc3luYyhkYXRhLCBpbnRlcm5hbFRleHR1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2FwcyA9IHRoaXMuX2VuZ2luZS5nZXRDYXBzKCk7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWRUZXh0dXJlc0NhcHMgPSB7XG4gICAgICAgICAgICBhc3RjOiAhIWNhcHMuYXN0YyxcbiAgICAgICAgICAgIGJwdGM6ICEhY2Fwcy5icHRjLFxuICAgICAgICAgICAgczN0YzogISFjYXBzLnMzdGMsXG4gICAgICAgICAgICBwdnJ0YzogISFjYXBzLnB2cnRjLFxuICAgICAgICAgICAgZXRjMjogISFjYXBzLmV0YzIsXG4gICAgICAgICAgICBldGMxOiAhIWNhcHMuZXRjMSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fV29ya2VyUG9vbFByb21pc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlclBvb2wgPSBhd2FpdCBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lcjIuX1dvcmtlclBvb2xQcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB3b3JrZXJQb29sLnB1c2goKHdvcmtlciwgb25Db21wbGV0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbk1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YS5hY3Rpb24gPT09IFwiZGVjb2RlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25NZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7IG1lc3NhZ2U6IG1lc3NhZ2UuZGF0YS5tc2cgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlVGV4dHVyZShtZXNzYWdlLmRhdGEuZGVjb2RlZERhdGEsIGludGVybmFsVGV4dHVyZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHsgbWVzc2FnZTogZXJyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IGFjdGlvbjogXCJzZXREZWZhdWx0RGVjb2Rlck9wdGlvbnNcIiwgb3B0aW9uczogS2hyb25vc1RleHR1cmVDb250YWluZXIyLkRlZmF1bHREZWNvZGVyT3B0aW9ucy5fZ2V0S1RYMkRlY29kZXJPcHRpb25zKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFDb3B5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyBhY3Rpb246IFwiZGVjb2RlXCIsIGRhdGE6IGRhdGFDb3B5LCBjYXBzOiBjb21wcmVzc2VkVGV4dHVyZXNDYXBzLCBvcHRpb25zIH0sIFtkYXRhQ29weS5idWZmZXJdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fRGVjb2Rlck1vZHVsZVByb21pc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBhd2FpdCBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lcjIuX0RlY29kZXJNb2R1bGVQcm9taXNlO1xuICAgICAgICAgICAgaWYgKEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5EZWZhdWx0RGVjb2Rlck9wdGlvbnMuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5fS1RYMkRlY29kZXJNb2R1bGUuS1RYMkRlY29kZXIuRGVmYXVsdERlY29kZXJPcHRpb25zID0gS2hyb25vc1RleHR1cmVDb250YWluZXIyLkRlZmF1bHREZWNvZGVyT3B0aW9ucy5fZ2V0S1RYMkRlY29kZXJPcHRpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlY29kZXJcbiAgICAgICAgICAgICAgICAgICAgLmRlY29kZShkYXRhLCBjYXBzKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVUZXh0dXJlKGRhdGEsIGludGVybmFsVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoeyBtZXNzYWdlOiByZWFzb24gfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLVFgyIGRlY29kZXIgbW9kdWxlIGlzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgfVxuICAgIF9jcmVhdGVUZXh0dXJlKGRhdGEsIGludGVybmFsVGV4dHVyZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvZ2xUZXh0dXJlMkQgPSAzNTUzOyAvLyBnbC5URVhUVVJFXzJEXG4gICAgICAgIHRoaXMuX2VuZ2luZS5fYmluZFRleHR1cmVEaXJlY3RseShvZ2xUZXh0dXJlMkQsIGludGVybmFsVGV4dHVyZSk7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gYmFjayBzb21lIGluZm9ybWF0aW9uIGFib3V0IHRoZSBkZWNvZGVkIGRhdGFcbiAgICAgICAgICAgIG9wdGlvbnMudHJhbnNjb2RlZEZvcm1hdCA9IGRhdGEudHJhbnNjb2RlZEZvcm1hdDtcbiAgICAgICAgICAgIG9wdGlvbnMuaXNJbkdhbW1hU3BhY2UgPSBkYXRhLmlzSW5HYW1tYVNwYWNlO1xuICAgICAgICAgICAgb3B0aW9ucy5oYXNBbHBoYSA9IGRhdGEuaGFzQWxwaGE7XG4gICAgICAgICAgICBvcHRpb25zLnRyYW5zY29kZXJOYW1lID0gZGF0YS50cmFuc2NvZGVyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNVbmNvbXByZXNzZWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICBzd2l0Y2ggKGRhdGEudHJhbnNjb2RlZEZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAweDgwNTggLyogUkdCQTggKi86XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlLnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgIGludGVybmFsVGV4dHVyZS5mb3JtYXQgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweDgyMjkgLyogUjggKi86XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlLnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgIGludGVybmFsVGV4dHVyZS5mb3JtYXQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweDgyMmIgLyogUkc4ICovOlxuICAgICAgICAgICAgICAgIGludGVybmFsVGV4dHVyZS50eXBlID0gMDtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUuZm9ybWF0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUZXh0dXJlLmZvcm1hdCA9IGRhdGEudHJhbnNjb2RlZEZvcm1hdDtcbiAgICAgICAgICAgICAgICBpc1VuY29tcHJlc3NlZEZvcm1hdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGludGVybmFsVGV4dHVyZS5fZ2FtbWFTcGFjZSA9IGRhdGEuaXNJbkdhbW1hU3BhY2U7XG4gICAgICAgIGludGVybmFsVGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMgPSBkYXRhLm1pcG1hcHMubGVuZ3RoID4gMTtcbiAgICAgICAgaWYgKGRhdGEuZXJyb3JzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLVFgyIGNvbnRhaW5lciAtIGNvdWxkIG5vdCB0cmFuc2NvZGUgdGhlIGRhdGEuIFwiICsgZGF0YS5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZGF0YS5taXBtYXBzLmxlbmd0aDsgKyt0KSB7XG4gICAgICAgICAgICBjb25zdCBtaXBtYXAgPSBkYXRhLm1pcG1hcHNbdF07XG4gICAgICAgICAgICBpZiAoIW1pcG1hcCB8fCAhbWlwbWFwLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLVFgyIGNvbnRhaW5lciAtIGNvdWxkIG5vdCB0cmFuc2NvZGUgb25lIG9mIHRoZSBpbWFnZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1VuY29tcHJlc3NlZEZvcm1hdCkge1xuICAgICAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBSR0JBIC8gUjggLyBSRzhcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFRleHR1cmUud2lkdGggPSBtaXBtYXAud2lkdGg7IC8vIG5lZWQgdG8gc2V0IHdpZHRoL2hlaWdodCBzbyB0aGF0IHRoZSBjYWxsIHRvIF91cGxvYWREYXRhVG9UZXh0dXJlRGlyZWN0bHkgdXNlcyB0aGUgcmlnaHQgZGltZW5zaW9uc1xuICAgICAgICAgICAgICAgIGludGVybmFsVGV4dHVyZS5oZWlnaHQgPSBtaXBtYXAuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5fdXBsb2FkRGF0YVRvVGV4dHVyZURpcmVjdGx5KGludGVybmFsVGV4dHVyZSwgbWlwbWFwLmRhdGEsIDAsIHQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUuX3VwbG9hZENvbXByZXNzZWREYXRhVG9UZXh0dXJlRGlyZWN0bHkoaW50ZXJuYWxUZXh0dXJlLCBkYXRhLnRyYW5zY29kZWRGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgbWlwbWFwLmRhdGEsIDAsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGludGVybmFsVGV4dHVyZS5fZXh0ZW5zaW9uID0gXCIua3R4MlwiO1xuICAgICAgICBpbnRlcm5hbFRleHR1cmUud2lkdGggPSBkYXRhLm1pcG1hcHNbMF0ud2lkdGg7XG4gICAgICAgIGludGVybmFsVGV4dHVyZS5oZWlnaHQgPSBkYXRhLm1pcG1hcHNbMF0uaGVpZ2h0O1xuICAgICAgICBpbnRlcm5hbFRleHR1cmUuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2VuZ2luZS5fYmluZFRleHR1cmVEaXJlY3RseShvZ2xUZXh0dXJlMkQsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGRhdGEgc3RhcnRzIHdpdGggYSBLVFgyIGZpbGUgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGRhdGEgaXMgYSBLVFgyIGZpbGUgb3IgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3RhdGljIElzVmFsaWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5ieXRlTGVuZ3RoID49IDEyKSB7XG4gICAgICAgICAgICAvLyAnwqsnLCAnSycsICdUJywgJ1gnLCAnICcsICcyJywgJzAnLCAnwrsnLCAnXFxyJywgJ1xcbicsICdcXHgxQScsICdcXG4nXG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgMTIpO1xuICAgICAgICAgICAgaWYgKGlkZW50aWZpZXJbMF0gPT09IDB4YWIgJiZcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyWzFdID09PSAweDRiICYmXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllclsyXSA9PT0gMHg1NCAmJlxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXJbM10gPT09IDB4NTggJiZcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyWzRdID09PSAweDIwICYmXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcls1XSA9PT0gMHgzMiAmJlxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXJbNl0gPT09IDB4MzAgJiZcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyWzddID09PSAweGJiICYmXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcls4XSA9PT0gMHgwZCAmJlxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXJbOV0gPT09IDB4MGEgJiZcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyWzEwXSA9PT0gMHgxYSAmJlxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXJbMTFdID09PSAweDBhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVVJMcyB0byB1c2Ugd2hlbiBsb2FkaW5nIHRoZSBLVFgyIGRlY29kZXIgbW9kdWxlIGFzIHdlbGwgYXMgaXRzIGRlcGVuZGVuY2llc1xuICogSWYgYSB1cmwgaXMgbnVsbCwgdGhlIGRlZmF1bHQgdXJsIGlzIHVzZWQgKHBvaW50aW5nIHRvIGh0dHBzOi8vcHJldmlldy5iYWJ5bG9uanMuY29tKVxuICogTm90ZSB0aGF0IGpzRGVjb2Rlck1vZHVsZSBjYW4ndCBiZSBudWxsIGFuZCB0aGF0IHRoZSBvdGhlciBkZXBlbmRlbmNpZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpZiBuZWNlc3NhcnlcbiAqIFVybHMgeW91IGNhbiBjaGFuZ2U6XG4gKiAgICAgVVJMQ29uZmlnLmpzRGVjb2Rlck1vZHVsZVxuICogICAgIFVSTENvbmZpZy53YXNtVUFTVENUb0FTVENcbiAqICAgICBVUkxDb25maWcud2FzbVVBU1RDVG9CQzdcbiAqICAgICBVUkxDb25maWcud2FzbVVBU1RDVG9SR0JBX1VOT1JNXG4gKiAgICAgVVJMQ29uZmlnLndhc21VQVNUQ1RvUkdCQV9TUkdCXG4gKiAgICAgVVJMQ29uZmlnLndhc21VQVNUQ1RvUjhfVU5PUk1cbiAqICAgICBVUkxDb25maWcud2FzbVVBU1RDVG9SRzhfVU5PUk1cbiAqICAgICBVUkxDb25maWcuanNNU0NUcmFuc2NvZGVyXG4gKiAgICAgVVJMQ29uZmlnLndhc21NU0NUcmFuc2NvZGVyXG4gKiAgICAgVVJMQ29uZmlnLndhc21aU1RERGVjb2RlclxuICogWW91IGNhbiBzZWUgdGhlaXIgZGVmYXVsdCB2YWx1ZXMgaW4gdGhpcyBQRzogaHR0cHM6Ly9wbGF5Z3JvdW5kLmJhYnlsb25qcy5jb20vI0VJSkg4TCMyOVxuICovXG5LaHJvbm9zVGV4dHVyZUNvbnRhaW5lcjIuVVJMQ29uZmlnID0ge1xuICAgIGpzRGVjb2Rlck1vZHVsZTogXCJodHRwczovL2Nkbi5iYWJ5bG9uanMuY29tL2JhYnlsb24ua3R4MkRlY29kZXIuanNcIixcbiAgICB3YXNtVUFTVENUb0FTVEM6IG51bGwsXG4gICAgd2FzbVVBU1RDVG9CQzc6IG51bGwsXG4gICAgd2FzbVVBU1RDVG9SR0JBX1VOT1JNOiBudWxsLFxuICAgIHdhc21VQVNUQ1RvUkdCQV9TUkdCOiBudWxsLFxuICAgIHdhc21VQVNUQ1RvUjhfVU5PUk06IG51bGwsXG4gICAgd2FzbVVBU1RDVG9SRzhfVU5PUk06IG51bGwsXG4gICAganNNU0NUcmFuc2NvZGVyOiBudWxsLFxuICAgIHdhc21NU0NUcmFuc2NvZGVyOiBudWxsLFxuICAgIHdhc21aU1RERGVjb2RlcjogbnVsbCxcbn07XG4vKipcbiAqIERlZmF1bHQgbnVtYmVyIG9mIHdvcmtlcnMgdXNlZCB0byBoYW5kbGUgZGF0YSBkZWNvZGluZ1xuICovXG5LaHJvbm9zVGV4dHVyZUNvbnRhaW5lcjIuRGVmYXVsdE51bVdvcmtlcnMgPSBLaHJvbm9zVGV4dHVyZUNvbnRhaW5lcjIuR2V0RGVmYXVsdE51bVdvcmtlcnMoKTtcbi8qKlxuICogRGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciB0aGUgS1RYMiBkZWNvZGVyLlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBpbiB0aGlzIHdheSBoYXZlIHByaW9yaXR5IG92ZXIgdGhvc2UgcGFzc2VkIHdoZW4gY3JlYXRpbmcgYSBLVFgyIHRleHR1cmUgd2l0aCBuZXcgVGV4dHVyZSguLi4pLlxuICovXG5LaHJvbm9zVGV4dHVyZUNvbnRhaW5lcjIuRGVmYXVsdERlY29kZXJPcHRpb25zID0gbmV3IERlZmF1bHRLVFgyRGVjb2Rlck9wdGlvbnMoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtocm9ub3NUZXh0dXJlQ29udGFpbmVyMi5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gYXBwbHlDb25maWcodXJscywgYmluYXJpZXNBbmRNb2R1bGVzQ29udGFpbmVyKSB7XG4gICAgY29uc3QgS1RYMkRlY29kZXJNb2R1bGUgPSBiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXI/LmpzRGVjb2Rlck1vZHVsZSB8fCBLVFgyREVDT0RFUjtcbiAgICBpZiAodXJscykge1xuICAgICAgICBpZiAodXJscy53YXNtVUFTVENUb0FTVEMpIHtcbiAgICAgICAgICAgIEtUWDJEZWNvZGVyTW9kdWxlLkxpdGVUcmFuc2NvZGVyX1VBU1RDX0FTVEMuV2FzbU1vZHVsZVVSTCA9IHVybHMud2FzbVVBU1RDVG9BU1RDO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmxzLndhc21VQVNUQ1RvQkM3KSB7XG4gICAgICAgICAgICBLVFgyRGVjb2Rlck1vZHVsZS5MaXRlVHJhbnNjb2Rlcl9VQVNUQ19CQzcuV2FzbU1vZHVsZVVSTCA9IHVybHMud2FzbVVBU1RDVG9CQzc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybHMud2FzbVVBU1RDVG9SR0JBX1VOT1JNKSB7XG4gICAgICAgICAgICBLVFgyRGVjb2Rlck1vZHVsZS5MaXRlVHJhbnNjb2Rlcl9VQVNUQ19SR0JBX1VOT1JNLldhc21Nb2R1bGVVUkwgPSB1cmxzLndhc21VQVNUQ1RvUkdCQV9VTk9STTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJscy53YXNtVUFTVENUb1JHQkFfU1JHQikge1xuICAgICAgICAgICAgS1RYMkRlY29kZXJNb2R1bGUuTGl0ZVRyYW5zY29kZXJfVUFTVENfUkdCQV9TUkdCLldhc21Nb2R1bGVVUkwgPSB1cmxzLndhc21VQVNUQ1RvUkdCQV9TUkdCO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmxzLndhc21VQVNUQ1RvUjhfVU5PUk0pIHtcbiAgICAgICAgICAgIEtUWDJEZWNvZGVyTW9kdWxlLkxpdGVUcmFuc2NvZGVyX1VBU1RDX1I4X1VOT1JNLldhc21Nb2R1bGVVUkwgPSB1cmxzLndhc21VQVNUQ1RvUjhfVU5PUk07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybHMud2FzbVVBU1RDVG9SRzhfVU5PUk0pIHtcbiAgICAgICAgICAgIEtUWDJEZWNvZGVyTW9kdWxlLkxpdGVUcmFuc2NvZGVyX1VBU1RDX1JHOF9VTk9STS5XYXNtTW9kdWxlVVJMID0gdXJscy53YXNtVUFTVENUb1JHOF9VTk9STTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJscy5qc01TQ1RyYW5zY29kZXIpIHtcbiAgICAgICAgICAgIEtUWDJEZWNvZGVyTW9kdWxlLk1TQ1RyYW5zY29kZXIuSlNNb2R1bGVVUkwgPSB1cmxzLmpzTVNDVHJhbnNjb2RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJscy53YXNtTVNDVHJhbnNjb2Rlcikge1xuICAgICAgICAgICAgS1RYMkRlY29kZXJNb2R1bGUuTVNDVHJhbnNjb2Rlci5XYXNtTW9kdWxlVVJMID0gdXJscy53YXNtTVNDVHJhbnNjb2RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJscy53YXNtWlNURERlY29kZXIpIHtcbiAgICAgICAgICAgIEtUWDJEZWNvZGVyTW9kdWxlLlpTVEREZWNvZGVyLldhc21Nb2R1bGVVUkwgPSB1cmxzLndhc21aU1RERGVjb2RlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmluYXJpZXNBbmRNb2R1bGVzQ29udGFpbmVyKSB7XG4gICAgICAgIGlmIChiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXIud2FzbVVBU1RDVG9BU1RDKSB7XG4gICAgICAgICAgICBLVFgyRGVjb2Rlck1vZHVsZS5MaXRlVHJhbnNjb2Rlcl9VQVNUQ19BU1RDLldhc21CaW5hcnkgPSBiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXIud2FzbVVBU1RDVG9BU1RDO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXIud2FzbVVBU1RDVG9CQzcpIHtcbiAgICAgICAgICAgIEtUWDJEZWNvZGVyTW9kdWxlLkxpdGVUcmFuc2NvZGVyX1VBU1RDX0JDNy5XYXNtQmluYXJ5ID0gYmluYXJpZXNBbmRNb2R1bGVzQ29udGFpbmVyLndhc21VQVNUQ1RvQkM3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXIud2FzbVVBU1RDVG9SR0JBX1VOT1JNKSB7XG4gICAgICAgICAgICBLVFgyRGVjb2Rlck1vZHVsZS5MaXRlVHJhbnNjb2Rlcl9VQVNUQ19SR0JBX1VOT1JNLldhc21CaW5hcnkgPSBiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXIud2FzbVVBU1RDVG9SR0JBX1VOT1JNO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXIud2FzbVVBU1RDVG9SR0JBX1NSR0IpIHtcbiAgICAgICAgICAgIEtUWDJEZWNvZGVyTW9kdWxlLkxpdGVUcmFuc2NvZGVyX1VBU1RDX1JHQkFfU1JHQi5XYXNtQmluYXJ5ID0gYmluYXJpZXNBbmRNb2R1bGVzQ29udGFpbmVyLndhc21VQVNUQ1RvUkdCQV9TUkdCO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXIud2FzbVVBU1RDVG9SOF9VTk9STSkge1xuICAgICAgICAgICAgS1RYMkRlY29kZXJNb2R1bGUuTGl0ZVRyYW5zY29kZXJfVUFTVENfUjhfVU5PUk0uV2FzbUJpbmFyeSA9IGJpbmFyaWVzQW5kTW9kdWxlc0NvbnRhaW5lci53YXNtVUFTVENUb1I4X1VOT1JNO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXIud2FzbVVBU1RDVG9SRzhfVU5PUk0pIHtcbiAgICAgICAgICAgIEtUWDJEZWNvZGVyTW9kdWxlLkxpdGVUcmFuc2NvZGVyX1VBU1RDX1JHOF9VTk9STS5XYXNtQmluYXJ5ID0gYmluYXJpZXNBbmRNb2R1bGVzQ29udGFpbmVyLndhc21VQVNUQ1RvUkc4X1VOT1JNO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXIuanNNU0NUcmFuc2NvZGVyKSB7XG4gICAgICAgICAgICBLVFgyRGVjb2Rlck1vZHVsZS5NU0NUcmFuc2NvZGVyLkpTTW9kdWxlID0gYmluYXJpZXNBbmRNb2R1bGVzQ29udGFpbmVyLmpzTVNDVHJhbnNjb2RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluYXJpZXNBbmRNb2R1bGVzQ29udGFpbmVyLndhc21NU0NUcmFuc2NvZGVyKSB7XG4gICAgICAgICAgICBLVFgyRGVjb2Rlck1vZHVsZS5NU0NUcmFuc2NvZGVyLldhc21CaW5hcnkgPSBiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXIud2FzbU1TQ1RyYW5zY29kZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmFyaWVzQW5kTW9kdWxlc0NvbnRhaW5lci53YXNtWlNURERlY29kZXIpIHtcbiAgICAgICAgICAgIEtUWDJEZWNvZGVyTW9kdWxlLlpTVEREZWNvZGVyLldhc21CaW5hcnkgPSBiaW5hcmllc0FuZE1vZHVsZXNDb250YWluZXIud2FzbVpTVEREZWNvZGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHdvcmtlckZ1bmN0aW9uKEtUWDJEZWNvZGVyTW9kdWxlKSB7XG4gICAgaWYgKHR5cGVvZiBLVFgyRGVjb2Rlck1vZHVsZSA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgS1RYMkRFQ09ERVIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgS1RYMkRlY29kZXJNb2R1bGUgPSBLVFgyREVDT0RFUjtcbiAgICB9XG4gICAgbGV0IGt0eDJEZWNvZGVyO1xuICAgIG9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIWV2ZW50LmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmRhdGEuYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW5pdFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJscyA9IGV2ZW50LmRhdGEudXJscztcbiAgICAgICAgICAgICAgICBpZiAodXJscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXJscy5qc0RlY29kZXJNb2R1bGUgJiYgdHlwZW9mIEtUWDJEZWNvZGVyTW9kdWxlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRTY3JpcHRzKHVybHMuanNEZWNvZGVyTW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtaW5nIGdsb2JhbCBuYW1lc3BhY2UgcG9wdWxhdGVkIGJ5IHRoZSBzY3JpcHQgKFVNRCBwYXR0ZXJuKVxuICAgICAgICAgICAgICAgICAgICAgICAgS1RYMkRlY29kZXJNb2R1bGUgPSBLVFgyREVDT0RFUjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcHBseUNvbmZpZyh1cmxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEud2FzbUJpbmFyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5Q29uZmlnKHVuZGVmaW5lZCwgeyAuLi5ldmVudC5kYXRhLndhc21CaW5hcmllcywganNEZWNvZGVyTW9kdWxlOiBLVFgyRGVjb2Rlck1vZHVsZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga3R4MkRlY29kZXIgPSBuZXcgS1RYMkRlY29kZXJNb2R1bGUuS1RYMkRlY29kZXIoKTtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IGFjdGlvbjogXCJpbml0XCIgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic2V0RGVmYXVsdERlY29kZXJPcHRpb25zXCI6IHtcbiAgICAgICAgICAgICAgICBLVFgyRGVjb2Rlck1vZHVsZS5LVFgyRGVjb2Rlci5EZWZhdWx0RGVjb2Rlck9wdGlvbnMgPSBldmVudC5kYXRhLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZGVjb2RlXCI6XG4gICAgICAgICAgICAgICAga3R4MkRlY29kZXJcbiAgICAgICAgICAgICAgICAgICAgLmRlY29kZShldmVudC5kYXRhLmRhdGEsIGV2ZW50LmRhdGEuY2FwcywgZXZlbnQuZGF0YS5vcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG1pcCA9IDA7IG1pcCA8IGRhdGEubWlwbWFwcy5sZW5ndGg7ICsrbWlwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaXBtYXAgPSBkYXRhLm1pcG1hcHNbbWlwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaXBtYXAgJiYgbWlwbWFwLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2gobWlwbWFwLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IGFjdGlvbjogXCJkZWNvZGVkXCIsIHN1Y2Nlc3M6IHRydWUsIGRlY29kZWREYXRhOiBkYXRhIH0sIGJ1ZmZlcnMpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgYWN0aW9uOiBcImRlY29kZWRcIiwgc3VjY2VzczogZmFsc2UsIG1zZzogcmVhc29uIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplV2ViV29ya2VyKHdvcmtlciwgd2FzbUJpbmFyaWVzLCB1cmxzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25NZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEuYWN0aW9uID09PSBcImluaXRcIikge1xuICAgICAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh3b3JrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25NZXNzYWdlKTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbml0XCIsXG4gICAgICAgICAgICB1cmxzLFxuICAgICAgICAgICAgd2FzbUJpbmFyaWVzLFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtocm9ub3NUZXh0dXJlQ29udGFpbmVyMldvcmtlci5qcy5tYXAiLCIvKipcbiAqIEhlbHBlciBjbGFzcyB0byBwdXNoIGFjdGlvbnMgdG8gYSBwb29sIG9mIHdvcmtlcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JrZXJQb29sIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB3b3JrZXJzIEFycmF5IG9mIHdvcmtlcnMgdG8gdXNlIGZvciBhY3Rpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iod29ya2Vycykge1xuICAgICAgICB0aGlzLl9wZW5kaW5nQWN0aW9ucyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLl93b3JrZXJJbmZvcyA9IHdvcmtlcnMubWFwKCh3b3JrZXIpID0+ICh7XG4gICAgICAgICAgICB3b3JrZXJQcm9taXNlOiBQcm9taXNlLnJlc29sdmUod29ya2VyKSxcbiAgICAgICAgICAgIGlkbGU6IHRydWUsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVybWluYXRlcyBhbGwgd29ya2VycyBhbmQgY2xlYXJzIGFueSBwZW5kaW5nIGFjdGlvbnMuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCB3b3JrZXJJbmZvIG9mIHRoaXMuX3dvcmtlckluZm9zKSB7XG4gICAgICAgICAgICB3b3JrZXJJbmZvLndvcmtlclByb21pc2UudGhlbigod29ya2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya2VySW5mb3MubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0FjdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGFuIGFjdGlvbiB0byB0aGUgd29ya2VyIHBvb2wuIElmIGFsbCB0aGUgd29ya2VycyBhcmUgYWN0aXZlLCB0aGUgYWN0aW9uIHdpbGwgYmVcbiAgICAgKiBwZW5kZWQgdW50aWwgYSB3b3JrZXIgaGFzIGNvbXBsZXRlZCBpdHMgYWN0aW9uLlxuICAgICAqIEBwYXJhbSBhY3Rpb24gVGhlIGFjdGlvbiB0byBwZXJmb3JtLiBDYWxsIG9uQ29tcGxldGUgd2hlbiB0aGUgYWN0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIHB1c2goYWN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXhlY3V0ZU9uSWRsZVdvcmtlcihhY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2V4ZWN1dGVPbklkbGVXb3JrZXIoYWN0aW9uKSB7XG4gICAgICAgIGZvciAoY29uc3Qgd29ya2VySW5mbyBvZiB0aGlzLl93b3JrZXJJbmZvcykge1xuICAgICAgICAgICAgaWYgKHdvcmtlckluZm8uaWRsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGUod29ya2VySW5mbywgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9leGVjdXRlKHdvcmtlckluZm8sIGFjdGlvbikge1xuICAgICAgICB3b3JrZXJJbmZvLmlkbGUgPSBmYWxzZTtcbiAgICAgICAgd29ya2VySW5mby53b3JrZXJQcm9taXNlLnRoZW4oKHdvcmtlcikgPT4ge1xuICAgICAgICAgICAgYWN0aW9uKHdvcmtlciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRBY3Rpb24gPSB0aGlzLl9wZW5kaW5nQWN0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGUod29ya2VySW5mbywgbmV4dEFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXJJbmZvLmlkbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFNpbWlsYXIgdG8gdGhlIFdvcmtlclBvb2wgY2xhc3MgZXhjZXB0IGl0IGNyZWF0ZXMgYW5kIGRlc3Ryb3lzIHdvcmtlcnMgYXV0b21hdGljYWxseSB3aXRoIGEgbWF4aW11bSBvZiBgbWF4V29ya2Vyc2Agd29ya2Vycy5cbiAqIFdvcmtlcnMgYXJlIHRlcm1pbmF0ZWQgd2hlbiBpdCBpcyBpZGxlIGZvciBhdCBsZWFzdCBgaWRsZVRpbWVFbGFwc2VkQmVmb3JlUmVsZWFzZWAgbWlsbGlzZWNvbmRzLlxuICovXG5leHBvcnQgY2xhc3MgQXV0b1JlbGVhc2VXb3JrZXJQb29sIGV4dGVuZHMgV29ya2VyUG9vbCB7XG4gICAgY29uc3RydWN0b3IobWF4V29ya2VycywgY3JlYXRlV29ya2VyQXN5bmMsIG9wdGlvbnMgPSBBdXRvUmVsZWFzZVdvcmtlclBvb2wuRGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoW10pO1xuICAgICAgICB0aGlzLl9tYXhXb3JrZXJzID0gbWF4V29ya2VycztcbiAgICAgICAgdGhpcy5fY3JlYXRlV29ya2VyQXN5bmMgPSBjcmVhdGVXb3JrZXJBc3luYztcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHB1c2goYWN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXhlY3V0ZU9uSWRsZVdvcmtlcihhY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya2VySW5mb3MubGVuZ3RoIDwgdGhpcy5fbWF4V29ya2Vycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtlckluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlclByb21pc2U6IHRoaXMuX2NyZWF0ZVdvcmtlckFzeW5jKCksXG4gICAgICAgICAgICAgICAgICAgIGlkbGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2VySW5mb3MucHVzaCh3b3JrZXJJbmZvKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9leGVjdXRlKHdvcmtlckluZm8sIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nQWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2V4ZWN1dGUod29ya2VySW5mbywgYWN0aW9uKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBpZGxlIHRpbWVvdXQuXG4gICAgICAgIGlmICh3b3JrZXJJbmZvLnRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHdvcmtlckluZm8udGltZW91dElkKTtcbiAgICAgICAgICAgIGRlbGV0ZSB3b3JrZXJJbmZvLnRpbWVvdXRJZDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5fZXhlY3V0ZSh3b3JrZXJJbmZvLCAod29ya2VyLCBvbkNvbXBsZXRlKSA9PiB7XG4gICAgICAgICAgICBhY3Rpb24od29ya2VyLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICh3b3JrZXJJbmZvLmlkbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIHdvcmtlciB0byBiZSB0ZXJtaW5hdGVkIGFmdGVyIHRoZSBlbGFwc2VkIHRpbWUuXG4gICAgICAgICAgICAgICAgICAgIHdvcmtlckluZm8udGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJJbmZvLndvcmtlclByb21pc2UudGhlbigod29ya2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleE9mID0gdGhpcy5fd29ya2VySW5mb3MuaW5kZXhPZih3b3JrZXJJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleE9mICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtlckluZm9zLnNwbGljZShpbmRleE9mLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5fb3B0aW9ucy5pZGxlVGltZUVsYXBzZWRCZWZvcmVSZWxlYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIE92ZXJyaWRlIHRvIGNoYW5nZSB0aGUgZGVmYXVsdHMuXG4gKi9cbkF1dG9SZWxlYXNlV29ya2VyUG9vbC5EZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBpZGxlVGltZUVsYXBzZWRCZWZvcmVSZWxlYXNlOiAxMDAwLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlclBvb2wuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9