"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["vendors-node_modules_babylonjs_core_Materials_Textures_Loaders_tgaTextureLoader_js"],{

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/tgaTextureLoader.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/tgaTextureLoader.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _TGATextureLoader: () => (/* binding */ _TGATextureLoader)
/* harmony export */ });
/* harmony import */ var _Misc_tga_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Misc/tga.js */ "./node_modules/@babylonjs/core/Misc/tga.js");

/**
 * Implementation of the TGA Texture Loader.
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class _TGATextureLoader {
    constructor() {
        /**
         * Defines whether the loader supports cascade loading the different faces.
         */
        this.supportCascades = false;
    }
    /**
     * Uploads the cube texture data to the WebGL texture. It has already been bound.
     */
    loadCubeData() {
        // eslint-disable-next-line no-throw-literal
        throw ".env not supported in Cube.";
    }
    /**
     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param callback defines the method to call once ready to upload
     */
    loadData(data, texture, callback) {
        const bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        const header = (0,_Misc_tga_js__WEBPACK_IMPORTED_MODULE_0__.GetTGAHeader)(bytes);
        callback(header.width, header.height, texture.generateMipMaps, false, () => {
            (0,_Misc_tga_js__WEBPACK_IMPORTED_MODULE_0__.UploadContent)(texture, bytes);
        });
    }
}
//# sourceMappingURL=tgaTextureLoader.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/tga.js":
/*!**************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/tga.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GetTGAHeader: () => (/* binding */ GetTGAHeader),
/* harmony export */   TGATools: () => (/* binding */ TGATools),
/* harmony export */   UploadContent: () => (/* binding */ UploadContent)
/* harmony export */ });
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");

//private static _TYPE_NO_DATA = 0;
const _TYPE_INDEXED = 1;
const _TYPE_RGB = 2;
const _TYPE_GREY = 3;
const _TYPE_RLE_INDEXED = 9;
const _TYPE_RLE_RGB = 10;
const _TYPE_RLE_GREY = 11;
const _ORIGIN_MASK = 0x30;
const _ORIGIN_SHIFT = 0x04;
const _ORIGIN_BL = 0x00;
const _ORIGIN_BR = 0x01;
const _ORIGIN_UL = 0x02;
const _ORIGIN_UR = 0x03;
/**
 * Gets the header of a TGA file
 * @param data defines the TGA data
 * @returns the header
 */
function GetTGAHeader(data) {
    let offset = 0;
    const header = {
        id_length: data[offset++],
        colormap_type: data[offset++],
        image_type: data[offset++],
        colormap_index: data[offset++] | (data[offset++] << 8),
        colormap_length: data[offset++] | (data[offset++] << 8),
        colormap_size: data[offset++],
        origin: [data[offset++] | (data[offset++] << 8), data[offset++] | (data[offset++] << 8)],
        width: data[offset++] | (data[offset++] << 8),
        height: data[offset++] | (data[offset++] << 8),
        pixel_size: data[offset++],
        flags: data[offset++],
    };
    return header;
}
/**
 * Uploads TGA content to a Babylon Texture
 * @internal
 */
function UploadContent(texture, data) {
    // Not enough data to contain header ?
    if (data.length < 19) {
        _Misc_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Unable to load TGA file - Not enough data to contain header");
        return;
    }
    // Read Header
    let offset = 18;
    const header = GetTGAHeader(data);
    // Assume it's a valid Targa file.
    if (header.id_length + offset > data.length) {
        _Misc_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Unable to load TGA file - Not enough data");
        return;
    }
    // Skip not needed data
    offset += header.id_length;
    let use_rle = false;
    let use_pal = false;
    let use_grey = false;
    // Get some informations.
    switch (header.image_type) {
        case _TYPE_RLE_INDEXED:
            use_rle = true;
        // eslint-disable-next-line no-fallthrough
        case _TYPE_INDEXED:
            use_pal = true;
            break;
        case _TYPE_RLE_RGB:
            use_rle = true;
        // eslint-disable-next-line no-fallthrough
        case _TYPE_RGB:
            // use_rgb = true;
            break;
        case _TYPE_RLE_GREY:
            use_rle = true;
        // eslint-disable-next-line no-fallthrough
        case _TYPE_GREY:
            use_grey = true;
            break;
    }
    let pixel_data;
    // var numAlphaBits = header.flags & 0xf;
    const pixel_size = header.pixel_size >> 3;
    const pixel_total = header.width * header.height * pixel_size;
    // Read palettes
    let palettes;
    if (use_pal) {
        palettes = data.subarray(offset, (offset += header.colormap_length * (header.colormap_size >> 3)));
    }
    // Read LRE
    if (use_rle) {
        pixel_data = new Uint8Array(pixel_total);
        let c, count, i;
        let localOffset = 0;
        const pixels = new Uint8Array(pixel_size);
        while (offset < pixel_total && localOffset < pixel_total) {
            c = data[offset++];
            count = (c & 0x7f) + 1;
            // RLE pixels
            if (c & 0x80) {
                // Bind pixel tmp array
                for (i = 0; i < pixel_size; ++i) {
                    pixels[i] = data[offset++];
                }
                // Copy pixel array
                for (i = 0; i < count; ++i) {
                    pixel_data.set(pixels, localOffset + i * pixel_size);
                }
                localOffset += pixel_size * count;
            }
            // Raw pixels
            else {
                count *= pixel_size;
                for (i = 0; i < count; ++i) {
                    pixel_data[localOffset + i] = data[offset++];
                }
                localOffset += count;
            }
        }
    }
    // RAW Pixels
    else {
        pixel_data = data.subarray(offset, (offset += use_pal ? header.width * header.height : pixel_total));
    }
    // Load to texture
    let x_start, y_start, x_step, y_step, y_end, x_end;
    switch ((header.flags & _ORIGIN_MASK) >> _ORIGIN_SHIFT) {
        default:
        case _ORIGIN_UL:
            x_start = 0;
            x_step = 1;
            x_end = header.width;
            y_start = 0;
            y_step = 1;
            y_end = header.height;
            break;
        case _ORIGIN_BL:
            x_start = 0;
            x_step = 1;
            x_end = header.width;
            y_start = header.height - 1;
            y_step = -1;
            y_end = -1;
            break;
        case _ORIGIN_UR:
            x_start = header.width - 1;
            x_step = -1;
            x_end = -1;
            y_start = 0;
            y_step = 1;
            y_end = header.height;
            break;
        case _ORIGIN_BR:
            x_start = header.width - 1;
            x_step = -1;
            x_end = -1;
            y_start = header.height - 1;
            y_step = -1;
            y_end = -1;
            break;
    }
    // Load the specify method
    const func = "_getImageData" + (use_grey ? "Grey" : "") + header.pixel_size + "bits";
    const imageData = TGATools[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);
    const engine = texture.getEngine();
    engine._uploadDataToTextureDirectly(texture, imageData);
}
/**
 * @internal
 */
function GetImageData8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data, colormap = palettes;
    const width = header.width, height = header.height;
    let color, i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i++) {
            color = image[i];
            imageData[(x + width * y) * 4 + 3] = 255;
            imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];
            imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];
            imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];
        }
    }
    return imageData;
}
/**
 * @internal
 */
function GetImageData16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data;
    const width = header.width, height = header.height;
    let color, i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i += 2) {
            color = image[i + 0] + (image[i + 1] << 8); // Inversed ?
            const r = ((((color & 0x7c00) >> 10) * 255) / 0x1f) | 0;
            const g = ((((color & 0x03e0) >> 5) * 255) / 0x1f) | 0;
            const b = (((color & 0x001f) * 255) / 0x1f) | 0;
            imageData[(x + width * y) * 4 + 0] = r;
            imageData[(x + width * y) * 4 + 1] = g;
            imageData[(x + width * y) * 4 + 2] = b;
            imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;
        }
    }
    return imageData;
}
/**
 * @internal
 */
function GetImageData24bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data;
    const width = header.width, height = header.height;
    let i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i += 3) {
            imageData[(x + width * y) * 4 + 3] = 255;
            imageData[(x + width * y) * 4 + 2] = image[i + 0];
            imageData[(x + width * y) * 4 + 1] = image[i + 1];
            imageData[(x + width * y) * 4 + 0] = image[i + 2];
        }
    }
    return imageData;
}
/**
 * @internal
 */
function GetImageData32bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data;
    const width = header.width, height = header.height;
    let i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i += 4) {
            imageData[(x + width * y) * 4 + 2] = image[i + 0];
            imageData[(x + width * y) * 4 + 1] = image[i + 1];
            imageData[(x + width * y) * 4 + 0] = image[i + 2];
            imageData[(x + width * y) * 4 + 3] = image[i + 3];
        }
    }
    return imageData;
}
/**
 * @internal
 */
function GetImageDataGrey8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data;
    const width = header.width, height = header.height;
    let color, i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i++) {
            color = image[i];
            imageData[(x + width * y) * 4 + 0] = color;
            imageData[(x + width * y) * 4 + 1] = color;
            imageData[(x + width * y) * 4 + 2] = color;
            imageData[(x + width * y) * 4 + 3] = 255;
        }
    }
    return imageData;
}
/**
 * @internal
 */
function GetImageDataGrey16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data;
    const width = header.width, height = header.height;
    let i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for (y = y_start; y !== y_end; y += y_step) {
        for (x = x_start; x !== x_end; x += x_step, i += 2) {
            imageData[(x + width * y) * 4 + 0] = image[i + 0];
            imageData[(x + width * y) * 4 + 1] = image[i + 0];
            imageData[(x + width * y) * 4 + 2] = image[i + 0];
            imageData[(x + width * y) * 4 + 3] = image[i + 1];
        }
    }
    return imageData;
}
/**
 * Based on jsTGALoader - Javascript loader for TGA file
 * By Vincent Thibault
 * @see http://blog.robrowser.com/javascript-tga-loader.html
 */
const TGATools = {
    /**
     * Gets the header of a TGA file
     * @param data defines the TGA data
     * @returns the header
     */
    GetTGAHeader,
    /**
     * Uploads TGA content to a Babylon Texture
     * @internal
     */
    UploadContent,
    /** @internal */
    _getImageData8bits: GetImageData8bits,
    /** @internal */
    _getImageData16bits: GetImageData16bits,
    /** @internal */
    _getImageData24bits: GetImageData24bits,
    /** @internal */
    _getImageData32bits: GetImageData32bits,
    /** @internal */
    _getImageDataGrey8bits: GetImageDataGrey8bits,
    /** @internal */
    _getImageDataGrey16bits: GetImageDataGrey16bits,
};
//# sourceMappingURL=tga.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfTWF0ZXJpYWxzX1RleHR1cmVzX0xvYWRlcnNfdGdhVGV4dHVyZUxvYWRlcl9qcy5icm93c2VyLXBhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBEQUFZO0FBQ25DO0FBQ0EsWUFBWSwyREFBYTtBQUN6QixTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2xDMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsUUFBUSxtREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DLDBCQUEwQixhQUFhO0FBQ3ZDLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQywwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGVyaWFscy9UZXh0dXJlcy9Mb2FkZXJzL3RnYVRleHR1cmVMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01pc2MvdGdhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdldFRHQUhlYWRlciwgVXBsb2FkQ29udGVudCB9IGZyb20gXCIuLi8uLi8uLi9NaXNjL3RnYS5qc1wiO1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgVEdBIFRleHR1cmUgTG9hZGVyLlxuICogQGludGVybmFsXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjbGFzcyBfVEdBVGV4dHVyZUxvYWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGhlIGxvYWRlciBzdXBwb3J0cyBjYXNjYWRlIGxvYWRpbmcgdGhlIGRpZmZlcmVudCBmYWNlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcG9ydENhc2NhZGVzID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIGN1YmUgdGV4dHVyZSBkYXRhIHRvIHRoZSBXZWJHTCB0ZXh0dXJlLiBJdCBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kLlxuICAgICAqL1xuICAgIGxvYWRDdWJlRGF0YSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgdGhyb3cgXCIuZW52IG5vdCBzdXBwb3J0ZWQgaW4gQ3ViZS5cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgMkQgdGV4dHVyZSBkYXRhIHRvIHRoZSBXZWJHTCB0ZXh0dXJlLiBJdCBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kIG9uY2UgaW4gdGhlIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSBkYXRhIGNvbnRhaW5zIHRoZSB0ZXh0dXJlIGRhdGFcbiAgICAgKiBAcGFyYW0gdGV4dHVyZSBkZWZpbmVzIHRoZSBCYWJ5bG9uSlMgaW50ZXJuYWwgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBkZWZpbmVzIHRoZSBtZXRob2QgdG8gY2FsbCBvbmNlIHJlYWR5IHRvIHVwbG9hZFxuICAgICAqL1xuICAgIGxvYWREYXRhKGRhdGEsIHRleHR1cmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gR2V0VEdBSGVhZGVyKGJ5dGVzKTtcbiAgICAgICAgY2FsbGJhY2soaGVhZGVyLndpZHRoLCBoZWFkZXIuaGVpZ2h0LCB0ZXh0dXJlLmdlbmVyYXRlTWlwTWFwcywgZmFsc2UsICgpID0+IHtcbiAgICAgICAgICAgIFVwbG9hZENvbnRlbnQodGV4dHVyZSwgYnl0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10Z2FUZXh0dXJlTG9hZGVyLmpzLm1hcCIsImltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9NaXNjL2xvZ2dlci5qc1wiO1xuLy9wcml2YXRlIHN0YXRpYyBfVFlQRV9OT19EQVRBID0gMDtcbmNvbnN0IF9UWVBFX0lOREVYRUQgPSAxO1xuY29uc3QgX1RZUEVfUkdCID0gMjtcbmNvbnN0IF9UWVBFX0dSRVkgPSAzO1xuY29uc3QgX1RZUEVfUkxFX0lOREVYRUQgPSA5O1xuY29uc3QgX1RZUEVfUkxFX1JHQiA9IDEwO1xuY29uc3QgX1RZUEVfUkxFX0dSRVkgPSAxMTtcbmNvbnN0IF9PUklHSU5fTUFTSyA9IDB4MzA7XG5jb25zdCBfT1JJR0lOX1NISUZUID0gMHgwNDtcbmNvbnN0IF9PUklHSU5fQkwgPSAweDAwO1xuY29uc3QgX09SSUdJTl9CUiA9IDB4MDE7XG5jb25zdCBfT1JJR0lOX1VMID0gMHgwMjtcbmNvbnN0IF9PUklHSU5fVVIgPSAweDAzO1xuLyoqXG4gKiBHZXRzIHRoZSBoZWFkZXIgb2YgYSBUR0EgZmlsZVxuICogQHBhcmFtIGRhdGEgZGVmaW5lcyB0aGUgVEdBIGRhdGFcbiAqIEByZXR1cm5zIHRoZSBoZWFkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEdldFRHQUhlYWRlcihkYXRhKSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgICBpZF9sZW5ndGg6IGRhdGFbb2Zmc2V0KytdLFxuICAgICAgICBjb2xvcm1hcF90eXBlOiBkYXRhW29mZnNldCsrXSxcbiAgICAgICAgaW1hZ2VfdHlwZTogZGF0YVtvZmZzZXQrK10sXG4gICAgICAgIGNvbG9ybWFwX2luZGV4OiBkYXRhW29mZnNldCsrXSB8IChkYXRhW29mZnNldCsrXSA8PCA4KSxcbiAgICAgICAgY29sb3JtYXBfbGVuZ3RoOiBkYXRhW29mZnNldCsrXSB8IChkYXRhW29mZnNldCsrXSA8PCA4KSxcbiAgICAgICAgY29sb3JtYXBfc2l6ZTogZGF0YVtvZmZzZXQrK10sXG4gICAgICAgIG9yaWdpbjogW2RhdGFbb2Zmc2V0KytdIHwgKGRhdGFbb2Zmc2V0KytdIDw8IDgpLCBkYXRhW29mZnNldCsrXSB8IChkYXRhW29mZnNldCsrXSA8PCA4KV0sXG4gICAgICAgIHdpZHRoOiBkYXRhW29mZnNldCsrXSB8IChkYXRhW29mZnNldCsrXSA8PCA4KSxcbiAgICAgICAgaGVpZ2h0OiBkYXRhW29mZnNldCsrXSB8IChkYXRhW29mZnNldCsrXSA8PCA4KSxcbiAgICAgICAgcGl4ZWxfc2l6ZTogZGF0YVtvZmZzZXQrK10sXG4gICAgICAgIGZsYWdzOiBkYXRhW29mZnNldCsrXSxcbiAgICB9O1xuICAgIHJldHVybiBoZWFkZXI7XG59XG4vKipcbiAqIFVwbG9hZHMgVEdBIGNvbnRlbnQgdG8gYSBCYWJ5bG9uIFRleHR1cmVcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gVXBsb2FkQ29udGVudCh0ZXh0dXJlLCBkYXRhKSB7XG4gICAgLy8gTm90IGVub3VnaCBkYXRhIHRvIGNvbnRhaW4gaGVhZGVyID9cbiAgICBpZiAoZGF0YS5sZW5ndGggPCAxOSkge1xuICAgICAgICBMb2dnZXIuRXJyb3IoXCJVbmFibGUgdG8gbG9hZCBUR0EgZmlsZSAtIE5vdCBlbm91Z2ggZGF0YSB0byBjb250YWluIGhlYWRlclwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZWFkIEhlYWRlclxuICAgIGxldCBvZmZzZXQgPSAxODtcbiAgICBjb25zdCBoZWFkZXIgPSBHZXRUR0FIZWFkZXIoZGF0YSk7XG4gICAgLy8gQXNzdW1lIGl0J3MgYSB2YWxpZCBUYXJnYSBmaWxlLlxuICAgIGlmIChoZWFkZXIuaWRfbGVuZ3RoICsgb2Zmc2V0ID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgTG9nZ2VyLkVycm9yKFwiVW5hYmxlIHRvIGxvYWQgVEdBIGZpbGUgLSBOb3QgZW5vdWdoIGRhdGFcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU2tpcCBub3QgbmVlZGVkIGRhdGFcbiAgICBvZmZzZXQgKz0gaGVhZGVyLmlkX2xlbmd0aDtcbiAgICBsZXQgdXNlX3JsZSA9IGZhbHNlO1xuICAgIGxldCB1c2VfcGFsID0gZmFsc2U7XG4gICAgbGV0IHVzZV9ncmV5ID0gZmFsc2U7XG4gICAgLy8gR2V0IHNvbWUgaW5mb3JtYXRpb25zLlxuICAgIHN3aXRjaCAoaGVhZGVyLmltYWdlX3R5cGUpIHtcbiAgICAgICAgY2FzZSBfVFlQRV9STEVfSU5ERVhFRDpcbiAgICAgICAgICAgIHVzZV9ybGUgPSB0cnVlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSBfVFlQRV9JTkRFWEVEOlxuICAgICAgICAgICAgdXNlX3BhbCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfVFlQRV9STEVfUkdCOlxuICAgICAgICAgICAgdXNlX3JsZSA9IHRydWU7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIF9UWVBFX1JHQjpcbiAgICAgICAgICAgIC8vIHVzZV9yZ2IgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX1RZUEVfUkxFX0dSRVk6XG4gICAgICAgICAgICB1c2VfcmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgX1RZUEVfR1JFWTpcbiAgICAgICAgICAgIHVzZV9ncmV5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgcGl4ZWxfZGF0YTtcbiAgICAvLyB2YXIgbnVtQWxwaGFCaXRzID0gaGVhZGVyLmZsYWdzICYgMHhmO1xuICAgIGNvbnN0IHBpeGVsX3NpemUgPSBoZWFkZXIucGl4ZWxfc2l6ZSA+PiAzO1xuICAgIGNvbnN0IHBpeGVsX3RvdGFsID0gaGVhZGVyLndpZHRoICogaGVhZGVyLmhlaWdodCAqIHBpeGVsX3NpemU7XG4gICAgLy8gUmVhZCBwYWxldHRlc1xuICAgIGxldCBwYWxldHRlcztcbiAgICBpZiAodXNlX3BhbCkge1xuICAgICAgICBwYWxldHRlcyA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCAob2Zmc2V0ICs9IGhlYWRlci5jb2xvcm1hcF9sZW5ndGggKiAoaGVhZGVyLmNvbG9ybWFwX3NpemUgPj4gMykpKTtcbiAgICB9XG4gICAgLy8gUmVhZCBMUkVcbiAgICBpZiAodXNlX3JsZSkge1xuICAgICAgICBwaXhlbF9kYXRhID0gbmV3IFVpbnQ4QXJyYXkocGl4ZWxfdG90YWwpO1xuICAgICAgICBsZXQgYywgY291bnQsIGk7XG4gICAgICAgIGxldCBsb2NhbE9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IHBpeGVscyA9IG5ldyBVaW50OEFycmF5KHBpeGVsX3NpemUpO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgcGl4ZWxfdG90YWwgJiYgbG9jYWxPZmZzZXQgPCBwaXhlbF90b3RhbCkge1xuICAgICAgICAgICAgYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgY291bnQgPSAoYyAmIDB4N2YpICsgMTtcbiAgICAgICAgICAgIC8vIFJMRSBwaXhlbHNcbiAgICAgICAgICAgIGlmIChjICYgMHg4MCkge1xuICAgICAgICAgICAgICAgIC8vIEJpbmQgcGl4ZWwgdG1wIGFycmF5XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBpeGVsX3NpemU7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbaV0gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29weSBwaXhlbCBhcnJheVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsX2RhdGEuc2V0KHBpeGVscywgbG9jYWxPZmZzZXQgKyBpICogcGl4ZWxfc2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsT2Zmc2V0ICs9IHBpeGVsX3NpemUgKiBjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJhdyBwaXhlbHNcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ICo9IHBpeGVsX3NpemU7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxfZGF0YVtsb2NhbE9mZnNldCArIGldID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsT2Zmc2V0ICs9IGNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJBVyBQaXhlbHNcbiAgICBlbHNlIHtcbiAgICAgICAgcGl4ZWxfZGF0YSA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCAob2Zmc2V0ICs9IHVzZV9wYWwgPyBoZWFkZXIud2lkdGggKiBoZWFkZXIuaGVpZ2h0IDogcGl4ZWxfdG90YWwpKTtcbiAgICB9XG4gICAgLy8gTG9hZCB0byB0ZXh0dXJlXG4gICAgbGV0IHhfc3RhcnQsIHlfc3RhcnQsIHhfc3RlcCwgeV9zdGVwLCB5X2VuZCwgeF9lbmQ7XG4gICAgc3dpdGNoICgoaGVhZGVyLmZsYWdzICYgX09SSUdJTl9NQVNLKSA+PiBfT1JJR0lOX1NISUZUKSB7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhc2UgX09SSUdJTl9VTDpcbiAgICAgICAgICAgIHhfc3RhcnQgPSAwO1xuICAgICAgICAgICAgeF9zdGVwID0gMTtcbiAgICAgICAgICAgIHhfZW5kID0gaGVhZGVyLndpZHRoO1xuICAgICAgICAgICAgeV9zdGFydCA9IDA7XG4gICAgICAgICAgICB5X3N0ZXAgPSAxO1xuICAgICAgICAgICAgeV9lbmQgPSBoZWFkZXIuaGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX09SSUdJTl9CTDpcbiAgICAgICAgICAgIHhfc3RhcnQgPSAwO1xuICAgICAgICAgICAgeF9zdGVwID0gMTtcbiAgICAgICAgICAgIHhfZW5kID0gaGVhZGVyLndpZHRoO1xuICAgICAgICAgICAgeV9zdGFydCA9IGhlYWRlci5oZWlnaHQgLSAxO1xuICAgICAgICAgICAgeV9zdGVwID0gLTE7XG4gICAgICAgICAgICB5X2VuZCA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX09SSUdJTl9VUjpcbiAgICAgICAgICAgIHhfc3RhcnQgPSBoZWFkZXIud2lkdGggLSAxO1xuICAgICAgICAgICAgeF9zdGVwID0gLTE7XG4gICAgICAgICAgICB4X2VuZCA9IC0xO1xuICAgICAgICAgICAgeV9zdGFydCA9IDA7XG4gICAgICAgICAgICB5X3N0ZXAgPSAxO1xuICAgICAgICAgICAgeV9lbmQgPSBoZWFkZXIuaGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX09SSUdJTl9CUjpcbiAgICAgICAgICAgIHhfc3RhcnQgPSBoZWFkZXIud2lkdGggLSAxO1xuICAgICAgICAgICAgeF9zdGVwID0gLTE7XG4gICAgICAgICAgICB4X2VuZCA9IC0xO1xuICAgICAgICAgICAgeV9zdGFydCA9IGhlYWRlci5oZWlnaHQgLSAxO1xuICAgICAgICAgICAgeV9zdGVwID0gLTE7XG4gICAgICAgICAgICB5X2VuZCA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIExvYWQgdGhlIHNwZWNpZnkgbWV0aG9kXG4gICAgY29uc3QgZnVuYyA9IFwiX2dldEltYWdlRGF0YVwiICsgKHVzZV9ncmV5ID8gXCJHcmV5XCIgOiBcIlwiKSArIGhlYWRlci5waXhlbF9zaXplICsgXCJiaXRzXCI7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gVEdBVG9vbHNbZnVuY10oaGVhZGVyLCBwYWxldHRlcywgcGl4ZWxfZGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCk7XG4gICAgY29uc3QgZW5naW5lID0gdGV4dHVyZS5nZXRFbmdpbmUoKTtcbiAgICBlbmdpbmUuX3VwbG9hZERhdGFUb1RleHR1cmVEaXJlY3RseSh0ZXh0dXJlLCBpbWFnZURhdGEpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gR2V0SW1hZ2VEYXRhOGJpdHMoaGVhZGVyLCBwYWxldHRlcywgcGl4ZWxfZGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCkge1xuICAgIGNvbnN0IGltYWdlID0gcGl4ZWxfZGF0YSwgY29sb3JtYXAgPSBwYWxldHRlcztcbiAgICBjb25zdCB3aWR0aCA9IGhlYWRlci53aWR0aCwgaGVpZ2h0ID0gaGVhZGVyLmhlaWdodDtcbiAgICBsZXQgY29sb3IsIGkgPSAwLCB4LCB5O1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgZm9yICh5ID0geV9zdGFydDsgeSAhPT0geV9lbmQ7IHkgKz0geV9zdGVwKSB7XG4gICAgICAgIGZvciAoeCA9IHhfc3RhcnQ7IHggIT09IHhfZW5kOyB4ICs9IHhfc3RlcCwgaSsrKSB7XG4gICAgICAgICAgICBjb2xvciA9IGltYWdlW2ldO1xuICAgICAgICAgICAgaW1hZ2VEYXRhWyh4ICsgd2lkdGggKiB5KSAqIDQgKyAzXSA9IDI1NTtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgMl0gPSBjb2xvcm1hcFtjb2xvciAqIDMgKyAwXTtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgMV0gPSBjb2xvcm1hcFtjb2xvciAqIDMgKyAxXTtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgMF0gPSBjb2xvcm1hcFtjb2xvciAqIDMgKyAyXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VEYXRhO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gR2V0SW1hZ2VEYXRhMTZiaXRzKGhlYWRlciwgcGFsZXR0ZXMsIHBpeGVsX2RhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQpIHtcbiAgICBjb25zdCBpbWFnZSA9IHBpeGVsX2RhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBoZWFkZXIud2lkdGgsIGhlaWdodCA9IGhlYWRlci5oZWlnaHQ7XG4gICAgbGV0IGNvbG9yLCBpID0gMCwgeCwgeTtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGZvciAoeSA9IHlfc3RhcnQ7IHkgIT09IHlfZW5kOyB5ICs9IHlfc3RlcCkge1xuICAgICAgICBmb3IgKHggPSB4X3N0YXJ0OyB4ICE9PSB4X2VuZDsgeCArPSB4X3N0ZXAsIGkgKz0gMikge1xuICAgICAgICAgICAgY29sb3IgPSBpbWFnZVtpICsgMF0gKyAoaW1hZ2VbaSArIDFdIDw8IDgpOyAvLyBJbnZlcnNlZCA/XG4gICAgICAgICAgICBjb25zdCByID0gKCgoKGNvbG9yICYgMHg3YzAwKSA+PiAxMCkgKiAyNTUpIC8gMHgxZikgfCAwO1xuICAgICAgICAgICAgY29uc3QgZyA9ICgoKChjb2xvciAmIDB4MDNlMCkgPj4gNSkgKiAyNTUpIC8gMHgxZikgfCAwO1xuICAgICAgICAgICAgY29uc3QgYiA9ICgoKGNvbG9yICYgMHgwMDFmKSAqIDI1NSkgLyAweDFmKSB8IDA7XG4gICAgICAgICAgICBpbWFnZURhdGFbKHggKyB3aWR0aCAqIHkpICogNCArIDBdID0gcjtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgMV0gPSBnO1xuICAgICAgICAgICAgaW1hZ2VEYXRhWyh4ICsgd2lkdGggKiB5KSAqIDQgKyAyXSA9IGI7XG4gICAgICAgICAgICBpbWFnZURhdGFbKHggKyB3aWR0aCAqIHkpICogNCArIDNdID0gY29sb3IgJiAweDgwMDAgPyAwIDogMjU1O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbWFnZURhdGE7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBHZXRJbWFnZURhdGEyNGJpdHMoaGVhZGVyLCBwYWxldHRlcywgcGl4ZWxfZGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCkge1xuICAgIGNvbnN0IGltYWdlID0gcGl4ZWxfZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGhlYWRlci53aWR0aCwgaGVpZ2h0ID0gaGVhZGVyLmhlaWdodDtcbiAgICBsZXQgaSA9IDAsIHgsIHk7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICBmb3IgKHkgPSB5X3N0YXJ0OyB5ICE9PSB5X2VuZDsgeSArPSB5X3N0ZXApIHtcbiAgICAgICAgZm9yICh4ID0geF9zdGFydDsgeCAhPT0geF9lbmQ7IHggKz0geF9zdGVwLCBpICs9IDMpIHtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgM10gPSAyNTU7XG4gICAgICAgICAgICBpbWFnZURhdGFbKHggKyB3aWR0aCAqIHkpICogNCArIDJdID0gaW1hZ2VbaSArIDBdO1xuICAgICAgICAgICAgaW1hZ2VEYXRhWyh4ICsgd2lkdGggKiB5KSAqIDQgKyAxXSA9IGltYWdlW2kgKyAxXTtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgMF0gPSBpbWFnZVtpICsgMl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltYWdlRGF0YTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIEdldEltYWdlRGF0YTMyYml0cyhoZWFkZXIsIHBhbGV0dGVzLCBwaXhlbF9kYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kKSB7XG4gICAgY29uc3QgaW1hZ2UgPSBwaXhlbF9kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaGVhZGVyLndpZHRoLCBoZWlnaHQgPSBoZWFkZXIuaGVpZ2h0O1xuICAgIGxldCBpID0gMCwgeCwgeTtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGZvciAoeSA9IHlfc3RhcnQ7IHkgIT09IHlfZW5kOyB5ICs9IHlfc3RlcCkge1xuICAgICAgICBmb3IgKHggPSB4X3N0YXJ0OyB4ICE9PSB4X2VuZDsgeCArPSB4X3N0ZXAsIGkgKz0gNCkge1xuICAgICAgICAgICAgaW1hZ2VEYXRhWyh4ICsgd2lkdGggKiB5KSAqIDQgKyAyXSA9IGltYWdlW2kgKyAwXTtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgMV0gPSBpbWFnZVtpICsgMV07XG4gICAgICAgICAgICBpbWFnZURhdGFbKHggKyB3aWR0aCAqIHkpICogNCArIDBdID0gaW1hZ2VbaSArIDJdO1xuICAgICAgICAgICAgaW1hZ2VEYXRhWyh4ICsgd2lkdGggKiB5KSAqIDQgKyAzXSA9IGltYWdlW2kgKyAzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VEYXRhO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gR2V0SW1hZ2VEYXRhR3JleThiaXRzKGhlYWRlciwgcGFsZXR0ZXMsIHBpeGVsX2RhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQpIHtcbiAgICBjb25zdCBpbWFnZSA9IHBpeGVsX2RhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBoZWFkZXIud2lkdGgsIGhlaWdodCA9IGhlYWRlci5oZWlnaHQ7XG4gICAgbGV0IGNvbG9yLCBpID0gMCwgeCwgeTtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGZvciAoeSA9IHlfc3RhcnQ7IHkgIT09IHlfZW5kOyB5ICs9IHlfc3RlcCkge1xuICAgICAgICBmb3IgKHggPSB4X3N0YXJ0OyB4ICE9PSB4X2VuZDsgeCArPSB4X3N0ZXAsIGkrKykge1xuICAgICAgICAgICAgY29sb3IgPSBpbWFnZVtpXTtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgMF0gPSBjb2xvcjtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgMV0gPSBjb2xvcjtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgMl0gPSBjb2xvcjtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltYWdlRGF0YTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIEdldEltYWdlRGF0YUdyZXkxNmJpdHMoaGVhZGVyLCBwYWxldHRlcywgcGl4ZWxfZGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCkge1xuICAgIGNvbnN0IGltYWdlID0gcGl4ZWxfZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGhlYWRlci53aWR0aCwgaGVpZ2h0ID0gaGVhZGVyLmhlaWdodDtcbiAgICBsZXQgaSA9IDAsIHgsIHk7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICBmb3IgKHkgPSB5X3N0YXJ0OyB5ICE9PSB5X2VuZDsgeSArPSB5X3N0ZXApIHtcbiAgICAgICAgZm9yICh4ID0geF9zdGFydDsgeCAhPT0geF9lbmQ7IHggKz0geF9zdGVwLCBpICs9IDIpIHtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgMF0gPSBpbWFnZVtpICsgMF07XG4gICAgICAgICAgICBpbWFnZURhdGFbKHggKyB3aWR0aCAqIHkpICogNCArIDFdID0gaW1hZ2VbaSArIDBdO1xuICAgICAgICAgICAgaW1hZ2VEYXRhWyh4ICsgd2lkdGggKiB5KSAqIDQgKyAyXSA9IGltYWdlW2kgKyAwXTtcbiAgICAgICAgICAgIGltYWdlRGF0YVsoeCArIHdpZHRoICogeSkgKiA0ICsgM10gPSBpbWFnZVtpICsgMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltYWdlRGF0YTtcbn1cbi8qKlxuICogQmFzZWQgb24ganNUR0FMb2FkZXIgLSBKYXZhc2NyaXB0IGxvYWRlciBmb3IgVEdBIGZpbGVcbiAqIEJ5IFZpbmNlbnQgVGhpYmF1bHRcbiAqIEBzZWUgaHR0cDovL2Jsb2cucm9icm93c2VyLmNvbS9qYXZhc2NyaXB0LXRnYS1sb2FkZXIuaHRtbFxuICovXG5leHBvcnQgY29uc3QgVEdBVG9vbHMgPSB7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGVhZGVyIG9mIGEgVEdBIGZpbGVcbiAgICAgKiBAcGFyYW0gZGF0YSBkZWZpbmVzIHRoZSBUR0EgZGF0YVxuICAgICAqIEByZXR1cm5zIHRoZSBoZWFkZXJcbiAgICAgKi9cbiAgICBHZXRUR0FIZWFkZXIsXG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBUR0EgY29udGVudCB0byBhIEJhYnlsb24gVGV4dHVyZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFVwbG9hZENvbnRlbnQsXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRJbWFnZURhdGE4Yml0czogR2V0SW1hZ2VEYXRhOGJpdHMsXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRJbWFnZURhdGExNmJpdHM6IEdldEltYWdlRGF0YTE2Yml0cyxcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldEltYWdlRGF0YTI0Yml0czogR2V0SW1hZ2VEYXRhMjRiaXRzLFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0SW1hZ2VEYXRhMzJiaXRzOiBHZXRJbWFnZURhdGEzMmJpdHMsXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRJbWFnZURhdGFHcmV5OGJpdHM6IEdldEltYWdlRGF0YUdyZXk4Yml0cyxcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldEltYWdlRGF0YUdyZXkxNmJpdHM6IEdldEltYWdlRGF0YUdyZXkxNmJpdHMsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGdhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==