"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["vendors-node_modules_babylonjs_core_Materials_Textures_Loaders_hdrTextureLoader_js"],{

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/hdrTextureLoader.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/hdrTextureLoader.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _HDRTextureLoader: () => (/* binding */ _HDRTextureLoader)
/* harmony export */ });
/* harmony import */ var _Misc_HighDynamicRange_hdr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Misc/HighDynamicRange/hdr.js */ "./node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js");


/**
 * Implementation of the HDR Texture Loader.
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class _HDRTextureLoader {
    constructor() {
        /**
         * Defines whether the loader supports cascade loading the different faces.
         */
        this.supportCascades = false;
    }
    /**
     * Uploads the cube texture data to the WebGL texture. It has already been bound.
     * Cube texture are not supported by .hdr files
     */
    loadCubeData() {
        // eslint-disable-next-line no-throw-literal
        throw ".hdr not supported in Cube.";
    }
    /**
     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param callback defines the method to call once ready to upload
     */
    loadData(data, texture, callback) {
        const uint8array = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        const hdrInfo = (0,_Misc_HighDynamicRange_hdr_js__WEBPACK_IMPORTED_MODULE_0__.RGBE_ReadHeader)(uint8array);
        const pixelsDataRGB32 = (0,_Misc_HighDynamicRange_hdr_js__WEBPACK_IMPORTED_MODULE_0__.RGBE_ReadPixels)(uint8array, hdrInfo);
        const pixels = hdrInfo.width * hdrInfo.height;
        const pixelsDataRGBA32 = new Float32Array(pixels * 4);
        for (let i = 0; i < pixels; i += 1) {
            pixelsDataRGBA32[i * 4] = pixelsDataRGB32[i * 3];
            pixelsDataRGBA32[i * 4 + 1] = pixelsDataRGB32[i * 3 + 1];
            pixelsDataRGBA32[i * 4 + 2] = pixelsDataRGB32[i * 3 + 2];
            pixelsDataRGBA32[i * 4 + 3] = 1;
        }
        callback(hdrInfo.width, hdrInfo.height, texture.generateMipMaps, false, () => {
            const engine = texture.getEngine();
            texture.type = 1;
            texture.format = 5;
            texture._gammaSpace = false;
            engine._uploadDataToTextureDirectly(texture, pixelsDataRGBA32);
        });
    }
}
//# sourceMappingURL=hdrTextureLoader.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GetCubeMapTextureData: () => (/* binding */ GetCubeMapTextureData),
/* harmony export */   HDRTools: () => (/* binding */ HDRTools),
/* harmony export */   RGBE_ReadHeader: () => (/* binding */ RGBE_ReadHeader),
/* harmony export */   RGBE_ReadPixels: () => (/* binding */ RGBE_ReadPixels)
/* harmony export */ });
/* harmony import */ var _panoramaToCubemap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./panoramaToCubemap.js */ "./node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js");

/* This groups tools to convert HDR texture to native colors array. */
function Ldexp(mantissa, exponent) {
    if (exponent > 1023) {
        return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);
    }
    if (exponent < -1074) {
        return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);
    }
    return mantissa * Math.pow(2, exponent);
}
function Rgbe2float(float32array, red, green, blue, exponent, index) {
    if (exponent > 0) {
        /*nonzero pixel*/
        exponent = Ldexp(1.0, exponent - (128 + 8));
        float32array[index + 0] = red * exponent;
        float32array[index + 1] = green * exponent;
        float32array[index + 2] = blue * exponent;
    }
    else {
        float32array[index + 0] = 0;
        float32array[index + 1] = 0;
        float32array[index + 2] = 0;
    }
}
function ReadStringLine(uint8array, startIndex) {
    let line = "";
    let character = "";
    for (let i = startIndex; i < uint8array.length - startIndex; i++) {
        character = String.fromCharCode(uint8array[i]);
        if (character == "\n") {
            break;
        }
        line += character;
    }
    return line;
}
/**
 * Reads header information from an RGBE texture stored in a native array.
 * More information on this format are available here:
 * https://en.wikipedia.org/wiki/RGBE_image_format
 *
 * @param uint8array The binary file stored in  native array.
 * @returns The header information.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function RGBE_ReadHeader(uint8array) {
    let height = 0;
    let width = 0;
    let line = ReadStringLine(uint8array, 0);
    if (line[0] != "#" || line[1] != "?") {
        // eslint-disable-next-line no-throw-literal
        throw "Bad HDR Format.";
    }
    let endOfHeader = false;
    let findFormat = false;
    let lineIndex = 0;
    do {
        lineIndex += line.length + 1;
        line = ReadStringLine(uint8array, lineIndex);
        if (line == "FORMAT=32-bit_rle_rgbe") {
            findFormat = true;
        }
        else if (line.length == 0) {
            endOfHeader = true;
        }
    } while (!endOfHeader);
    if (!findFormat) {
        // eslint-disable-next-line no-throw-literal
        throw "HDR Bad header format, unsupported FORMAT";
    }
    lineIndex += line.length + 1;
    line = ReadStringLine(uint8array, lineIndex);
    const sizeRegexp = /^-Y (.*) \+X (.*)$/g;
    const match = sizeRegexp.exec(line);
    // TODO. Support +Y and -X if needed.
    if (!match || match.length < 3) {
        // eslint-disable-next-line no-throw-literal
        throw "HDR Bad header format, no size";
    }
    width = parseInt(match[2]);
    height = parseInt(match[1]);
    if (width < 8 || width > 0x7fff) {
        // eslint-disable-next-line no-throw-literal
        throw "HDR Bad header format, unsupported size";
    }
    lineIndex += line.length + 1;
    return {
        height: height,
        width: width,
        dataPosition: lineIndex,
    };
}
/**
 * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.
 * This RGBE texture needs to store the information as a panorama.
 *
 * More information on this format are available here:
 * https://en.wikipedia.org/wiki/RGBE_image_format
 *
 * @param buffer The binary file stored in an array buffer.
 * @param size The expected size of the extracted cubemap.
 * @param supersample enable supersampling the cubemap (default: false)
 * @returns The Cube Map information.
 */
function GetCubeMapTextureData(buffer, size, supersample = false) {
    const uint8array = new Uint8Array(buffer);
    const hdrInfo = RGBE_ReadHeader(uint8array);
    const data = RGBE_ReadPixels(uint8array, hdrInfo);
    const cubeMapData = _panoramaToCubemap_js__WEBPACK_IMPORTED_MODULE_0__.PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size, supersample);
    return cubeMapData;
}
/**
 * Returns the pixels data extracted from an RGBE texture.
 * This pixels will be stored left to right up to down in the R G B order in one array.
 *
 * More information on this format are available here:
 * https://en.wikipedia.org/wiki/RGBE_image_format
 *
 * @param uint8array The binary file stored in an array buffer.
 * @param hdrInfo The header information of the file.
 * @returns The pixels data in RGB right to left up to down order.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function RGBE_ReadPixels(uint8array, hdrInfo) {
    return ReadRGBEPixelsRLE(uint8array, hdrInfo);
}
// eslint-disable-next-line @typescript-eslint/naming-convention
function ReadRGBEPixelsRLE(uint8array, hdrInfo) {
    let numScanlines = hdrInfo.height;
    const scanlineWidth = hdrInfo.width;
    let a, b, c, d, count;
    let dataIndex = hdrInfo.dataPosition;
    let index = 0, endIndex = 0, i = 0;
    const scanLineArrayBuffer = new ArrayBuffer(scanlineWidth * 4); // four channel R G B E
    const scanLineArray = new Uint8Array(scanLineArrayBuffer);
    // 3 channels of 4 bytes per pixel in float.
    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);
    const resultArray = new Float32Array(resultBuffer);
    // read in each successive scanline
    while (numScanlines > 0) {
        a = uint8array[dataIndex++];
        b = uint8array[dataIndex++];
        c = uint8array[dataIndex++];
        d = uint8array[dataIndex++];
        if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {
            return ReadRGBEPixelsNotRLE(uint8array, hdrInfo);
        }
        if (((c << 8) | d) != scanlineWidth) {
            // eslint-disable-next-line no-throw-literal
            throw "HDR Bad header format, wrong scan line width";
        }
        index = 0;
        // read each of the four channels for the scanline into the buffer
        for (i = 0; i < 4; i++) {
            endIndex = (i + 1) * scanlineWidth;
            while (index < endIndex) {
                a = uint8array[dataIndex++];
                b = uint8array[dataIndex++];
                if (a > 128) {
                    // a run of the same value
                    count = a - 128;
                    if (count == 0 || count > endIndex - index) {
                        // eslint-disable-next-line no-throw-literal
                        throw "HDR Bad Format, bad scanline data (run)";
                    }
                    while (count-- > 0) {
                        scanLineArray[index++] = b;
                    }
                }
                else {
                    // a non-run
                    count = a;
                    if (count == 0 || count > endIndex - index) {
                        // eslint-disable-next-line no-throw-literal
                        throw "HDR Bad Format, bad scanline data (non-run)";
                    }
                    scanLineArray[index++] = b;
                    if (--count > 0) {
                        for (let j = 0; j < count; j++) {
                            scanLineArray[index++] = uint8array[dataIndex++];
                        }
                    }
                }
            }
        }
        // now convert data from buffer into floats
        for (i = 0; i < scanlineWidth; i++) {
            a = scanLineArray[i];
            b = scanLineArray[i + scanlineWidth];
            c = scanLineArray[i + 2 * scanlineWidth];
            d = scanLineArray[i + 3 * scanlineWidth];
            Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - numScanlines) * scanlineWidth * 3 + i * 3);
        }
        numScanlines--;
    }
    return resultArray;
}
// eslint-disable-next-line @typescript-eslint/naming-convention
function ReadRGBEPixelsNotRLE(uint8array, hdrInfo) {
    // this file is not run length encoded
    // read values sequentially
    let numScanlines = hdrInfo.height;
    const scanlineWidth = hdrInfo.width;
    let a, b, c, d, i;
    let dataIndex = hdrInfo.dataPosition;
    // 3 channels of 4 bytes per pixel in float.
    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);
    const resultArray = new Float32Array(resultBuffer);
    // read in each successive scanline
    while (numScanlines > 0) {
        for (i = 0; i < hdrInfo.width; i++) {
            a = uint8array[dataIndex++];
            b = uint8array[dataIndex++];
            c = uint8array[dataIndex++];
            d = uint8array[dataIndex++];
            Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - numScanlines) * scanlineWidth * 3 + i * 3);
        }
        numScanlines--;
    }
    return resultArray;
}
/**
 * @deprecated Use functions separately
 */
const HDRTools = {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    RGBE_ReadHeader,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    GetCubeMapTextureData,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    RGBE_ReadPixels,
};
//# sourceMappingURL=hdr.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PanoramaToCubeMapTools: () => (/* binding */ PanoramaToCubeMapTools)
/* harmony export */ });
/* harmony import */ var _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math.vector.js */ "./node_modules/@babylonjs/core/Maths/math.vector.js");


/**
 * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.
 */
class PanoramaToCubeMapTools {
    /**
     * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).
     *
     * @param float32Array The source data.
     * @param inputWidth The width of the input panorama.
     * @param inputHeight The height of the input panorama.
     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)
     * @param supersample enable supersampling the cubemap
     * @returns The cubemap data
     */
    static ConvertPanoramaToCubemap(float32Array, inputWidth, inputHeight, size, supersample = false) {
        if (!float32Array) {
            // eslint-disable-next-line no-throw-literal
            throw "ConvertPanoramaToCubemap: input cannot be null";
        }
        if (float32Array.length != inputWidth * inputHeight * 3) {
            // eslint-disable-next-line no-throw-literal
            throw "ConvertPanoramaToCubemap: input size is wrong";
        }
        const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight, supersample);
        const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight, supersample);
        const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight, supersample);
        const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight, supersample);
        const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight, supersample);
        const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight, supersample);
        return {
            front: textureFront,
            back: textureBack,
            left: textureLeft,
            right: textureRight,
            up: textureUp,
            down: textureDown,
            size: size,
            type: 1,
            format: 4,
            gammaSpace: false,
        };
    }
    static CreateCubemapTexture(texSize, faceData, float32Array, inputWidth, inputHeight, supersample = false) {
        const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);
        const textureArray = new Float32Array(buffer);
        // If supersampling, determine number of samples needed when source texture width is divided for 4 cube faces
        const samples = supersample ? Math.max(1, Math.round(inputWidth / 4 / texSize)) : 1;
        const sampleFactor = 1 / samples;
        const sampleFactorSqr = sampleFactor * sampleFactor;
        const rotDX1 = faceData[1].subtract(faceData[0]).scale(sampleFactor / texSize);
        const rotDX2 = faceData[3].subtract(faceData[2]).scale(sampleFactor / texSize);
        const dy = 1 / texSize;
        let fy = 0;
        for (let y = 0; y < texSize; y++) {
            for (let sy = 0; sy < samples; sy++) {
                let xv1 = faceData[0];
                let xv2 = faceData[2];
                for (let x = 0; x < texSize; x++) {
                    for (let sx = 0; sx < samples; sx++) {
                        const v = xv2.subtract(xv1).scale(fy).add(xv1);
                        v.normalize();
                        const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);
                        // 3 channels per pixels
                        textureArray[y * texSize * 3 + x * 3 + 0] += color.r * sampleFactorSqr;
                        textureArray[y * texSize * 3 + x * 3 + 1] += color.g * sampleFactorSqr;
                        textureArray[y * texSize * 3 + x * 3 + 2] += color.b * sampleFactorSqr;
                        xv1 = xv1.add(rotDX1);
                        xv2 = xv2.add(rotDX2);
                    }
                }
                fy += dy * sampleFactor;
            }
        }
        return textureArray;
    }
    static CalcProjectionSpherical(vDir, float32Array, inputWidth, inputHeight) {
        let theta = Math.atan2(vDir.z, vDir.x);
        const phi = Math.acos(vDir.y);
        while (theta < -Math.PI) {
            theta += 2 * Math.PI;
        }
        while (theta > Math.PI) {
            theta -= 2 * Math.PI;
        }
        let dx = theta / Math.PI;
        const dy = phi / Math.PI;
        // recenter.
        dx = dx * 0.5 + 0.5;
        let px = Math.round(dx * inputWidth);
        if (px < 0) {
            px = 0;
        }
        else if (px >= inputWidth) {
            px = inputWidth - 1;
        }
        let py = Math.round(dy * inputHeight);
        if (py < 0) {
            py = 0;
        }
        else if (py >= inputHeight) {
            py = inputHeight - 1;
        }
        const inputY = inputHeight - py - 1;
        const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];
        const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];
        const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];
        return {
            r: r,
            g: g,
            b: b,
        };
    }
}
PanoramaToCubeMapTools.FACE_LEFT = [new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, -1.0, -1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, -1.0, -1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, 1.0, -1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, 1.0, -1.0)];
PanoramaToCubeMapTools.FACE_RIGHT = [new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, -1.0, 1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, -1.0, 1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, 1.0, 1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, 1.0, 1.0)];
PanoramaToCubeMapTools.FACE_FRONT = [new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, -1.0, -1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, -1.0, 1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, 1.0, -1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, 1.0, 1.0)];
PanoramaToCubeMapTools.FACE_BACK = [new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, -1.0, 1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, -1.0, -1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, 1.0, 1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, 1.0, -1.0)];
PanoramaToCubeMapTools.FACE_DOWN = [new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, 1.0, -1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, 1.0, 1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, 1.0, -1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, 1.0, 1.0)];
PanoramaToCubeMapTools.FACE_UP = [new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, -1.0, -1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1.0, -1.0, 1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, -1.0, -1.0), new _Maths_math_vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0, -1.0, 1.0)];
//# sourceMappingURL=panoramaToCubemap.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfTWF0ZXJpYWxzX1RleHR1cmVzX0xvYWRlcnNfaGRyVGV4dHVyZUxvYWRlcl9qcy5icm93c2VyLXBhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBeUY7O0FBRXpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhFQUFlO0FBQ3ZDLGdDQUFnQyw4RUFBZTtBQUMvQztBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pEZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9DQUFvQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFPLHVCQUF1QiwwREFBTztBQUN4SSIsInNvdXJjZXMiOlsid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvTG9hZGVycy9oZHJUZXh0dXJlTG9hZGVyLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NaXNjL0hpZ2hEeW5hbWljUmFuZ2UvaGRyLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NaXNjL0hpZ2hEeW5hbWljUmFuZ2UvcGFub3JhbWFUb0N1YmVtYXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUkdCRV9SZWFkSGVhZGVyLCBSR0JFX1JlYWRQaXhlbHMgfSBmcm9tIFwiLi4vLi4vLi4vTWlzYy9IaWdoRHluYW1pY1JhbmdlL2hkci5qc1wiO1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBIRFIgVGV4dHVyZSBMb2FkZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNsYXNzIF9IRFJUZXh0dXJlTG9hZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgd2hldGhlciB0aGUgbG9hZGVyIHN1cHBvcnRzIGNhc2NhZGUgbG9hZGluZyB0aGUgZGlmZmVyZW50IGZhY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdXBwb3J0Q2FzY2FkZXMgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgY3ViZSB0ZXh0dXJlIGRhdGEgdG8gdGhlIFdlYkdMIHRleHR1cmUuIEl0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmQuXG4gICAgICogQ3ViZSB0ZXh0dXJlIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IC5oZHIgZmlsZXNcbiAgICAgKi9cbiAgICBsb2FkQ3ViZURhdGEoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gICAgICAgIHRocm93IFwiLmhkciBub3Qgc3VwcG9ydGVkIGluIEN1YmUuXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIDJEIHRleHR1cmUgZGF0YSB0byB0aGUgV2ViR0wgdGV4dHVyZS4gSXQgaGFzIGFscmVhZHkgYmVlbiBib3VuZCBvbmNlIGluIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0gZGF0YSBjb250YWlucyB0aGUgdGV4dHVyZSBkYXRhXG4gICAgICogQHBhcmFtIHRleHR1cmUgZGVmaW5lcyB0aGUgQmFieWxvbkpTIGludGVybmFsIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgZGVmaW5lcyB0aGUgbWV0aG9kIHRvIGNhbGwgb25jZSByZWFkeSB0byB1cGxvYWRcbiAgICAgKi9cbiAgICBsb2FkRGF0YShkYXRhLCB0ZXh0dXJlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB1aW50OGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaGRySW5mbyA9IFJHQkVfUmVhZEhlYWRlcih1aW50OGFycmF5KTtcbiAgICAgICAgY29uc3QgcGl4ZWxzRGF0YVJHQjMyID0gUkdCRV9SZWFkUGl4ZWxzKHVpbnQ4YXJyYXksIGhkckluZm8pO1xuICAgICAgICBjb25zdCBwaXhlbHMgPSBoZHJJbmZvLndpZHRoICogaGRySW5mby5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHBpeGVsc0RhdGFSR0JBMzIgPSBuZXcgRmxvYXQzMkFycmF5KHBpeGVscyAqIDQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpeGVsczsgaSArPSAxKSB7XG4gICAgICAgICAgICBwaXhlbHNEYXRhUkdCQTMyW2kgKiA0XSA9IHBpeGVsc0RhdGFSR0IzMltpICogM107XG4gICAgICAgICAgICBwaXhlbHNEYXRhUkdCQTMyW2kgKiA0ICsgMV0gPSBwaXhlbHNEYXRhUkdCMzJbaSAqIDMgKyAxXTtcbiAgICAgICAgICAgIHBpeGVsc0RhdGFSR0JBMzJbaSAqIDQgKyAyXSA9IHBpeGVsc0RhdGFSR0IzMltpICogMyArIDJdO1xuICAgICAgICAgICAgcGl4ZWxzRGF0YVJHQkEzMltpICogNCArIDNdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhoZHJJbmZvLndpZHRoLCBoZHJJbmZvLmhlaWdodCwgdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMsIGZhbHNlLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbmdpbmUgPSB0ZXh0dXJlLmdldEVuZ2luZSgpO1xuICAgICAgICAgICAgdGV4dHVyZS50eXBlID0gMTtcbiAgICAgICAgICAgIHRleHR1cmUuZm9ybWF0ID0gNTtcbiAgICAgICAgICAgIHRleHR1cmUuX2dhbW1hU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGVuZ2luZS5fdXBsb2FkRGF0YVRvVGV4dHVyZURpcmVjdGx5KHRleHR1cmUsIHBpeGVsc0RhdGFSR0JBMzIpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZHJUZXh0dXJlTG9hZGVyLmpzLm1hcCIsImltcG9ydCB7IFBhbm9yYW1hVG9DdWJlTWFwVG9vbHMgfSBmcm9tIFwiLi9wYW5vcmFtYVRvQ3ViZW1hcC5qc1wiO1xuLyogVGhpcyBncm91cHMgdG9vbHMgdG8gY29udmVydCBIRFIgdGV4dHVyZSB0byBuYXRpdmUgY29sb3JzIGFycmF5LiAqL1xuZnVuY3Rpb24gTGRleHAobWFudGlzc2EsIGV4cG9uZW50KSB7XG4gICAgaWYgKGV4cG9uZW50ID4gMTAyMykge1xuICAgICAgICByZXR1cm4gbWFudGlzc2EgKiBNYXRoLnBvdygyLCAxMDIzKSAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTAyMyk7XG4gICAgfVxuICAgIGlmIChleHBvbmVudCA8IC0xMDc0KSB7XG4gICAgICAgIHJldHVybiBtYW50aXNzYSAqIE1hdGgucG93KDIsIC0xMDc0KSAqIE1hdGgucG93KDIsIGV4cG9uZW50ICsgMTA3NCk7XG4gICAgfVxuICAgIHJldHVybiBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbn1cbmZ1bmN0aW9uIFJnYmUyZmxvYXQoZmxvYXQzMmFycmF5LCByZWQsIGdyZWVuLCBibHVlLCBleHBvbmVudCwgaW5kZXgpIHtcbiAgICBpZiAoZXhwb25lbnQgPiAwKSB7XG4gICAgICAgIC8qbm9uemVybyBwaXhlbCovXG4gICAgICAgIGV4cG9uZW50ID0gTGRleHAoMS4wLCBleHBvbmVudCAtICgxMjggKyA4KSk7XG4gICAgICAgIGZsb2F0MzJhcnJheVtpbmRleCArIDBdID0gcmVkICogZXhwb25lbnQ7XG4gICAgICAgIGZsb2F0MzJhcnJheVtpbmRleCArIDFdID0gZ3JlZW4gKiBleHBvbmVudDtcbiAgICAgICAgZmxvYXQzMmFycmF5W2luZGV4ICsgMl0gPSBibHVlICogZXhwb25lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmbG9hdDMyYXJyYXlbaW5kZXggKyAwXSA9IDA7XG4gICAgICAgIGZsb2F0MzJhcnJheVtpbmRleCArIDFdID0gMDtcbiAgICAgICAgZmxvYXQzMmFycmF5W2luZGV4ICsgMl0gPSAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFJlYWRTdHJpbmdMaW5lKHVpbnQ4YXJyYXksIHN0YXJ0SW5kZXgpIHtcbiAgICBsZXQgbGluZSA9IFwiXCI7XG4gICAgbGV0IGNoYXJhY3RlciA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCB1aW50OGFycmF5Lmxlbmd0aCAtIHN0YXJ0SW5kZXg7IGkrKykge1xuICAgICAgICBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVpbnQ4YXJyYXlbaV0pO1xuICAgICAgICBpZiAoY2hhcmFjdGVyID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgKz0gY2hhcmFjdGVyO1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cbi8qKlxuICogUmVhZHMgaGVhZGVyIGluZm9ybWF0aW9uIGZyb20gYW4gUkdCRSB0ZXh0dXJlIHN0b3JlZCBpbiBhIG5hdGl2ZSBhcnJheS5cbiAqIE1vcmUgaW5mb3JtYXRpb24gb24gdGhpcyBmb3JtYXQgYXJlIGF2YWlsYWJsZSBoZXJlOlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUkdCRV9pbWFnZV9mb3JtYXRcbiAqXG4gKiBAcGFyYW0gdWludDhhcnJheSBUaGUgYmluYXJ5IGZpbGUgc3RvcmVkIGluICBuYXRpdmUgYXJyYXkuXG4gKiBAcmV0dXJucyBUaGUgaGVhZGVyIGluZm9ybWF0aW9uLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgZnVuY3Rpb24gUkdCRV9SZWFkSGVhZGVyKHVpbnQ4YXJyYXkpIHtcbiAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICBsZXQgd2lkdGggPSAwO1xuICAgIGxldCBsaW5lID0gUmVhZFN0cmluZ0xpbmUodWludDhhcnJheSwgMCk7XG4gICAgaWYgKGxpbmVbMF0gIT0gXCIjXCIgfHwgbGluZVsxXSAhPSBcIj9cIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgICB0aHJvdyBcIkJhZCBIRFIgRm9ybWF0LlwiO1xuICAgIH1cbiAgICBsZXQgZW5kT2ZIZWFkZXIgPSBmYWxzZTtcbiAgICBsZXQgZmluZEZvcm1hdCA9IGZhbHNlO1xuICAgIGxldCBsaW5lSW5kZXggPSAwO1xuICAgIGRvIHtcbiAgICAgICAgbGluZUluZGV4ICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgbGluZSA9IFJlYWRTdHJpbmdMaW5lKHVpbnQ4YXJyYXksIGxpbmVJbmRleCk7XG4gICAgICAgIGlmIChsaW5lID09IFwiRk9STUFUPTMyLWJpdF9ybGVfcmdiZVwiKSB7XG4gICAgICAgICAgICBmaW5kRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBlbmRPZkhlYWRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlICghZW5kT2ZIZWFkZXIpO1xuICAgIGlmICghZmluZEZvcm1hdCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgICB0aHJvdyBcIkhEUiBCYWQgaGVhZGVyIGZvcm1hdCwgdW5zdXBwb3J0ZWQgRk9STUFUXCI7XG4gICAgfVxuICAgIGxpbmVJbmRleCArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgbGluZSA9IFJlYWRTdHJpbmdMaW5lKHVpbnQ4YXJyYXksIGxpbmVJbmRleCk7XG4gICAgY29uc3Qgc2l6ZVJlZ2V4cCA9IC9eLVkgKC4qKSBcXCtYICguKikkL2c7XG4gICAgY29uc3QgbWF0Y2ggPSBzaXplUmVnZXhwLmV4ZWMobGluZSk7XG4gICAgLy8gVE9ETy4gU3VwcG9ydCArWSBhbmQgLVggaWYgbmVlZGVkLlxuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2gubGVuZ3RoIDwgMykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgICB0aHJvdyBcIkhEUiBCYWQgaGVhZGVyIGZvcm1hdCwgbm8gc2l6ZVwiO1xuICAgIH1cbiAgICB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICBoZWlnaHQgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgaWYgKHdpZHRoIDwgOCB8fCB3aWR0aCA+IDB4N2ZmZikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgICB0aHJvdyBcIkhEUiBCYWQgaGVhZGVyIGZvcm1hdCwgdW5zdXBwb3J0ZWQgc2l6ZVwiO1xuICAgIH1cbiAgICBsaW5lSW5kZXggKz0gbGluZS5sZW5ndGggKyAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGRhdGFQb3NpdGlvbjogbGluZUluZGV4LFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGN1YmVtYXAgaW5mb3JtYXRpb24gKGVhY2ggZmFjZXMgdGV4dHVyZSBkYXRhKSBleHRyYWN0ZWQgZnJvbSBhbiBSR0JFIHRleHR1cmUuXG4gKiBUaGlzIFJHQkUgdGV4dHVyZSBuZWVkcyB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gYXMgYSBwYW5vcmFtYS5cbiAqXG4gKiBNb3JlIGluZm9ybWF0aW9uIG9uIHRoaXMgZm9ybWF0IGFyZSBhdmFpbGFibGUgaGVyZTpcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JHQkVfaW1hZ2VfZm9ybWF0XG4gKlxuICogQHBhcmFtIGJ1ZmZlciBUaGUgYmluYXJ5IGZpbGUgc3RvcmVkIGluIGFuIGFycmF5IGJ1ZmZlci5cbiAqIEBwYXJhbSBzaXplIFRoZSBleHBlY3RlZCBzaXplIG9mIHRoZSBleHRyYWN0ZWQgY3ViZW1hcC5cbiAqIEBwYXJhbSBzdXBlcnNhbXBsZSBlbmFibGUgc3VwZXJzYW1wbGluZyB0aGUgY3ViZW1hcCAoZGVmYXVsdDogZmFsc2UpXG4gKiBAcmV0dXJucyBUaGUgQ3ViZSBNYXAgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRDdWJlTWFwVGV4dHVyZURhdGEoYnVmZmVyLCBzaXplLCBzdXBlcnNhbXBsZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgdWludDhhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3QgaGRySW5mbyA9IFJHQkVfUmVhZEhlYWRlcih1aW50OGFycmF5KTtcbiAgICBjb25zdCBkYXRhID0gUkdCRV9SZWFkUGl4ZWxzKHVpbnQ4YXJyYXksIGhkckluZm8pO1xuICAgIGNvbnN0IGN1YmVNYXBEYXRhID0gUGFub3JhbWFUb0N1YmVNYXBUb29scy5Db252ZXJ0UGFub3JhbWFUb0N1YmVtYXAoZGF0YSwgaGRySW5mby53aWR0aCwgaGRySW5mby5oZWlnaHQsIHNpemUsIHN1cGVyc2FtcGxlKTtcbiAgICByZXR1cm4gY3ViZU1hcERhdGE7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHBpeGVscyBkYXRhIGV4dHJhY3RlZCBmcm9tIGFuIFJHQkUgdGV4dHVyZS5cbiAqIFRoaXMgcGl4ZWxzIHdpbGwgYmUgc3RvcmVkIGxlZnQgdG8gcmlnaHQgdXAgdG8gZG93biBpbiB0aGUgUiBHIEIgb3JkZXIgaW4gb25lIGFycmF5LlxuICpcbiAqIE1vcmUgaW5mb3JtYXRpb24gb24gdGhpcyBmb3JtYXQgYXJlIGF2YWlsYWJsZSBoZXJlOlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUkdCRV9pbWFnZV9mb3JtYXRcbiAqXG4gKiBAcGFyYW0gdWludDhhcnJheSBUaGUgYmluYXJ5IGZpbGUgc3RvcmVkIGluIGFuIGFycmF5IGJ1ZmZlci5cbiAqIEBwYXJhbSBoZHJJbmZvIFRoZSBoZWFkZXIgaW5mb3JtYXRpb24gb2YgdGhlIGZpbGUuXG4gKiBAcmV0dXJucyBUaGUgcGl4ZWxzIGRhdGEgaW4gUkdCIHJpZ2h0IHRvIGxlZnQgdXAgdG8gZG93biBvcmRlci5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGZ1bmN0aW9uIFJHQkVfUmVhZFBpeGVscyh1aW50OGFycmF5LCBoZHJJbmZvKSB7XG4gICAgcmV0dXJuIFJlYWRSR0JFUGl4ZWxzUkxFKHVpbnQ4YXJyYXksIGhkckluZm8pO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZnVuY3Rpb24gUmVhZFJHQkVQaXhlbHNSTEUodWludDhhcnJheSwgaGRySW5mbykge1xuICAgIGxldCBudW1TY2FubGluZXMgPSBoZHJJbmZvLmhlaWdodDtcbiAgICBjb25zdCBzY2FubGluZVdpZHRoID0gaGRySW5mby53aWR0aDtcbiAgICBsZXQgYSwgYiwgYywgZCwgY291bnQ7XG4gICAgbGV0IGRhdGFJbmRleCA9IGhkckluZm8uZGF0YVBvc2l0aW9uO1xuICAgIGxldCBpbmRleCA9IDAsIGVuZEluZGV4ID0gMCwgaSA9IDA7XG4gICAgY29uc3Qgc2NhbkxpbmVBcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzY2FubGluZVdpZHRoICogNCk7IC8vIGZvdXIgY2hhbm5lbCBSIEcgQiBFXG4gICAgY29uc3Qgc2NhbkxpbmVBcnJheSA9IG5ldyBVaW50OEFycmF5KHNjYW5MaW5lQXJyYXlCdWZmZXIpO1xuICAgIC8vIDMgY2hhbm5lbHMgb2YgNCBieXRlcyBwZXIgcGl4ZWwgaW4gZmxvYXQuXG4gICAgY29uc3QgcmVzdWx0QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGhkckluZm8ud2lkdGggKiBoZHJJbmZvLmhlaWdodCAqIDQgKiAzKTtcbiAgICBjb25zdCByZXN1bHRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkocmVzdWx0QnVmZmVyKTtcbiAgICAvLyByZWFkIGluIGVhY2ggc3VjY2Vzc2l2ZSBzY2FubGluZVxuICAgIHdoaWxlIChudW1TY2FubGluZXMgPiAwKSB7XG4gICAgICAgIGEgPSB1aW50OGFycmF5W2RhdGFJbmRleCsrXTtcbiAgICAgICAgYiA9IHVpbnQ4YXJyYXlbZGF0YUluZGV4KytdO1xuICAgICAgICBjID0gdWludDhhcnJheVtkYXRhSW5kZXgrK107XG4gICAgICAgIGQgPSB1aW50OGFycmF5W2RhdGFJbmRleCsrXTtcbiAgICAgICAgaWYgKGEgIT0gMiB8fCBiICE9IDIgfHwgYyAmIDB4ODAgfHwgaGRySW5mby53aWR0aCA8IDggfHwgaGRySW5mby53aWR0aCA+IDMyNzY3KSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhZFJHQkVQaXhlbHNOb3RSTEUodWludDhhcnJheSwgaGRySW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoYyA8PCA4KSB8IGQpICE9IHNjYW5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gICAgICAgICAgICB0aHJvdyBcIkhEUiBCYWQgaGVhZGVyIGZvcm1hdCwgd3Jvbmcgc2NhbiBsaW5lIHdpZHRoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAvLyByZWFkIGVhY2ggb2YgdGhlIGZvdXIgY2hhbm5lbHMgZm9yIHRoZSBzY2FubGluZSBpbnRvIHRoZSBidWZmZXJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgZW5kSW5kZXggPSAoaSArIDEpICogc2NhbmxpbmVXaWR0aDtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgYSA9IHVpbnQ4YXJyYXlbZGF0YUluZGV4KytdO1xuICAgICAgICAgICAgICAgIGIgPSB1aW50OGFycmF5W2RhdGFJbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoYSA+IDEyOCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhIHJ1biBvZiB0aGUgc2FtZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IGEgLSAxMjg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PSAwIHx8IGNvdW50ID4gZW5kSW5kZXggLSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiSERSIEJhZCBGb3JtYXQsIGJhZCBzY2FubGluZSBkYXRhIChydW4pXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FuTGluZUFycmF5W2luZGV4KytdID0gYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBub24tcnVuXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID09IDAgfHwgY291bnQgPiBlbmRJbmRleCAtIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJIRFIgQmFkIEZvcm1hdCwgYmFkIHNjYW5saW5lIGRhdGEgKG5vbi1ydW4pXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2NhbkxpbmVBcnJheVtpbmRleCsrXSA9IGI7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbkxpbmVBcnJheVtpbmRleCsrXSA9IHVpbnQ4YXJyYXlbZGF0YUluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBjb252ZXJ0IGRhdGEgZnJvbSBidWZmZXIgaW50byBmbG9hdHNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5saW5lV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgYSA9IHNjYW5MaW5lQXJyYXlbaV07XG4gICAgICAgICAgICBiID0gc2NhbkxpbmVBcnJheVtpICsgc2NhbmxpbmVXaWR0aF07XG4gICAgICAgICAgICBjID0gc2NhbkxpbmVBcnJheVtpICsgMiAqIHNjYW5saW5lV2lkdGhdO1xuICAgICAgICAgICAgZCA9IHNjYW5MaW5lQXJyYXlbaSArIDMgKiBzY2FubGluZVdpZHRoXTtcbiAgICAgICAgICAgIFJnYmUyZmxvYXQocmVzdWx0QXJyYXksIGEsIGIsIGMsIGQsIChoZHJJbmZvLmhlaWdodCAtIG51bVNjYW5saW5lcykgKiBzY2FubGluZVdpZHRoICogMyArIGkgKiAzKTtcbiAgICAgICAgfVxuICAgICAgICBudW1TY2FubGluZXMtLTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdEFycmF5O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZnVuY3Rpb24gUmVhZFJHQkVQaXhlbHNOb3RSTEUodWludDhhcnJheSwgaGRySW5mbykge1xuICAgIC8vIHRoaXMgZmlsZSBpcyBub3QgcnVuIGxlbmd0aCBlbmNvZGVkXG4gICAgLy8gcmVhZCB2YWx1ZXMgc2VxdWVudGlhbGx5XG4gICAgbGV0IG51bVNjYW5saW5lcyA9IGhkckluZm8uaGVpZ2h0O1xuICAgIGNvbnN0IHNjYW5saW5lV2lkdGggPSBoZHJJbmZvLndpZHRoO1xuICAgIGxldCBhLCBiLCBjLCBkLCBpO1xuICAgIGxldCBkYXRhSW5kZXggPSBoZHJJbmZvLmRhdGFQb3NpdGlvbjtcbiAgICAvLyAzIGNoYW5uZWxzIG9mIDQgYnl0ZXMgcGVyIHBpeGVsIGluIGZsb2F0LlxuICAgIGNvbnN0IHJlc3VsdEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihoZHJJbmZvLndpZHRoICogaGRySW5mby5oZWlnaHQgKiA0ICogMyk7XG4gICAgY29uc3QgcmVzdWx0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdEJ1ZmZlcik7XG4gICAgLy8gcmVhZCBpbiBlYWNoIHN1Y2Nlc3NpdmUgc2NhbmxpbmVcbiAgICB3aGlsZSAobnVtU2NhbmxpbmVzID4gMCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaGRySW5mby53aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICBhID0gdWludDhhcnJheVtkYXRhSW5kZXgrK107XG4gICAgICAgICAgICBiID0gdWludDhhcnJheVtkYXRhSW5kZXgrK107XG4gICAgICAgICAgICBjID0gdWludDhhcnJheVtkYXRhSW5kZXgrK107XG4gICAgICAgICAgICBkID0gdWludDhhcnJheVtkYXRhSW5kZXgrK107XG4gICAgICAgICAgICBSZ2JlMmZsb2F0KHJlc3VsdEFycmF5LCBhLCBiLCBjLCBkLCAoaGRySW5mby5oZWlnaHQgLSBudW1TY2FubGluZXMpICogc2NhbmxpbmVXaWR0aCAqIDMgKyBpICogMyk7XG4gICAgICAgIH1cbiAgICAgICAgbnVtU2NhbmxpbmVzLS07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRBcnJheTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGZ1bmN0aW9ucyBzZXBhcmF0ZWx5XG4gKi9cbmV4cG9ydCBjb25zdCBIRFJUb29scyA9IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgUkdCRV9SZWFkSGVhZGVyLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBHZXRDdWJlTWFwVGV4dHVyZURhdGEsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIFJHQkVfUmVhZFBpeGVscyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZHIuanMubWFwIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCIuLi8uLi9NYXRocy9tYXRoLnZlY3Rvci5qc1wiO1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB1c2VmdWwgdG8gY29udmVydCBwYW5vcmFtYSBwaWN0dXJlIHRvIHRoZWlyIGN1YmVtYXAgcmVwcmVzZW50YXRpb24gaW4gNiBmYWNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhbm9yYW1hVG9DdWJlTWFwVG9vbHMge1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgcGFub3JhbWEgc3RvcmVkIGluIFJHQiByaWdodCB0byBsZWZ0IHVwIHRvIGRvd24gZm9ybWF0IGludG8gYSBjdWJlbWFwICg2IGZhY2VzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbG9hdDMyQXJyYXkgVGhlIHNvdXJjZSBkYXRhLlxuICAgICAqIEBwYXJhbSBpbnB1dFdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcGFub3JhbWEuXG4gICAgICogQHBhcmFtIGlucHV0SGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHBhbm9yYW1hLlxuICAgICAqIEBwYXJhbSBzaXplIFRoZSB3aWxsaW5nIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBjdWJlbWFwIChlYWNoIGZhY2VzIHdpbGwgYmUgc2l6ZSAqIHNpemUgcGl4ZWxzKVxuICAgICAqIEBwYXJhbSBzdXBlcnNhbXBsZSBlbmFibGUgc3VwZXJzYW1wbGluZyB0aGUgY3ViZW1hcFxuICAgICAqIEByZXR1cm5zIFRoZSBjdWJlbWFwIGRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgQ29udmVydFBhbm9yYW1hVG9DdWJlbWFwKGZsb2F0MzJBcnJheSwgaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHQsIHNpemUsIHN1cGVyc2FtcGxlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFmbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gICAgICAgICAgICB0aHJvdyBcIkNvbnZlcnRQYW5vcmFtYVRvQ3ViZW1hcDogaW5wdXQgY2Fubm90IGJlIG51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxvYXQzMkFycmF5Lmxlbmd0aCAhPSBpbnB1dFdpZHRoICogaW5wdXRIZWlnaHQgKiAzKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgICAgICAgdGhyb3cgXCJDb252ZXJ0UGFub3JhbWFUb0N1YmVtYXA6IGlucHV0IHNpemUgaXMgd3JvbmdcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0dXJlRnJvbnQgPSB0aGlzLkNyZWF0ZUN1YmVtYXBUZXh0dXJlKHNpemUsIHRoaXMuRkFDRV9GUk9OVCwgZmxvYXQzMkFycmF5LCBpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCwgc3VwZXJzYW1wbGUpO1xuICAgICAgICBjb25zdCB0ZXh0dXJlQmFjayA9IHRoaXMuQ3JlYXRlQ3ViZW1hcFRleHR1cmUoc2l6ZSwgdGhpcy5GQUNFX0JBQ0ssIGZsb2F0MzJBcnJheSwgaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHQsIHN1cGVyc2FtcGxlKTtcbiAgICAgICAgY29uc3QgdGV4dHVyZUxlZnQgPSB0aGlzLkNyZWF0ZUN1YmVtYXBUZXh0dXJlKHNpemUsIHRoaXMuRkFDRV9MRUZULCBmbG9hdDMyQXJyYXksIGlucHV0V2lkdGgsIGlucHV0SGVpZ2h0LCBzdXBlcnNhbXBsZSk7XG4gICAgICAgIGNvbnN0IHRleHR1cmVSaWdodCA9IHRoaXMuQ3JlYXRlQ3ViZW1hcFRleHR1cmUoc2l6ZSwgdGhpcy5GQUNFX1JJR0hULCBmbG9hdDMyQXJyYXksIGlucHV0V2lkdGgsIGlucHV0SGVpZ2h0LCBzdXBlcnNhbXBsZSk7XG4gICAgICAgIGNvbnN0IHRleHR1cmVVcCA9IHRoaXMuQ3JlYXRlQ3ViZW1hcFRleHR1cmUoc2l6ZSwgdGhpcy5GQUNFX1VQLCBmbG9hdDMyQXJyYXksIGlucHV0V2lkdGgsIGlucHV0SGVpZ2h0LCBzdXBlcnNhbXBsZSk7XG4gICAgICAgIGNvbnN0IHRleHR1cmVEb3duID0gdGhpcy5DcmVhdGVDdWJlbWFwVGV4dHVyZShzaXplLCB0aGlzLkZBQ0VfRE9XTiwgZmxvYXQzMkFycmF5LCBpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCwgc3VwZXJzYW1wbGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbnQ6IHRleHR1cmVGcm9udCxcbiAgICAgICAgICAgIGJhY2s6IHRleHR1cmVCYWNrLFxuICAgICAgICAgICAgbGVmdDogdGV4dHVyZUxlZnQsXG4gICAgICAgICAgICByaWdodDogdGV4dHVyZVJpZ2h0LFxuICAgICAgICAgICAgdXA6IHRleHR1cmVVcCxcbiAgICAgICAgICAgIGRvd246IHRleHR1cmVEb3duLFxuICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIHR5cGU6IDEsXG4gICAgICAgICAgICBmb3JtYXQ6IDQsXG4gICAgICAgICAgICBnYW1tYVNwYWNlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIENyZWF0ZUN1YmVtYXBUZXh0dXJlKHRleFNpemUsIGZhY2VEYXRhLCBmbG9hdDMyQXJyYXksIGlucHV0V2lkdGgsIGlucHV0SGVpZ2h0LCBzdXBlcnNhbXBsZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0ZXhTaXplICogdGV4U2l6ZSAqIDQgKiAzKTtcbiAgICAgICAgY29uc3QgdGV4dHVyZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICAvLyBJZiBzdXBlcnNhbXBsaW5nLCBkZXRlcm1pbmUgbnVtYmVyIG9mIHNhbXBsZXMgbmVlZGVkIHdoZW4gc291cmNlIHRleHR1cmUgd2lkdGggaXMgZGl2aWRlZCBmb3IgNCBjdWJlIGZhY2VzXG4gICAgICAgIGNvbnN0IHNhbXBsZXMgPSBzdXBlcnNhbXBsZSA/IE1hdGgubWF4KDEsIE1hdGgucm91bmQoaW5wdXRXaWR0aCAvIDQgLyB0ZXhTaXplKSkgOiAxO1xuICAgICAgICBjb25zdCBzYW1wbGVGYWN0b3IgPSAxIC8gc2FtcGxlcztcbiAgICAgICAgY29uc3Qgc2FtcGxlRmFjdG9yU3FyID0gc2FtcGxlRmFjdG9yICogc2FtcGxlRmFjdG9yO1xuICAgICAgICBjb25zdCByb3REWDEgPSBmYWNlRGF0YVsxXS5zdWJ0cmFjdChmYWNlRGF0YVswXSkuc2NhbGUoc2FtcGxlRmFjdG9yIC8gdGV4U2l6ZSk7XG4gICAgICAgIGNvbnN0IHJvdERYMiA9IGZhY2VEYXRhWzNdLnN1YnRyYWN0KGZhY2VEYXRhWzJdKS5zY2FsZShzYW1wbGVGYWN0b3IgLyB0ZXhTaXplKTtcbiAgICAgICAgY29uc3QgZHkgPSAxIC8gdGV4U2l6ZTtcbiAgICAgICAgbGV0IGZ5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0ZXhTaXplOyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHN5ID0gMDsgc3kgPCBzYW1wbGVzOyBzeSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHh2MSA9IGZhY2VEYXRhWzBdO1xuICAgICAgICAgICAgICAgIGxldCB4djIgPSBmYWNlRGF0YVsyXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRleFNpemU7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzeCA9IDA7IHN4IDwgc2FtcGxlczsgc3grKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHh2Mi5zdWJ0cmFjdCh4djEpLnNjYWxlKGZ5KS5hZGQoeHYxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuQ2FsY1Byb2plY3Rpb25TcGhlcmljYWwodiwgZmxvYXQzMkFycmF5LCBpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAzIGNoYW5uZWxzIHBlciBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVBcnJheVt5ICogdGV4U2l6ZSAqIDMgKyB4ICogMyArIDBdICs9IGNvbG9yLnIgKiBzYW1wbGVGYWN0b3JTcXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlQXJyYXlbeSAqIHRleFNpemUgKiAzICsgeCAqIDMgKyAxXSArPSBjb2xvci5nICogc2FtcGxlRmFjdG9yU3FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZUFycmF5W3kgKiB0ZXhTaXplICogMyArIHggKiAzICsgMl0gKz0gY29sb3IuYiAqIHNhbXBsZUZhY3RvclNxcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHh2MSA9IHh2MS5hZGQocm90RFgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHh2MiA9IHh2Mi5hZGQocm90RFgyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmeSArPSBkeSAqIHNhbXBsZUZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dHVyZUFycmF5O1xuICAgIH1cbiAgICBzdGF0aWMgQ2FsY1Byb2plY3Rpb25TcGhlcmljYWwodkRpciwgZmxvYXQzMkFycmF5LCBpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCkge1xuICAgICAgICBsZXQgdGhldGEgPSBNYXRoLmF0YW4yKHZEaXIueiwgdkRpci54KTtcbiAgICAgICAgY29uc3QgcGhpID0gTWF0aC5hY29zKHZEaXIueSk7XG4gICAgICAgIHdoaWxlICh0aGV0YSA8IC1NYXRoLlBJKSB7XG4gICAgICAgICAgICB0aGV0YSArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhldGEgPiBNYXRoLlBJKSB7XG4gICAgICAgICAgICB0aGV0YSAtPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZHggPSB0aGV0YSAvIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IGR5ID0gcGhpIC8gTWF0aC5QSTtcbiAgICAgICAgLy8gcmVjZW50ZXIuXG4gICAgICAgIGR4ID0gZHggKiAwLjUgKyAwLjU7XG4gICAgICAgIGxldCBweCA9IE1hdGgucm91bmQoZHggKiBpbnB1dFdpZHRoKTtcbiAgICAgICAgaWYgKHB4IDwgMCkge1xuICAgICAgICAgICAgcHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB4ID49IGlucHV0V2lkdGgpIHtcbiAgICAgICAgICAgIHB4ID0gaW5wdXRXaWR0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB5ID0gTWF0aC5yb3VuZChkeSAqIGlucHV0SGVpZ2h0KTtcbiAgICAgICAgaWYgKHB5IDwgMCkge1xuICAgICAgICAgICAgcHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB5ID49IGlucHV0SGVpZ2h0KSB7XG4gICAgICAgICAgICBweSA9IGlucHV0SGVpZ2h0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFkgPSBpbnB1dEhlaWdodCAtIHB5IC0gMTtcbiAgICAgICAgY29uc3QgciA9IGZsb2F0MzJBcnJheVtpbnB1dFkgKiBpbnB1dFdpZHRoICogMyArIHB4ICogMyArIDBdO1xuICAgICAgICBjb25zdCBnID0gZmxvYXQzMkFycmF5W2lucHV0WSAqIGlucHV0V2lkdGggKiAzICsgcHggKiAzICsgMV07XG4gICAgICAgIGNvbnN0IGIgPSBmbG9hdDMyQXJyYXlbaW5wdXRZICogaW5wdXRXaWR0aCAqIDMgKyBweCAqIDMgKyAyXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHIsXG4gICAgICAgICAgICBnOiBnLFxuICAgICAgICAgICAgYjogYixcbiAgICAgICAgfTtcbiAgICB9XG59XG5QYW5vcmFtYVRvQ3ViZU1hcFRvb2xzLkZBQ0VfTEVGVCA9IFtuZXcgVmVjdG9yMygtMS4wLCAtMS4wLCAtMS4wKSwgbmV3IFZlY3RvcjMoMS4wLCAtMS4wLCAtMS4wKSwgbmV3IFZlY3RvcjMoLTEuMCwgMS4wLCAtMS4wKSwgbmV3IFZlY3RvcjMoMS4wLCAxLjAsIC0xLjApXTtcblBhbm9yYW1hVG9DdWJlTWFwVG9vbHMuRkFDRV9SSUdIVCA9IFtuZXcgVmVjdG9yMygxLjAsIC0xLjAsIDEuMCksIG5ldyBWZWN0b3IzKC0xLjAsIC0xLjAsIDEuMCksIG5ldyBWZWN0b3IzKDEuMCwgMS4wLCAxLjApLCBuZXcgVmVjdG9yMygtMS4wLCAxLjAsIDEuMCldO1xuUGFub3JhbWFUb0N1YmVNYXBUb29scy5GQUNFX0ZST05UID0gW25ldyBWZWN0b3IzKDEuMCwgLTEuMCwgLTEuMCksIG5ldyBWZWN0b3IzKDEuMCwgLTEuMCwgMS4wKSwgbmV3IFZlY3RvcjMoMS4wLCAxLjAsIC0xLjApLCBuZXcgVmVjdG9yMygxLjAsIDEuMCwgMS4wKV07XG5QYW5vcmFtYVRvQ3ViZU1hcFRvb2xzLkZBQ0VfQkFDSyA9IFtuZXcgVmVjdG9yMygtMS4wLCAtMS4wLCAxLjApLCBuZXcgVmVjdG9yMygtMS4wLCAtMS4wLCAtMS4wKSwgbmV3IFZlY3RvcjMoLTEuMCwgMS4wLCAxLjApLCBuZXcgVmVjdG9yMygtMS4wLCAxLjAsIC0xLjApXTtcblBhbm9yYW1hVG9DdWJlTWFwVG9vbHMuRkFDRV9ET1dOID0gW25ldyBWZWN0b3IzKDEuMCwgMS4wLCAtMS4wKSwgbmV3IFZlY3RvcjMoMS4wLCAxLjAsIDEuMCksIG5ldyBWZWN0b3IzKC0xLjAsIDEuMCwgLTEuMCksIG5ldyBWZWN0b3IzKC0xLjAsIDEuMCwgMS4wKV07XG5QYW5vcmFtYVRvQ3ViZU1hcFRvb2xzLkZBQ0VfVVAgPSBbbmV3IFZlY3RvcjMoLTEuMCwgLTEuMCwgLTEuMCksIG5ldyBWZWN0b3IzKC0xLjAsIC0xLjAsIDEuMCksIG5ldyBWZWN0b3IzKDEuMCwgLTEuMCwgLTEuMCksIG5ldyBWZWN0b3IzKDEuMCwgLTEuMCwgMS4wKV07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYW5vcmFtYVRvQ3ViZW1hcC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=