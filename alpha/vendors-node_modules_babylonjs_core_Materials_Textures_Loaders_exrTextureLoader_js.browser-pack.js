"use strict";
(self["webpackChunkab2ac"] = self["webpackChunkab2ac"] || []).push([["vendors-node_modules_babylonjs_core_Materials_Textures_Loaders_exrTextureLoader_js"],{

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.compression.huf.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.compression.huf.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApplyLut: () => (/* binding */ ApplyLut),
/* harmony export */   HufUncompress: () => (/* binding */ HufUncompress),
/* harmony export */   ReverseLutFromBitmap: () => (/* binding */ ReverseLutFromBitmap),
/* harmony export */   Wav2Decode: () => (/* binding */ Wav2Decode)
/* harmony export */ });
/* harmony import */ var _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exrLoader.core.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.core.js");
/* harmony import */ var _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exrLoader.interfaces.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.interfaces.js");


/**
 * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js
 * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation.
 */
// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */
// // TinyEXR contains some OpenEXR code, which is licensed under ------------
// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light & Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////
// // End of OpenEXR license -------------------------------------------------
const NBITS = 16;
const A_OFFSET = 1 << (NBITS - 1);
const MOD_MASK = (1 << NBITS) - 1;
/** @internal */
function ReverseLutFromBitmap(bitmap, lut) {
    let k = 0;
    for (let i = 0; i < _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.USHORT_RANGE; ++i) {
        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {
            lut[k++] = i;
        }
    }
    const n = k - 1;
    while (k < _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.USHORT_RANGE) {
        lut[k++] = 0;
    }
    return n;
}
function HufClearDecTable(hdec) {
    for (let i = 0; i < _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_DECSIZE; i++) {
        hdec[i] = {};
        hdec[i].len = 0;
        hdec[i].lit = 0;
        hdec[i].p = null;
    }
}
function GetBits(nBits, c, lc, array, offset) {
    while (lc < nBits) {
        c = (c << 8) | (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.ParseUint8Array)(array, offset);
        lc += 8;
    }
    lc -= nBits;
    return {
        l: (c >> lc) & ((1 << nBits) - 1),
        c,
        lc,
    };
}
function GetChar(c, lc, array, offset) {
    c = (c << 8) | (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.ParseUint8Array)(array, offset);
    lc += 8;
    return {
        c,
        lc,
    };
}
function GetCode(po, rlc, c, lc, array, offset, outBuffer, outBufferOffset, outBufferEndOffset) {
    if (po == rlc) {
        if (lc < 8) {
            const gc = GetChar(c, lc, array, offset);
            c = gc.c;
            lc = gc.lc;
        }
        lc -= 8;
        let cs = c >> lc;
        cs = new Uint8Array([cs])[0];
        if (outBufferOffset.value + cs > outBufferEndOffset) {
            return null;
        }
        const s = outBuffer[outBufferOffset.value - 1];
        while (cs-- > 0) {
            outBuffer[outBufferOffset.value++] = s;
        }
    }
    else if (outBufferOffset.value < outBufferEndOffset) {
        outBuffer[outBufferOffset.value++] = po;
    }
    else {
        return null;
    }
    return { c, lc };
}
const HufTableBuffer = new Array(59);
function HufCanonicalCodeTable(hcode) {
    for (let i = 0; i <= 58; ++i) {
        HufTableBuffer[i] = 0;
    }
    for (let i = 0; i < _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_ENCSIZE; ++i) {
        HufTableBuffer[hcode[i]] += 1;
    }
    let c = 0;
    for (let i = 58; i > 0; --i) {
        const nc = (c + HufTableBuffer[i]) >> 1;
        HufTableBuffer[i] = c;
        c = nc;
    }
    for (let i = 0; i < _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_ENCSIZE; ++i) {
        const l = hcode[i];
        if (l > 0) {
            hcode[i] = l | (HufTableBuffer[l]++ << 6);
        }
    }
}
function HufUnpackEncTable(array, offset, ni, im, iM, hcode) {
    const p = offset;
    let c = 0;
    let lc = 0;
    for (; im <= iM; im++) {
        if (p.value - offset.value > ni) {
            return;
        }
        let gb = GetBits(6, c, lc, array, p);
        const l = gb.l;
        c = gb.c;
        lc = gb.lc;
        hcode[im] = l;
        if (l == _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.LONG_ZEROCODE_RUN) {
            if (p.value - offset.value > ni) {
                throw new Error("Error in HufUnpackEncTable");
            }
            gb = GetBits(8, c, lc, array, p);
            let zerun = gb.l + _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.SHORTEST_LONG_RUN;
            c = gb.c;
            lc = gb.lc;
            if (im + zerun > iM + 1) {
                throw new Error("Error in HufUnpackEncTable");
            }
            while (zerun--) {
                hcode[im++] = 0;
            }
            im--;
        }
        else if (l >= _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.SHORT_ZEROCODE_RUN) {
            let zerun = l - _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.SHORT_ZEROCODE_RUN + 2;
            if (im + zerun > iM + 1) {
                throw new Error("Error in HufUnpackEncTable");
            }
            while (zerun--) {
                hcode[im++] = 0;
            }
            im--;
        }
    }
    HufCanonicalCodeTable(hcode);
}
function HufLength(code) {
    return code & 63;
}
function HufCode(code) {
    return code >> 6;
}
function HufBuildDecTable(hcode, im, iM, hdecod) {
    for (; im <= iM; im++) {
        const c = HufCode(hcode[im]);
        const l = HufLength(hcode[im]);
        if (c >> l) {
            throw new Error("Invalid table entry");
        }
        if (l > _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_DECBITS) {
            const pl = hdecod[c >> (l - _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_DECBITS)];
            if (pl.len) {
                throw new Error("Invalid table entry");
            }
            pl.lit++;
            if (pl.p) {
                const p = pl.p;
                pl.p = new Array(pl.lit);
                for (let i = 0; i < pl.lit - 1; ++i) {
                    pl.p[i] = p[i];
                }
            }
            else {
                pl.p = new Array(1);
            }
            pl.p[pl.lit - 1] = im;
        }
        else if (l) {
            let plOffset = 0;
            for (let i = 1 << (_exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_DECBITS - l); i > 0; i--) {
                const pl = hdecod[(c << (_exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_DECBITS - l)) + plOffset];
                if (pl.len || pl.p) {
                    throw new Error("Invalid table entry");
                }
                pl.len = l;
                pl.lit = im;
                plOffset++;
            }
        }
    }
    return true;
}
function HufDecode(encodingTable, decodingTable, array, offset, ni, rlc, no, outBuffer, outOffset) {
    let c = 0;
    let lc = 0;
    const outBufferEndOffset = no;
    const inOffsetEnd = Math.trunc(offset.value + (ni + 7) / 8);
    while (offset.value < inOffsetEnd) {
        let gc = GetChar(c, lc, array, offset);
        c = gc.c;
        lc = gc.lc;
        while (lc >= _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_DECBITS) {
            const index = (c >> (lc - _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_DECBITS)) & _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_DECMASK;
            const pl = decodingTable[index];
            if (pl.len) {
                lc -= pl.len;
                const gCode = GetCode(pl.lit, rlc, c, lc, array, offset, outBuffer, outOffset, outBufferEndOffset);
                if (gCode) {
                    c = gCode.c;
                    lc = gCode.lc;
                }
            }
            else {
                if (!pl.p) {
                    throw new Error("hufDecode issues");
                }
                let j;
                for (j = 0; j < pl.lit; j++) {
                    const l = HufLength(encodingTable[pl.p[j]]);
                    while (lc < l && offset.value < inOffsetEnd) {
                        gc = GetChar(c, lc, array, offset);
                        c = gc.c;
                        lc = gc.lc;
                    }
                    if (lc >= l) {
                        if (HufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {
                            lc -= l;
                            const gCode = GetCode(pl.p[j], rlc, c, lc, array, offset, outBuffer, outOffset, outBufferEndOffset);
                            if (gCode) {
                                c = gCode.c;
                                lc = gCode.lc;
                            }
                            break;
                        }
                    }
                }
                if (j == pl.lit) {
                    throw new Error("HufDecode issues");
                }
            }
        }
    }
    const i = (8 - ni) & 7;
    c >>= i;
    lc -= i;
    while (lc > 0) {
        const pl = decodingTable[(c << (_exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_DECBITS - lc)) & _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_DECMASK];
        if (pl.len) {
            lc -= pl.len;
            const gCode = GetCode(pl.lit, rlc, c, lc, array, offset, outBuffer, outOffset, outBufferEndOffset);
            if (gCode) {
                c = gCode.c;
                lc = gCode.lc;
            }
        }
        else {
            throw new Error("HufDecode issues");
        }
    }
    return true;
}
/** @internal */
function HufUncompress(array, dataView, offset, nCompressed, outBuffer, nRaw) {
    const outOffset = { value: 0 };
    const initialInOffset = offset.value;
    const im = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.ParseUint32)(dataView, offset);
    const iM = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.ParseUint32)(dataView, offset);
    offset.value += 4;
    const nBits = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.ParseUint32)(dataView, offset);
    offset.value += 4;
    if (im < 0 || im >= _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_ENCSIZE || iM < 0 || iM >= _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_ENCSIZE) {
        throw new Error("Wrong HUF_ENCSIZE");
    }
    const freq = new Array(_exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_ENCSIZE);
    const hdec = new Array(_exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.HUF_DECSIZE);
    HufClearDecTable(hdec);
    const ni = nCompressed - (offset.value - initialInOffset);
    HufUnpackEncTable(array, offset, ni, im, iM, freq);
    if (nBits > 8 * (nCompressed - (offset.value - initialInOffset))) {
        throw new Error("Wrong hufUncompress");
    }
    HufBuildDecTable(freq, im, iM, hdec);
    HufDecode(freq, hdec, array, offset, nBits, iM, nRaw, outBuffer, outOffset);
}
function UInt16(value) {
    return value & 0xffff;
}
function Int16(value) {
    const ref = UInt16(value);
    return ref > 0x7fff ? ref - 0x10000 : ref;
}
function Wdec14(l, h) {
    const ls = Int16(l);
    const hs = Int16(h);
    const hi = hs;
    const ai = ls + (hi & 1) + (hi >> 1);
    const as = ai;
    const bs = ai - hi;
    return { a: as, b: bs };
}
function Wdec16(l, h) {
    const m = UInt16(l);
    const d = UInt16(h);
    const bb = (m - (d >> 1)) & MOD_MASK;
    const aa = (d + bb - A_OFFSET) & MOD_MASK;
    return { a: aa, b: bb };
}
/** @internal */
function Wav2Decode(buffer, j, nx, ox, ny, oy, mx) {
    const w14 = mx < 1 << 14;
    const n = nx > ny ? ny : nx;
    let p = 1;
    let p2;
    let py;
    while (p <= n) {
        p <<= 1;
    }
    p >>= 1;
    p2 = p;
    p >>= 1;
    while (p >= 1) {
        py = 0;
        const ey = py + oy * (ny - p2);
        const oy1 = oy * p;
        const oy2 = oy * p2;
        const ox1 = ox * p;
        const ox2 = ox * p2;
        let i00, i01, i10, i11;
        for (; py <= ey; py += oy2) {
            let px = py;
            const ex = py + ox * (nx - p2);
            for (; px <= ex; px += ox2) {
                const p01 = px + ox1;
                const p10 = px + oy1;
                const p11 = p10 + ox1;
                if (w14) {
                    let result = Wdec14(buffer[px + j], buffer[p10 + j]);
                    i00 = result.a;
                    i10 = result.b;
                    result = Wdec14(buffer[p01 + j], buffer[p11 + j]);
                    i01 = result.a;
                    i11 = result.b;
                    result = Wdec14(i00, i01);
                    buffer[px + j] = result.a;
                    buffer[p01 + j] = result.b;
                    result = Wdec14(i10, i11);
                    buffer[p10 + j] = result.a;
                    buffer[p11 + j] = result.b;
                }
                else {
                    let result = Wdec16(buffer[px + j], buffer[p10 + j]);
                    i00 = result.a;
                    i10 = result.b;
                    result = Wdec16(buffer[p01 + j], buffer[p11 + j]);
                    i01 = result.a;
                    i11 = result.b;
                    result = Wdec16(i00, i01);
                    buffer[px + j] = result.a;
                    buffer[p01 + j] = result.b;
                    result = Wdec16(i10, i11);
                    buffer[p10 + j] = result.a;
                    buffer[p11 + j] = result.b;
                }
            }
            if (nx & p) {
                const p10 = px + oy1;
                let result;
                if (w14) {
                    result = Wdec14(buffer[px + j], buffer[p10 + j]);
                }
                else {
                    result = Wdec16(buffer[px + j], buffer[p10 + j]);
                }
                i00 = result.a;
                buffer[p10 + j] = result.b;
                buffer[px + j] = i00;
            }
        }
        if (ny & p) {
            let px = py;
            const ex = py + ox * (nx - p2);
            for (; px <= ex; px += ox2) {
                const p01 = px + ox1;
                let result;
                if (w14) {
                    result = Wdec14(buffer[px + j], buffer[p01 + j]);
                }
                else {
                    result = Wdec16(buffer[px + j], buffer[p01 + j]);
                }
                i00 = result.a;
                buffer[p01 + j] = result.b;
                buffer[px + j] = i00;
            }
        }
        p2 = p;
        p >>= 1;
    }
    return py;
}
/** @internal */
function ApplyLut(lut, data, nData) {
    for (let i = 0; i < nData; ++i) {
        data[i] = lut[data[i]];
    }
}
//# sourceMappingURL=exrLoader.compression.huf.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.compression.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.compression.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UncompressPIZ: () => (/* binding */ UncompressPIZ),
/* harmony export */   UncompressPXR: () => (/* binding */ UncompressPXR),
/* harmony export */   UncompressRAW: () => (/* binding */ UncompressRAW),
/* harmony export */   UncompressRLE: () => (/* binding */ UncompressRLE),
/* harmony export */   UncompressZIP: () => (/* binding */ UncompressZIP)
/* harmony export */ });
/* harmony import */ var _exrLoader_compression_huf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exrLoader.compression.huf.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.compression.huf.js");
/* harmony import */ var _exrLoader_compression_rle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exrLoader.compression.rle.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.compression.rle.js");
/* harmony import */ var _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./exrLoader.core.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.core.js");
/* harmony import */ var _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./exrLoader.interfaces.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.interfaces.js");




/**
 * No compression
 * @param decoder defines the decoder to use
 * @returns a decompressed data view
 */
function UncompressRAW(decoder) {
    return new DataView(decoder.array.buffer, decoder.offset.value, decoder.size);
}
/**
 * RLE compression
 * @param decoder defines the decoder to use
 * @returns a decompressed data view
 */
function UncompressRLE(decoder) {
    const compressed = decoder.viewer.buffer.slice(decoder.offset.value, decoder.offset.value + decoder.size);
    const rawBuffer = new Uint8Array((0,_exrLoader_compression_rle_js__WEBPACK_IMPORTED_MODULE_1__.DecodeRunLength)(compressed));
    const tmpBuffer = new Uint8Array(rawBuffer.length);
    (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_2__.Predictor)(rawBuffer);
    (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_2__.InterleaveScalar)(rawBuffer, tmpBuffer);
    return new DataView(tmpBuffer.buffer);
}
/**
 * Zip compression
 * @param decoder defines the decoder to use
 * @returns a decompressed data view
 */
function UncompressZIP(decoder) {
    const compressed = decoder.array.slice(decoder.offset.value, decoder.offset.value + decoder.size);
    const rawBuffer = fflate.unzlibSync(compressed);
    const tmpBuffer = new Uint8Array(rawBuffer.length);
    (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_2__.Predictor)(rawBuffer);
    (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_2__.InterleaveScalar)(rawBuffer, tmpBuffer);
    return new DataView(tmpBuffer.buffer);
}
/**
 * PXR compression
 * @param decoder defines the decoder to use
 * @returns a decompressed data view
 */
function UncompressPXR(decoder) {
    const compressed = decoder.array.slice(decoder.offset.value, decoder.offset.value + decoder.size);
    const rawBuffer = fflate.unzlibSync(compressed);
    const sz = decoder.lines * decoder.channels * decoder.width;
    const tmpBuffer = decoder.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);
    let tmpBufferEnd = 0;
    let writePtr = 0;
    const ptr = new Array(4);
    for (let y = 0; y < decoder.lines; y++) {
        for (let c = 0; c < decoder.channels; c++) {
            let pixel = 0;
            switch (decoder.type) {
                case 1:
                    ptr[0] = tmpBufferEnd;
                    ptr[1] = ptr[0] + decoder.width;
                    tmpBufferEnd = ptr[1] + decoder.width;
                    for (let j = 0; j < decoder.width; ++j) {
                        const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++];
                        pixel += diff;
                        tmpBuffer[writePtr] = pixel;
                        writePtr++;
                    }
                    break;
                case 2:
                    ptr[0] = tmpBufferEnd;
                    ptr[1] = ptr[0] + decoder.width;
                    ptr[2] = ptr[1] + decoder.width;
                    tmpBufferEnd = ptr[2] + decoder.width;
                    for (let j = 0; j < decoder.width; ++j) {
                        const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8);
                        pixel += diff;
                        tmpBuffer[writePtr] = pixel;
                        writePtr++;
                    }
                    break;
            }
        }
    }
    return new DataView(tmpBuffer.buffer);
}
/**
 * PIZ compression
 * @param decoder defines the decoder to use
 * @returns a decompressed data view
 */
function UncompressPIZ(decoder) {
    const inDataView = decoder.viewer;
    const inOffset = { value: decoder.offset.value };
    const outBuffer = new Uint16Array(decoder.width * decoder.scanlineBlockSize * (decoder.channels * decoder.type));
    const bitmap = new Uint8Array(_exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_3__.BITMAP_SIZE);
    // Setup channel info
    let outBufferEnd = 0;
    const pizChannelData = new Array(decoder.channels);
    for (let i = 0; i < decoder.channels; i++) {
        pizChannelData[i] = {};
        pizChannelData[i]["start"] = outBufferEnd;
        pizChannelData[i]["end"] = pizChannelData[i]["start"];
        pizChannelData[i]["nx"] = decoder.width;
        pizChannelData[i]["ny"] = decoder.lines;
        pizChannelData[i]["size"] = decoder.type;
        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;
    }
    // Read range compression data
    const minNonZero = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_2__.ParseUint16)(inDataView, inOffset);
    const maxNonZero = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_2__.ParseUint16)(inDataView, inOffset);
    if (maxNonZero >= _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_3__.BITMAP_SIZE) {
        throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");
    }
    if (minNonZero <= maxNonZero) {
        for (let i = 0; i < maxNonZero - minNonZero + 1; i++) {
            bitmap[i + minNonZero] = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_2__.ParseUint8)(inDataView, inOffset);
        }
    }
    // Reverse LUT
    const lut = new Uint16Array(_exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_3__.USHORT_RANGE);
    const maxValue = (0,_exrLoader_compression_huf_js__WEBPACK_IMPORTED_MODULE_0__.ReverseLutFromBitmap)(bitmap, lut);
    const length = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_2__.ParseUint32)(inDataView, inOffset);
    // Huffman decoding
    (0,_exrLoader_compression_huf_js__WEBPACK_IMPORTED_MODULE_0__.HufUncompress)(decoder.array, inDataView, inOffset, length, outBuffer, outBufferEnd);
    // Wavelet decoding
    for (let i = 0; i < decoder.channels; ++i) {
        const cd = pizChannelData[i];
        for (let j = 0; j < pizChannelData[i].size; ++j) {
            (0,_exrLoader_compression_huf_js__WEBPACK_IMPORTED_MODULE_0__.Wav2Decode)(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);
        }
    }
    // Expand the pixel data to their original range
    (0,_exrLoader_compression_huf_js__WEBPACK_IMPORTED_MODULE_0__.ApplyLut)(lut, outBuffer, outBufferEnd);
    // Rearrange the pixel data into the format expected by the caller.
    let tmpOffset = 0;
    const tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);
    for (let y = 0; y < decoder.lines; y++) {
        for (let c = 0; c < decoder.channels; c++) {
            const cd = pizChannelData[c];
            const n = cd.nx * cd.size;
            const cp = new Uint8Array(outBuffer.buffer, cd.end * _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_3__.INT16_SIZE, n * _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_3__.INT16_SIZE);
            tmpBuffer.set(cp, tmpOffset);
            tmpOffset += n * _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_3__.INT16_SIZE;
            cd.end += n;
        }
    }
    return new DataView(tmpBuffer.buffer);
}
//# sourceMappingURL=exrLoader.compression.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.compression.rle.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.compression.rle.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DecodeRunLength: () => (/* binding */ DecodeRunLength)
/* harmony export */ });
/**
 * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js
 * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation.
 */
// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */
// // TinyEXR contains some OpenEXR code, which is licensed under ------------
// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light & Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////
// // End of OpenEXR license -------------------------------------------------
/** @internal */
function DecodeRunLength(source) {
    let size = source.byteLength;
    const out = [];
    let p = 0;
    const reader = new DataView(source);
    while (size > 0) {
        const l = reader.getInt8(p++);
        if (l < 0) {
            const count = -l;
            size -= count + 1;
            for (let i = 0; i < count; i++) {
                out.push(reader.getUint8(p++));
            }
        }
        else {
            const count = l;
            size -= 2;
            const value = reader.getUint8(p++);
            for (let i = 0; i < count + 1; i++) {
                out.push(value);
            }
        }
    }
    return out;
}
//# sourceMappingURL=exrLoader.compression.rle.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.configuration.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.configuration.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXROutputType: () => (/* binding */ EXROutputType),
/* harmony export */   ExrLoaderGlobalConfiguration: () => (/* binding */ ExrLoaderGlobalConfiguration)
/* harmony export */ });
var EXROutputType;
(function (EXROutputType) {
    EXROutputType[EXROutputType["Float"] = 0] = "Float";
    EXROutputType[EXROutputType["HalfFloat"] = 1] = "HalfFloat";
})(EXROutputType || (EXROutputType = {}));
/**
 * Class used to store configuration of the exr loader
 */
class ExrLoaderGlobalConfiguration {
}
/**
 * Defines the default output type to use (Half float by default)
 */
ExrLoaderGlobalConfiguration.DefaultOutputType = EXROutputType.HalfFloat;
/**
 * Url to use to load the fflate library (for zip decompression)
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
ExrLoaderGlobalConfiguration.FFLATEUrl = "https://unpkg.com/fflate@0.8.2";
//# sourceMappingURL=exrLoader.configuration.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.core.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.core.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CompressionCodes: () => (/* binding */ CompressionCodes),
/* harmony export */   DecodeFloat32: () => (/* binding */ DecodeFloat32),
/* harmony export */   InterleaveScalar: () => (/* binding */ InterleaveScalar),
/* harmony export */   ParseFloat16: () => (/* binding */ ParseFloat16),
/* harmony export */   ParseFloat32: () => (/* binding */ ParseFloat32),
/* harmony export */   ParseInt32: () => (/* binding */ ParseInt32),
/* harmony export */   ParseInt64: () => (/* binding */ ParseInt64),
/* harmony export */   ParseNullTerminatedString: () => (/* binding */ ParseNullTerminatedString),
/* harmony export */   ParseUint16: () => (/* binding */ ParseUint16),
/* harmony export */   ParseUint32: () => (/* binding */ ParseUint32),
/* harmony export */   ParseUint8: () => (/* binding */ ParseUint8),
/* harmony export */   ParseUint8Array: () => (/* binding */ ParseUint8Array),
/* harmony export */   ParseValue: () => (/* binding */ ParseValue),
/* harmony export */   Predictor: () => (/* binding */ Predictor)
/* harmony export */ });
/* harmony import */ var _Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Maths/math.scalar.functions.js */ "./node_modules/@babylonjs/core/Maths/math.scalar.functions.js");
/* harmony import */ var _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exrLoader.interfaces.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.interfaces.js");


/**
 * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js
 * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation.
 */
// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */
// // TinyEXR contains some OpenEXR code, which is licensed under ------------
// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light & Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////
// // End of OpenEXR license -------------------------------------------------
var CompressionCodes;
(function (CompressionCodes) {
    CompressionCodes[CompressionCodes["NO_COMPRESSION"] = 0] = "NO_COMPRESSION";
    CompressionCodes[CompressionCodes["RLE_COMPRESSION"] = 1] = "RLE_COMPRESSION";
    CompressionCodes[CompressionCodes["ZIPS_COMPRESSION"] = 2] = "ZIPS_COMPRESSION";
    CompressionCodes[CompressionCodes["ZIP_COMPRESSION"] = 3] = "ZIP_COMPRESSION";
    CompressionCodes[CompressionCodes["PIZ_COMPRESSION"] = 4] = "PIZ_COMPRESSION";
    CompressionCodes[CompressionCodes["PXR24_COMPRESSION"] = 5] = "PXR24_COMPRESSION";
})(CompressionCodes || (CompressionCodes = {}));
var LineOrders;
(function (LineOrders) {
    LineOrders[LineOrders["INCREASING_Y"] = 0] = "INCREASING_Y";
    LineOrders[LineOrders["DECREASING_Y"] = 1] = "DECREASING_Y";
})(LineOrders || (LineOrders = {}));
const Tables = GenerateTables();
// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
function GenerateTables() {
    // float32 to float16 helpers
    const buffer = new ArrayBuffer(4);
    const floatView = new Float32Array(buffer);
    const uint32View = new Uint32Array(buffer);
    const baseTable = new Uint32Array(512);
    const shiftTable = new Uint32Array(512);
    for (let i = 0; i < 256; ++i) {
        const e = i - 127;
        // very small number (0, -0)
        if (e < -27) {
            baseTable[i] = 0x0000;
            baseTable[i | 0x100] = 0x8000;
            shiftTable[i] = 24;
            shiftTable[i | 0x100] = 24;
            // small number (denorm)
        }
        else if (e < -14) {
            baseTable[i] = 0x0400 >> (-e - 14);
            baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
            shiftTable[i] = -e - 1;
            shiftTable[i | 0x100] = -e - 1;
            // normal number
        }
        else if (e <= 15) {
            baseTable[i] = (e + 15) << 10;
            baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
            shiftTable[i] = 13;
            shiftTable[i | 0x100] = 13;
            // large number (Infinity, -Infinity)
        }
        else if (e < 128) {
            baseTable[i] = 0x7c00;
            baseTable[i | 0x100] = 0xfc00;
            shiftTable[i] = 24;
            shiftTable[i | 0x100] = 24;
            // stay (NaN, Infinity, -Infinity)
        }
        else {
            baseTable[i] = 0x7c00;
            baseTable[i | 0x100] = 0xfc00;
            shiftTable[i] = 13;
            shiftTable[i | 0x100] = 13;
        }
    }
    // float16 to float32 helpers
    const mantissaTable = new Uint32Array(2048);
    const exponentTable = new Uint32Array(64);
    const offsetTable = new Uint32Array(64);
    for (let i = 1; i < 1024; ++i) {
        let m = i << 13; // zero pad mantissa bits
        let e = 0; // zero exponent
        // normalized
        while ((m & 0x00800000) === 0) {
            m <<= 1;
            e -= 0x00800000; // decrement exponent
        }
        m &= ~0x00800000; // clear leading 1 bit
        e += 0x38800000; // adjust bias
        mantissaTable[i] = m | e;
    }
    for (let i = 1024; i < 2048; ++i) {
        mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
    }
    for (let i = 1; i < 31; ++i) {
        exponentTable[i] = i << 23;
    }
    exponentTable[31] = 0x47800000;
    exponentTable[32] = 0x80000000;
    for (let i = 33; i < 63; ++i) {
        exponentTable[i] = 0x80000000 + ((i - 32) << 23);
    }
    exponentTable[63] = 0xc7800000;
    for (let i = 1; i < 64; ++i) {
        if (i !== 32) {
            offsetTable[i] = 1024;
        }
    }
    return {
        floatView: floatView,
        uint32View: uint32View,
        baseTable: baseTable,
        shiftTable: shiftTable,
        mantissaTable: mantissaTable,
        exponentTable: exponentTable,
        offsetTable: offsetTable,
    };
}
/**
 * Parse a null terminated string from the buffer
 * @param buffer buffer to read from
 * @param offset current offset in the buffer
 * @returns a string
 */
function ParseNullTerminatedString(buffer, offset) {
    const uintBuffer = new Uint8Array(buffer);
    let endOffset = 0;
    while (uintBuffer[offset.value + endOffset] != 0) {
        endOffset += 1;
    }
    const stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));
    offset.value = offset.value + endOffset + 1;
    return stringValue;
}
/**
 * Parse an int32 from the buffer
 * @param dataView dataview on the data
 * @param offset current offset in the data view
 * @returns an int32
 */
function ParseInt32(dataView, offset) {
    const value = dataView.getInt32(offset.value, true);
    offset.value += _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.INT32_SIZE;
    return value;
}
/**
 * Parse an uint32 from the buffer
 * @param dataView data view to read from
 * @param offset offset in the data view
 * @returns an uint32
 */
function ParseUint32(dataView, offset) {
    const value = dataView.getUint32(offset.value, true);
    offset.value += _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.INT32_SIZE;
    return value;
}
/**
 * Parse an uint8 from the buffer
 * @param dataView dataview on the data
 * @param offset current offset in the data view
 * @returns an uint8
 */
function ParseUint8(dataView, offset) {
    const value = dataView.getUint8(offset.value);
    offset.value += _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.INT8_SIZE;
    return value;
}
/**
 * Parse an uint16 from the buffer
 * @param dataView dataview on the data
 * @param offset current offset in the data view
 * @returns an uint16
 */
function ParseUint16(dataView, offset) {
    const value = dataView.getUint16(offset.value, true);
    offset.value += _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.INT16_SIZE;
    return value;
}
/**
 * Parse an uint8 from an array buffer
 * @param array array buffer
 * @param offset current offset in the data view
 * @returns an uint16
 */
function ParseUint8Array(array, offset) {
    const value = array[offset.value];
    offset.value += _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.INT8_SIZE;
    return value;
}
/**
 * Parse an int64 from the buffer
 * @param dataView dataview on the data
 * @param offset current offset in the data view
 * @returns an int64
 */
function ParseInt64(dataView, offset) {
    let int;
    if ("getBigInt64" in DataView.prototype) {
        int = Number(dataView.getBigInt64(offset.value, true));
    }
    else {
        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32);
    }
    offset.value += _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.ULONG_SIZE;
    return int;
}
/**
 * Parse a float32 from the buffer
 * @param dataView dataview on the data
 * @param offset current offset in the data view
 * @returns a float32
 */
function ParseFloat32(dataView, offset) {
    const value = dataView.getFloat32(offset.value, true);
    offset.value += _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_1__.FLOAT32_SIZE;
    return value;
}
/**
 * Parse a float16 from the buffer
 * @param dataView dataview on the data
 * @param offset current offset in the data view
 * @returns a float16
 */
function ParseFloat16(dataView, offset) {
    return DecodeFloat16(ParseUint16(dataView, offset));
}
function DecodeFloat16(binary) {
    const exponent = (binary & 0x7c00) >> 10;
    const fraction = binary & 0x03ff;
    return ((binary >> 15 ? -1 : 1) *
        (exponent ? (exponent === 0x1f ? (fraction ? NaN : Infinity) : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)) : 6.103515625e-5 * (fraction / 0x400)));
}
function ToHalfFloat(value) {
    if (Math.abs(value) > 65504) {
        throw new Error("Value out of range.Consider using float instead of half-float.");
    }
    value = (0,_Maths_math_scalar_functions_js__WEBPACK_IMPORTED_MODULE_0__.Clamp)(value, -65504, 65504);
    Tables.floatView[0] = value;
    const f = Tables.uint32View[0];
    const e = (f >> 23) & 0x1ff;
    return Tables.baseTable[e] + ((f & 0x007fffff) >> Tables.shiftTable[e]);
}
/**
 * Decode a float32 from the buffer
 * @param dataView dataview on the data
 * @param offset current offset in the data view
 * @returns a float32
 */
function DecodeFloat32(dataView, offset) {
    return ToHalfFloat(ParseFloat32(dataView, offset));
}
function ParseFixedLengthString(buffer, offset, size) {
    const stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));
    offset.value = offset.value + size;
    return stringValue;
}
function ParseRational(dataView, offset) {
    const x = ParseInt32(dataView, offset);
    const y = ParseUint32(dataView, offset);
    return [x, y];
}
function ParseTimecode(dataView, offset) {
    const x = ParseUint32(dataView, offset);
    const y = ParseUint32(dataView, offset);
    return [x, y];
}
function ParseV2f(dataView, offset) {
    const x = ParseFloat32(dataView, offset);
    const y = ParseFloat32(dataView, offset);
    return [x, y];
}
function ParseV3f(dataView, offset) {
    const x = ParseFloat32(dataView, offset);
    const y = ParseFloat32(dataView, offset);
    const z = ParseFloat32(dataView, offset);
    return [x, y, z];
}
function ParseChlist(dataView, offset, size) {
    const startOffset = offset.value;
    const channels = [];
    while (offset.value < startOffset + size - 1) {
        const name = ParseNullTerminatedString(dataView.buffer, offset);
        const pixelType = ParseInt32(dataView, offset);
        const pLinear = ParseUint8(dataView, offset);
        offset.value += 3; // reserved, three chars
        const xSampling = ParseInt32(dataView, offset);
        const ySampling = ParseInt32(dataView, offset);
        channels.push({
            name: name,
            pixelType: pixelType,
            pLinear: pLinear,
            xSampling: xSampling,
            ySampling: ySampling,
        });
    }
    offset.value += 1;
    return channels;
}
function ParseChromaticities(dataView, offset) {
    const redX = ParseFloat32(dataView, offset);
    const redY = ParseFloat32(dataView, offset);
    const greenX = ParseFloat32(dataView, offset);
    const greenY = ParseFloat32(dataView, offset);
    const blueX = ParseFloat32(dataView, offset);
    const blueY = ParseFloat32(dataView, offset);
    const whiteX = ParseFloat32(dataView, offset);
    const whiteY = ParseFloat32(dataView, offset);
    return { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };
}
function ParseCompression(dataView, offset) {
    return ParseUint8(dataView, offset);
}
function ParseBox2i(dataView, offset) {
    const xMin = ParseInt32(dataView, offset);
    const yMin = ParseInt32(dataView, offset);
    const xMax = ParseInt32(dataView, offset);
    const yMax = ParseInt32(dataView, offset);
    return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };
}
function ParseLineOrder(dataView, offset) {
    const lineOrder = ParseUint8(dataView, offset);
    return LineOrders[lineOrder];
}
/**
 * Parse a value from the data view
 * @param dataView defines the data view to read from
 * @param offset defines the current offset in the data view
 * @param type defines the type of the value to read
 * @param size defines the size of the value to read
 * @returns the parsed value
 */
function ParseValue(dataView, offset, type, size) {
    switch (type) {
        case "string":
        case "stringvector":
        case "iccProfile":
            return ParseFixedLengthString(dataView.buffer, offset, size);
        case "chlist":
            return ParseChlist(dataView, offset, size);
        case "chromaticities":
            return ParseChromaticities(dataView, offset);
        case "compression":
            return ParseCompression(dataView, offset);
        case "box2i":
            return ParseBox2i(dataView, offset);
        case "lineOrder":
            return ParseLineOrder(dataView, offset);
        case "float":
            return ParseFloat32(dataView, offset);
        case "v2f":
            return ParseV2f(dataView, offset);
        case "v3f":
            return ParseV3f(dataView, offset);
        case "int":
            return ParseInt32(dataView, offset);
        case "rational":
            return ParseRational(dataView, offset);
        case "timecode":
            return ParseTimecode(dataView, offset);
        case "preview":
            offset.value += size;
            return "skipped";
        default:
            offset.value += size;
            return undefined;
    }
}
/**
 * Revert the endianness of the data
 * @param source defines the source
 */
function Predictor(source) {
    for (let t = 1; t < source.length; t++) {
        const d = source[t - 1] + source[t] - 128;
        source[t] = d;
    }
}
/**
 * Interleave pixels
 * @param source defines the data source
 * @param out defines the output
 */
function InterleaveScalar(source, out) {
    let t1 = 0;
    let t2 = Math.floor((source.length + 1) / 2);
    let s = 0;
    const stop = source.length - 1;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (s > stop) {
            break;
        }
        out[s++] = source[t1++];
        if (s > stop) {
            break;
        }
        out[s++] = source[t2++];
    }
}
//# sourceMappingURL=exrLoader.core.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.decoder.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.decoder.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CreateDecoderAsync: () => (/* binding */ CreateDecoderAsync),
/* harmony export */   ScanData: () => (/* binding */ ScanData)
/* harmony export */ });
/* harmony import */ var _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exrLoader.core.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.core.js");
/* harmony import */ var _exrLoader_compression_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exrLoader.compression.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.compression.js");
/* harmony import */ var _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./exrLoader.interfaces.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.interfaces.js");
/* harmony import */ var _Misc_tools_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../Misc/tools.js */ "./node_modules/@babylonjs/core/Misc/tools.js");
/* harmony import */ var _exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./exrLoader.configuration.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.configuration.js");






/**
 * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js
 * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation.
 */
// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */
// // TinyEXR contains some OpenEXR code, which is licensed under ------------
// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light & Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////
// // End of OpenEXR license -------------------------------------------------
/**
 * Create a decoder for the exr file
 * @param header header of the exr file
 * @param dataView dataview of the exr file
 * @param offset current offset
 * @param outputType expected output type (float or half float)
 * @returns a promise that resolves with the decoder
 */
async function CreateDecoderAsync(header, dataView, offset, outputType) {
    const decoder = {
        size: 0,
        viewer: dataView,
        array: new Uint8Array(dataView.buffer),
        offset: offset,
        width: header.dataWindow.xMax - header.dataWindow.xMin + 1,
        height: header.dataWindow.yMax - header.dataWindow.yMin + 1,
        channels: header.channels.length,
        channelLineOffsets: {},
        scanOrder: () => 0,
        bytesPerLine: 0,
        outLineWidth: 0,
        lines: 0,
        scanlineBlockSize: 0,
        inputSize: null,
        type: 0,
        uncompress: null,
        getter: () => 0,
        format: 5,
        outputChannels: 0,
        decodeChannels: {},
        blockCount: null,
        byteArray: null,
        linearSpace: false,
        textureType: 0,
    };
    switch (header.compression) {
        case _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.CompressionCodes.NO_COMPRESSION:
            decoder.lines = 1;
            decoder.uncompress = _exrLoader_compression_js__WEBPACK_IMPORTED_MODULE_1__.UncompressRAW;
            break;
        case _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.CompressionCodes.RLE_COMPRESSION:
            decoder.lines = 1;
            decoder.uncompress = _exrLoader_compression_js__WEBPACK_IMPORTED_MODULE_1__.UncompressRLE;
            break;
        case _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.CompressionCodes.ZIPS_COMPRESSION:
            decoder.lines = 1;
            decoder.uncompress = _exrLoader_compression_js__WEBPACK_IMPORTED_MODULE_1__.UncompressZIP;
            await _Misc_tools_js__WEBPACK_IMPORTED_MODULE_3__.Tools.LoadScriptAsync(_exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_4__.ExrLoaderGlobalConfiguration.FFLATEUrl);
            break;
        case _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.CompressionCodes.ZIP_COMPRESSION:
            decoder.lines = 16;
            decoder.uncompress = _exrLoader_compression_js__WEBPACK_IMPORTED_MODULE_1__.UncompressZIP;
            await _Misc_tools_js__WEBPACK_IMPORTED_MODULE_3__.Tools.LoadScriptAsync(_exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_4__.ExrLoaderGlobalConfiguration.FFLATEUrl);
            break;
        case _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.CompressionCodes.PIZ_COMPRESSION:
            decoder.lines = 32;
            decoder.uncompress = _exrLoader_compression_js__WEBPACK_IMPORTED_MODULE_1__.UncompressPIZ;
            break;
        case _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.CompressionCodes.PXR24_COMPRESSION:
            decoder.lines = 16;
            decoder.uncompress = _exrLoader_compression_js__WEBPACK_IMPORTED_MODULE_1__.UncompressPXR;
            await _Misc_tools_js__WEBPACK_IMPORTED_MODULE_3__.Tools.LoadScriptAsync(_exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_4__.ExrLoaderGlobalConfiguration.FFLATEUrl);
            break;
        default:
            throw new Error(_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.CompressionCodes[header.compression] + " is unsupported");
    }
    decoder.scanlineBlockSize = decoder.lines;
    const channels = {};
    for (const channel of header.channels) {
        switch (channel.name) {
            case "R":
            case "G":
            case "B":
            case "A":
                channels[channel.name] = true;
                decoder.type = channel.pixelType;
                break;
            case "Y":
                channels[channel.name] = true;
                decoder.type = channel.pixelType;
                // Note: 'Y' is deprecated in OpenGL 3.0+; prefer 'R' for single-channel EXRs.
                break;
            default:
                // Skip unsupported channels
                break;
        }
    }
    // RGB images will be converted to RGBA format, preventing software emulation in select devices.
    let fillAlpha = false;
    if (channels.R && channels.G && channels.B && channels.A) {
        decoder.outputChannels = 4;
        decoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };
    }
    else if (channels.R && channels.G && channels.B) {
        fillAlpha = true;
        decoder.outputChannels = 4;
        decoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };
    }
    else if (channels.R && channels.G) {
        decoder.outputChannels = 2;
        decoder.decodeChannels = { R: 0, G: 1 };
    }
    else if (channels.R) {
        decoder.outputChannels = 1;
        decoder.decodeChannels = { R: 0 };
    }
    else if (channels.Y) {
        decoder.outputChannels = 1;
        decoder.decodeChannels = { Y: 0 };
        // Note: Supporting 'Y' channel for legacy compatibility; prefer 'R' in new EXRs.
    }
    else {
        throw new Error("EXRLoader.parse: file contains unsupported data channels.");
    }
    if (decoder.type === 1) {
        // half
        switch (outputType) {
            case _exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_4__.EXROutputType.Float:
                decoder.getter = _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.ParseFloat16;
                decoder.inputSize = _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_2__.INT16_SIZE;
                break;
            case _exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_4__.EXROutputType.HalfFloat:
                decoder.getter = _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.ParseUint16;
                decoder.inputSize = _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_2__.INT16_SIZE;
                break;
        }
    }
    else if (decoder.type === 2) {
        // float
        switch (outputType) {
            case _exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_4__.EXROutputType.Float:
                decoder.getter = _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.ParseFloat32;
                decoder.inputSize = _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_2__.FLOAT32_SIZE;
                break;
            case _exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_4__.EXROutputType.HalfFloat:
                decoder.getter = _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.DecodeFloat32;
                decoder.inputSize = _exrLoader_interfaces_js__WEBPACK_IMPORTED_MODULE_2__.FLOAT32_SIZE;
        }
    }
    else {
        throw new Error("Unsupported pixelType " + decoder.type + " for " + header.compression);
    }
    decoder.blockCount = decoder.height / decoder.scanlineBlockSize;
    for (let i = 0; i < decoder.blockCount; i++) {
        (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.ParseInt64)(dataView, offset); // scanlineOffset
    }
    // we should be passed the scanline offset table, ready to start reading pixel data.
    const size = decoder.width * decoder.height * decoder.outputChannels;
    switch (outputType) {
        case _exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_4__.EXROutputType.Float:
            decoder.byteArray = new Float32Array(size);
            decoder.textureType = 1;
            // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten
            if (fillAlpha) {
                decoder.byteArray.fill(1, 0, size);
            }
            break;
        case _exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_4__.EXROutputType.HalfFloat:
            decoder.byteArray = new Uint16Array(size);
            decoder.textureType = 2;
            if (fillAlpha) {
                decoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1
            }
            break;
        default:
            throw new Error("Unsupported type: " + outputType);
    }
    let byteOffset = 0;
    for (const channel of header.channels) {
        if (decoder.decodeChannels[channel.name] !== undefined) {
            decoder.channelLineOffsets[channel.name] = byteOffset * decoder.width;
        }
        byteOffset += channel.pixelType * 2;
    }
    decoder.bytesPerLine = decoder.width * byteOffset;
    decoder.outLineWidth = decoder.width * decoder.outputChannels;
    if (header.lineOrder === "INCREASING_Y") {
        decoder.scanOrder = (y) => y;
    }
    else {
        decoder.scanOrder = (y) => decoder.height - 1 - y;
    }
    if (decoder.outputChannels == 4) {
        decoder.format = 5;
        decoder.linearSpace = true;
    }
    else {
        decoder.format = 6;
        decoder.linearSpace = false;
    }
    return decoder;
}
/**
 * Scan the data of the exr file
 * @param decoder decoder to use
 * @param header header of the exr file
 * @param dataView dataview of the exr file
 * @param offset current offset
 */
function ScanData(decoder, header, dataView, offset) {
    const tmpOffset = { value: 0 };
    for (let scanlineBlockIdx = 0; scanlineBlockIdx < decoder.height / decoder.scanlineBlockSize; scanlineBlockIdx++) {
        const line = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.ParseInt32)(dataView, offset) - header.dataWindow.yMin; // line_no
        decoder.size = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_0__.ParseUint32)(dataView, offset); // data_len
        decoder.lines = line + decoder.scanlineBlockSize > decoder.height ? decoder.height - line : decoder.scanlineBlockSize;
        const isCompressed = decoder.size < decoder.lines * decoder.bytesPerLine;
        const viewer = isCompressed && decoder.uncompress ? decoder.uncompress(decoder) : (0,_exrLoader_compression_js__WEBPACK_IMPORTED_MODULE_1__.UncompressRAW)(decoder);
        offset.value += decoder.size;
        for (let lineY = 0; lineY < decoder.scanlineBlockSize; lineY++) {
            const scanY = scanlineBlockIdx * decoder.scanlineBlockSize;
            const trueY = lineY + decoder.scanOrder(scanY);
            if (trueY >= decoder.height) {
                continue;
            }
            const lineOffset = lineY * decoder.bytesPerLine;
            const outLineOffset = (decoder.height - 1 - trueY) * decoder.outLineWidth;
            for (let channelID = 0; channelID < decoder.channels; channelID++) {
                const name = header.channels[channelID].name;
                const lOff = decoder.channelLineOffsets[name];
                const cOff = decoder.decodeChannels[name];
                if (cOff === undefined) {
                    continue;
                }
                tmpOffset.value = lineOffset + lOff;
                for (let x = 0; x < decoder.width; x++) {
                    const outIndex = outLineOffset + x * decoder.outputChannels + cOff;
                    if (decoder.byteArray) {
                        decoder.byteArray[outIndex] = decoder.getter(viewer, tmpOffset);
                    }
                }
            }
        }
    }
}
//# sourceMappingURL=exrLoader.decoder.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.header.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.header.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GetExrHeader: () => (/* binding */ GetExrHeader)
/* harmony export */ });
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");
/* harmony import */ var _exrLoader_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exrLoader.core.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.core.js");
/* eslint-disable @typescript-eslint/naming-convention */


/**
 * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js
 * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation.
 */
// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */
// // TinyEXR contains some OpenEXR code, which is licensed under ------------
// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light & Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////
// // End of OpenEXR license -------------------------------------------------
const EXR_MAGIC = 20000630;
/**
 * Gets the EXR header
 * @param dataView defines the data view to read from
 * @param offset defines the offset to start reading from
 * @returns the header
 */
function GetExrHeader(dataView, offset) {
    if (dataView.getUint32(0, true) != EXR_MAGIC) {
        throw new Error("Incorrect OpenEXR format");
    }
    const version = dataView.getUint8(4);
    const specData = dataView.getUint8(5); // fullMask
    const spec = {
        singleTile: !!(specData & 2),
        longName: !!(specData & 4),
        deepFormat: !!(specData & 8),
        multiPart: !!(specData & 16),
    };
    offset.value = 8;
    const headerData = {};
    let keepReading = true;
    while (keepReading) {
        const attributeName = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_1__.ParseNullTerminatedString)(dataView.buffer, offset);
        if (!attributeName) {
            keepReading = false;
        }
        else {
            const attributeType = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_1__.ParseNullTerminatedString)(dataView.buffer, offset);
            const attributeSize = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_1__.ParseUint32)(dataView, offset);
            const attributeValue = (0,_exrLoader_core_js__WEBPACK_IMPORTED_MODULE_1__.ParseValue)(dataView, offset, attributeType, attributeSize);
            if (attributeValue === undefined) {
                _Misc_logger_js__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn(`Unknown header attribute type ${attributeType}'.`);
            }
            else {
                headerData[attributeName] = attributeValue;
            }
        }
    }
    if ((specData & ~0x04) != 0) {
        throw new Error("Unsupported file format");
    }
    return { version: version, spec: spec, ...headerData };
}
//# sourceMappingURL=exrLoader.header.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.interfaces.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.interfaces.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BITMAP_SIZE: () => (/* binding */ BITMAP_SIZE),
/* harmony export */   FLOAT32_SIZE: () => (/* binding */ FLOAT32_SIZE),
/* harmony export */   HUF_DECBITS: () => (/* binding */ HUF_DECBITS),
/* harmony export */   HUF_DECMASK: () => (/* binding */ HUF_DECMASK),
/* harmony export */   HUF_DECSIZE: () => (/* binding */ HUF_DECSIZE),
/* harmony export */   HUF_ENCBITS: () => (/* binding */ HUF_ENCBITS),
/* harmony export */   HUF_ENCSIZE: () => (/* binding */ HUF_ENCSIZE),
/* harmony export */   INT16_SIZE: () => (/* binding */ INT16_SIZE),
/* harmony export */   INT32_SIZE: () => (/* binding */ INT32_SIZE),
/* harmony export */   INT8_SIZE: () => (/* binding */ INT8_SIZE),
/* harmony export */   LONG_ZEROCODE_RUN: () => (/* binding */ LONG_ZEROCODE_RUN),
/* harmony export */   SHORTEST_LONG_RUN: () => (/* binding */ SHORTEST_LONG_RUN),
/* harmony export */   SHORT_ZEROCODE_RUN: () => (/* binding */ SHORT_ZEROCODE_RUN),
/* harmony export */   ULONG_SIZE: () => (/* binding */ ULONG_SIZE),
/* harmony export */   USHORT_RANGE: () => (/* binding */ USHORT_RANGE)
/* harmony export */ });
const INT32_SIZE = 4;
const FLOAT32_SIZE = 4;
const INT8_SIZE = 1;
const INT16_SIZE = 2;
const ULONG_SIZE = 8;
const USHORT_RANGE = 1 << 16;
const BITMAP_SIZE = USHORT_RANGE >> 3;
const HUF_ENCBITS = 16;
const HUF_DECBITS = 14;
const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;
const HUF_DECSIZE = 1 << HUF_DECBITS;
const HUF_DECMASK = HUF_DECSIZE - 1;
const SHORT_ZEROCODE_RUN = 59;
const LONG_ZEROCODE_RUN = 63;
const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
//# sourceMappingURL=exrLoader.interfaces.js.map

/***/ }),

/***/ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/exrTextureLoader.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/Textures/Loaders/exrTextureLoader.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _ExrTextureLoader: () => (/* binding */ _ExrTextureLoader)
/* harmony export */ });
/* harmony import */ var _EXR_exrLoader_header_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EXR/exrLoader.header.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.header.js");
/* harmony import */ var _EXR_exrLoader_decoder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EXR/exrLoader.decoder.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.decoder.js");
/* harmony import */ var _EXR_exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EXR/exrLoader.configuration.js */ "./node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.configuration.js");
/* harmony import */ var _Misc_logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../Misc/logger.js */ "./node_modules/@babylonjs/core/Misc/logger.js");




/**
 * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js
 * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation.
 */
// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */
// // TinyEXR contains some OpenEXR code, which is licensed under ------------
// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light & Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////
// // End of OpenEXR license -------------------------------------------------
/**
 * Loader for .exr file format
 * @see [PIZ compression](https://playground.babylonjs.com/#4RN0VF#151)
 * @see [ZIP compression](https://playground.babylonjs.com/#4RN0VF#146)
 * @see [RLE compression](https://playground.babylonjs.com/#4RN0VF#149)
 * @see [PXR24 compression](https://playground.babylonjs.com/#4RN0VF#150)
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class _ExrTextureLoader {
    constructor() {
        /**
         * Defines whether the loader supports cascade loading the different faces.
         */
        this.supportCascades = false;
    }
    /**
     * Uploads the cube texture data to the WebGL texture. It has already been bound.
     * @param _data contains the texture data
     * @param _texture defines the BabylonJS internal texture
     * @param _createPolynomials will be true if polynomials have been requested
     * @param _onLoad defines the callback to trigger once the texture is ready
     * @param _onError defines the callback to trigger in case of error
     * Cube texture are not supported by .exr files
     */
    loadCubeData(_data, _texture, _createPolynomials, _onLoad, _onError) {
        // eslint-disable-next-line no-throw-literal
        throw ".exr not supported in Cube.";
    }
    /**
     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.
     * @param data contains the texture data
     * @param texture defines the BabylonJS internal texture
     * @param callback defines the method to call once ready to upload
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    loadData(data, texture, callback) {
        const dataView = new DataView(data.buffer);
        const offset = { value: 0 };
        const header = (0,_EXR_exrLoader_header_js__WEBPACK_IMPORTED_MODULE_0__.GetExrHeader)(dataView, offset);
        (0,_EXR_exrLoader_decoder_js__WEBPACK_IMPORTED_MODULE_1__.CreateDecoderAsync)(header, dataView, offset, _EXR_exrLoader_configuration_js__WEBPACK_IMPORTED_MODULE_2__.ExrLoaderGlobalConfiguration.DefaultOutputType)
            .then((decoder) => {
            (0,_EXR_exrLoader_decoder_js__WEBPACK_IMPORTED_MODULE_1__.ScanData)(decoder, header, dataView, offset);
            // Updating texture
            const width = header.dataWindow.xMax - header.dataWindow.xMin + 1;
            const height = header.dataWindow.yMax - header.dataWindow.yMin + 1;
            callback(width, height, texture.generateMipMaps, false, () => {
                const engine = texture.getEngine();
                texture.format = header.format;
                texture.type = decoder.textureType;
                texture.invertY = false;
                texture._gammaSpace = !header.linearSpace;
                if (decoder.byteArray) {
                    engine._uploadDataToTextureDirectly(texture, decoder.byteArray, 0, 0, undefined, true);
                }
            });
        })
            .catch((error) => {
            _Misc_logger_js__WEBPACK_IMPORTED_MODULE_3__.Logger.Error("Failed to load EXR texture: ", error);
        });
    }
}
//# sourceMappingURL=exrTextureLoader.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYmFieWxvbmpzX2NvcmVfTWF0ZXJpYWxzX1RleHR1cmVzX0xvYWRlcnNfZXhyVGV4dHVyZUxvYWRlcl9qcy5icm93c2VyLXBhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ29HO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLElBQUksa0VBQVksRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrRUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUksaUVBQVcsRUFBRTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1FQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1FQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLElBQUksaUVBQVcsRUFBRTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJLGlFQUFXLEVBQUU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1RUFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUVBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdFQUFrQjtBQUN4Qyw0QkFBNEIsd0VBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlFQUFXO0FBQzNCLHdDQUF3QyxpRUFBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUVBQVcsT0FBTyxPQUFPO0FBQ3hELHlDQUF5QyxpRUFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlFQUFXO0FBQ2hDLHNDQUFzQyxpRUFBVyxLQUFLLGlFQUFXO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpRUFBVyxVQUFVLGlFQUFXO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asd0JBQXdCO0FBQ3hCO0FBQ0EsZUFBZSwrREFBVztBQUMxQixlQUFlLCtEQUFXO0FBQzFCO0FBQ0Esa0JBQWtCLCtEQUFXO0FBQzdCO0FBQ0Esd0JBQXdCLGlFQUFXLG9CQUFvQixpRUFBVztBQUNsRTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFXO0FBQ3RDLDJCQUEyQixpRUFBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1YzJHO0FBQzFDO0FBQ3VDO0FBQ3RCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFDQUFxQyw4RUFBZTtBQUNwRDtBQUNBLElBQUksNkRBQVM7QUFDYixJQUFJLG9FQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2REFBUztBQUNiLElBQUksb0VBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLGtDQUFrQyxpRUFBVztBQUM3QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrREFBVztBQUNsQyx1QkFBdUIsK0RBQVc7QUFDbEMsc0JBQXNCLGlFQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQscUNBQXFDLDhEQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrRUFBWTtBQUM1QyxxQkFBcUIsbUZBQW9CO0FBQ3pDLG1CQUFtQiwrREFBVztBQUM5QjtBQUNBLElBQUksNEVBQWE7QUFDakI7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRCxZQUFZLHlFQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBLGlFQUFpRSxnRUFBVSxNQUFNLGdFQUFVO0FBQzNGO0FBQ0EsNkJBQTZCLGdFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDMUZPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25CbUU7QUFDcUM7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUIseUJBQXlCO0FBQ3pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLGdFQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLGdFQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLCtEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLGdFQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLCtEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdFQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLGtFQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix1QkFBdUIsc0VBQVk7QUFDbkMsUUFBUSw2RUFBa0IsMkJBQTJCLHlGQUE0QjtBQUNqRjtBQUNBLFlBQVksbUVBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLFlBQVksbURBQU07QUFDbEIsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvTG9hZGVycy9FWFIvZXhyTG9hZGVyLmNvbXByZXNzaW9uLmh1Zi5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL0xvYWRlcnMvRVhSL2V4ckxvYWRlci5jb21wcmVzc2lvbi5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL0xvYWRlcnMvRVhSL2V4ckxvYWRlci5jb21wcmVzc2lvbi5ybGUuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGVyaWFscy9UZXh0dXJlcy9Mb2FkZXJzL0VYUi9leHJMb2FkZXIuY29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9hYjJhYy8uL25vZGVfbW9kdWxlcy9AYmFieWxvbmpzL2NvcmUvTWF0ZXJpYWxzL1RleHR1cmVzL0xvYWRlcnMvRVhSL2V4ckxvYWRlci5jb3JlLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvTG9hZGVycy9FWFIvZXhyTG9hZGVyLmRlY29kZXIuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGVyaWFscy9UZXh0dXJlcy9Mb2FkZXJzL0VYUi9leHJMb2FkZXIuaGVhZGVyLmpzIiwid2VicGFjazovL2FiMmFjLy4vbm9kZV9tb2R1bGVzL0BiYWJ5bG9uanMvY29yZS9NYXRlcmlhbHMvVGV4dHVyZXMvTG9hZGVycy9FWFIvZXhyTG9hZGVyLmludGVyZmFjZXMuanMiLCJ3ZWJwYWNrOi8vYWIyYWMvLi9ub2RlX21vZHVsZXMvQGJhYnlsb25qcy9jb3JlL01hdGVyaWFscy9UZXh0dXJlcy9Mb2FkZXJzL2V4clRleHR1cmVMb2FkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFyc2VVaW50MzIsIFBhcnNlVWludDhBcnJheSB9IGZyb20gXCIuL2V4ckxvYWRlci5jb3JlLmpzXCI7XG5pbXBvcnQgeyBIVUZfREVDQklUUywgSFVGX0RFQ01BU0ssIEhVRl9ERUNTSVpFLCBIVUZfRU5DU0laRSwgTE9OR19aRVJPQ09ERV9SVU4sIFNIT1JUX1pFUk9DT0RFX1JVTiwgU0hPUlRFU1RfTE9OR19SVU4sIFVTSE9SVF9SQU5HRSB9IGZyb20gXCIuL2V4ckxvYWRlci5pbnRlcmZhY2VzLmpzXCI7XG4vKipcbiAqIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9zY2llY29kZS90aHJlZS5qcy9ibG9iL2Rldi9leGFtcGxlcy9qc20vbG9hZGVycy9FWFJMb2FkZXIuanNcbiAqIFJlZmVycmVkIHRvIHRoZSBvcmlnaW5hbCBJbmR1c3RyaWFsIExpZ2h0ICYgTWFnaWMgT3BlbkVYUiBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlIFRpbnlFWFIgLyBTeW95byBGdWppdGFcbiAqIGltcGxlbWVudGF0aW9uLlxuICovXG4vLyAvKlxuLy8gQ29weXJpZ2h0IChjKSAyMDE0IC0gMjAxNywgU3lveW8gRnVqaXRhXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbi8vICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuLy8gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIFN5b3lvIEZ1aml0YSBub3IgdGhlXG4vLyAgICAgICBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuLy8gICAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbi8vIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4vLyBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4vLyBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbi8vIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4vLyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4vLyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbi8vIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuLy8gU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vLyAqL1xuLy8gLy8gVGlueUVYUiBjb250YWlucyBzb21lIE9wZW5FWFIgY29kZSwgd2hpY2ggaXMgbGljZW5zZWQgdW5kZXIgLS0tLS0tLS0tLS0tXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIC8vXG4vLyAvLyBDb3B5cmlnaHQgKGMpIDIwMDIsIEluZHVzdHJpYWwgTGlnaHQgJiBNYWdpYywgYSBkaXZpc2lvbiBvZiBMdWNhc1xuLy8gLy8gRGlnaXRhbCBMdGQuIExMQ1xuLy8gLy9cbi8vIC8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAvL1xuLy8gLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyAvLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyAvLyBtZXQ6XG4vLyAvLyAqICAgICAgIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAvLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAvLyAqICAgICAgIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIC8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIC8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIC8vIGRpc3RyaWJ1dGlvbi5cbi8vIC8vICogICAgICAgTmVpdGhlciB0aGUgbmFtZSBvZiBJbmR1c3RyaWFsIExpZ2h0ICYgTWFnaWMgbm9yIHRoZSBuYW1lcyBvZlxuLy8gLy8gaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuLy8gLy8gZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy8gLy9cbi8vIC8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIC8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIC8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIC8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyAvLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIC8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIC8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vIC8vXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIC8vIEVuZCBvZiBPcGVuRVhSIGxpY2Vuc2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgTkJJVFMgPSAxNjtcbmNvbnN0IEFfT0ZGU0VUID0gMSA8PCAoTkJJVFMgLSAxKTtcbmNvbnN0IE1PRF9NQVNLID0gKDEgPDwgTkJJVFMpIC0gMTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBSZXZlcnNlTHV0RnJvbUJpdG1hcChiaXRtYXAsIGx1dCkge1xuICAgIGxldCBrID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFVTSE9SVF9SQU5HRTsgKytpKSB7XG4gICAgICAgIGlmIChpID09IDAgfHwgYml0bWFwW2kgPj4gM10gJiAoMSA8PCAoaSAmIDcpKSkge1xuICAgICAgICAgICAgbHV0W2srK10gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG4gPSBrIC0gMTtcbiAgICB3aGlsZSAoayA8IFVTSE9SVF9SQU5HRSkge1xuICAgICAgICBsdXRbaysrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuZnVuY3Rpb24gSHVmQ2xlYXJEZWNUYWJsZShoZGVjKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBIVUZfREVDU0laRTsgaSsrKSB7XG4gICAgICAgIGhkZWNbaV0gPSB7fTtcbiAgICAgICAgaGRlY1tpXS5sZW4gPSAwO1xuICAgICAgICBoZGVjW2ldLmxpdCA9IDA7XG4gICAgICAgIGhkZWNbaV0ucCA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gR2V0Qml0cyhuQml0cywgYywgbGMsIGFycmF5LCBvZmZzZXQpIHtcbiAgICB3aGlsZSAobGMgPCBuQml0cykge1xuICAgICAgICBjID0gKGMgPDwgOCkgfCBQYXJzZVVpbnQ4QXJyYXkoYXJyYXksIG9mZnNldCk7XG4gICAgICAgIGxjICs9IDg7XG4gICAgfVxuICAgIGxjIC09IG5CaXRzO1xuICAgIHJldHVybiB7XG4gICAgICAgIGw6IChjID4+IGxjKSAmICgoMSA8PCBuQml0cykgLSAxKSxcbiAgICAgICAgYyxcbiAgICAgICAgbGMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEdldENoYXIoYywgbGMsIGFycmF5LCBvZmZzZXQpIHtcbiAgICBjID0gKGMgPDwgOCkgfCBQYXJzZVVpbnQ4QXJyYXkoYXJyYXksIG9mZnNldCk7XG4gICAgbGMgKz0gODtcbiAgICByZXR1cm4ge1xuICAgICAgICBjLFxuICAgICAgICBsYyxcbiAgICB9O1xufVxuZnVuY3Rpb24gR2V0Q29kZShwbywgcmxjLCBjLCBsYywgYXJyYXksIG9mZnNldCwgb3V0QnVmZmVyLCBvdXRCdWZmZXJPZmZzZXQsIG91dEJ1ZmZlckVuZE9mZnNldCkge1xuICAgIGlmIChwbyA9PSBybGMpIHtcbiAgICAgICAgaWYgKGxjIDwgOCkge1xuICAgICAgICAgICAgY29uc3QgZ2MgPSBHZXRDaGFyKGMsIGxjLCBhcnJheSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGMgPSBnYy5jO1xuICAgICAgICAgICAgbGMgPSBnYy5sYztcbiAgICAgICAgfVxuICAgICAgICBsYyAtPSA4O1xuICAgICAgICBsZXQgY3MgPSBjID4+IGxjO1xuICAgICAgICBjcyA9IG5ldyBVaW50OEFycmF5KFtjc10pWzBdO1xuICAgICAgICBpZiAob3V0QnVmZmVyT2Zmc2V0LnZhbHVlICsgY3MgPiBvdXRCdWZmZXJFbmRPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHMgPSBvdXRCdWZmZXJbb3V0QnVmZmVyT2Zmc2V0LnZhbHVlIC0gMV07XG4gICAgICAgIHdoaWxlIChjcy0tID4gMCkge1xuICAgICAgICAgICAgb3V0QnVmZmVyW291dEJ1ZmZlck9mZnNldC52YWx1ZSsrXSA9IHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAob3V0QnVmZmVyT2Zmc2V0LnZhbHVlIDwgb3V0QnVmZmVyRW5kT2Zmc2V0KSB7XG4gICAgICAgIG91dEJ1ZmZlcltvdXRCdWZmZXJPZmZzZXQudmFsdWUrK10gPSBwbztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBjLCBsYyB9O1xufVxuY29uc3QgSHVmVGFibGVCdWZmZXIgPSBuZXcgQXJyYXkoNTkpO1xuZnVuY3Rpb24gSHVmQ2Fub25pY2FsQ29kZVRhYmxlKGhjb2RlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gNTg7ICsraSkge1xuICAgICAgICBIdWZUYWJsZUJ1ZmZlcltpXSA9IDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSFVGX0VOQ1NJWkU7ICsraSkge1xuICAgICAgICBIdWZUYWJsZUJ1ZmZlcltoY29kZVtpXV0gKz0gMTtcbiAgICB9XG4gICAgbGV0IGMgPSAwO1xuICAgIGZvciAobGV0IGkgPSA1ODsgaSA+IDA7IC0taSkge1xuICAgICAgICBjb25zdCBuYyA9IChjICsgSHVmVGFibGVCdWZmZXJbaV0pID4+IDE7XG4gICAgICAgIEh1ZlRhYmxlQnVmZmVyW2ldID0gYztcbiAgICAgICAgYyA9IG5jO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IEhVRl9FTkNTSVpFOyArK2kpIHtcbiAgICAgICAgY29uc3QgbCA9IGhjb2RlW2ldO1xuICAgICAgICBpZiAobCA+IDApIHtcbiAgICAgICAgICAgIGhjb2RlW2ldID0gbCB8IChIdWZUYWJsZUJ1ZmZlcltsXSsrIDw8IDYpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gSHVmVW5wYWNrRW5jVGFibGUoYXJyYXksIG9mZnNldCwgbmksIGltLCBpTSwgaGNvZGUpIHtcbiAgICBjb25zdCBwID0gb2Zmc2V0O1xuICAgIGxldCBjID0gMDtcbiAgICBsZXQgbGMgPSAwO1xuICAgIGZvciAoOyBpbSA8PSBpTTsgaW0rKykge1xuICAgICAgICBpZiAocC52YWx1ZSAtIG9mZnNldC52YWx1ZSA+IG5pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdiID0gR2V0Qml0cyg2LCBjLCBsYywgYXJyYXksIHApO1xuICAgICAgICBjb25zdCBsID0gZ2IubDtcbiAgICAgICAgYyA9IGdiLmM7XG4gICAgICAgIGxjID0gZ2IubGM7XG4gICAgICAgIGhjb2RlW2ltXSA9IGw7XG4gICAgICAgIGlmIChsID09IExPTkdfWkVST0NPREVfUlVOKSB7XG4gICAgICAgICAgICBpZiAocC52YWx1ZSAtIG9mZnNldC52YWx1ZSA+IG5pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gSHVmVW5wYWNrRW5jVGFibGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYiA9IEdldEJpdHMoOCwgYywgbGMsIGFycmF5LCBwKTtcbiAgICAgICAgICAgIGxldCB6ZXJ1biA9IGdiLmwgKyBTSE9SVEVTVF9MT05HX1JVTjtcbiAgICAgICAgICAgIGMgPSBnYi5jO1xuICAgICAgICAgICAgbGMgPSBnYi5sYztcbiAgICAgICAgICAgIGlmIChpbSArIHplcnVuID4gaU0gKyAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gSHVmVW5wYWNrRW5jVGFibGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoemVydW4tLSkge1xuICAgICAgICAgICAgICAgIGhjb2RlW2ltKytdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobCA+PSBTSE9SVF9aRVJPQ09ERV9SVU4pIHtcbiAgICAgICAgICAgIGxldCB6ZXJ1biA9IGwgLSBTSE9SVF9aRVJPQ09ERV9SVU4gKyAyO1xuICAgICAgICAgICAgaWYgKGltICsgemVydW4gPiBpTSArIDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBIdWZVbnBhY2tFbmNUYWJsZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh6ZXJ1bi0tKSB7XG4gICAgICAgICAgICAgICAgaGNvZGVbaW0rK10gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW0tLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBIdWZDYW5vbmljYWxDb2RlVGFibGUoaGNvZGUpO1xufVxuZnVuY3Rpb24gSHVmTGVuZ3RoKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSAmIDYzO1xufVxuZnVuY3Rpb24gSHVmQ29kZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj4gNjtcbn1cbmZ1bmN0aW9uIEh1ZkJ1aWxkRGVjVGFibGUoaGNvZGUsIGltLCBpTSwgaGRlY29kKSB7XG4gICAgZm9yICg7IGltIDw9IGlNOyBpbSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBIdWZDb2RlKGhjb2RlW2ltXSk7XG4gICAgICAgIGNvbnN0IGwgPSBIdWZMZW5ndGgoaGNvZGVbaW1dKTtcbiAgICAgICAgaWYgKGMgPj4gbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YWJsZSBlbnRyeVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobCA+IEhVRl9ERUNCSVRTKSB7XG4gICAgICAgICAgICBjb25zdCBwbCA9IGhkZWNvZFtjID4+IChsIC0gSFVGX0RFQ0JJVFMpXTtcbiAgICAgICAgICAgIGlmIChwbC5sZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGwubGl0Kys7XG4gICAgICAgICAgICBpZiAocGwucCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwbC5wO1xuICAgICAgICAgICAgICAgIHBsLnAgPSBuZXcgQXJyYXkocGwubGl0KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsLmxpdCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwbC5wW2ldID0gcFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbC5wID0gbmV3IEFycmF5KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGwucFtwbC5saXQgLSAxXSA9IGltO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGwpIHtcbiAgICAgICAgICAgIGxldCBwbE9mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMSA8PCAoSFVGX0RFQ0JJVFMgLSBsKTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsID0gaGRlY29kWyhjIDw8IChIVUZfREVDQklUUyAtIGwpKSArIHBsT2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBpZiAocGwubGVuIHx8IHBsLnApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YWJsZSBlbnRyeVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGwubGVuID0gbDtcbiAgICAgICAgICAgICAgICBwbC5saXQgPSBpbTtcbiAgICAgICAgICAgICAgICBwbE9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gSHVmRGVjb2RlKGVuY29kaW5nVGFibGUsIGRlY29kaW5nVGFibGUsIGFycmF5LCBvZmZzZXQsIG5pLCBybGMsIG5vLCBvdXRCdWZmZXIsIG91dE9mZnNldCkge1xuICAgIGxldCBjID0gMDtcbiAgICBsZXQgbGMgPSAwO1xuICAgIGNvbnN0IG91dEJ1ZmZlckVuZE9mZnNldCA9IG5vO1xuICAgIGNvbnN0IGluT2Zmc2V0RW5kID0gTWF0aC50cnVuYyhvZmZzZXQudmFsdWUgKyAobmkgKyA3KSAvIDgpO1xuICAgIHdoaWxlIChvZmZzZXQudmFsdWUgPCBpbk9mZnNldEVuZCkge1xuICAgICAgICBsZXQgZ2MgPSBHZXRDaGFyKGMsIGxjLCBhcnJheSwgb2Zmc2V0KTtcbiAgICAgICAgYyA9IGdjLmM7XG4gICAgICAgIGxjID0gZ2MubGM7XG4gICAgICAgIHdoaWxlIChsYyA+PSBIVUZfREVDQklUUykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSAoYyA+PiAobGMgLSBIVUZfREVDQklUUykpICYgSFVGX0RFQ01BU0s7XG4gICAgICAgICAgICBjb25zdCBwbCA9IGRlY29kaW5nVGFibGVbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBsLmxlbikge1xuICAgICAgICAgICAgICAgIGxjIC09IHBsLmxlbjtcbiAgICAgICAgICAgICAgICBjb25zdCBnQ29kZSA9IEdldENvZGUocGwubGl0LCBybGMsIGMsIGxjLCBhcnJheSwgb2Zmc2V0LCBvdXRCdWZmZXIsIG91dE9mZnNldCwgb3V0QnVmZmVyRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZ0NvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGdDb2RlLmM7XG4gICAgICAgICAgICAgICAgICAgIGxjID0gZ0NvZGUubGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwbC5wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImh1ZkRlY29kZSBpc3N1ZXNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBqO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwbC5saXQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsID0gSHVmTGVuZ3RoKGVuY29kaW5nVGFibGVbcGwucFtqXV0pO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGMgPCBsICYmIG9mZnNldC52YWx1ZSA8IGluT2Zmc2V0RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnYyA9IEdldENoYXIoYywgbGMsIGFycmF5LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGdjLmM7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYyA9IGdjLmxjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYyA+PSBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSHVmQ29kZShlbmNvZGluZ1RhYmxlW3BsLnBbal1dKSA9PSAoKGMgPj4gKGxjIC0gbCkpICYgKCgxIDw8IGwpIC0gMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGMgLT0gbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnQ29kZSA9IEdldENvZGUocGwucFtqXSwgcmxjLCBjLCBsYywgYXJyYXksIG9mZnNldCwgb3V0QnVmZmVyLCBvdXRPZmZzZXQsIG91dEJ1ZmZlckVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBnQ29kZS5jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYyA9IGdDb2RlLmxjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaiA9PSBwbC5saXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSHVmRGVjb2RlIGlzc3Vlc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaSA9ICg4IC0gbmkpICYgNztcbiAgICBjID4+PSBpO1xuICAgIGxjIC09IGk7XG4gICAgd2hpbGUgKGxjID4gMCkge1xuICAgICAgICBjb25zdCBwbCA9IGRlY29kaW5nVGFibGVbKGMgPDwgKEhVRl9ERUNCSVRTIC0gbGMpKSAmIEhVRl9ERUNNQVNLXTtcbiAgICAgICAgaWYgKHBsLmxlbikge1xuICAgICAgICAgICAgbGMgLT0gcGwubGVuO1xuICAgICAgICAgICAgY29uc3QgZ0NvZGUgPSBHZXRDb2RlKHBsLmxpdCwgcmxjLCBjLCBsYywgYXJyYXksIG9mZnNldCwgb3V0QnVmZmVyLCBvdXRPZmZzZXQsIG91dEJ1ZmZlckVuZE9mZnNldCk7XG4gICAgICAgICAgICBpZiAoZ0NvZGUpIHtcbiAgICAgICAgICAgICAgICBjID0gZ0NvZGUuYztcbiAgICAgICAgICAgICAgICBsYyA9IGdDb2RlLmxjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSHVmRGVjb2RlIGlzc3Vlc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBIdWZVbmNvbXByZXNzKGFycmF5LCBkYXRhVmlldywgb2Zmc2V0LCBuQ29tcHJlc3NlZCwgb3V0QnVmZmVyLCBuUmF3KSB7XG4gICAgY29uc3Qgb3V0T2Zmc2V0ID0geyB2YWx1ZTogMCB9O1xuICAgIGNvbnN0IGluaXRpYWxJbk9mZnNldCA9IG9mZnNldC52YWx1ZTtcbiAgICBjb25zdCBpbSA9IFBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIGNvbnN0IGlNID0gUGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgb2Zmc2V0LnZhbHVlICs9IDQ7XG4gICAgY29uc3QgbkJpdHMgPSBQYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICBvZmZzZXQudmFsdWUgKz0gNDtcbiAgICBpZiAoaW0gPCAwIHx8IGltID49IEhVRl9FTkNTSVpFIHx8IGlNIDwgMCB8fCBpTSA+PSBIVUZfRU5DU0laRSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBIVUZfRU5DU0laRVwiKTtcbiAgICB9XG4gICAgY29uc3QgZnJlcSA9IG5ldyBBcnJheShIVUZfRU5DU0laRSk7XG4gICAgY29uc3QgaGRlYyA9IG5ldyBBcnJheShIVUZfREVDU0laRSk7XG4gICAgSHVmQ2xlYXJEZWNUYWJsZShoZGVjKTtcbiAgICBjb25zdCBuaSA9IG5Db21wcmVzc2VkIC0gKG9mZnNldC52YWx1ZSAtIGluaXRpYWxJbk9mZnNldCk7XG4gICAgSHVmVW5wYWNrRW5jVGFibGUoYXJyYXksIG9mZnNldCwgbmksIGltLCBpTSwgZnJlcSk7XG4gICAgaWYgKG5CaXRzID4gOCAqIChuQ29tcHJlc3NlZCAtIChvZmZzZXQudmFsdWUgLSBpbml0aWFsSW5PZmZzZXQpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBodWZVbmNvbXByZXNzXCIpO1xuICAgIH1cbiAgICBIdWZCdWlsZERlY1RhYmxlKGZyZXEsIGltLCBpTSwgaGRlYyk7XG4gICAgSHVmRGVjb2RlKGZyZXEsIGhkZWMsIGFycmF5LCBvZmZzZXQsIG5CaXRzLCBpTSwgblJhdywgb3V0QnVmZmVyLCBvdXRPZmZzZXQpO1xufVxuZnVuY3Rpb24gVUludDE2KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYgMHhmZmZmO1xufVxuZnVuY3Rpb24gSW50MTYodmFsdWUpIHtcbiAgICBjb25zdCByZWYgPSBVSW50MTYodmFsdWUpO1xuICAgIHJldHVybiByZWYgPiAweDdmZmYgPyByZWYgLSAweDEwMDAwIDogcmVmO1xufVxuZnVuY3Rpb24gV2RlYzE0KGwsIGgpIHtcbiAgICBjb25zdCBscyA9IEludDE2KGwpO1xuICAgIGNvbnN0IGhzID0gSW50MTYoaCk7XG4gICAgY29uc3QgaGkgPSBocztcbiAgICBjb25zdCBhaSA9IGxzICsgKGhpICYgMSkgKyAoaGkgPj4gMSk7XG4gICAgY29uc3QgYXMgPSBhaTtcbiAgICBjb25zdCBicyA9IGFpIC0gaGk7XG4gICAgcmV0dXJuIHsgYTogYXMsIGI6IGJzIH07XG59XG5mdW5jdGlvbiBXZGVjMTYobCwgaCkge1xuICAgIGNvbnN0IG0gPSBVSW50MTYobCk7XG4gICAgY29uc3QgZCA9IFVJbnQxNihoKTtcbiAgICBjb25zdCBiYiA9IChtIC0gKGQgPj4gMSkpICYgTU9EX01BU0s7XG4gICAgY29uc3QgYWEgPSAoZCArIGJiIC0gQV9PRkZTRVQpICYgTU9EX01BU0s7XG4gICAgcmV0dXJuIHsgYTogYWEsIGI6IGJiIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gV2F2MkRlY29kZShidWZmZXIsIGosIG54LCBveCwgbnksIG95LCBteCkge1xuICAgIGNvbnN0IHcxNCA9IG14IDwgMSA8PCAxNDtcbiAgICBjb25zdCBuID0gbnggPiBueSA/IG55IDogbng7XG4gICAgbGV0IHAgPSAxO1xuICAgIGxldCBwMjtcbiAgICBsZXQgcHk7XG4gICAgd2hpbGUgKHAgPD0gbikge1xuICAgICAgICBwIDw8PSAxO1xuICAgIH1cbiAgICBwID4+PSAxO1xuICAgIHAyID0gcDtcbiAgICBwID4+PSAxO1xuICAgIHdoaWxlIChwID49IDEpIHtcbiAgICAgICAgcHkgPSAwO1xuICAgICAgICBjb25zdCBleSA9IHB5ICsgb3kgKiAobnkgLSBwMik7XG4gICAgICAgIGNvbnN0IG95MSA9IG95ICogcDtcbiAgICAgICAgY29uc3Qgb3kyID0gb3kgKiBwMjtcbiAgICAgICAgY29uc3Qgb3gxID0gb3ggKiBwO1xuICAgICAgICBjb25zdCBveDIgPSBveCAqIHAyO1xuICAgICAgICBsZXQgaTAwLCBpMDEsIGkxMCwgaTExO1xuICAgICAgICBmb3IgKDsgcHkgPD0gZXk7IHB5ICs9IG95Mikge1xuICAgICAgICAgICAgbGV0IHB4ID0gcHk7XG4gICAgICAgICAgICBjb25zdCBleCA9IHB5ICsgb3ggKiAobnggLSBwMik7XG4gICAgICAgICAgICBmb3IgKDsgcHggPD0gZXg7IHB4ICs9IG94Mikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAwMSA9IHB4ICsgb3gxO1xuICAgICAgICAgICAgICAgIGNvbnN0IHAxMCA9IHB4ICsgb3kxO1xuICAgICAgICAgICAgICAgIGNvbnN0IHAxMSA9IHAxMCArIG94MTtcbiAgICAgICAgICAgICAgICBpZiAodzE0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBXZGVjMTQoYnVmZmVyW3B4ICsgal0sIGJ1ZmZlcltwMTAgKyBqXSk7XG4gICAgICAgICAgICAgICAgICAgIGkwMCA9IHJlc3VsdC5hO1xuICAgICAgICAgICAgICAgICAgICBpMTAgPSByZXN1bHQuYjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gV2RlYzE0KGJ1ZmZlcltwMDEgKyBqXSwgYnVmZmVyW3AxMSArIGpdKTtcbiAgICAgICAgICAgICAgICAgICAgaTAxID0gcmVzdWx0LmE7XG4gICAgICAgICAgICAgICAgICAgIGkxMSA9IHJlc3VsdC5iO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBXZGVjMTQoaTAwLCBpMDEpO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbcHggKyBqXSA9IHJlc3VsdC5hO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbcDAxICsgal0gPSByZXN1bHQuYjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gV2RlYzE0KGkxMCwgaTExKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW3AxMCArIGpdID0gcmVzdWx0LmE7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltwMTEgKyBqXSA9IHJlc3VsdC5iO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFdkZWMxNihidWZmZXJbcHggKyBqXSwgYnVmZmVyW3AxMCArIGpdKTtcbiAgICAgICAgICAgICAgICAgICAgaTAwID0gcmVzdWx0LmE7XG4gICAgICAgICAgICAgICAgICAgIGkxMCA9IHJlc3VsdC5iO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBXZGVjMTYoYnVmZmVyW3AwMSArIGpdLCBidWZmZXJbcDExICsgal0pO1xuICAgICAgICAgICAgICAgICAgICBpMDEgPSByZXN1bHQuYTtcbiAgICAgICAgICAgICAgICAgICAgaTExID0gcmVzdWx0LmI7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFdkZWMxNihpMDAsIGkwMSk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltweCArIGpdID0gcmVzdWx0LmE7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltwMDEgKyBqXSA9IHJlc3VsdC5iO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBXZGVjMTYoaTEwLCBpMTEpO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbcDEwICsgal0gPSByZXN1bHQuYTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW3AxMSArIGpdID0gcmVzdWx0LmI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG54ICYgcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAxMCA9IHB4ICsgb3kxO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHcxNCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBXZGVjMTQoYnVmZmVyW3B4ICsgal0sIGJ1ZmZlcltwMTAgKyBqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBXZGVjMTYoYnVmZmVyW3B4ICsgal0sIGJ1ZmZlcltwMTAgKyBqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkwMCA9IHJlc3VsdC5hO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltwMTAgKyBqXSA9IHJlc3VsdC5iO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltweCArIGpdID0gaTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChueSAmIHApIHtcbiAgICAgICAgICAgIGxldCBweCA9IHB5O1xuICAgICAgICAgICAgY29uc3QgZXggPSBweSArIG94ICogKG54IC0gcDIpO1xuICAgICAgICAgICAgZm9yICg7IHB4IDw9IGV4OyBweCArPSBveDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwMDEgPSBweCArIG94MTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICh3MTQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gV2RlYzE0KGJ1ZmZlcltweCArIGpdLCBidWZmZXJbcDAxICsgal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gV2RlYzE2KGJ1ZmZlcltweCArIGpdLCBidWZmZXJbcDAxICsgal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpMDAgPSByZXN1bHQuYTtcbiAgICAgICAgICAgICAgICBidWZmZXJbcDAxICsgal0gPSByZXN1bHQuYjtcbiAgICAgICAgICAgICAgICBidWZmZXJbcHggKyBqXSA9IGkwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwMiA9IHA7XG4gICAgICAgIHAgPj49IDE7XG4gICAgfVxuICAgIHJldHVybiBweTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBBcHBseUx1dChsdXQsIGRhdGEsIG5EYXRhKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuRGF0YTsgKytpKSB7XG4gICAgICAgIGRhdGFbaV0gPSBsdXRbZGF0YVtpXV07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhyTG9hZGVyLmNvbXByZXNzaW9uLmh1Zi5qcy5tYXAiLCJpbXBvcnQgeyBBcHBseUx1dCwgSHVmVW5jb21wcmVzcywgUmV2ZXJzZUx1dEZyb21CaXRtYXAsIFdhdjJEZWNvZGUgfSBmcm9tIFwiLi9leHJMb2FkZXIuY29tcHJlc3Npb24uaHVmLmpzXCI7XG5pbXBvcnQgeyBEZWNvZGVSdW5MZW5ndGggfSBmcm9tIFwiLi9leHJMb2FkZXIuY29tcHJlc3Npb24ucmxlLmpzXCI7XG5pbXBvcnQgeyBJbnRlcmxlYXZlU2NhbGFyLCBQYXJzZVVpbnQxNiwgUGFyc2VVaW50MzIsIFBhcnNlVWludDgsIFByZWRpY3RvciB9IGZyb20gXCIuL2V4ckxvYWRlci5jb3JlLmpzXCI7XG5pbXBvcnQgeyBCSVRNQVBfU0laRSwgSU5UMTZfU0laRSwgVVNIT1JUX1JBTkdFIH0gZnJvbSBcIi4vZXhyTG9hZGVyLmludGVyZmFjZXMuanNcIjtcbi8qKlxuICogTm8gY29tcHJlc3Npb25cbiAqIEBwYXJhbSBkZWNvZGVyIGRlZmluZXMgdGhlIGRlY29kZXIgdG8gdXNlXG4gKiBAcmV0dXJucyBhIGRlY29tcHJlc3NlZCBkYXRhIHZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFVuY29tcHJlc3NSQVcoZGVjb2Rlcikge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoZGVjb2Rlci5hcnJheS5idWZmZXIsIGRlY29kZXIub2Zmc2V0LnZhbHVlLCBkZWNvZGVyLnNpemUpO1xufVxuLyoqXG4gKiBSTEUgY29tcHJlc3Npb25cbiAqIEBwYXJhbSBkZWNvZGVyIGRlZmluZXMgdGhlIGRlY29kZXIgdG8gdXNlXG4gKiBAcmV0dXJucyBhIGRlY29tcHJlc3NlZCBkYXRhIHZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFVuY29tcHJlc3NSTEUoZGVjb2Rlcikge1xuICAgIGNvbnN0IGNvbXByZXNzZWQgPSBkZWNvZGVyLnZpZXdlci5idWZmZXIuc2xpY2UoZGVjb2Rlci5vZmZzZXQudmFsdWUsIGRlY29kZXIub2Zmc2V0LnZhbHVlICsgZGVjb2Rlci5zaXplKTtcbiAgICBjb25zdCByYXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShEZWNvZGVSdW5MZW5ndGgoY29tcHJlc3NlZCkpO1xuICAgIGNvbnN0IHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHJhd0J1ZmZlci5sZW5ndGgpO1xuICAgIFByZWRpY3RvcihyYXdCdWZmZXIpO1xuICAgIEludGVybGVhdmVTY2FsYXIocmF3QnVmZmVyLCB0bXBCdWZmZXIpO1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG59XG4vKipcbiAqIFppcCBjb21wcmVzc2lvblxuICogQHBhcmFtIGRlY29kZXIgZGVmaW5lcyB0aGUgZGVjb2RlciB0byB1c2VcbiAqIEByZXR1cm5zIGEgZGVjb21wcmVzc2VkIGRhdGEgdmlld1xuICovXG5leHBvcnQgZnVuY3Rpb24gVW5jb21wcmVzc1pJUChkZWNvZGVyKSB7XG4gICAgY29uc3QgY29tcHJlc3NlZCA9IGRlY29kZXIuYXJyYXkuc2xpY2UoZGVjb2Rlci5vZmZzZXQudmFsdWUsIGRlY29kZXIub2Zmc2V0LnZhbHVlICsgZGVjb2Rlci5zaXplKTtcbiAgICBjb25zdCByYXdCdWZmZXIgPSBmZmxhdGUudW56bGliU3luYyhjb21wcmVzc2VkKTtcbiAgICBjb25zdCB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShyYXdCdWZmZXIubGVuZ3RoKTtcbiAgICBQcmVkaWN0b3IocmF3QnVmZmVyKTtcbiAgICBJbnRlcmxlYXZlU2NhbGFyKHJhd0J1ZmZlciwgdG1wQnVmZmVyKTtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xufVxuLyoqXG4gKiBQWFIgY29tcHJlc3Npb25cbiAqIEBwYXJhbSBkZWNvZGVyIGRlZmluZXMgdGhlIGRlY29kZXIgdG8gdXNlXG4gKiBAcmV0dXJucyBhIGRlY29tcHJlc3NlZCBkYXRhIHZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFVuY29tcHJlc3NQWFIoZGVjb2Rlcikge1xuICAgIGNvbnN0IGNvbXByZXNzZWQgPSBkZWNvZGVyLmFycmF5LnNsaWNlKGRlY29kZXIub2Zmc2V0LnZhbHVlLCBkZWNvZGVyLm9mZnNldC52YWx1ZSArIGRlY29kZXIuc2l6ZSk7XG4gICAgY29uc3QgcmF3QnVmZmVyID0gZmZsYXRlLnVuemxpYlN5bmMoY29tcHJlc3NlZCk7XG4gICAgY29uc3Qgc3ogPSBkZWNvZGVyLmxpbmVzICogZGVjb2Rlci5jaGFubmVscyAqIGRlY29kZXIud2lkdGg7XG4gICAgY29uc3QgdG1wQnVmZmVyID0gZGVjb2Rlci50eXBlID09IDEgPyBuZXcgVWludDE2QXJyYXkoc3opIDogbmV3IFVpbnQzMkFycmF5KHN6KTtcbiAgICBsZXQgdG1wQnVmZmVyRW5kID0gMDtcbiAgICBsZXQgd3JpdGVQdHIgPSAwO1xuICAgIGNvbnN0IHB0ciA9IG5ldyBBcnJheSg0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGRlY29kZXIubGluZXM7IHkrKykge1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGRlY29kZXIuY2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgICAgbGV0IHBpeGVsID0gMDtcbiAgICAgICAgICAgIHN3aXRjaCAoZGVjb2Rlci50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBwdHJbMF0gPSB0bXBCdWZmZXJFbmQ7XG4gICAgICAgICAgICAgICAgICAgIHB0clsxXSA9IHB0clswXSArIGRlY29kZXIud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHRtcEJ1ZmZlckVuZCA9IHB0clsxXSArIGRlY29kZXIud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGVjb2Rlci53aWR0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gKHJhd0J1ZmZlcltwdHJbMF0rK10gPDwgOCkgfCByYXdCdWZmZXJbcHRyWzFdKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWwgKz0gZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcEJ1ZmZlclt3cml0ZVB0cl0gPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlUHRyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBwdHJbMF0gPSB0bXBCdWZmZXJFbmQ7XG4gICAgICAgICAgICAgICAgICAgIHB0clsxXSA9IHB0clswXSArIGRlY29kZXIud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHB0clsyXSA9IHB0clsxXSArIGRlY29kZXIud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHRtcEJ1ZmZlckVuZCA9IHB0clsyXSArIGRlY29kZXIud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGVjb2Rlci53aWR0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gKHJhd0J1ZmZlcltwdHJbMF0rK10gPDwgMjQpIHwgKHJhd0J1ZmZlcltwdHJbMV0rK10gPDwgMTYpIHwgKHJhd0J1ZmZlcltwdHJbMl0rK10gPDwgOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbCArPSBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wQnVmZmVyW3dyaXRlUHRyXSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xufVxuLyoqXG4gKiBQSVogY29tcHJlc3Npb25cbiAqIEBwYXJhbSBkZWNvZGVyIGRlZmluZXMgdGhlIGRlY29kZXIgdG8gdXNlXG4gKiBAcmV0dXJucyBhIGRlY29tcHJlc3NlZCBkYXRhIHZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFVuY29tcHJlc3NQSVooZGVjb2Rlcikge1xuICAgIGNvbnN0IGluRGF0YVZpZXcgPSBkZWNvZGVyLnZpZXdlcjtcbiAgICBjb25zdCBpbk9mZnNldCA9IHsgdmFsdWU6IGRlY29kZXIub2Zmc2V0LnZhbHVlIH07XG4gICAgY29uc3Qgb3V0QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGRlY29kZXIud2lkdGggKiBkZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplICogKGRlY29kZXIuY2hhbm5lbHMgKiBkZWNvZGVyLnR5cGUpKTtcbiAgICBjb25zdCBiaXRtYXAgPSBuZXcgVWludDhBcnJheShCSVRNQVBfU0laRSk7XG4gICAgLy8gU2V0dXAgY2hhbm5lbCBpbmZvXG4gICAgbGV0IG91dEJ1ZmZlckVuZCA9IDA7XG4gICAgY29uc3QgcGl6Q2hhbm5lbERhdGEgPSBuZXcgQXJyYXkoZGVjb2Rlci5jaGFubmVscyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVyLmNoYW5uZWxzOyBpKyspIHtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV0gPSB7fTtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJzdGFydFwiXSA9IG91dEJ1ZmZlckVuZDtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJlbmRcIl0gPSBwaXpDaGFubmVsRGF0YVtpXVtcInN0YXJ0XCJdO1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcIm54XCJdID0gZGVjb2Rlci53aWR0aDtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJueVwiXSA9IGRlY29kZXIubGluZXM7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wic2l6ZVwiXSA9IGRlY29kZXIudHlwZTtcbiAgICAgICAgb3V0QnVmZmVyRW5kICs9IHBpekNoYW5uZWxEYXRhW2ldLm54ICogcGl6Q2hhbm5lbERhdGFbaV0ubnkgKiBwaXpDaGFubmVsRGF0YVtpXS5zaXplO1xuICAgIH1cbiAgICAvLyBSZWFkIHJhbmdlIGNvbXByZXNzaW9uIGRhdGFcbiAgICBjb25zdCBtaW5Ob25aZXJvID0gUGFyc2VVaW50MTYoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgIGNvbnN0IG1heE5vblplcm8gPSBQYXJzZVVpbnQxNihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgaWYgKG1heE5vblplcm8gPj0gQklUTUFQX1NJWkUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgUElaX0NPTVBSRVNTSU9OIEJJVE1BUF9TSVpFXCIpO1xuICAgIH1cbiAgICBpZiAobWluTm9uWmVybyA8PSBtYXhOb25aZXJvKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4Tm9uWmVybyAtIG1pbk5vblplcm8gKyAxOyBpKyspIHtcbiAgICAgICAgICAgIGJpdG1hcFtpICsgbWluTm9uWmVyb10gPSBQYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXZlcnNlIExVVFxuICAgIGNvbnN0IGx1dCA9IG5ldyBVaW50MTZBcnJheShVU0hPUlRfUkFOR0UpO1xuICAgIGNvbnN0IG1heFZhbHVlID0gUmV2ZXJzZUx1dEZyb21CaXRtYXAoYml0bWFwLCBsdXQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IFBhcnNlVWludDMyKGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAvLyBIdWZmbWFuIGRlY29kaW5nXG4gICAgSHVmVW5jb21wcmVzcyhkZWNvZGVyLmFycmF5LCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbGVuZ3RoLCBvdXRCdWZmZXIsIG91dEJ1ZmZlckVuZCk7XG4gICAgLy8gV2F2ZWxldCBkZWNvZGluZ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2Rlci5jaGFubmVsczsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNkID0gcGl6Q2hhbm5lbERhdGFbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGl6Q2hhbm5lbERhdGFbaV0uc2l6ZTsgKytqKSB7XG4gICAgICAgICAgICBXYXYyRGVjb2RlKG91dEJ1ZmZlciwgY2Quc3RhcnQgKyBqLCBjZC5ueCwgY2Quc2l6ZSwgY2QubnksIGNkLm54ICogY2Quc2l6ZSwgbWF4VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEV4cGFuZCB0aGUgcGl4ZWwgZGF0YSB0byB0aGVpciBvcmlnaW5hbCByYW5nZVxuICAgIEFwcGx5THV0KGx1dCwgb3V0QnVmZmVyLCBvdXRCdWZmZXJFbmQpO1xuICAgIC8vIFJlYXJyYW5nZSB0aGUgcGl4ZWwgZGF0YSBpbnRvIHRoZSBmb3JtYXQgZXhwZWN0ZWQgYnkgdGhlIGNhbGxlci5cbiAgICBsZXQgdG1wT2Zmc2V0ID0gMDtcbiAgICBjb25zdCB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShvdXRCdWZmZXIuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgZGVjb2Rlci5saW5lczsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgZGVjb2Rlci5jaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZCA9IHBpekNoYW5uZWxEYXRhW2NdO1xuICAgICAgICAgICAgY29uc3QgbiA9IGNkLm54ICogY2Quc2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGNwID0gbmV3IFVpbnQ4QXJyYXkob3V0QnVmZmVyLmJ1ZmZlciwgY2QuZW5kICogSU5UMTZfU0laRSwgbiAqIElOVDE2X1NJWkUpO1xuICAgICAgICAgICAgdG1wQnVmZmVyLnNldChjcCwgdG1wT2Zmc2V0KTtcbiAgICAgICAgICAgIHRtcE9mZnNldCArPSBuICogSU5UMTZfU0laRTtcbiAgICAgICAgICAgIGNkLmVuZCArPSBuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHJMb2FkZXIuY29tcHJlc3Npb24uanMubWFwIiwiLyoqXG4gKiBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vc2NpZWNvZGUvdGhyZWUuanMvYmxvYi9kZXYvZXhhbXBsZXMvanNtL2xvYWRlcnMvRVhSTG9hZGVyLmpzXG4gKiBSZWZlcnJlZCB0byB0aGUgb3JpZ2luYWwgSW5kdXN0cmlhbCBMaWdodCAmIE1hZ2ljIE9wZW5FWFIgaW1wbGVtZW50YXRpb24gYW5kIHRoZSBUaW55RVhSIC8gU3lveW8gRnVqaXRhXG4gKiBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuLy8gLypcbi8vIENvcHlyaWdodCAoYykgMjAxNCAtIDIwMTcsIFN5b3lvIEZ1aml0YVxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4vLyAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbi8vICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4vLyAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBTeW95byBGdWppdGEgbm9yIHRoZVxuLy8gICAgICAgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbi8vICAgICAgIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG4vLyBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuLy8gV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuLy8gRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4vLyBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuLy8gKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuLy8gTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4vLyBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbi8vIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLy8gKi9cbi8vIC8vIFRpbnlFWFIgY29udGFpbnMgc29tZSBPcGVuRVhSIGNvZGUsIHdoaWNoIGlzIGxpY2Vuc2VkIHVuZGVyIC0tLS0tLS0tLS0tLVxuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyAvL1xuLy8gLy8gQ29weXJpZ2h0IChjKSAyMDAyLCBJbmR1c3RyaWFsIExpZ2h0ICYgTWFnaWMsIGEgZGl2aXNpb24gb2YgTHVjYXNcbi8vIC8vIERpZ2l0YWwgTHRkLiBMTENcbi8vIC8vXG4vLyAvLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gLy9cbi8vIC8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gLy8gbWV0OlxuLy8gLy8gKiAgICAgICBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gLy8gKiAgICAgICBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyAvLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyAvLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyAvLyBkaXN0cmlidXRpb24uXG4vLyAvLyAqICAgICAgIE5laXRoZXIgdGhlIG5hbWUgb2YgSW5kdXN0cmlhbCBMaWdodCAmIE1hZ2ljIG5vciB0aGUgbmFtZXMgb2Zcbi8vIC8vIGl0cyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbi8vIC8vIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vIC8vXG4vLyAvLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyAvLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyAvLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIC8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyAvLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIC8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIC8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyAvLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAvLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIC8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vLyAvL1xuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyAvLyBFbmQgb2YgT3BlbkVYUiBsaWNlbnNlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBEZWNvZGVSdW5MZW5ndGgoc291cmNlKSB7XG4gICAgbGV0IHNpemUgPSBzb3VyY2UuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcCA9IDA7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IERhdGFWaWV3KHNvdXJjZSk7XG4gICAgd2hpbGUgKHNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGwgPSByZWFkZXIuZ2V0SW50OChwKyspO1xuICAgICAgICBpZiAobCA8IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gLWw7XG4gICAgICAgICAgICBzaXplIC09IGNvdW50ICsgMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHJlYWRlci5nZXRVaW50OChwKyspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gbDtcbiAgICAgICAgICAgIHNpemUgLT0gMjtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVhZGVyLmdldFVpbnQ4KHArKyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHJMb2FkZXIuY29tcHJlc3Npb24ucmxlLmpzLm1hcCIsImV4cG9ydCB2YXIgRVhST3V0cHV0VHlwZTtcbihmdW5jdGlvbiAoRVhST3V0cHV0VHlwZSkge1xuICAgIEVYUk91dHB1dFR5cGVbRVhST3V0cHV0VHlwZVtcIkZsb2F0XCJdID0gMF0gPSBcIkZsb2F0XCI7XG4gICAgRVhST3V0cHV0VHlwZVtFWFJPdXRwdXRUeXBlW1wiSGFsZkZsb2F0XCJdID0gMV0gPSBcIkhhbGZGbG9hdFwiO1xufSkoRVhST3V0cHV0VHlwZSB8fCAoRVhST3V0cHV0VHlwZSA9IHt9KSk7XG4vKipcbiAqIENsYXNzIHVzZWQgdG8gc3RvcmUgY29uZmlndXJhdGlvbiBvZiB0aGUgZXhyIGxvYWRlclxuICovXG5leHBvcnQgY2xhc3MgRXhyTG9hZGVyR2xvYmFsQ29uZmlndXJhdGlvbiB7XG59XG4vKipcbiAqIERlZmluZXMgdGhlIGRlZmF1bHQgb3V0cHV0IHR5cGUgdG8gdXNlIChIYWxmIGZsb2F0IGJ5IGRlZmF1bHQpXG4gKi9cbkV4ckxvYWRlckdsb2JhbENvbmZpZ3VyYXRpb24uRGVmYXVsdE91dHB1dFR5cGUgPSBFWFJPdXRwdXRUeXBlLkhhbGZGbG9hdDtcbi8qKlxuICogVXJsIHRvIHVzZSB0byBsb2FkIHRoZSBmZmxhdGUgbGlicmFyeSAoZm9yIHppcCBkZWNvbXByZXNzaW9uKVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FeHJMb2FkZXJHbG9iYWxDb25maWd1cmF0aW9uLkZGTEFURVVybCA9IFwiaHR0cHM6Ly91bnBrZy5jb20vZmZsYXRlQDAuOC4yXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHJMb2FkZXIuY29uZmlndXJhdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBDbGFtcCB9IGZyb20gXCIuLi8uLi8uLi8uLi9NYXRocy9tYXRoLnNjYWxhci5mdW5jdGlvbnMuanNcIjtcbmltcG9ydCB7IEZMT0FUMzJfU0laRSwgSU5UMTZfU0laRSwgSU5UMzJfU0laRSwgSU5UOF9TSVpFLCBVTE9OR19TSVpFIH0gZnJvbSBcIi4vZXhyTG9hZGVyLmludGVyZmFjZXMuanNcIjtcbi8qKlxuICogSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL3NjaWVjb2RlL3RocmVlLmpzL2Jsb2IvZGV2L2V4YW1wbGVzL2pzbS9sb2FkZXJzL0VYUkxvYWRlci5qc1xuICogUmVmZXJyZWQgdG8gdGhlIG9yaWdpbmFsIEluZHVzdHJpYWwgTGlnaHQgJiBNYWdpYyBPcGVuRVhSIGltcGxlbWVudGF0aW9uIGFuZCB0aGUgVGlueUVYUiAvIFN5b3lvIEZ1aml0YVxuICogaW1wbGVtZW50YXRpb24uXG4gKi9cbi8vIC8qXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQgLSAyMDE3LCBTeW95byBGdWppdGFcbi8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuLy8gICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4vLyAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuLy8gICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgU3lveW8gRnVqaXRhIG5vciB0aGVcbi8vICAgICAgIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4vLyAgICAgICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuLy8gQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbi8vIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbi8vIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuLy8gRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbi8vIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbi8vIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuLy8gT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4vLyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vICovXG4vLyAvLyBUaW55RVhSIGNvbnRhaW5zIHNvbWUgT3BlbkVYUiBjb2RlLCB3aGljaCBpcyBsaWNlbnNlZCB1bmRlciAtLS0tLS0tLS0tLS1cbi8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gLy9cbi8vIC8vIENvcHlyaWdodCAoYykgMjAwMiwgSW5kdXN0cmlhbCBMaWdodCAmIE1hZ2ljLCBhIGRpdmlzaW9uIG9mIEx1Y2FzXG4vLyAvLyBEaWdpdGFsIEx0ZC4gTExDXG4vLyAvL1xuLy8gLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIC8vXG4vLyAvLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIC8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIC8vIG1ldDpcbi8vIC8vICogICAgICAgUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIC8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vIC8vICogICAgICAgUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuLy8gLy8gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuLy8gLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuLy8gLy8gZGlzdHJpYnV0aW9uLlxuLy8gLy8gKiAgICAgICBOZWl0aGVyIHRoZSBuYW1lIG9mIEluZHVzdHJpYWwgTGlnaHQgJiBNYWdpYyBub3IgdGhlIG5hbWVzIG9mXG4vLyAvLyBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4vLyAvLyBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vLyAvL1xuLy8gLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyAvLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyAvLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyAvLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIC8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyAvLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLy8gLy9cbi8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gLy8gRW5kIG9mIE9wZW5FWFIgbGljZW5zZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQgdmFyIENvbXByZXNzaW9uQ29kZXM7XG4oZnVuY3Rpb24gKENvbXByZXNzaW9uQ29kZXMpIHtcbiAgICBDb21wcmVzc2lvbkNvZGVzW0NvbXByZXNzaW9uQ29kZXNbXCJOT19DT01QUkVTU0lPTlwiXSA9IDBdID0gXCJOT19DT01QUkVTU0lPTlwiO1xuICAgIENvbXByZXNzaW9uQ29kZXNbQ29tcHJlc3Npb25Db2Rlc1tcIlJMRV9DT01QUkVTU0lPTlwiXSA9IDFdID0gXCJSTEVfQ09NUFJFU1NJT05cIjtcbiAgICBDb21wcmVzc2lvbkNvZGVzW0NvbXByZXNzaW9uQ29kZXNbXCJaSVBTX0NPTVBSRVNTSU9OXCJdID0gMl0gPSBcIlpJUFNfQ09NUFJFU1NJT05cIjtcbiAgICBDb21wcmVzc2lvbkNvZGVzW0NvbXByZXNzaW9uQ29kZXNbXCJaSVBfQ09NUFJFU1NJT05cIl0gPSAzXSA9IFwiWklQX0NPTVBSRVNTSU9OXCI7XG4gICAgQ29tcHJlc3Npb25Db2Rlc1tDb21wcmVzc2lvbkNvZGVzW1wiUElaX0NPTVBSRVNTSU9OXCJdID0gNF0gPSBcIlBJWl9DT01QUkVTU0lPTlwiO1xuICAgIENvbXByZXNzaW9uQ29kZXNbQ29tcHJlc3Npb25Db2Rlc1tcIlBYUjI0X0NPTVBSRVNTSU9OXCJdID0gNV0gPSBcIlBYUjI0X0NPTVBSRVNTSU9OXCI7XG59KShDb21wcmVzc2lvbkNvZGVzIHx8IChDb21wcmVzc2lvbkNvZGVzID0ge30pKTtcbnZhciBMaW5lT3JkZXJzO1xuKGZ1bmN0aW9uIChMaW5lT3JkZXJzKSB7XG4gICAgTGluZU9yZGVyc1tMaW5lT3JkZXJzW1wiSU5DUkVBU0lOR19ZXCJdID0gMF0gPSBcIklOQ1JFQVNJTkdfWVwiO1xuICAgIExpbmVPcmRlcnNbTGluZU9yZGVyc1tcIkRFQ1JFQVNJTkdfWVwiXSA9IDFdID0gXCJERUNSRUFTSU5HX1lcIjtcbn0pKExpbmVPcmRlcnMgfHwgKExpbmVPcmRlcnMgPSB7fSkpO1xuY29uc3QgVGFibGVzID0gR2VuZXJhdGVUYWJsZXMoKTtcbi8vIEZhc3QgSGFsZiBGbG9hdCBDb252ZXJzaW9ucywgaHR0cDovL3d3dy5mb3gtdG9vbGtpdC5vcmcvZnRwL2Zhc3RoYWxmZmxvYXRjb252ZXJzaW9uLnBkZlxuZnVuY3Rpb24gR2VuZXJhdGVUYWJsZXMoKSB7XG4gICAgLy8gZmxvYXQzMiB0byBmbG9hdDE2IGhlbHBlcnNcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gICAgY29uc3QgZmxvYXRWaWV3ID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IHVpbnQzMlZpZXcgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBiYXNlVGFibGUgPSBuZXcgVWludDMyQXJyYXkoNTEyKTtcbiAgICBjb25zdCBzaGlmdFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KDUxMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICBjb25zdCBlID0gaSAtIDEyNztcbiAgICAgICAgLy8gdmVyeSBzbWFsbCBudW1iZXIgKDAsIC0wKVxuICAgICAgICBpZiAoZSA8IC0yNykge1xuICAgICAgICAgICAgYmFzZVRhYmxlW2ldID0gMHgwMDAwO1xuICAgICAgICAgICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAweDgwMDA7XG4gICAgICAgICAgICBzaGlmdFRhYmxlW2ldID0gMjQ7XG4gICAgICAgICAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAyNDtcbiAgICAgICAgICAgIC8vIHNtYWxsIG51bWJlciAoZGVub3JtKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUgPCAtMTQpIHtcbiAgICAgICAgICAgIGJhc2VUYWJsZVtpXSA9IDB4MDQwMCA+PiAoLWUgLSAxNCk7XG4gICAgICAgICAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9ICgweDA0MDAgPj4gKC1lIC0gMTQpKSB8IDB4ODAwMDtcbiAgICAgICAgICAgIHNoaWZ0VGFibGVbaV0gPSAtZSAtIDE7XG4gICAgICAgICAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAtZSAtIDE7XG4gICAgICAgICAgICAvLyBub3JtYWwgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZSA8PSAxNSkge1xuICAgICAgICAgICAgYmFzZVRhYmxlW2ldID0gKGUgKyAxNSkgPDwgMTA7XG4gICAgICAgICAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9ICgoZSArIDE1KSA8PCAxMCkgfCAweDgwMDA7XG4gICAgICAgICAgICBzaGlmdFRhYmxlW2ldID0gMTM7XG4gICAgICAgICAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAxMztcbiAgICAgICAgICAgIC8vIGxhcmdlIG51bWJlciAoSW5maW5pdHksIC1JbmZpbml0eSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlIDwgMTI4KSB7XG4gICAgICAgICAgICBiYXNlVGFibGVbaV0gPSAweDdjMDA7XG4gICAgICAgICAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9IDB4ZmMwMDtcbiAgICAgICAgICAgIHNoaWZ0VGFibGVbaV0gPSAyNDtcbiAgICAgICAgICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDI0O1xuICAgICAgICAgICAgLy8gc3RheSAoTmFOLCBJbmZpbml0eSwgLUluZmluaXR5KVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmFzZVRhYmxlW2ldID0gMHg3YzAwO1xuICAgICAgICAgICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAweGZjMDA7XG4gICAgICAgICAgICBzaGlmdFRhYmxlW2ldID0gMTM7XG4gICAgICAgICAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAxMztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBmbG9hdDE2IHRvIGZsb2F0MzIgaGVscGVyc1xuICAgIGNvbnN0IG1hbnRpc3NhVGFibGUgPSBuZXcgVWludDMyQXJyYXkoMjA0OCk7XG4gICAgY29uc3QgZXhwb25lbnRUYWJsZSA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG4gICAgY29uc3Qgb2Zmc2V0VGFibGUgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMTAyNDsgKytpKSB7XG4gICAgICAgIGxldCBtID0gaSA8PCAxMzsgLy8gemVybyBwYWQgbWFudGlzc2EgYml0c1xuICAgICAgICBsZXQgZSA9IDA7IC8vIHplcm8gZXhwb25lbnRcbiAgICAgICAgLy8gbm9ybWFsaXplZFxuICAgICAgICB3aGlsZSAoKG0gJiAweDAwODAwMDAwKSA9PT0gMCkge1xuICAgICAgICAgICAgbSA8PD0gMTtcbiAgICAgICAgICAgIGUgLT0gMHgwMDgwMDAwMDsgLy8gZGVjcmVtZW50IGV4cG9uZW50XG4gICAgICAgIH1cbiAgICAgICAgbSAmPSB+MHgwMDgwMDAwMDsgLy8gY2xlYXIgbGVhZGluZyAxIGJpdFxuICAgICAgICBlICs9IDB4Mzg4MDAwMDA7IC8vIGFkanVzdCBiaWFzXG4gICAgICAgIG1hbnRpc3NhVGFibGVbaV0gPSBtIHwgZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDEwMjQ7IGkgPCAyMDQ4OyArK2kpIHtcbiAgICAgICAgbWFudGlzc2FUYWJsZVtpXSA9IDB4MzgwMDAwMDAgKyAoKGkgLSAxMDI0KSA8PCAxMyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMzE7ICsraSkge1xuICAgICAgICBleHBvbmVudFRhYmxlW2ldID0gaSA8PCAyMztcbiAgICB9XG4gICAgZXhwb25lbnRUYWJsZVszMV0gPSAweDQ3ODAwMDAwO1xuICAgIGV4cG9uZW50VGFibGVbMzJdID0gMHg4MDAwMDAwMDtcbiAgICBmb3IgKGxldCBpID0gMzM7IGkgPCA2MzsgKytpKSB7XG4gICAgICAgIGV4cG9uZW50VGFibGVbaV0gPSAweDgwMDAwMDAwICsgKChpIC0gMzIpIDw8IDIzKTtcbiAgICB9XG4gICAgZXhwb25lbnRUYWJsZVs2M10gPSAweGM3ODAwMDAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICBpZiAoaSAhPT0gMzIpIHtcbiAgICAgICAgICAgIG9mZnNldFRhYmxlW2ldID0gMTAyNDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmbG9hdFZpZXc6IGZsb2F0VmlldyxcbiAgICAgICAgdWludDMyVmlldzogdWludDMyVmlldyxcbiAgICAgICAgYmFzZVRhYmxlOiBiYXNlVGFibGUsXG4gICAgICAgIHNoaWZ0VGFibGU6IHNoaWZ0VGFibGUsXG4gICAgICAgIG1hbnRpc3NhVGFibGU6IG1hbnRpc3NhVGFibGUsXG4gICAgICAgIGV4cG9uZW50VGFibGU6IGV4cG9uZW50VGFibGUsXG4gICAgICAgIG9mZnNldFRhYmxlOiBvZmZzZXRUYWJsZSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYXJzZSBhIG51bGwgdGVybWluYXRlZCBzdHJpbmcgZnJvbSB0aGUgYnVmZmVyXG4gKiBAcGFyYW0gYnVmZmVyIGJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEBwYXJhbSBvZmZzZXQgY3VycmVudCBvZmZzZXQgaW4gdGhlIGJ1ZmZlclxuICogQHJldHVybnMgYSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBjb25zdCB1aW50QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBsZXQgZW5kT2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAodWludEJ1ZmZlcltvZmZzZXQudmFsdWUgKyBlbmRPZmZzZXRdICE9IDApIHtcbiAgICAgICAgZW5kT2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnRCdWZmZXIuc2xpY2Uob2Zmc2V0LnZhbHVlLCBvZmZzZXQudmFsdWUgKyBlbmRPZmZzZXQpKTtcbiAgICBvZmZzZXQudmFsdWUgPSBvZmZzZXQudmFsdWUgKyBlbmRPZmZzZXQgKyAxO1xuICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbn1cbi8qKlxuICogUGFyc2UgYW4gaW50MzIgZnJvbSB0aGUgYnVmZmVyXG4gKiBAcGFyYW0gZGF0YVZpZXcgZGF0YXZpZXcgb24gdGhlIGRhdGFcbiAqIEBwYXJhbSBvZmZzZXQgY3VycmVudCBvZmZzZXQgaW4gdGhlIGRhdGEgdmlld1xuICogQHJldHVybnMgYW4gaW50MzJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIGNvbnN0IHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MzIob2Zmc2V0LnZhbHVlLCB0cnVlKTtcbiAgICBvZmZzZXQudmFsdWUgKz0gSU5UMzJfU0laRTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIFBhcnNlIGFuIHVpbnQzMiBmcm9tIHRoZSBidWZmZXJcbiAqIEBwYXJhbSBkYXRhVmlldyBkYXRhIHZpZXcgdG8gcmVhZCBmcm9tXG4gKiBAcGFyYW0gb2Zmc2V0IG9mZnNldCBpbiB0aGUgZGF0YSB2aWV3XG4gKiBAcmV0dXJucyBhbiB1aW50MzJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQudmFsdWUsIHRydWUpO1xuICAgIG9mZnNldC52YWx1ZSArPSBJTlQzMl9TSVpFO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogUGFyc2UgYW4gdWludDggZnJvbSB0aGUgYnVmZmVyXG4gKiBAcGFyYW0gZGF0YVZpZXcgZGF0YXZpZXcgb24gdGhlIGRhdGFcbiAqIEBwYXJhbSBvZmZzZXQgY3VycmVudCBvZmZzZXQgaW4gdGhlIGRhdGEgdmlld1xuICogQHJldHVybnMgYW4gdWludDhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBhcnNlVWludDgoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIGNvbnN0IHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0LnZhbHVlKTtcbiAgICBvZmZzZXQudmFsdWUgKz0gSU5UOF9TSVpFO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogUGFyc2UgYW4gdWludDE2IGZyb20gdGhlIGJ1ZmZlclxuICogQHBhcmFtIGRhdGFWaWV3IGRhdGF2aWV3IG9uIHRoZSBkYXRhXG4gKiBAcGFyYW0gb2Zmc2V0IGN1cnJlbnQgb2Zmc2V0IGluIHRoZSBkYXRhIHZpZXdcbiAqIEByZXR1cm5zIGFuIHVpbnQxNlxuICovXG5leHBvcnQgZnVuY3Rpb24gUGFyc2VVaW50MTYoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIGNvbnN0IHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldC52YWx1ZSwgdHJ1ZSk7XG4gICAgb2Zmc2V0LnZhbHVlICs9IElOVDE2X1NJWkU7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBQYXJzZSBhbiB1aW50OCBmcm9tIGFuIGFycmF5IGJ1ZmZlclxuICogQHBhcmFtIGFycmF5IGFycmF5IGJ1ZmZlclxuICogQHBhcmFtIG9mZnNldCBjdXJyZW50IG9mZnNldCBpbiB0aGUgZGF0YSB2aWV3XG4gKiBAcmV0dXJucyBhbiB1aW50MTZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFBhcnNlVWludDhBcnJheShhcnJheSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBhcnJheVtvZmZzZXQudmFsdWVdO1xuICAgIG9mZnNldC52YWx1ZSArPSBJTlQ4X1NJWkU7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBQYXJzZSBhbiBpbnQ2NCBmcm9tIHRoZSBidWZmZXJcbiAqIEBwYXJhbSBkYXRhVmlldyBkYXRhdmlldyBvbiB0aGUgZGF0YVxuICogQHBhcmFtIG9mZnNldCBjdXJyZW50IG9mZnNldCBpbiB0aGUgZGF0YSB2aWV3XG4gKiBAcmV0dXJucyBhbiBpbnQ2NFxuICovXG5leHBvcnQgZnVuY3Rpb24gUGFyc2VJbnQ2NChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgbGV0IGludDtcbiAgICBpZiAoXCJnZXRCaWdJbnQ2NFwiIGluIERhdGFWaWV3LnByb3RvdHlwZSkge1xuICAgICAgICBpbnQgPSBOdW1iZXIoZGF0YVZpZXcuZ2V0QmlnSW50NjQob2Zmc2V0LnZhbHVlLCB0cnVlKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnQgPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0LnZhbHVlICsgNCwgdHJ1ZSkgKyBOdW1iZXIoZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldC52YWx1ZSwgdHJ1ZSkgPDwgMzIpO1xuICAgIH1cbiAgICBvZmZzZXQudmFsdWUgKz0gVUxPTkdfU0laRTtcbiAgICByZXR1cm4gaW50O1xufVxuLyoqXG4gKiBQYXJzZSBhIGZsb2F0MzIgZnJvbSB0aGUgYnVmZmVyXG4gKiBAcGFyYW0gZGF0YVZpZXcgZGF0YXZpZXcgb24gdGhlIGRhdGFcbiAqIEBwYXJhbSBvZmZzZXQgY3VycmVudCBvZmZzZXQgaW4gdGhlIGRhdGEgdmlld1xuICogQHJldHVybnMgYSBmbG9hdDMyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIGNvbnN0IHZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihvZmZzZXQudmFsdWUsIHRydWUpO1xuICAgIG9mZnNldC52YWx1ZSArPSBGTE9BVDMyX1NJWkU7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBQYXJzZSBhIGZsb2F0MTYgZnJvbSB0aGUgYnVmZmVyXG4gKiBAcGFyYW0gZGF0YVZpZXcgZGF0YXZpZXcgb24gdGhlIGRhdGFcbiAqIEBwYXJhbSBvZmZzZXQgY3VycmVudCBvZmZzZXQgaW4gdGhlIGRhdGEgdmlld1xuICogQHJldHVybnMgYSBmbG9hdDE2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQYXJzZUZsb2F0MTYoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBEZWNvZGVGbG9hdDE2KFBhcnNlVWludDE2KGRhdGFWaWV3LCBvZmZzZXQpKTtcbn1cbmZ1bmN0aW9uIERlY29kZUZsb2F0MTYoYmluYXJ5KSB7XG4gICAgY29uc3QgZXhwb25lbnQgPSAoYmluYXJ5ICYgMHg3YzAwKSA+PiAxMDtcbiAgICBjb25zdCBmcmFjdGlvbiA9IGJpbmFyeSAmIDB4MDNmZjtcbiAgICByZXR1cm4gKChiaW5hcnkgPj4gMTUgPyAtMSA6IDEpICpcbiAgICAgICAgKGV4cG9uZW50ID8gKGV4cG9uZW50ID09PSAweDFmID8gKGZyYWN0aW9uID8gTmFOIDogSW5maW5pdHkpIDogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNSkgKiAoMSArIGZyYWN0aW9uIC8gMHg0MDApKSA6IDYuMTAzNTE1NjI1ZS01ICogKGZyYWN0aW9uIC8gMHg0MDApKSk7XG59XG5mdW5jdGlvbiBUb0hhbGZGbG9hdCh2YWx1ZSkge1xuICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPiA2NTUwNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBvdXQgb2YgcmFuZ2UuQ29uc2lkZXIgdXNpbmcgZmxvYXQgaW5zdGVhZCBvZiBoYWxmLWZsb2F0LlwiKTtcbiAgICB9XG4gICAgdmFsdWUgPSBDbGFtcCh2YWx1ZSwgLTY1NTA0LCA2NTUwNCk7XG4gICAgVGFibGVzLmZsb2F0Vmlld1swXSA9IHZhbHVlO1xuICAgIGNvbnN0IGYgPSBUYWJsZXMudWludDMyVmlld1swXTtcbiAgICBjb25zdCBlID0gKGYgPj4gMjMpICYgMHgxZmY7XG4gICAgcmV0dXJuIFRhYmxlcy5iYXNlVGFibGVbZV0gKyAoKGYgJiAweDAwN2ZmZmZmKSA+PiBUYWJsZXMuc2hpZnRUYWJsZVtlXSk7XG59XG4vKipcbiAqIERlY29kZSBhIGZsb2F0MzIgZnJvbSB0aGUgYnVmZmVyXG4gKiBAcGFyYW0gZGF0YVZpZXcgZGF0YXZpZXcgb24gdGhlIGRhdGFcbiAqIEBwYXJhbSBvZmZzZXQgY3VycmVudCBvZmZzZXQgaW4gdGhlIGRhdGEgdmlld1xuICogQHJldHVybnMgYSBmbG9hdDMyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBEZWNvZGVGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gVG9IYWxmRmxvYXQoUGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpKTtcbn1cbmZ1bmN0aW9uIFBhcnNlRml4ZWRMZW5ndGhTdHJpbmcoYnVmZmVyLCBvZmZzZXQsIHNpemUpIHtcbiAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShuZXcgVWludDhBcnJheShidWZmZXIpLnNsaWNlKG9mZnNldC52YWx1ZSwgb2Zmc2V0LnZhbHVlICsgc2l6ZSkpO1xuICAgIG9mZnNldC52YWx1ZSA9IG9mZnNldC52YWx1ZSArIHNpemU7XG4gICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xufVxuZnVuY3Rpb24gUGFyc2VSYXRpb25hbChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgY29uc3QgeCA9IFBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgY29uc3QgeSA9IFBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIHJldHVybiBbeCwgeV07XG59XG5mdW5jdGlvbiBQYXJzZVRpbWVjb2RlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICBjb25zdCB4ID0gUGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgY29uc3QgeSA9IFBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIHJldHVybiBbeCwgeV07XG59XG5mdW5jdGlvbiBQYXJzZVYyZihkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgY29uc3QgeCA9IFBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICBjb25zdCB5ID0gUGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIHJldHVybiBbeCwgeV07XG59XG5mdW5jdGlvbiBQYXJzZVYzZihkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgY29uc3QgeCA9IFBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICBjb25zdCB5ID0gUGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIGNvbnN0IHogPSBQYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgcmV0dXJuIFt4LCB5LCB6XTtcbn1cbmZ1bmN0aW9uIFBhcnNlQ2hsaXN0KGRhdGFWaWV3LCBvZmZzZXQsIHNpemUpIHtcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IG9mZnNldC52YWx1ZTtcbiAgICBjb25zdCBjaGFubmVscyA9IFtdO1xuICAgIHdoaWxlIChvZmZzZXQudmFsdWUgPCBzdGFydE9mZnNldCArIHNpemUgLSAxKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBQYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGRhdGFWaWV3LmJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcGl4ZWxUeXBlID0gUGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcExpbmVhciA9IFBhcnNlVWludDgoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldC52YWx1ZSArPSAzOyAvLyByZXNlcnZlZCwgdGhyZWUgY2hhcnNcbiAgICAgICAgY29uc3QgeFNhbXBsaW5nID0gUGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgeVNhbXBsaW5nID0gUGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgY2hhbm5lbHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgcGl4ZWxUeXBlOiBwaXhlbFR5cGUsXG4gICAgICAgICAgICBwTGluZWFyOiBwTGluZWFyLFxuICAgICAgICAgICAgeFNhbXBsaW5nOiB4U2FtcGxpbmcsXG4gICAgICAgICAgICB5U2FtcGxpbmc6IHlTYW1wbGluZyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9mZnNldC52YWx1ZSArPSAxO1xuICAgIHJldHVybiBjaGFubmVscztcbn1cbmZ1bmN0aW9uIFBhcnNlQ2hyb21hdGljaXRpZXMoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIGNvbnN0IHJlZFggPSBQYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgY29uc3QgcmVkWSA9IFBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICBjb25zdCBncmVlblggPSBQYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgY29uc3QgZ3JlZW5ZID0gUGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIGNvbnN0IGJsdWVYID0gUGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIGNvbnN0IGJsdWVZID0gUGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIGNvbnN0IHdoaXRlWCA9IFBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICBjb25zdCB3aGl0ZVkgPSBQYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgcmV0dXJuIHsgcmVkWDogcmVkWCwgcmVkWTogcmVkWSwgZ3JlZW5YOiBncmVlblgsIGdyZWVuWTogZ3JlZW5ZLCBibHVlWDogYmx1ZVgsIGJsdWVZOiBibHVlWSwgd2hpdGVYOiB3aGl0ZVgsIHdoaXRlWTogd2hpdGVZIH07XG59XG5mdW5jdGlvbiBQYXJzZUNvbXByZXNzaW9uKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gUGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIFBhcnNlQm94MmkoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIGNvbnN0IHhNaW4gPSBQYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIGNvbnN0IHlNaW4gPSBQYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIGNvbnN0IHhNYXggPSBQYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIGNvbnN0IHlNYXggPSBQYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIHJldHVybiB7IHhNaW46IHhNaW4sIHlNaW46IHlNaW4sIHhNYXg6IHhNYXgsIHlNYXg6IHlNYXggfTtcbn1cbmZ1bmN0aW9uIFBhcnNlTGluZU9yZGVyKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICBjb25zdCBsaW5lT3JkZXIgPSBQYXJzZVVpbnQ4KGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgIHJldHVybiBMaW5lT3JkZXJzW2xpbmVPcmRlcl07XG59XG4vKipcbiAqIFBhcnNlIGEgdmFsdWUgZnJvbSB0aGUgZGF0YSB2aWV3XG4gKiBAcGFyYW0gZGF0YVZpZXcgZGVmaW5lcyB0aGUgZGF0YSB2aWV3IHRvIHJlYWQgZnJvbVxuICogQHBhcmFtIG9mZnNldCBkZWZpbmVzIHRoZSBjdXJyZW50IG9mZnNldCBpbiB0aGUgZGF0YSB2aWV3XG4gKiBAcGFyYW0gdHlwZSBkZWZpbmVzIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byByZWFkXG4gKiBAcGFyYW0gc2l6ZSBkZWZpbmVzIHRoZSBzaXplIG9mIHRoZSB2YWx1ZSB0byByZWFkXG4gKiBAcmV0dXJucyB0aGUgcGFyc2VkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQYXJzZVZhbHVlKGRhdGFWaWV3LCBvZmZzZXQsIHR5cGUsIHNpemUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwic3RyaW5ndmVjdG9yXCI6XG4gICAgICAgIGNhc2UgXCJpY2NQcm9maWxlXCI6XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VGaXhlZExlbmd0aFN0cmluZyhkYXRhVmlldy5idWZmZXIsIG9mZnNldCwgc2l6ZSk7XG4gICAgICAgIGNhc2UgXCJjaGxpc3RcIjpcbiAgICAgICAgICAgIHJldHVybiBQYXJzZUNobGlzdChkYXRhVmlldywgb2Zmc2V0LCBzaXplKTtcbiAgICAgICAgY2FzZSBcImNocm9tYXRpY2l0aWVzXCI6XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VDaHJvbWF0aWNpdGllcyhkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgY2FzZSBcImNvbXByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VDb21wcmVzc2lvbihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgY2FzZSBcImJveDJpXCI6XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VCb3gyaShkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgY2FzZSBcImxpbmVPcmRlclwiOlxuICAgICAgICAgICAgcmV0dXJuIFBhcnNlTGluZU9yZGVyKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgICAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgICAgIHJldHVybiBQYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgICAgIGNhc2UgXCJ2MmZcIjpcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVYyZihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgY2FzZSBcInYzZlwiOlxuICAgICAgICAgICAgcmV0dXJuIFBhcnNlVjNmKGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgICAgICBjYXNlIFwiaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgY2FzZSBcInJhdGlvbmFsXCI6XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VSYXRpb25hbChkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgY2FzZSBcInRpbWVjb2RlXCI6XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VUaW1lY29kZShkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgY2FzZSBcInByZXZpZXdcIjpcbiAgICAgICAgICAgIG9mZnNldC52YWx1ZSArPSBzaXplO1xuICAgICAgICAgICAgcmV0dXJuIFwic2tpcHBlZFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb2Zmc2V0LnZhbHVlICs9IHNpemU7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogUmV2ZXJ0IHRoZSBlbmRpYW5uZXNzIG9mIHRoZSBkYXRhXG4gKiBAcGFyYW0gc291cmNlIGRlZmluZXMgdGhlIHNvdXJjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gUHJlZGljdG9yKHNvdXJjZSkge1xuICAgIGZvciAobGV0IHQgPSAxOyB0IDwgc291cmNlLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSBzb3VyY2VbdCAtIDFdICsgc291cmNlW3RdIC0gMTI4O1xuICAgICAgICBzb3VyY2VbdF0gPSBkO1xuICAgIH1cbn1cbi8qKlxuICogSW50ZXJsZWF2ZSBwaXhlbHNcbiAqIEBwYXJhbSBzb3VyY2UgZGVmaW5lcyB0aGUgZGF0YSBzb3VyY2VcbiAqIEBwYXJhbSBvdXQgZGVmaW5lcyB0aGUgb3V0cHV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBJbnRlcmxlYXZlU2NhbGFyKHNvdXJjZSwgb3V0KSB7XG4gICAgbGV0IHQxID0gMDtcbiAgICBsZXQgdDIgPSBNYXRoLmZsb29yKChzb3VyY2UubGVuZ3RoICsgMSkgLyAyKTtcbiAgICBsZXQgcyA9IDA7XG4gICAgY29uc3Qgc3RvcCA9IHNvdXJjZS5sZW5ndGggLSAxO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAocyA+IHN0b3ApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG91dFtzKytdID0gc291cmNlW3QxKytdO1xuICAgICAgICBpZiAocyA+IHN0b3ApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG91dFtzKytdID0gc291cmNlW3QyKytdO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4ckxvYWRlci5jb3JlLmpzLm1hcCIsImltcG9ydCB7IENvbXByZXNzaW9uQ29kZXMsIERlY29kZUZsb2F0MzIsIFBhcnNlRmxvYXQxNiwgUGFyc2VGbG9hdDMyLCBQYXJzZUludDMyLCBQYXJzZUludDY0LCBQYXJzZVVpbnQxNiwgUGFyc2VVaW50MzIgfSBmcm9tIFwiLi9leHJMb2FkZXIuY29yZS5qc1wiO1xuaW1wb3J0IHsgVW5jb21wcmVzc1BJWiwgVW5jb21wcmVzc1BYUiwgVW5jb21wcmVzc1JBVywgVW5jb21wcmVzc1JMRSwgVW5jb21wcmVzc1pJUCB9IGZyb20gXCIuL2V4ckxvYWRlci5jb21wcmVzc2lvbi5qc1wiO1xuaW1wb3J0IHsgRkxPQVQzMl9TSVpFLCBJTlQxNl9TSVpFIH0gZnJvbSBcIi4vZXhyTG9hZGVyLmludGVyZmFjZXMuanNcIjtcblxuaW1wb3J0IHsgVG9vbHMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vTWlzYy90b29scy5qc1wiO1xuaW1wb3J0IHsgRXhyTG9hZGVyR2xvYmFsQ29uZmlndXJhdGlvbiwgRVhST3V0cHV0VHlwZSB9IGZyb20gXCIuL2V4ckxvYWRlci5jb25maWd1cmF0aW9uLmpzXCI7XG4vKipcbiAqIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9zY2llY29kZS90aHJlZS5qcy9ibG9iL2Rldi9leGFtcGxlcy9qc20vbG9hZGVycy9FWFJMb2FkZXIuanNcbiAqIFJlZmVycmVkIHRvIHRoZSBvcmlnaW5hbCBJbmR1c3RyaWFsIExpZ2h0ICYgTWFnaWMgT3BlbkVYUiBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlIFRpbnlFWFIgLyBTeW95byBGdWppdGFcbiAqIGltcGxlbWVudGF0aW9uLlxuICovXG4vLyAvKlxuLy8gQ29weXJpZ2h0IChjKSAyMDE0IC0gMjAxNywgU3lveW8gRnVqaXRhXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbi8vICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuLy8gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIFN5b3lvIEZ1aml0YSBub3IgdGhlXG4vLyAgICAgICBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuLy8gICAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbi8vIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4vLyBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4vLyBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbi8vIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4vLyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4vLyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbi8vIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuLy8gU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vLyAqL1xuLy8gLy8gVGlueUVYUiBjb250YWlucyBzb21lIE9wZW5FWFIgY29kZSwgd2hpY2ggaXMgbGljZW5zZWQgdW5kZXIgLS0tLS0tLS0tLS0tXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIC8vXG4vLyAvLyBDb3B5cmlnaHQgKGMpIDIwMDIsIEluZHVzdHJpYWwgTGlnaHQgJiBNYWdpYywgYSBkaXZpc2lvbiBvZiBMdWNhc1xuLy8gLy8gRGlnaXRhbCBMdGQuIExMQ1xuLy8gLy9cbi8vIC8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyAvL1xuLy8gLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyAvLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyAvLyBtZXQ6XG4vLyAvLyAqICAgICAgIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAvLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAvLyAqICAgICAgIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIC8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIC8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIC8vIGRpc3RyaWJ1dGlvbi5cbi8vIC8vICogICAgICAgTmVpdGhlciB0aGUgbmFtZSBvZiBJbmR1c3RyaWFsIExpZ2h0ICYgTWFnaWMgbm9yIHRoZSBuYW1lcyBvZlxuLy8gLy8gaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuLy8gLy8gZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy8gLy9cbi8vIC8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIC8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIC8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIC8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyAvLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIC8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIC8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vIC8vXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIC8vIEVuZCBvZiBPcGVuRVhSIGxpY2Vuc2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBDcmVhdGUgYSBkZWNvZGVyIGZvciB0aGUgZXhyIGZpbGVcbiAqIEBwYXJhbSBoZWFkZXIgaGVhZGVyIG9mIHRoZSBleHIgZmlsZVxuICogQHBhcmFtIGRhdGFWaWV3IGRhdGF2aWV3IG9mIHRoZSBleHIgZmlsZVxuICogQHBhcmFtIG9mZnNldCBjdXJyZW50IG9mZnNldFxuICogQHBhcmFtIG91dHB1dFR5cGUgZXhwZWN0ZWQgb3V0cHV0IHR5cGUgKGZsb2F0IG9yIGhhbGYgZmxvYXQpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBkZWNvZGVyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBDcmVhdGVEZWNvZGVyQXN5bmMoaGVhZGVyLCBkYXRhVmlldywgb2Zmc2V0LCBvdXRwdXRUeXBlKSB7XG4gICAgY29uc3QgZGVjb2RlciA9IHtcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgdmlld2VyOiBkYXRhVmlldyxcbiAgICAgICAgYXJyYXk6IG5ldyBVaW50OEFycmF5KGRhdGFWaWV3LmJ1ZmZlciksXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICB3aWR0aDogaGVhZGVyLmRhdGFXaW5kb3cueE1heCAtIGhlYWRlci5kYXRhV2luZG93LnhNaW4gKyAxLFxuICAgICAgICBoZWlnaHQ6IGhlYWRlci5kYXRhV2luZG93LnlNYXggLSBoZWFkZXIuZGF0YVdpbmRvdy55TWluICsgMSxcbiAgICAgICAgY2hhbm5lbHM6IGhlYWRlci5jaGFubmVscy5sZW5ndGgsXG4gICAgICAgIGNoYW5uZWxMaW5lT2Zmc2V0czoge30sXG4gICAgICAgIHNjYW5PcmRlcjogKCkgPT4gMCxcbiAgICAgICAgYnl0ZXNQZXJMaW5lOiAwLFxuICAgICAgICBvdXRMaW5lV2lkdGg6IDAsXG4gICAgICAgIGxpbmVzOiAwLFxuICAgICAgICBzY2FubGluZUJsb2NrU2l6ZTogMCxcbiAgICAgICAgaW5wdXRTaXplOiBudWxsLFxuICAgICAgICB0eXBlOiAwLFxuICAgICAgICB1bmNvbXByZXNzOiBudWxsLFxuICAgICAgICBnZXR0ZXI6ICgpID0+IDAsXG4gICAgICAgIGZvcm1hdDogNSxcbiAgICAgICAgb3V0cHV0Q2hhbm5lbHM6IDAsXG4gICAgICAgIGRlY29kZUNoYW5uZWxzOiB7fSxcbiAgICAgICAgYmxvY2tDb3VudDogbnVsbCxcbiAgICAgICAgYnl0ZUFycmF5OiBudWxsLFxuICAgICAgICBsaW5lYXJTcGFjZTogZmFsc2UsXG4gICAgICAgIHRleHR1cmVUeXBlOiAwLFxuICAgIH07XG4gICAgc3dpdGNoIChoZWFkZXIuY29tcHJlc3Npb24pIHtcbiAgICAgICAgY2FzZSBDb21wcmVzc2lvbkNvZGVzLk5PX0NPTVBSRVNTSU9OOlxuICAgICAgICAgICAgZGVjb2Rlci5saW5lcyA9IDE7XG4gICAgICAgICAgICBkZWNvZGVyLnVuY29tcHJlc3MgPSBVbmNvbXByZXNzUkFXO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29tcHJlc3Npb25Db2Rlcy5STEVfQ09NUFJFU1NJT046XG4gICAgICAgICAgICBkZWNvZGVyLmxpbmVzID0gMTtcbiAgICAgICAgICAgIGRlY29kZXIudW5jb21wcmVzcyA9IFVuY29tcHJlc3NSTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb21wcmVzc2lvbkNvZGVzLlpJUFNfQ09NUFJFU1NJT046XG4gICAgICAgICAgICBkZWNvZGVyLmxpbmVzID0gMTtcbiAgICAgICAgICAgIGRlY29kZXIudW5jb21wcmVzcyA9IFVuY29tcHJlc3NaSVA7XG4gICAgICAgICAgICBhd2FpdCBUb29scy5Mb2FkU2NyaXB0QXN5bmMoRXhyTG9hZGVyR2xvYmFsQ29uZmlndXJhdGlvbi5GRkxBVEVVcmwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29tcHJlc3Npb25Db2Rlcy5aSVBfQ09NUFJFU1NJT046XG4gICAgICAgICAgICBkZWNvZGVyLmxpbmVzID0gMTY7XG4gICAgICAgICAgICBkZWNvZGVyLnVuY29tcHJlc3MgPSBVbmNvbXByZXNzWklQO1xuICAgICAgICAgICAgYXdhaXQgVG9vbHMuTG9hZFNjcmlwdEFzeW5jKEV4ckxvYWRlckdsb2JhbENvbmZpZ3VyYXRpb24uRkZMQVRFVXJsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbXByZXNzaW9uQ29kZXMuUElaX0NPTVBSRVNTSU9OOlxuICAgICAgICAgICAgZGVjb2Rlci5saW5lcyA9IDMyO1xuICAgICAgICAgICAgZGVjb2Rlci51bmNvbXByZXNzID0gVW5jb21wcmVzc1BJWjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbXByZXNzaW9uQ29kZXMuUFhSMjRfQ09NUFJFU1NJT046XG4gICAgICAgICAgICBkZWNvZGVyLmxpbmVzID0gMTY7XG4gICAgICAgICAgICBkZWNvZGVyLnVuY29tcHJlc3MgPSBVbmNvbXByZXNzUFhSO1xuICAgICAgICAgICAgYXdhaXQgVG9vbHMuTG9hZFNjcmlwdEFzeW5jKEV4ckxvYWRlckdsb2JhbENvbmZpZ3VyYXRpb24uRkZMQVRFVXJsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKENvbXByZXNzaW9uQ29kZXNbaGVhZGVyLmNvbXByZXNzaW9uXSArIFwiIGlzIHVuc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBkZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplID0gZGVjb2Rlci5saW5lcztcbiAgICBjb25zdCBjaGFubmVscyA9IHt9O1xuICAgIGZvciAoY29uc3QgY2hhbm5lbCBvZiBoZWFkZXIuY2hhbm5lbHMpIHtcbiAgICAgICAgc3dpdGNoIChjaGFubmVsLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJSXCI6XG4gICAgICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgICAgY2FzZSBcIkJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgICAgY2hhbm5lbHNbY2hhbm5lbC5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGVjb2Rlci50eXBlID0gY2hhbm5lbC5waXhlbFR5cGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiWVwiOlxuICAgICAgICAgICAgICAgIGNoYW5uZWxzW2NoYW5uZWwubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRlY29kZXIudHlwZSA9IGNoYW5uZWwucGl4ZWxUeXBlO1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6ICdZJyBpcyBkZXByZWNhdGVkIGluIE9wZW5HTCAzLjArOyBwcmVmZXIgJ1InIGZvciBzaW5nbGUtY2hhbm5lbCBFWFJzLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHVuc3VwcG9ydGVkIGNoYW5uZWxzXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUkdCIGltYWdlcyB3aWxsIGJlIGNvbnZlcnRlZCB0byBSR0JBIGZvcm1hdCwgcHJldmVudGluZyBzb2Z0d2FyZSBlbXVsYXRpb24gaW4gc2VsZWN0IGRldmljZXMuXG4gICAgbGV0IGZpbGxBbHBoYSA9IGZhbHNlO1xuICAgIGlmIChjaGFubmVscy5SICYmIGNoYW5uZWxzLkcgJiYgY2hhbm5lbHMuQiAmJiBjaGFubmVscy5BKSB7XG4gICAgICAgIGRlY29kZXIub3V0cHV0Q2hhbm5lbHMgPSA0O1xuICAgICAgICBkZWNvZGVyLmRlY29kZUNoYW5uZWxzID0geyBSOiAwLCBHOiAxLCBCOiAyLCBBOiAzIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYW5uZWxzLlIgJiYgY2hhbm5lbHMuRyAmJiBjaGFubmVscy5CKSB7XG4gICAgICAgIGZpbGxBbHBoYSA9IHRydWU7XG4gICAgICAgIGRlY29kZXIub3V0cHV0Q2hhbm5lbHMgPSA0O1xuICAgICAgICBkZWNvZGVyLmRlY29kZUNoYW5uZWxzID0geyBSOiAwLCBHOiAxLCBCOiAyLCBBOiAzIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYW5uZWxzLlIgJiYgY2hhbm5lbHMuRykge1xuICAgICAgICBkZWNvZGVyLm91dHB1dENoYW5uZWxzID0gMjtcbiAgICAgICAgZGVjb2Rlci5kZWNvZGVDaGFubmVscyA9IHsgUjogMCwgRzogMSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFubmVscy5SKSB7XG4gICAgICAgIGRlY29kZXIub3V0cHV0Q2hhbm5lbHMgPSAxO1xuICAgICAgICBkZWNvZGVyLmRlY29kZUNoYW5uZWxzID0geyBSOiAwIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYW5uZWxzLlkpIHtcbiAgICAgICAgZGVjb2Rlci5vdXRwdXRDaGFubmVscyA9IDE7XG4gICAgICAgIGRlY29kZXIuZGVjb2RlQ2hhbm5lbHMgPSB7IFk6IDAgfTtcbiAgICAgICAgLy8gTm90ZTogU3VwcG9ydGluZyAnWScgY2hhbm5lbCBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHk7IHByZWZlciAnUicgaW4gbmV3IEVYUnMuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFWFJMb2FkZXIucGFyc2U6IGZpbGUgY29udGFpbnMgdW5zdXBwb3J0ZWQgZGF0YSBjaGFubmVscy5cIik7XG4gICAgfVxuICAgIGlmIChkZWNvZGVyLnR5cGUgPT09IDEpIHtcbiAgICAgICAgLy8gaGFsZlxuICAgICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRVhST3V0cHV0VHlwZS5GbG9hdDpcbiAgICAgICAgICAgICAgICBkZWNvZGVyLmdldHRlciA9IFBhcnNlRmxvYXQxNjtcbiAgICAgICAgICAgICAgICBkZWNvZGVyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVYUk91dHB1dFR5cGUuSGFsZkZsb2F0OlxuICAgICAgICAgICAgICAgIGRlY29kZXIuZ2V0dGVyID0gUGFyc2VVaW50MTY7XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5pbnB1dFNpemUgPSBJTlQxNl9TSVpFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlY29kZXIudHlwZSA9PT0gMikge1xuICAgICAgICAvLyBmbG9hdFxuICAgICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRVhST3V0cHV0VHlwZS5GbG9hdDpcbiAgICAgICAgICAgICAgICBkZWNvZGVyLmdldHRlciA9IFBhcnNlRmxvYXQzMjtcbiAgICAgICAgICAgICAgICBkZWNvZGVyLmlucHV0U2l6ZSA9IEZMT0FUMzJfU0laRTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRVhST3V0cHV0VHlwZS5IYWxmRmxvYXQ6XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5nZXR0ZXIgPSBEZWNvZGVGbG9hdDMyO1xuICAgICAgICAgICAgICAgIGRlY29kZXIuaW5wdXRTaXplID0gRkxPQVQzMl9TSVpFO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwaXhlbFR5cGUgXCIgKyBkZWNvZGVyLnR5cGUgKyBcIiBmb3IgXCIgKyBoZWFkZXIuY29tcHJlc3Npb24pO1xuICAgIH1cbiAgICBkZWNvZGVyLmJsb2NrQ291bnQgPSBkZWNvZGVyLmhlaWdodCAvIGRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVyLmJsb2NrQ291bnQ7IGkrKykge1xuICAgICAgICBQYXJzZUludDY0KGRhdGFWaWV3LCBvZmZzZXQpOyAvLyBzY2FubGluZU9mZnNldFxuICAgIH1cbiAgICAvLyB3ZSBzaG91bGQgYmUgcGFzc2VkIHRoZSBzY2FubGluZSBvZmZzZXQgdGFibGUsIHJlYWR5IHRvIHN0YXJ0IHJlYWRpbmcgcGl4ZWwgZGF0YS5cbiAgICBjb25zdCBzaXplID0gZGVjb2Rlci53aWR0aCAqIGRlY29kZXIuaGVpZ2h0ICogZGVjb2Rlci5vdXRwdXRDaGFubmVscztcbiAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSBFWFJPdXRwdXRUeXBlLkZsb2F0OlxuICAgICAgICAgICAgZGVjb2Rlci5ieXRlQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgICAgICAgICAgZGVjb2Rlci50ZXh0dXJlVHlwZSA9IDE7XG4gICAgICAgICAgICAvLyBGaWxsIGluaXRpYWxseSB3aXRoIDFzIGZvciB0aGUgYWxwaGEgdmFsdWUgaWYgdGhlIHRleHR1cmUgaXMgbm90IFJHQkEsIFJHQiB2YWx1ZXMgd2lsbCBiZSBvdmVyd3JpdHRlblxuICAgICAgICAgICAgaWYgKGZpbGxBbHBoYSkge1xuICAgICAgICAgICAgICAgIGRlY29kZXIuYnl0ZUFycmF5LmZpbGwoMSwgMCwgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBFWFJPdXRwdXRUeXBlLkhhbGZGbG9hdDpcbiAgICAgICAgICAgIGRlY29kZXIuYnl0ZUFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHNpemUpO1xuICAgICAgICAgICAgZGVjb2Rlci50ZXh0dXJlVHlwZSA9IDI7XG4gICAgICAgICAgICBpZiAoZmlsbEFscGhhKSB7XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5ieXRlQXJyYXkuZmlsbCgweDNjMDAsIDAsIHNpemUpOyAvLyBVaW50MTZBcnJheSBob2xkcyBoYWxmIGZsb2F0IGRhdGEsIDB4M0MwMCBpcyAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGU6IFwiICsgb3V0cHV0VHlwZSk7XG4gICAgfVxuICAgIGxldCBieXRlT2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgaGVhZGVyLmNoYW5uZWxzKSB7XG4gICAgICAgIGlmIChkZWNvZGVyLmRlY29kZUNoYW5uZWxzW2NoYW5uZWwubmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVjb2Rlci5jaGFubmVsTGluZU9mZnNldHNbY2hhbm5lbC5uYW1lXSA9IGJ5dGVPZmZzZXQgKiBkZWNvZGVyLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVPZmZzZXQgKz0gY2hhbm5lbC5waXhlbFR5cGUgKiAyO1xuICAgIH1cbiAgICBkZWNvZGVyLmJ5dGVzUGVyTGluZSA9IGRlY29kZXIud2lkdGggKiBieXRlT2Zmc2V0O1xuICAgIGRlY29kZXIub3V0TGluZVdpZHRoID0gZGVjb2Rlci53aWR0aCAqIGRlY29kZXIub3V0cHV0Q2hhbm5lbHM7XG4gICAgaWYgKGhlYWRlci5saW5lT3JkZXIgPT09IFwiSU5DUkVBU0lOR19ZXCIpIHtcbiAgICAgICAgZGVjb2Rlci5zY2FuT3JkZXIgPSAoeSkgPT4geTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlY29kZXIuc2Nhbk9yZGVyID0gKHkpID0+IGRlY29kZXIuaGVpZ2h0IC0gMSAtIHk7XG4gICAgfVxuICAgIGlmIChkZWNvZGVyLm91dHB1dENoYW5uZWxzID09IDQpIHtcbiAgICAgICAgZGVjb2Rlci5mb3JtYXQgPSA1O1xuICAgICAgICBkZWNvZGVyLmxpbmVhclNwYWNlID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlY29kZXIuZm9ybWF0ID0gNjtcbiAgICAgICAgZGVjb2Rlci5saW5lYXJTcGFjZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2Rlcjtcbn1cbi8qKlxuICogU2NhbiB0aGUgZGF0YSBvZiB0aGUgZXhyIGZpbGVcbiAqIEBwYXJhbSBkZWNvZGVyIGRlY29kZXIgdG8gdXNlXG4gKiBAcGFyYW0gaGVhZGVyIGhlYWRlciBvZiB0aGUgZXhyIGZpbGVcbiAqIEBwYXJhbSBkYXRhVmlldyBkYXRhdmlldyBvZiB0aGUgZXhyIGZpbGVcbiAqIEBwYXJhbSBvZmZzZXQgY3VycmVudCBvZmZzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNjYW5EYXRhKGRlY29kZXIsIGhlYWRlciwgZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIGNvbnN0IHRtcE9mZnNldCA9IHsgdmFsdWU6IDAgfTtcbiAgICBmb3IgKGxldCBzY2FubGluZUJsb2NrSWR4ID0gMDsgc2NhbmxpbmVCbG9ja0lkeCA8IGRlY29kZXIuaGVpZ2h0IC8gZGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTsgc2NhbmxpbmVCbG9ja0lkeCsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBQYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQpIC0gaGVhZGVyLmRhdGFXaW5kb3cueU1pbjsgLy8gbGluZV9ub1xuICAgICAgICBkZWNvZGVyLnNpemUgPSBQYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0KTsgLy8gZGF0YV9sZW5cbiAgICAgICAgZGVjb2Rlci5saW5lcyA9IGxpbmUgKyBkZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplID4gZGVjb2Rlci5oZWlnaHQgPyBkZWNvZGVyLmhlaWdodCAtIGxpbmUgOiBkZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplO1xuICAgICAgICBjb25zdCBpc0NvbXByZXNzZWQgPSBkZWNvZGVyLnNpemUgPCBkZWNvZGVyLmxpbmVzICogZGVjb2Rlci5ieXRlc1BlckxpbmU7XG4gICAgICAgIGNvbnN0IHZpZXdlciA9IGlzQ29tcHJlc3NlZCAmJiBkZWNvZGVyLnVuY29tcHJlc3MgPyBkZWNvZGVyLnVuY29tcHJlc3MoZGVjb2RlcikgOiBVbmNvbXByZXNzUkFXKGRlY29kZXIpO1xuICAgICAgICBvZmZzZXQudmFsdWUgKz0gZGVjb2Rlci5zaXplO1xuICAgICAgICBmb3IgKGxldCBsaW5lWSA9IDA7IGxpbmVZIDwgZGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTsgbGluZVkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2NhblkgPSBzY2FubGluZUJsb2NrSWR4ICogZGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IHRydWVZID0gbGluZVkgKyBkZWNvZGVyLnNjYW5PcmRlcihzY2FuWSk7XG4gICAgICAgICAgICBpZiAodHJ1ZVkgPj0gZGVjb2Rlci5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpbmVPZmZzZXQgPSBsaW5lWSAqIGRlY29kZXIuYnl0ZXNQZXJMaW5lO1xuICAgICAgICAgICAgY29uc3Qgb3V0TGluZU9mZnNldCA9IChkZWNvZGVyLmhlaWdodCAtIDEgLSB0cnVlWSkgKiBkZWNvZGVyLm91dExpbmVXaWR0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGNoYW5uZWxJRCA9IDA7IGNoYW5uZWxJRCA8IGRlY29kZXIuY2hhbm5lbHM7IGNoYW5uZWxJRCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5jaGFubmVsc1tjaGFubmVsSURdLm5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbE9mZiA9IGRlY29kZXIuY2hhbm5lbExpbmVPZmZzZXRzW25hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNPZmYgPSBkZWNvZGVyLmRlY29kZUNoYW5uZWxzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChjT2ZmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRtcE9mZnNldC52YWx1ZSA9IGxpbmVPZmZzZXQgKyBsT2ZmO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgZGVjb2Rlci53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dEluZGV4ID0gb3V0TGluZU9mZnNldCArIHggKiBkZWNvZGVyLm91dHB1dENoYW5uZWxzICsgY09mZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY29kZXIuYnl0ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLmJ5dGVBcnJheVtvdXRJbmRleF0gPSBkZWNvZGVyLmdldHRlcih2aWV3ZXIsIHRtcE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHJMb2FkZXIuZGVjb2Rlci5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9NaXNjL2xvZ2dlci5qc1wiO1xuaW1wb3J0IHsgUGFyc2VOdWxsVGVybWluYXRlZFN0cmluZywgUGFyc2VVaW50MzIsIFBhcnNlVmFsdWUgfSBmcm9tIFwiLi9leHJMb2FkZXIuY29yZS5qc1wiO1xuLyoqXG4gKiBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vc2NpZWNvZGUvdGhyZWUuanMvYmxvYi9kZXYvZXhhbXBsZXMvanNtL2xvYWRlcnMvRVhSTG9hZGVyLmpzXG4gKiBSZWZlcnJlZCB0byB0aGUgb3JpZ2luYWwgSW5kdXN0cmlhbCBMaWdodCAmIE1hZ2ljIE9wZW5FWFIgaW1wbGVtZW50YXRpb24gYW5kIHRoZSBUaW55RVhSIC8gU3lveW8gRnVqaXRhXG4gKiBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuLy8gLypcbi8vIENvcHlyaWdodCAoYykgMjAxNCAtIDIwMTcsIFN5b3lvIEZ1aml0YVxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4vLyAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbi8vICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4vLyAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBTeW95byBGdWppdGEgbm9yIHRoZVxuLy8gICAgICAgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbi8vICAgICAgIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG4vLyBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuLy8gV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuLy8gRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4vLyBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuLy8gKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuLy8gTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4vLyBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbi8vIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLy8gKi9cbi8vIC8vIFRpbnlFWFIgY29udGFpbnMgc29tZSBPcGVuRVhSIGNvZGUsIHdoaWNoIGlzIGxpY2Vuc2VkIHVuZGVyIC0tLS0tLS0tLS0tLVxuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyAvL1xuLy8gLy8gQ29weXJpZ2h0IChjKSAyMDAyLCBJbmR1c3RyaWFsIExpZ2h0ICYgTWFnaWMsIGEgZGl2aXNpb24gb2YgTHVjYXNcbi8vIC8vIERpZ2l0YWwgTHRkLiBMTENcbi8vIC8vXG4vLyAvLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gLy9cbi8vIC8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gLy8gbWV0OlxuLy8gLy8gKiAgICAgICBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gLy8gKiAgICAgICBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyAvLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyAvLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyAvLyBkaXN0cmlidXRpb24uXG4vLyAvLyAqICAgICAgIE5laXRoZXIgdGhlIG5hbWUgb2YgSW5kdXN0cmlhbCBMaWdodCAmIE1hZ2ljIG5vciB0aGUgbmFtZXMgb2Zcbi8vIC8vIGl0cyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbi8vIC8vIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vIC8vXG4vLyAvLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyAvLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyAvLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIC8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyAvLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIC8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIC8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyAvLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAvLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIC8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vLyAvL1xuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyAvLyBFbmQgb2YgT3BlbkVYUiBsaWNlbnNlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IEVYUl9NQUdJQyA9IDIwMDAwNjMwO1xuLyoqXG4gKiBHZXRzIHRoZSBFWFIgaGVhZGVyXG4gKiBAcGFyYW0gZGF0YVZpZXcgZGVmaW5lcyB0aGUgZGF0YSB2aWV3IHRvIHJlYWQgZnJvbVxuICogQHBhcmFtIG9mZnNldCBkZWZpbmVzIHRoZSBvZmZzZXQgdG8gc3RhcnQgcmVhZGluZyBmcm9tXG4gKiBAcmV0dXJucyB0aGUgaGVhZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBHZXRFeHJIZWFkZXIoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIGlmIChkYXRhVmlldy5nZXRVaW50MzIoMCwgdHJ1ZSkgIT0gRVhSX01BR0lDKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBPcGVuRVhSIGZvcm1hdFwiKTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbiA9IGRhdGFWaWV3LmdldFVpbnQ4KDQpO1xuICAgIGNvbnN0IHNwZWNEYXRhID0gZGF0YVZpZXcuZ2V0VWludDgoNSk7IC8vIGZ1bGxNYXNrXG4gICAgY29uc3Qgc3BlYyA9IHtcbiAgICAgICAgc2luZ2xlVGlsZTogISEoc3BlY0RhdGEgJiAyKSxcbiAgICAgICAgbG9uZ05hbWU6ICEhKHNwZWNEYXRhICYgNCksXG4gICAgICAgIGRlZXBGb3JtYXQ6ICEhKHNwZWNEYXRhICYgOCksXG4gICAgICAgIG11bHRpUGFydDogISEoc3BlY0RhdGEgJiAxNiksXG4gICAgfTtcbiAgICBvZmZzZXQudmFsdWUgPSA4O1xuICAgIGNvbnN0IGhlYWRlckRhdGEgPSB7fTtcbiAgICBsZXQga2VlcFJlYWRpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChrZWVwUmVhZGluZykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gUGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhkYXRhVmlldy5idWZmZXIsIG9mZnNldCk7XG4gICAgICAgIGlmICghYXR0cmlidXRlTmFtZSkge1xuICAgICAgICAgICAga2VlcFJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGUgPSBQYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGRhdGFWaWV3LmJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVNpemUgPSBQYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVZhbHVlID0gUGFyc2VWYWx1ZShkYXRhVmlldywgb2Zmc2V0LCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGVTaXplKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLldhcm4oYFVua25vd24gaGVhZGVyIGF0dHJpYnV0ZSB0eXBlICR7YXR0cmlidXRlVHlwZX0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyRGF0YVthdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgoc3BlY0RhdGEgJiB+MHgwNCkgIT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBmaWxlIGZvcm1hdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmVyc2lvbjogdmVyc2lvbiwgc3BlYzogc3BlYywgLi4uaGVhZGVyRGF0YSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhyTG9hZGVyLmhlYWRlci5qcy5tYXAiLCJleHBvcnQgY29uc3QgSU5UMzJfU0laRSA9IDQ7XG5leHBvcnQgY29uc3QgRkxPQVQzMl9TSVpFID0gNDtcbmV4cG9ydCBjb25zdCBJTlQ4X1NJWkUgPSAxO1xuZXhwb3J0IGNvbnN0IElOVDE2X1NJWkUgPSAyO1xuZXhwb3J0IGNvbnN0IFVMT05HX1NJWkUgPSA4O1xuZXhwb3J0IGNvbnN0IFVTSE9SVF9SQU5HRSA9IDEgPDwgMTY7XG5leHBvcnQgY29uc3QgQklUTUFQX1NJWkUgPSBVU0hPUlRfUkFOR0UgPj4gMztcbmV4cG9ydCBjb25zdCBIVUZfRU5DQklUUyA9IDE2O1xuZXhwb3J0IGNvbnN0IEhVRl9ERUNCSVRTID0gMTQ7XG5leHBvcnQgY29uc3QgSFVGX0VOQ1NJWkUgPSAoMSA8PCBIVUZfRU5DQklUUykgKyAxO1xuZXhwb3J0IGNvbnN0IEhVRl9ERUNTSVpFID0gMSA8PCBIVUZfREVDQklUUztcbmV4cG9ydCBjb25zdCBIVUZfREVDTUFTSyA9IEhVRl9ERUNTSVpFIC0gMTtcbmV4cG9ydCBjb25zdCBTSE9SVF9aRVJPQ09ERV9SVU4gPSA1OTtcbmV4cG9ydCBjb25zdCBMT05HX1pFUk9DT0RFX1JVTiA9IDYzO1xuZXhwb3J0IGNvbnN0IFNIT1JURVNUX0xPTkdfUlVOID0gMiArIExPTkdfWkVST0NPREVfUlVOIC0gU0hPUlRfWkVST0NPREVfUlVOO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhyTG9hZGVyLmludGVyZmFjZXMuanMubWFwIiwiaW1wb3J0IHsgR2V0RXhySGVhZGVyIH0gZnJvbSBcIi4vRVhSL2V4ckxvYWRlci5oZWFkZXIuanNcIjtcbmltcG9ydCB7IENyZWF0ZURlY29kZXJBc3luYywgU2NhbkRhdGEgfSBmcm9tIFwiLi9FWFIvZXhyTG9hZGVyLmRlY29kZXIuanNcIjtcbmltcG9ydCB7IEV4ckxvYWRlckdsb2JhbENvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi9FWFIvZXhyTG9hZGVyLmNvbmZpZ3VyYXRpb24uanNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi8uLi8uLi9NaXNjL2xvZ2dlci5qc1wiO1xuLyoqXG4gKiBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vc2NpZWNvZGUvdGhyZWUuanMvYmxvYi9kZXYvZXhhbXBsZXMvanNtL2xvYWRlcnMvRVhSTG9hZGVyLmpzXG4gKiBSZWZlcnJlZCB0byB0aGUgb3JpZ2luYWwgSW5kdXN0cmlhbCBMaWdodCAmIE1hZ2ljIE9wZW5FWFIgaW1wbGVtZW50YXRpb24gYW5kIHRoZSBUaW55RVhSIC8gU3lveW8gRnVqaXRhXG4gKiBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuLy8gLypcbi8vIENvcHlyaWdodCAoYykgMjAxNCAtIDIwMTcsIFN5b3lvIEZ1aml0YVxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4vLyAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbi8vICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4vLyAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBTeW95byBGdWppdGEgbm9yIHRoZVxuLy8gICAgICAgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbi8vICAgICAgIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG4vLyBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuLy8gV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuLy8gRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4vLyBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuLy8gKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuLy8gTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4vLyBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbi8vIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLy8gKi9cbi8vIC8vIFRpbnlFWFIgY29udGFpbnMgc29tZSBPcGVuRVhSIGNvZGUsIHdoaWNoIGlzIGxpY2Vuc2VkIHVuZGVyIC0tLS0tLS0tLS0tLVxuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyAvL1xuLy8gLy8gQ29weXJpZ2h0IChjKSAyMDAyLCBJbmR1c3RyaWFsIExpZ2h0ICYgTWFnaWMsIGEgZGl2aXNpb24gb2YgTHVjYXNcbi8vIC8vIERpZ2l0YWwgTHRkLiBMTENcbi8vIC8vXG4vLyAvLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gLy9cbi8vIC8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gLy8gbWV0OlxuLy8gLy8gKiAgICAgICBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gLy8gKiAgICAgICBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyAvLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyAvLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyAvLyBkaXN0cmlidXRpb24uXG4vLyAvLyAqICAgICAgIE5laXRoZXIgdGhlIG5hbWUgb2YgSW5kdXN0cmlhbCBMaWdodCAmIE1hZ2ljIG5vciB0aGUgbmFtZXMgb2Zcbi8vIC8vIGl0cyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbi8vIC8vIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vIC8vXG4vLyAvLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyAvLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyAvLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIC8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyAvLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIC8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIC8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyAvLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAvLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIC8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4vLyAvL1xuLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyAvLyBFbmQgb2YgT3BlbkVYUiBsaWNlbnNlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogTG9hZGVyIGZvciAuZXhyIGZpbGUgZm9ybWF0XG4gKiBAc2VlIFtQSVogY29tcHJlc3Npb25dKGh0dHBzOi8vcGxheWdyb3VuZC5iYWJ5bG9uanMuY29tLyM0Uk4wVkYjMTUxKVxuICogQHNlZSBbWklQIGNvbXByZXNzaW9uXShodHRwczovL3BsYXlncm91bmQuYmFieWxvbmpzLmNvbS8jNFJOMFZGIzE0NilcbiAqIEBzZWUgW1JMRSBjb21wcmVzc2lvbl0oaHR0cHM6Ly9wbGF5Z3JvdW5kLmJhYnlsb25qcy5jb20vIzRSTjBWRiMxNDkpXG4gKiBAc2VlIFtQWFIyNCBjb21wcmVzc2lvbl0oaHR0cHM6Ly9wbGF5Z3JvdW5kLmJhYnlsb25qcy5jb20vIzRSTjBWRiMxNTApXG4gKiBAaW50ZXJuYWxcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNsYXNzIF9FeHJUZXh0dXJlTG9hZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgd2hldGhlciB0aGUgbG9hZGVyIHN1cHBvcnRzIGNhc2NhZGUgbG9hZGluZyB0aGUgZGlmZmVyZW50IGZhY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdXBwb3J0Q2FzY2FkZXMgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgY3ViZSB0ZXh0dXJlIGRhdGEgdG8gdGhlIFdlYkdMIHRleHR1cmUuIEl0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmQuXG4gICAgICogQHBhcmFtIF9kYXRhIGNvbnRhaW5zIHRoZSB0ZXh0dXJlIGRhdGFcbiAgICAgKiBAcGFyYW0gX3RleHR1cmUgZGVmaW5lcyB0aGUgQmFieWxvbkpTIGludGVybmFsIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gX2NyZWF0ZVBvbHlub21pYWxzIHdpbGwgYmUgdHJ1ZSBpZiBwb2x5bm9taWFscyBoYXZlIGJlZW4gcmVxdWVzdGVkXG4gICAgICogQHBhcmFtIF9vbkxvYWQgZGVmaW5lcyB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBvbmNlIHRoZSB0ZXh0dXJlIGlzIHJlYWR5XG4gICAgICogQHBhcmFtIF9vbkVycm9yIGRlZmluZXMgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgaW4gY2FzZSBvZiBlcnJvclxuICAgICAqIEN1YmUgdGV4dHVyZSBhcmUgbm90IHN1cHBvcnRlZCBieSAuZXhyIGZpbGVzXG4gICAgICovXG4gICAgbG9hZEN1YmVEYXRhKF9kYXRhLCBfdGV4dHVyZSwgX2NyZWF0ZVBvbHlub21pYWxzLCBfb25Mb2FkLCBfb25FcnJvcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgICB0aHJvdyBcIi5leHIgbm90IHN1cHBvcnRlZCBpbiBDdWJlLlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSAyRCB0ZXh0dXJlIGRhdGEgdG8gdGhlIFdlYkdMIHRleHR1cmUuIEl0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmQgb25jZSBpbiB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIGRhdGEgY29udGFpbnMgdGhlIHRleHR1cmUgZGF0YVxuICAgICAqIEBwYXJhbSB0ZXh0dXJlIGRlZmluZXMgdGhlIEJhYnlsb25KUyBpbnRlcm5hbCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIGRlZmluZXMgdGhlIG1ldGhvZCB0byBjYWxsIG9uY2UgcmVhZHkgdG8gdXBsb2FkXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIGxvYWREYXRhKGRhdGEsIHRleHR1cmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0geyB2YWx1ZTogMCB9O1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBHZXRFeHJIZWFkZXIoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgICAgIENyZWF0ZURlY29kZXJBc3luYyhoZWFkZXIsIGRhdGFWaWV3LCBvZmZzZXQsIEV4ckxvYWRlckdsb2JhbENvbmZpZ3VyYXRpb24uRGVmYXVsdE91dHB1dFR5cGUpXG4gICAgICAgICAgICAudGhlbigoZGVjb2RlcikgPT4ge1xuICAgICAgICAgICAgU2NhbkRhdGEoZGVjb2RlciwgaGVhZGVyLCBkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIHRleHR1cmVcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaGVhZGVyLmRhdGFXaW5kb3cueE1heCAtIGhlYWRlci5kYXRhV2luZG93LnhNaW4gKyAxO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaGVhZGVyLmRhdGFXaW5kb3cueU1heCAtIGhlYWRlci5kYXRhV2luZG93LnlNaW4gKyAxO1xuICAgICAgICAgICAgY2FsbGJhY2sod2lkdGgsIGhlaWdodCwgdGV4dHVyZS5nZW5lcmF0ZU1pcE1hcHMsIGZhbHNlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5naW5lID0gdGV4dHVyZS5nZXRFbmdpbmUoKTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IGhlYWRlci5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS50eXBlID0gZGVjb2Rlci50ZXh0dXJlVHlwZTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmludmVydFkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLl9nYW1tYVNwYWNlID0gIWhlYWRlci5saW5lYXJTcGFjZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjb2Rlci5ieXRlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5naW5lLl91cGxvYWREYXRhVG9UZXh0dXJlRGlyZWN0bHkodGV4dHVyZSwgZGVjb2Rlci5ieXRlQXJyYXksIDAsIDAsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBMb2dnZXIuRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBFWFIgdGV4dHVyZTogXCIsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhyVGV4dHVyZUxvYWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=